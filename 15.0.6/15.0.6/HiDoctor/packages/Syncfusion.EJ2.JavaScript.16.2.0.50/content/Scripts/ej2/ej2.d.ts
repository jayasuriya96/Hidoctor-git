declare namespace ej { 
export namespace base { 

/**
 * Ajax class provides ability to make asynchronous HTTP request to the server
 * ```typescript
 *   var ajax = new Ajax("index.html", "GET", true);
 *   ajax.send().then(
 *               function (value) {
 *                   console.log(value);
 *               },
 *               function (reason) {
 *                   console.log(reason);
 *               });
 * ```
 */
export  class Ajax {
    /**
     * Specifies the URL to which request to be sent.
     * @default null
     */
    url: string;
    /**
     * Specifies which HTTP request method to be used. For ex., GET, POST
     * @default GET
     */
    type: string;
    /**
     * Specifies the data to be sent.
     * @default null
     */
    data: string | Object;
    /**
     * A boolean value indicating whether the request should be sent asynchronous or not.
     * @default true
     */
    mode: boolean;
    /**
     * Specifies the callback for creating the XMLHttpRequest object.
     * @default null
     */
    httpRequest: XMLHttpRequest;
    onLoad: (this: XMLHttpRequest, ev: Event) => object;
    onProgress: (this: XMLHttpRequest, ev: Event) => object;
    private options;
    onError: (this: XMLHttpRequest, ev: Event) => object;
    onAbort: (this: XMLHttpRequest, ev: Event) => object;
    private contentType;
    private dataType;
    /**
     * Constructor for Ajax class
     * @param  {string|Object} options?
     * @param  {string} type?
     * @param  {boolean} async?
     * @returns defaultType
     */
    constructor(options?: string | Object, type?: string, async?: boolean);
    /**
     * Send the request to server.
     * @param {any} data - To send the user data
     * @return {Promise}
     */
    send(data?: string | Object): Promise<Ajax>;
    /**
     * Specifies the callback function to be triggered before sending request to sever.
     * This can be used to modify the XMLHttpRequest object before it is sent.
     * @event
     */
    beforeSend: Function;
    /**
     * Specifies callback function to be triggered after XmlHttpRequest is succeeded.
     * The callback will contain server response as the parameter.
     * @event
     */
    onSuccess: Function;
    /**
     * Triggers when XmlHttpRequest is failed.
     * @event
     */
    onFailure: Function;
    private successHandler(data);
    private failureHandler(reason);
    private stateChange(resolve, reject);
    /**
     * To get the response header from XMLHttpRequest
     * @param  {string} key Key to search in the response header
     * @returns {string}
     */
    getResponseHeader(key: string): string;
}
export interface HeaderOptions {
    readyState?: number;
    getResponseHeader?: Function;
    setRequestHeader?: Function;
    overrideMimeType?: Function;
}
/**
 * Interface for a class Animation
 */
export interface AnimationModel {
    /**
     * Specify the type of animation
     * @default : 'FadeIn';
     */
    name?: Effect;
    /**
     * Specify the duration to animate
     * @default : 400;
     */
    duration?: number;
    /**
     * Specify the animation timing function
     * @default : 'ease';
     */
    timingFunction?: string;
    /**
     * Specify the delay to start animation
     * @default : 0;
     */
    delay?: number;
    /**
     * Triggers when animation is in-progress
     * @event
     */
    progress?: base.EmitType<AnimationOptions>;
    /**
     * Triggers when the animation is started
     * @event
     */
    begin?: base.EmitType<AnimationOptions>;
    /**
     * Triggers when animation is completed
     * @event
     */
    end?: base.EmitType<AnimationOptions>;
    /**
     * Triggers when animation is failed due to any scripts
     * @event
     */
    fail?: base.EmitType<AnimationOptions>;
}
/**
 * Animation effect names
 */
export  type Effect = 'FadeIn' | 'FadeOut' | 'FadeZoomIn' | 'FadeZoomOut' | 'FlipLeftDownIn' | 'FlipLeftDownOut' | 'FlipLeftUpIn' | 'FlipLeftUpOut' | 'FlipRightDownIn' | 'FlipRightDownOut' | 'FlipRightUpIn' | 'FlipRightUpOut' | 'FlipXDownIn' | 'FlipXDownOut' | 'FlipXUpIn' | 'FlipXUpOut' | 'FlipYLeftIn' | 'FlipYLeftOut' | 'FlipYRightIn' | 'FlipYRightOut' | 'SlideBottomIn' | 'SlideBottomOut' | 'SlideDown' | 'SlideLeft' | 'SlideLeftIn' | 'SlideLeftOut' | 'SlideRight' | 'SlideRightIn' | 'SlideRightOut' | 'SlideTopIn' | 'SlideTopOut' | 'SlideUp' | 'ZoomIn' | 'ZoomOut';
/**
 * The Animation framework provide options to animate the html DOM elements
 * ```typescript
 *   let animeObject = new Animation({
 *      name: 'SlideLeftIn',
 *      duration: 1000
 *   });
 *   animeObject.animate('#anime1');
 *   animeObject.animate('#anime2', { duration: 500 });
 * ```
 */
export  class Animation extends Base<HTMLElement> implements INotifyPropertyChanged {
    /**
     * Specify the type of animation
     * @default : 'FadeIn';
     */
    name: Effect;
    /**
     * Specify the duration to animate
     * @default : 400;
     */
    duration: number;
    /**
     * Specify the animation timing function
     * @default : 'ease';
     */
    timingFunction: string;
    /**
     * Specify the delay to start animation
     * @default : 0;
     */
    delay: number;
    /**
     * Triggers when animation is in-progress
     * @event
     */
    progress: EmitType<AnimationOptions>;
    /**
     * Triggers when the animation is started
     * @event
     */
    begin: EmitType<AnimationOptions>;
    /**
     * Triggers when animation is completed
     * @event
     */
    end: EmitType<AnimationOptions>;
    /**
     * Triggers when animation is failed due to any scripts
     * @event
     */
    fail: EmitType<AnimationOptions>;
    /**
     * @private
     */
    easing: {
        [key: string]: string;
    };
    constructor(options: AnimationModel);
    /**
     * Applies animation to the current element.
     * @param {string | HTMLElement} element - Element which needs to be animated.
     * @param {AnimationModel} options - Overriding default animation settings.
     * @return {void}
     */
    animate(element: string | HTMLElement, options?: AnimationModel): void;
    /**
     * Stop the animation effect on animated element.
     * @param {HTMLElement} element - Element which needs to be stop the animation.
     * @param {AnimationOptions} model - Handling the animation model at stop function.
     * @return {void}
     */
    static stop(element: HTMLElement, model?: AnimationOptions): void;
    /**
     * Set delay to animation element
     * @param {AnimationModel} model
     * @returns {void}
     */
    private static delayAnimation(model);
    /**
     * Triggers animation
     * @param {AnimationModel} model
     * @returns {void}
     */
    private static applyAnimation(model);
    /**
     * Returns Animation Model
     * @param {AnimationModel} options
     * @returns {AnimationModel}
     */
    private getModel(options);
    /**
     * @private
     */
    onPropertyChanged(newProp: AnimationModel, oldProp: AnimationModel): void;
    /**
     * Returns module name as animation
     * @private
     */
    getModuleName(): string;
    /**
     * @private
     */
    destroy(): void;
}
/**
 * Animation event argument for progress event handler
 */
export interface AnimationOptions extends AnimationModel {
    /**
     * Get current time-stamp in progress EventHandler
     */
    timeStamp?: number;
    /**
     * Get current animation element in progress EventHandler
     */
    element?: HTMLElement;
}
/**
 * Ripple provides material theme's wave effect when an element is clicked
 * ```html
 * <div id='ripple'></div>
 * <script>
 *   rippleEffect(document.getElementById('ripple'));
 * </script>
 * ```
 * @private
 * @param HTMLElement element - Target element
 * @param RippleOptions rippleOptions - Ripple options .
 */
export  function rippleEffect(element: HTMLElement, rippleOptions?: RippleOptions, done?: Function): () => void;
/**
 * Ripple method arguments to handle ripple effect
 * @private
 */
export interface RippleOptions {
    /**
     * Get selector child elements for ripple effect
     */
    selector?: string;
    /**
     * Get ignore elements to prevent ripple effect
     */
    ignore?: string;
    /**
     * Override the enableRipple method
     */
    rippleFlag?: boolean;
    /**
     * Set ripple effect from center position
     */
    isCenterRipple?: boolean;
    /**
     * Set ripple duration
     */
    duration?: number;
}
export  let isRippleEnabled: boolean;
/**
 * Animation Module provides support to enable ripple effect functionality to Essential JS 2 components.
 * @param {boolean} isRipple Specifies the boolean value to enable or disable ripple effect.
 * @returns {boolean}
 */
export  function enableRipple(isRipple: boolean): boolean;
export interface DomElements extends HTMLElement {
    ej2_instances: Object[];
}
export interface AngularEventEmitter {
    subscribe?: (generatorOrNext?: any, error?: any, complete?: any) => any;
}
export  type EmitType<T> = AngularEventEmitter & ((arg?: T, ...rest: any[]) => void);
/**
 * Base library module is common module for Framework modules like touch,keyboard and etc.,
 * @private
 */
export  abstract class Base<ElementType extends HTMLElement> {
    element: ElementType;
    isDestroyed: boolean;
    protected isProtectedOnChange: boolean;
    protected properties: {
        [key: string]: Object;
    };
    protected changedProperties: {
        [key: string]: Object;
    };
    protected oldProperties: {
        [key: string]: Object;
    };
    protected refreshing: boolean;
    protected finalUpdate: Function;
    protected modelObserver: Observer;
    protected childChangedProperties: {
        [key: string]: Object;
    };
    protected abstract getModuleName(): string;
    protected abstract onPropertyChanged(newProperties: Object, oldProperties?: Object): void;
    /** Property base section */
    /**
     * Function used to set bunch of property at a time.
     * @private
     * @param  {Object} prop - JSON object which holds components properties.
     * @param  {boolean} muteOnChange? - Specifies to true when we set properties.
     */
    setProperties(prop: Object, muteOnChange?: boolean): void;
    /**
     * Calls for child element data bind
     * @param {Object} obj
     * @param {Object} parent
     * @returns {void}
     */
    private static callChildDataBind(obj, parent);
    protected clearChanges(): void;
    /**
     * Bind property changes immediately to components
     */
    dataBind(): void;
    protected saveChanges(key: string, newValue: string, oldValue: string): void;
    /** Event Base Section */
    /**
     * Adds the handler to the given event listener.
     * @param {string} eventName - A String that specifies the name of the event
     * @param {Function} listener - Specifies the call to run when the event occurs.
     * @return {void}
     */
    addEventListener(eventName: string, handler: Function): void;
    /**
     * Removes the handler from the given event listener.
     * @param {string} eventName - A String that specifies the name of the event to remove
     * @param {Function} listener - Specifies the function to remove
     * @return {void}
     */
    removeEventListener(eventName: string, handler: Function): void;
    /**
     * Triggers the handlers in the specified event.
     * @private
     * @param {string} eventName - Specifies the event to trigger for the specified component properties.
     * Can be a custom event, or any of the standard events.
     * @param {Event} eventProp - Additional parameters to pass on to the event properties
     * @return {void}
     */
    trigger(eventName: string, eventProp?: Object): void;
    /**
     * Base constructor accept options and element
     */
    constructor(options: Object, element: ElementType | string);
    /**
     * To maintain instance in base class
     */
    protected addInstance(): void;
    /**
     * To remove the instance from the element
     */
    protected destroy(): void;
}
/**
 * Get configuration details for Browser
 * @private
 */
export  class Browser {
    private static uA;
    private static extractBrowserDetail();
    /**
     * To get events from the browser
     * @param {string} event - type of event triggered.
     * @returns {Boolean}
     */
    private static getEvent(event);
    /**
     * To get the Touch start event from browser
     * @returns {string}
     */
    private static getTouchStartEvent();
    /**
     * To get the Touch end event from browser
     * @returns {string}
     */
    private static getTouchEndEvent();
    /**
     * To get the Touch move event from browser
     * @returns {string}
     */
    private static getTouchMoveEvent();
    /**
     * To cancel the touch event from browser
     * @returns {string}
     */
    private static getTouchCancelEvent();
    /**
     * To get the value based on provided key and regX
     * @param {string} key
     * @param {RegExp} regX
     * @returns {Object}
     */
    private static getValue(key, regX);
    /**
     * Property specifies the userAgent of the browser. Default userAgent value is based on the browser.
     * Also we can set our own userAgent.
     */
    static userAgent: string;
    /**
     * Property is to get the browser information like Name, Version and Language
     * @returns BrowserInfo
     */
    static readonly info: BrowserInfo;
    /**
     * Property is to get whether the userAgent is based IE.
     */
    static readonly isIE: Boolean;
    /**
     * Property is to get whether the browser has touch support.
     */
    static readonly isTouch: Boolean;
    /**
     * Property is to get whether the browser has Pointer support.
     */
    static readonly isPointer: Boolean;
    /**
     * Property is to get whether the browser has MSPointer support.
     */
    static readonly isMSPointer: Boolean;
    /**
     * Property is to get whether the userAgent is device based.
     */
    static readonly isDevice: Boolean;
    /**
     * Property is to get whether the userAgent is IOS.
     */
    static readonly isIos: Boolean;
    /**
     * Property is to get whether the userAgent is Ios7.
     */
    static readonly isIos7: Boolean;
    /**
     * Property is to get whether the userAgent is Android.
     */
    static readonly isAndroid: Boolean;
    /**
     * Property is to identify whether application ran in web view.
     */
    static readonly isWebView: Boolean;
    /**
     * Property is to get whether the userAgent is Windows.
     */
    static readonly isWindows: Boolean;
    /**
     * Property is to get the touch start event. It returns event name based on browser.
     */
    static readonly touchStartEvent: string;
    /**
     * Property is to get the touch move event. It returns event name based on browser.
     */
    static readonly touchMoveEvent: string;
    /**
     * Property is to get the touch end event. It returns event name based on browser.
     */
    static readonly touchEndEvent: string;
    /**
     * Property is to cancel the touch end event.
     */
    static readonly touchCancelEvent: string;
}
export interface BrowserDetails {
    isAndroid?: Boolean;
    isDevice?: Boolean;
    isIE?: Boolean;
    isIos?: Boolean;
    isIos7?: Boolean;
    isMSPointer?: Boolean;
    isPointer?: Boolean;
    isTouch?: Boolean;
    isWebView?: Boolean;
    isWindows?: Boolean;
    info?: BrowserInfo;
    touchStartEvent?: string;
    touchMoveEvent?: string;
    touchEndEvent?: string;
    touchCancelEvent?: string;
}
export interface BrowserInfo {
    name?: string;
    version?: string;
    culture?: {
        name?: string;
        language?: string;
    };
}
/**
 * @private
 */
export  class CanvasRenderer {
    private canvasObj;
    /**
     * Specifies root id of the canvas element
     * @default null
     */
    private rootId;
    /**
     * Specifies the height of the canvas element.
     * @default null
     */
    height: number;
    /**
     * Specifies the width of the canvas element.
     * @default null
     */
    width: number;
    /**
     * Specifies the context of the canvas.
     * @default null
     */
    ctx: CanvasRenderingContext2D;
    /**
     * Holds the context of the rendered canvas as string.
     * @default null
     */
    dataUrl: string;
    constructor(rootID: string);
    private getOptionValue<T>(options, key);
    /**
     * To create a Html5 canvas element
     * @param {BaseAttibutes} options - Options to create canvas
     * @return {HTMLCanvasElement}
     */
    createCanvas(options: BaseAttibutes): HTMLCanvasElement;
    /**
     * To set the width and height for the Html5 canvas element
     * @param {number} width - width of the canvas
     * @param {number} height - height of the canvas
     * @return {void}
     */
    setCanvasSize(width: number, height: number): void;
    private setAttributes(options);
    /**
     * To draw a line
     * @param {LineAttributes} options - required options to draw a line on the canvas
     * @return {void}
     */
    drawLine(options: LineAttributes): void;
    /**
     * To draw a rectangle
     * @param {RectAttributes} options - required options to draw a rectangle on the canvas
     * @return {void}
     */
    drawRectangle(options: RectAttributes): void;
    private drawCornerRadius(options);
    /**
     * To draw a path on the canvas
     * @param {PathAttributes} options - options needed to draw path
     * @param {Int32Array} canvasTranslate - Array of numbers to translate the canvas
     * @return {void}
     */
    drawPath(options: PathAttributes, canvasTranslate: Int32Array): void;
    /**
     * To draw a text
     * @param {TextAttributes} options - options required to draw text
     * @param {string} label - Specifies the text which has to be drawn on the canvas
     * @return {void}
     */
    drawText(options: TextAttributes, label: string): void;
    /**
     * To draw circle on the canvas
     * @param {CircleAttributes} options - required options to draw the circle
     * @return {void}
     */
    drawCircle(options: CircleAttributes): void;
    /**
     * To draw polyline
     * @param {PolylineAttributes} options - options needed to draw polyline
     * @return {void}
     */
    drawPolyline(options: PolylineAttributes): void;
    /**
     * To draw an ellipse on the canvas
     * @param {EllipseAttributes} options - options needed to draw ellipse
     * @return {void}
     */
    drawEllipse(options: EllipseAttributes): void;
    /**
     * To draw an image
     * @param {ImageAttributes} options - options required to draw an image on the canvas
     * @return {void}
     */
    drawImage(options: ImageAttributes): void;
    /**
     * To create a linear gradient
     * @param {string[]} colors - Specifies the colors required to create linear gradient
     * @return {string}
     */
    createLinearGradient(colors: GradientColor[]): string;
    /**
     * To create a radial gradient
     * @param {string[]} colors - Specifies the colors required to create linear gradient
     * @return {string}
     */
    createRadialGradient(colors: GradientColor[]): string;
    private setGradientValues(colors, myGradient);
    /**
     * To set the attributes to the element
     * @param {SVGCanvasAttributes} options - Attributes to set for the element
     * @param {HTMLElement} element - The element to which the attributes need to be set
     * @return {HTMLElement}
     */
    setElementAttributes(options: SVGCanvasAttributes, element: HTMLElement): HTMLElement;
    /**
     * To update the values of the canvas element attributes
     * @param {SVGCanvasAttributes} options - Specifies the colors required to create gradient
     * @return {void}
     */
    updateCanvasAttributes(options: SVGCanvasAttributes): void;
}
/**
 * To detect the changes for inner properties.
 * @private
 */
export  class ChildProperty<T> {
    private parentObj;
    private controlParent;
    private propName;
    private isParentArray;
    protected properties: {
        [key: string]: Object;
    };
    protected changedProperties: {
        [key: string]: Object;
    };
    protected childChangedProperties: {
        [key: string]: Object;
    };
    protected oldProperties: {
        [key: string]: Object;
    };
    protected finalUpdate: Function;
    private callChildDataBind;
    constructor(parent: T, propName: string, defaultValue: Object, isArray?: boolean);
    /**
     * Updates the property changes
     * @param {boolean} val
     * @param {string} propName
     * @returns {void}
     */
    private updateChange(val, propName);
    /**
     * Updates time out duration
     */
    private updateTimeOut();
    /**
     * Clears changed properties
     */
    private clearChanges();
    /**
     * Set property changes
     * @param {Object} prop
     * @param {boolean} muteOnChange
     * {void}
     */
    protected setProperties(prop: Object, muteOnChange: boolean): void;
    /**
     * Binds data
     */
    protected dataBind(): void;
    /**
     * Saves changes to newer values
     * @param {string} key
     * @param {Object} newValue
     * @param {Object} oldValue
     * @returns {void}
     */
    protected saveChanges(key: string, newValue: Object, oldValue: Object): void;
}
/**
 * Interface for a class Component
 */
export interface ComponentModel {
    /**
     * Enable or disable persisting component's state between page reloads.
     * @default false
     */
    enablePersistence?: boolean;
    /**
     * Enable or disable rendering component in right to left direction.
     * @default false
     */
    enableRtl?: boolean;
    /**
     * Overrides the global culture and localization value for this component. Default global culture is 'en-US'.
     * @default undefined
     */
    locale?: string;
}
/**
 * Base class for all Essential JavaScript components
 */
export  abstract class Component<ElementType extends HTMLElement> extends Base<ElementType> {
    element: ElementType;
    private detectFunction;
    /**
     * Enable or disable persisting component's state between page reloads.
     * @default false
     */
    enablePersistence: boolean;
    /**
     * Enable or disable rendering component in right to left direction.
     * @default false
     */
    enableRtl: boolean;
    /**
     * Overrides the global culture and localization value for this component. Default global culture is 'en-US'.
     * @default undefined
     */
    locale: string;
    protected needsID: boolean;
    protected moduleLoader: ModuleLoader;
    protected localObserver: Observer;
    protected abstract render(): void;
    protected abstract preRender(): void;
    protected abstract getPersistData(): string;
    protected injectedModules: Function[];
    protected requiredModules(): ModuleDeclaration[];
    /**
     * Destroys the sub modules while destroying the widget
     */
    protected destroy(): void;
    /**
     * Applies all the pending property changes and render the component again.
     */
    refresh(): void;
    /**
     * Appends the control within the given HTML element
     * @param {string | HTMLElement} selector - Target element where control needs to be appended
     */
    appendTo(selector?: string | HTMLElement): void;
    /**
     * When invoked, applies the pending property changes immediately to the component.
     */
    dataBind(): void;
    /**
     * Attach one or more  event handler to the current component context.
     * It is used for internal handling event internally within the component only.
     * @param {BoundOptions[]| string} event - It is  optional type either to  Set the collection of event list or the eventName.
     * @param {Function} handler - optional parameter Specifies the handler to run when the event occurs
     * @param {Object} context - optional parameter Specifies the context to be bind in the handler.
     * @return {void}
     * @private
     */
    on(event: BoundOptions[] | string, handler?: Function, context?: Object): void;
    /**
     * To remove one or more event handler that has been attached with the on() method.
     * @param {BoundOptions[]| string} event - It is  optional type either to  Set the collection of event list or the eventName.
     * @param {Function} handler - optional parameter Specifies the function to run when the event occurs
     * @return {void}
     * @private
     */
    off(event: BoundOptions[] | string, handler?: Function): void;
    /**
     * To notify the handlers in the specified event.
     * @param {string} property - Specifies the event to be notify.
     * @param {Object} argument - Additional parameters to pass while calling the handler.
     * @return {void}
     * @private
     */
    notify(property: string, argument: Object): void;
    /**
     * Get injected modules
     * @private
     */
    getInjectedModules(): Function[];
    /**
     * Dynamically injects the required modules to the component.
     */
    static Inject(...moduleList: Function[]): void;
    /**
     * Initialize the constructor for component base
     */
    constructor(options?: Object, selector?: string | ElementType);
    private injectModules();
    private mergePersistData();
    private setPersistData();
    protected clearTemplate(templateName?: string[]): void;
    protected addOnPersist(options: string[]): string;
    protected getActualProperties<T>(obj: T): T;
    protected ignoreOnPersist(options: string[]): string;
    protected iterateJsonProperties(obj: {
        [key: string]: Object;
    }, ignoreList: string[]): Object;
}
/**
 * Function to create Html element.
 * @param tagName - Name of the tag, id and class names.
 * @param properties - Object to set properties in the element.
 * @param properties.id - To set the id to the created element.
 * @param properties.className - To add classes to the element.
 * @param properties.innerHTML - To set the innerHTML to element.
 * @param properties.styles - To set the some custom styles to element.
 * @param properties.attrs - To set the attributes to element.
 * @private
 */
export  function createElement(tagName: string, properties?: {
    id?: string;
    className?: string;
    innerHTML?: string;
    styles?: string;
    attrs?: {
        [key: string]: string;
    };
}): HTMLElement;
/**
 * The function used to add the classes to array of elements
 * @param  {Element[]|NodeList} elements - An array of elements that need to add a list of classes
 * @param  {string|string[]} classes - String or array of string that need to add an individual element as a class
 * @private
 */
export  function addClass(elements: Element[] | NodeList, classes: string | string[]): Element[] | NodeList;
/**
 * The function used to add the classes to array of elements
 * @param  {Element[]|NodeList} elements - An array of elements that need to remove a list of classes
 * @param  {string|string[]} classes - String or array of string that need to add an individual element as a class
 * @private
 */
export  function removeClass(elements: Element[] | NodeList, classes: string | string[]): Element[] | NodeList;
/**
 * The function used to check element is visible or not.
 * @param  {Element|Node} element - An element the need to check visibility
 * @private
 */
export  function isVisible(element: Element | Node): Boolean;
/**
 * The function used to insert an array of elements into a first of the element.
 * @param  {Element[]|NodeList} fromElements - An array of elements that need to prepend.
 * @param  {Element} toElement - An element that is going to prepend.
 * @private
 */
export  function prepend(fromElements: Element[] | NodeList, toElement: Element): Element[] | NodeList;
/**
 * The function used to insert an array of elements into last of the element.
 * @param  {Element[]|NodeList} fromElements - An array of elements that need to append.
 * @param  {Element} toElement - An element that is going to prepend.
 * @private
 */
export  function append(fromElements: Element[] | NodeList, toElement: Element): Element[] | NodeList;
/**
 * The function used to remove the element from the
 * @param  {Element|Node|HTMLElement} element - An element that is going to detach from the Dom
 * @private
 */
export  function detach(element: Element | Node | HTMLElement): Element;
/**
 * The function used to remove the element from Dom also clear the bounded events
 * @param  {Element|Node|HTMLElement} element - An element remove from the Dom
 * @private
 */
export  function remove(element: Element | Node | HTMLElement): void;
/**
 * The function helps to set multiple attributes to an element
 * @param  {Element|Node} element - An element that need to set attributes.
 * @param  {{[key:string]:string}} attributes - JSON Object that is going to as attributes.
 * @private
 */
export  function attributes(element: Element | Node, attributes: {
    [key: string]: string;
}): Element;
/**
 * The function selects the element from giving context.
 * @param  {string} selector - Selector string need fetch element from the
 * @param  {Document|Element=document} context - It is an optional type, That specifies a Dom context.
 * @private
 */
export  function select(selector: string, context?: Document | Element): Element;
/**
 * The function selects an array of element from the given context.
 * @param  {string} selector - Selector string need fetch element from the
 * @param  {Document|Element=document} context - It is an optional type, That specifies a Dom context.
 * @private
 */
export  function selectAll(selector: string, context?: Document | Element): HTMLElement[];
/**
 * Returns single closest parent element based on class selector.
 * @param  {Element} element - An element that need to find the closest element.
 * @param  {string} selector - A classSelector of closest element.
 * @private
 */
export  function closest(element: Element | Node, selector: string): Element;
/**
 * Returns all sibling elements of the given element.
 * @param  {Element|Node} element - An element that need to get siblings.
 * @private
 */
export  function siblings(element: Element | Node): Element[];
/**
 * set the value if not exist. Otherwise set the existing value
 * @param  {HTMLElement} element - An element to which we need to set value.
 * @param  {string} property - Property need to get or set.
 * @param  {string} value - value need to set.
 * @private
 */
export  function getAttributeOrDefault(element: HTMLElement, property: string, value: string): string;
/**
 * Set the style attributes to Html element.
 * @param {HTMLElement} element - Element which we want to set attributes
 * @param {any} attrs - Set the given attributes to element
 * @return {void}
 * @private
 */
export  function setStyleAttribute(element: HTMLElement, attrs: {
    [key: string]: Object;
}): void;
/**
 * Method for add and remove classes to a dom element.
 * @param {Element} element - Element for add and remove classes
 * @param {string[]} addClasses - List of classes need to be add to the element
 * @param {string[]} removeClasses - List of classes need to be remove from the element
 * @return {void}
 * @private
 */
export  function classList(element: Element, addClasses: string[], removeClasses: string[]): void;
/**
 * Method to check whether the element matches the given selector.
 * @param {Element} element - Element to compare with the selector.
 * @param {string} selector - String selector which element will satisfy.
 * @return {void}
 * @private
 */
export  function matches(element: Element, selector: string): boolean;
/**
 * Interface for a class Position
 */
export interface PositionModel {
    /**
     * Specifies the left position of cursor in draggable.
     */
    left?: number;
    /**
     * Specifies the left position of cursor in draggable.
     */
    top?: number;
}
/**
 * Interface for a class Draggable
 */
export interface DraggableModel {
    /**
     * Defines the distance between the cursor and the draggable element.
     */
    cursorAt?: PositionModel;
    /**
     * If `clone` set to true, drag operations are performed in duplicate element of the draggable element. 
     * @default true
     */
    clone?: boolean;
    /**
     * Defines the parent  element in which draggable element movement will be restricted.
     */
    dragArea?: HTMLElement | string;
    /**
     * Specifies the callback function for drag event.
     * @event
     */
    drag?: Function;
    /**
     * Specifies the callback function for dragStart event.
     * @event
     */
    dragStart?: Function;
    /**
     * Specifies the callback function for dragStop event.
     * @event
     */
    dragStop?: Function;
    /**
     * Defines the minimum distance draggable element to be moved to trigger the drag operation.
     * @default 1
     */
    distance?: number;
    /**
     * Defines the child element selector which will act as drag handle.
     */
    handle?: string;
    /**
     * Defines the child element selector which will prevent dragging of element.
     */
    abort?: string;
    /**
     * Defines the callback function for customizing the cloned  element.
     */
    helper?: Function;
    /**
     * Defines the scope value to group sets of draggable and droppable items. 
     * A draggable with the same scope value will be accepted by the droppable.
     */
    scope?: string;
    /**
     * Specifies the dragTarget by which the clone element is positioned if not given current context element will be considered.
     * @private
     */
    dragTarget?: string;
    /**
     * Defines the axis to limit the draggable element drag path.The possible axis path values are   
     * * `x` - Allows drag movement in horizontal direction only. 
     * * `y` - Allows drag movement in vertical direction only.
     */
    axis?: DragDirection;
    /**
     * Defines the function to change the position value.
     * @private
     */
    queryPositionInfo?: Function;
    /**
     * Defines whether the drag clone element will be split form the cursor pointer.
     * @private
     */
    enableTailMode?: boolean;
    /**
     * Defines whether to skip the previous drag movement comparison.
     * @private
     */
    skipDistanceCheck?: boolean;
    /**
     * @private
     */
    preventDefault?: boolean;
    /**
     * Defines whether to enable autoscroll on drag movement of draggable element.
     * enableAutoScroll
     * @private
     */
    enableAutoScroll?: boolean;
}
/**
 * Specifies the Direction in which drag movement happen.
 */
export  type DragDirection = 'x' | 'y';
/**
 * Specifies the position coordinates
 */
export  class Position extends ChildProperty<Position> {
    /**
     * Specifies the left position of cursor in draggable.
     */
    left: number;
    /**
     * Specifies the left position of cursor in draggable.
     */
    top: number;
}
/**
 * Coordinates for element position
 * @private
 */
export interface Coordinates {
    /**
     * Defines the x Coordinate of page.
     */
    pageX: number;
    /**
     * Defines the y Coordinate of page.
     */
    pageY: number;
    /**
     * Defines the x Coordinate of client.
     */
    clientX: number;
    /**
     * Defines the y Coordinate of client.
     */
    clientY: number;
}
/**
 * Interface to specify the drag data in the droppable.
 */
export interface DropInfo {
    /**
     * Specifies the current draggable element
     */
    draggable?: HTMLElement;
    /**
     * Specifies the current helper element.
     */
    helper?: HTMLElement;
    /**
     * Specifies the drag target element
     */
    draggedElement?: HTMLElement;
}
export interface DropObject {
    target: HTMLElement;
    instance: DropOption;
}
/**
 * Used to access values
 * @private
 */
export interface DragPosition {
    left: string;
    top: string;
}
/**
 * Used for accessing the interface.
 * @private
 */
export interface Instance extends HTMLElement {
    /**
     * Specifies current instance collection in element
     */
    ej2_instances: {
        [key: string]: Object;
    }[];
}
/**
 * Droppable function to be invoked from draggable
 * @private
 */
export interface DropOption {
    /**
     * Used to triggers over function while draggable element is over the droppable element.
     */
    intOver: Function;
    /**
     * Used to triggers out function while draggable element is out of the droppable element.
     */
    intOut: Function;
    /**
     * Used to triggers  out function while draggable element is dropped on the droppable element.
     */
    intDrop: Function;
    /**
     * Specifies the information about the drag element.
     */
    dragData: DropInfo;
    /**
     * Specifies the status of the drag of drag stop calling.
     */
    dragStopCalled: boolean;
}
/**
 * Drag Event arguments
 */
export interface DragEventArgs {
    /**
     * Specifies the actual event.
     */
    event?: MouseEvent & TouchEvent;
    /**
     * Specifies the current drag element.
     */
    element?: HTMLElement;
    /**
     * Specifies the current target element.
     */
    target?: HTMLElement;
}
/**
 * Draggable Module provides support to enable draggable functionality in Dom Elements.
 * ```html
 * <div id='drag'>Draggable</div>
 * <script>
 * var ele = document.getElementById('drag');
 * var drag:Draggable = new Draggable(ele,{
 *     clone:false,
 *     drag: function(e) {
 *      //drag handler code.
 *      },
 *     handle:'.class'
 * });
 * </script>
 * ```
 */
export  class Draggable extends Base<HTMLElement> implements INotifyPropertyChanged {
    /**
     * Defines the distance between the cursor and the draggable element.
     */
    cursorAt: PositionModel;
    /**
     * If `clone` set to true, drag operations are performed in duplicate element of the draggable element.
     * @default true
     */
    clone: boolean;
    /**
     * Defines the parent  element in which draggable element movement will be restricted.
     */
    dragArea: HTMLElement | string;
    /**
     * Specifies the callback function for drag event.
     * @event
     */
    drag: Function;
    /**
     * Specifies the callback function for dragStart event.
     * @event
     */
    dragStart: Function;
    /**
     * Specifies the callback function for dragStop event.
     * @event
     */
    dragStop: Function;
    /**
     * Defines the minimum distance draggable element to be moved to trigger the drag operation.
     * @default 1
     */
    distance: number;
    /**
     * Defines the child element selector which will act as drag handle.
     */
    handle: string;
    /**
     * Defines the child element selector which will prevent dragging of element.
     */
    abort: string;
    /**
     * Defines the callback function for customizing the cloned  element.
     */
    helper: Function;
    /**
     * Defines the scope value to group sets of draggable and droppable items.
     * A draggable with the same scope value will be accepted by the droppable.
     */
    scope: string;
    /**
     * Specifies the dragTarget by which the clone element is positioned if not given current context element will be considered.
     * @private
     */
    dragTarget: string;
    /**
     * Defines the axis to limit the draggable element drag path.The possible axis path values are
     * * `x` - Allows drag movement in horizontal direction only.
     * * `y` - Allows drag movement in vertical direction only.
     */
    axis: DragDirection;
    /**
     * Defines the function to change the position value.
     * @private
     */
    queryPositionInfo: Function;
    /**
     * Defines whether the drag clone element will be split form the cursor pointer.
     * @private
     */
    enableTailMode: boolean;
    /**
     * Defines whether to skip the previous drag movement comparison.
     * @private
     */
    skipDistanceCheck: boolean;
    /**
     * @private
     */
    preventDefault: boolean;
    /**
     * Defines whether to enable autoscroll on drag movement of draggable element.
     * enableAutoScroll
     * @private
     */
    enableAutoScroll: boolean;
    private target;
    private initialPosition;
    private relativeXPosition;
    private relativeYPosition;
    private margin;
    private offset;
    private position;
    private dragLimit;
    private borderWidth;
    private padding;
    private left;
    private top;
    private width;
    private height;
    private pageX;
    private diffX;
    private diffY;
    private pageY;
    private helperElement;
    private hoverObject;
    private parentClientRect;
    droppables: {
        [key: string]: DropInfo;
    };
    constructor(element: HTMLElement, options?: DraggableModel);
    protected bind(): void;
    private static getDefaultPosition();
    private toggleEvents(isUnWire?);
    private initialize(evt);
    private intDragStart(evt);
    private elementInViewport(el);
    private getProcessedPositionValue(value);
    private calculateParentPosition(ele);
    private intDrag(evt);
    private getDocumentWidthHeight(str);
    private intDragStop(evt);
    private intDestroy(evt);
    onPropertyChanged(newProp: DraggableModel, oldProp: DraggableModel): void;
    getModuleName(): string;
    private setDragArea();
    private getProperTargetElement(evt);
    private getMousePosition(evt);
    private getCoordinates(evt);
    private getHelperElement(evt);
    private setGlobalDroppables(reset, drag?, helper?);
    private checkTargetElement(evt);
    private getDropInstance(ele);
    destroy(): void;
}
/**
 * Interface for a class Droppable
 */
export interface DroppableModel {
    /**
     * Defines the selector for draggable element to be accepted by the droppable.
     */
    accept?: string;
    /**
     * Defines the scope value to group sets of draggable and droppable items. 
     * A draggable with the same scope value will only be accepted by the droppable.
     */
    scope?: string;
    /**
     * Specifies the callback function, which will be triggered while drag element is dropped in droppable.
     * @event
     */
    drop?: (args: DropEventArgs) => void;
    /**
     * Specifies the callback function, which will be triggered while drag element is moved over droppable element.
     * @event
     */
    over?: Function;
    /**
     * Specifies the callback function, which will be triggered while drag element is moved out of droppable element.
     * @event
     */
    out?: Function;
}
/**
 * Droppable arguments in drop callback.
 * @private
 */
export interface DropData {
    /**
     * Specifies that current element can be dropped.
     */
    canDrop: boolean;
    /**
     * Specifies target to drop.
     */
    target: HTMLElement;
}
export interface DropEvents extends MouseEvent, TouchEvent {
    dropTarget?: HTMLElement;
}
/**
 * Interface for drop event args
 */
export interface DropEventArgs {
    /**
     * Specifies the original mouse or touch  event arguments.
     */
    event?: MouseEvent & TouchEvent;
    /**
     * Specifies the target element.
     */
    target?: HTMLElement;
    /**
     *  Specifies the dropped element.
     */
    droppedElement?: HTMLElement;
    /**
     * Specifies the dragData
     */
    dragData?: DropInfo;
}
/**
 * Droppable Module provides support to enable droppable functionality in Dom Elements.
 * ```html
 * <div id='drop'>Droppable</div>
 * <script>
 * let ele:HTMLElement = document.getElementById('drop');
 * var drag:Droppable = new Droppable(ele,{
 *     accept:'.drop',
 *     drop: function(e) {
 *      //drop handler code.
 *     }
 * });
 * </script>
 * ```
 */
export  class Droppable extends Base<HTMLElement> implements INotifyPropertyChanged {
    /**
     * Defines the selector for draggable element to be accepted by the droppable.
     */
    accept: string;
    /**
     * Defines the scope value to group sets of draggable and droppable items.
     * A draggable with the same scope value will only be accepted by the droppable.
     */
    scope: string;
    /**
     * Specifies the callback function, which will be triggered while drag element is dropped in droppable.
     * @event
     */
    drop: (args: DropEventArgs) => void;
    /**
     * Specifies the callback function, which will be triggered while drag element is moved over droppable element.
     * @event
     */
    over: Function;
    /**
     * Specifies the callback function, which will be triggered while drag element is moved out of droppable element.
     * @event
     */
    out: Function;
    private mouseOver;
    dragData: {
        [key: string]: DropInfo;
    };
    constructor(element: HTMLElement, options?: DroppableModel);
    protected bind(): void;
    private wireEvents();
    onPropertyChanged(newProp: DroppableModel, oldProp: DroppableModel): void;
    getModuleName(): string;
    private dragStopCalled;
    intOver(event: MouseEvent & TouchEvent, element?: Element): void;
    intOut(event: MouseEvent & TouchEvent, element?: Element): void;
    private intDrop(evt, element?);
    private isDropArea(evt, helper, element?);
    destroy(): void;
}
/**
 * EventHandler class provides option to add, remove, clear and trigger events to a HTML DOM element
 * @private
 * ```html
 * <div id="Eventdiv">  </div>
 * <script>
 *   let node: HTMLElement = document.querySelector("#Eventdiv");
 *   EventHandler.addEventListener(node, "click", function(){
 *       // click handler function code
 *   });
 *   EventHandler.addEventListener(node, "onmouseover", function(){
 *       // mouseover handler function code
 *   });
 *   EventHandler.removeEventListener(node, "click", function(){
 *       // click handler function code
 *   });
 *   eventObj.clearEvents();
 * </script>
 * ```
 */
export  class EventHandler {
    private static addOrGetEventData(element);
    /**
     * Add an event to the specified DOM element.
     * @param {any} element - Target HTML DOM element
     * @param {string} eventName - A string that specifies the name of the event
     * @param {Function} listener - Specifies the function to run when the event occurs
     * @param {Object} bindTo - A object that binds 'this' variable in the event handler
     * @param {number} debounce - Specifies at what interval given event listener should be triggered.
     * @return {Function}
     */
    static add(element: Element | HTMLElement | Document, eventName: string, listener: Function, bindTo?: Object, intDebounce?: number): Function;
    /**
     * Remove an event listener that has been attached before.
     * @param {any} element - Specifies the target html element to remove the event
     * @param {string} eventName - A string that specifies the name of the event to remove
     * @param {Function} listener - Specifies the function to remove
     * @return {void}
     */
    static remove(element: Element | HTMLElement | Document, eventName: string, listener: Function): void;
    /**
     * Clear all the event listeners that has been previously attached to the element.
     * @param {any} element - Specifies the target html element to clear the events
     * @return {void}
     */
    static clearEvents(element: Element): void;
    /**
     * Trigger particular event of the element.
     * @param {any} element - Specifies the target html element to trigger the events
     * @param {string} eventName - Specifies the event to trigger for the specified element.
     * Can be a custom event, or any of the standard events.
     * @param {any} eventProp - Additional parameters to pass on to the event properties
     * @return {void}
     */
    static trigger(element: HTMLElement, eventName: string, eventProp?: Object): void;
}
/**
 * Common Event argument for all base Essential JavaScript 2 Events.
 * @private
 */
export interface BaseEventArgs {
    /**
     * Specifies name of the event.
     */
    name?: string;
}
/**
 * Base modules
 */
/**
 * Specifies the observer used for external change detection.
 */
export  let onIntlChange: Observer;
/**
 * Specifies the default rtl status for EJ2 components.
 */
export  let rightToLeft: boolean;
/**
 * Interface for dateFormatOptions
 *
 */
export interface DateFormatOptions {
    /**
     * Specifies the skeleton for date formatting.
     */
    skeleton?: string;
    /**
     * Specifies the type of date formatting either date, dateTime or time.
     */
    type?: string;
    /**
     * Specifies custom date formatting to be used.
     */
    format?: string;
}
/**
 * Interface for numberFormatOptions
 *
 */
export interface NumberFormatOptions {
    /**
     * Specifies minimum fraction digits in formatted value.
     */
    minimumFractionDigits?: number;
    /**
     * Specifies maximum fraction digits in formatted value.
     */
    maximumFractionDigits?: number;
    /**
     * Specifies minimum significant digits in formatted value.
     */
    minimumSignificantDigits?: number;
    /**
     * Specifies maximum significant digits in formatted value.
     */
    maximumSignificantDigits?: number;
    /**
     * Specifies whether to use grouping or not in formatted value,
     */
    useGrouping?: boolean;
    /**
     * Specifies the skeleton for perform formatting.
     */
    skeleton?: string;
    /**
     * Specifies the currency code to be used for formatting.
     */
    currency?: string;
    /**
     * Specifies minimum integer digits in formatted value.
     */
    minimumIntegerDigits?: number;
    /**
     * Specifies custom number format for formatting.
     */
    format?: string;
}
/**
 * Specifies the CLDR data loaded for internationalization functionalities.
 * @private
 */
export  let cldrData: Object;
/**
 * Specifies the default culture value to be considered.
 * @private
 */
export  let defaultCulture: string;
/**
 * Specifies default currency code to be considered
 * @private
 */
export  let defaultCurrencyCode: string;
/**
 * Internationalization class provides support to parse and format the number and date object to the desired format.
 * ```typescript
 * // To set the culture globally
 * setCulture('en-GB');
 *
 * // To set currency code globally
 * setCurrencyCode('EUR');
 *
 * //Load cldr data
 * loadCldr(gregorainData);
 * loadCldr(timeZoneData);
 * loadCldr(numbersData);
 * loadCldr(numberSystemData);
 *
 * // To use formatter in component side
 * let Intl:Internationalization = new Internationalization();
 *
 * // Date formatting
 * let dateFormatter: Function = Intl.getDateFormat({skeleton:'long',type:'dateTime'});
 * dateFormatter(new Date('11/2/2016'));
 * dateFormatter(new Date('25/2/2030'));
 * Intl.formatDate(new Date(),{skeleton:'E'});
 *
 * //Number formatting
 * let numberFormatter: Function = Intl.getNumberFormat({skeleton:'C5'})
 * numberFormatter(24563334);
 * Intl.formatNumber(123123,{skeleton:'p2'});
 *
 * // Date parser
 * let dateParser: Function = Intl.getDateParser({skeleton:'short',type:'time'});
 * dateParser('10:30 PM');
 * Intl.parseDate('10',{skeleton:'H'});
 * ```
 */
export  class Internationalization {
    culture: string;
    constructor(cultureName?: string);
    /**
     * Returns the format function for given options.
     * @param {DateFormatOptions} options - Specifies the format options in which the format function will return.
     * @returns {Function}
     */
    getDateFormat(options?: DateFormatOptions): Function;
    /**
     * Returns the format function for given options.
     * @param {NumberFormatOptions} options - Specifies the format options in which the format function will return.
     * @returns {Function}
     */
    getNumberFormat(options?: NumberFormatOptions): Function;
    /**
     * Returns the parser function for given options.
     * @param {DateFormatOptions} options - Specifies the format options in which the parser function will return.
     * @returns {Function}
     * @private
     */
    getDateParser(options?: DateFormatOptions): Function;
    /**
     * Returns the parser function for given options.
     * @param {NumberFormatOptions} options - Specifies the format options in which the parser function will return.
     * @returns {Function}
     */
    getNumberParser(options?: NumberFormatOptions): Function;
    /**
     * Returns the formatted string based on format options.
     * @param {Number} value - Specifies the number to format.
     * @param {NumberFormatOptions} option - Specifies the format options in which the number will be formatted.
     * @returns {string}
     */
    formatNumber(value: Number, option?: NumberFormatOptions): string;
    /**
     * Returns the formatted date string based on format options.
     * @param {Number} value - Specifies the number to format.
     * @param {DateFormatOptions} option - Specifies the format options in which the number will be formatted.
     * @returns {string}
     */
    formatDate(value: Date, option?: DateFormatOptions): string;
    /**
     * Returns the date object for given date string and options.
     * @param {string} value - Specifies the string to parse.
     * @param {DateFormatOptions} option - Specifies the parse options in which the date string will be parsed.
     * @returns {Date}
     */
    parseDate(value: string, option?: DateFormatOptions): Date;
    /**
     * Returns the number object from the given string value and options.
     * @param {string} value - Specifies the string to parse.
     * @param {NumberFormatOptions} option - Specifies the parse options in which the  string number  will be parsed.
     * @returns {number}
     */
    parseNumber(value: string, option?: NumberFormatOptions): number;
    /**
     * Returns Native Date Time Pattern
     * @param {DateFormatOptions} option - Specifies the parse options for resultant date time pattern.
     * @param {boolean} isExcelFormat - Specifies format value to be converted to excel pattern.
     * @returns {string}
     */
    getDatePattern(option: DateFormatOptions, isExcelFormat?: boolean): string;
    /**
     * Returns Native Number Pattern
     * @param {NumberFormatOptions} option - Specifies the parse options for resultant number pattern.
     * @returns {string}
     */
    getNumberPattern(option: NumberFormatOptions): string;
    private getCulture();
}
/**
 * Set the default culture to all EJ2 components
 * @param {string} cultureName - Specifies the culture name to be set as default culture.
 */
export  function setCulture(cultureName: string): void;
/**
 * Set the default currency code to all EJ2 components
 * @param {string} currencyCode Specifies the culture name to be set as default culture.
 * @returns {void}
 */
export  function setCurrencyCode(currencyCode: string): void;
/**
 * Load the CLDR data into context
 * @param {Object[]} obj Specifies the CLDR data's to be used for formatting and parser.
 * @returns {void}
 */
export  function loadCldr(...data: Object[]): void;
/**
 * To enable or disable RTL functionality for all components globally.
 * @param {boolean} status - Optional argument Specifies the status value to enable or disable rtl option.
 * @returns {void}
 */
export  function enableRtl(status?: boolean): void;
/**
 * To get the numeric CLDR object for given culture
 * @param {string} locale - Specifies the locale for which numericObject to be returned.
 * @ignore
 * @private
 */
export  function getNumericObject(locale: string, type?: string): Object;
/**
 * To get the default date CLDR object.
 * @ignore
 * @private
 */
export  function getDefaultDateObject(): Object;
export  const basicPatterns: string[];
/**
 * Interface for Date Format Options Module.
 * @private
 */
export interface FormatOptions {
    month?: Object;
    weekday?: Object;
    pattern?: string;
    designator?: Object;
    timeZone?: Object;
    era?: Object;
    hour12?: boolean;
    numMapper?: NumberMapper;
    dateSeperator?: string;
}
export  const datePartMatcher: {
    [key: string]: Object;
};
/**
 * Date Format is a framework provides support for date formatting.
 * @private
 */
export  class DateFormat {
    /**
     * Returns the formatter function for given skeleton.
     * @param {string} -  Specifies the culture name to be which formatting.
     * @param {DateFormatOptions} - Specific the format in which date  will format.
     * @param {cldr} - Specifies the global cldr data collection.
     * @return Function.
     */
    static dateFormat(culture: string, option: DateFormatOptions, cldr: Object): Function;
    /**
     * Returns formatted date string based on options passed.
     * @param {Date} value
     * @param {FormatOptions} options
     */
    private static intDateFormatter(value, options);
    /**
     * Returns two digit numbers for given value and length
     */
    private static checkTwodigitNumber(val, len);
    /**
     * Returns the value of the Time Zone.
     * @param {number} tVal
     * @param {string} pattern
     * @private
     */
    static getTimeZoneValue(tVal: number, pattern: string): string;
}
/**
 * Date Parser.
 * @private
 */
export  class DateParser {
    /**
     * Returns the parser function for given skeleton.
     * @param {string} -  Specifies the culture name to be which formatting.
     * @param {DateFormatOptions} - Specific the format in which string date  will be parsed.
     * @param {cldr} - Specifies the global cldr data collection.
     *  @return Function.
     */
    static dateParser(culture: string, option: DateFormatOptions, cldr: Object): Function;
    /**
     * Returns date object for provided date options
     * @param {DateParts} options
     * @param {Date} value
     * @returns {Date}
     */
    private static getDateObject(options, value?);
    /**
     * Returns date parsing options for provided value along with parse and numeric options
     * @param {string} value
     * @param {ParseOptions} parseOptions
     * @param {NumericOptions} num
     * @returns {DateParts}
     */
    private static internalDateParse(value, parseOptions, num);
    /**
     * Returns parsed number for provided Numeric string and Numeric Options
     * @param {string} value
     * @param {NumericOptions} option
     * @returns {number}
     */
    private static internalNumberParser(value, option);
    /**
     * Returns parsed time zone RegExp for provided hour format and time zone
     * @param {string} hourFormat
     * @param {base.IntlBase.TimeZoneOptions} tZone
     * @param {string} nRegex
     * @returns {string}
     */
    private static parseTimeZoneRegx(hourFormat, tZone, nRegex);
    /**
     * Returns zone based value.
     * @param {boolean} flag
     * @param {string} val1
     * @param {string} val2
     * @param {NumericOptions} num
     * @returns {number}
     */
    private static getZoneValue(flag, val1, val2, num);
}
/**
 * Internationalization
 */
/**
 * Date base common constants and function for date parser and formatter.
 */
export  namespace IntlBase {
    const negativeDataRegex: RegExp;
    const customRegex: RegExp;
    const latnParseRegex: RegExp;
    const defaultCurrency: string;
    interface NumericSkeleton {
        type?: string;
        isAccount?: boolean;
        fractionDigits?: number;
    }
    interface GenericFormatOptions {
        nData?: NegativeData;
        pData?: NegativeData;
        zeroData?: NegativeData;
    }
    interface GroupSize {
        primary?: number;
        secondary?: number;
    }
    interface NegativeData extends FormatParts {
        nlead?: string;
        nend?: string;
        groupPattern?: string;
        minimumFraction?: number;
        maximumFraction?: number;
    }
    const formatRegex: RegExp;
    const dateParseRegex: RegExp;
    const basicPatterns: string[];
    interface Dependables {
        parserObject?: Object;
        dateObject?: Object;
        numericObject?: Object;
    }
    interface TimeZoneOptions {
        hourFormat?: string;
        gmtFormat?: string;
        gmtZeroFormat?: string;
    }
    const defaultObject: Object;
    const monthIndex: Object;
    /**
     *
     */
    const month: string;
    const days: string;
    /**
     * Default numerber Object
     */
    const patternMatcher: {
        [key: string]: Object;
    };
    /**
     * Returns the resultant pattern based on the skeleton, dateObject and the type provided
     * @private
     * @param {string} skeleton
     * @param {Object} dateObject
     * @param {string} type
     * @returns {string}
     */
    function getResultantPattern(skeleton: string, dateObject: Object, type: string): string;
    /**
     * Returns the dependable object for provided cldr data and culture
     * @private
     * @param {Object} cldr
     * @param {string} culture
     * @param {boolean} isNumber
     * @returns {Dependables}
     */
    function getDependables(cldr: Object, culture: string, isNumber?: boolean): Dependables;
    /**
     * Returns the symbol pattern for provided parameters
     * @private
     * @param {string} type
     * @param {string} numSystem
     * @param {Object} obj
     * @param {boolean} isAccount
     * @returns {string}
     */
    function getSymbolPattern(type: string, numSystem: string, obj: Object, isAccount: boolean): string;
    /**
     * Returns proper numeric skeleton
     * @private
     * @param {string} skeleton
     * @returns {NumericSkeleton}
     */
    function getProperNumericSkeleton(skeleton: string): NumericSkeleton;
    /**
     * Returns format data for number formatting like minimum fraction, maximum fraction, etc..,
     * @private
     * @param {string} pattern
     * @param {boolean} needFraction
     * @param {string} cSymbol
     * @param {boolean} fractionOnly
     * @returns {NegativeData}
     */
    function getFormatData(pattern: string, needFraction: boolean, cSymbol: string, fractionOnly?: boolean): NegativeData;
    /**
     * Returns currency symbol based on currency code
     * @private
     * @param {Object} numericObject
     * @param {string} currencyCode
     * @returns {string}
     */
    function getCurrencySymbol(numericObject: Object, currencyCode: string): string;
    /**
     * Returns formatting options for custom number format
     * @private
     * @param {string} format
     * @param {CommonOptions} dOptions
     * @param {Dependables} obj
     * @returns {GenericFormatOptions}
     */
    function customFormat(format: string, dOptions: CommonOptions, obj: Dependables): GenericFormatOptions;
    /**
     * Returns formatting options for currency or percent type
     * @private
     * @param {string[]} parts
     * @param {string} actual
     * @param {string} symbol
     * @returns {NegativeData}
     */
    function isCurrencyPercent(parts: string[], actual: string, symbol: string): NegativeData;
    /**
     * Returns culture based date separator
     * @private
     * @param {Object} dateObj
     * @returns {string}
     */
    function getDateSeparator(dateObj: Object): string;
    /**
     * Returns Native Date Time pattern
     * @private
     * @param {string} culture
     * @param {DateFormatOptions} options
     * @param {Object} cldr
     * @returns {string}
     */
    function getActualDateTimeFormat(culture: string, options: DateFormatOptions, cldr?: Object, isExcelFormat?: boolean): string;
    /**
     * Returns Native Number pattern
     * @private
     * @param {string} culture
     * @param {NumberFormatOptions} options
     * @param {Object} cldr
     * @returns {string}
     */
    function getActualNumberFormat(culture: string, options: NumberFormatOptions, cldr?: Object): string;
}
/**
 * Interface for default formatting options
 * @private
 */
export interface FormatParts extends base.IntlBase.NumericSkeleton, NumberFormatOptions {
    groupOne?: boolean;
    isPercent?: boolean;
    isCurrency?: boolean;
    isNegative?: boolean;
    groupData?: GroupDetails;
    groupSeparator?: string;
}
/**
 * Interface for common formatting options
 */
export interface CommonOptions {
    numberMapper?: NumberMapper;
    currencySymbol?: string;
    percentSymbol?: string;
    minusSymbol?: string;
}
/**
 * Interface for grouping process
 */
export interface GroupDetails {
    primary?: number;
    secondary?: number;
}
/**
 * Module for number formatting.
 * @private
 */
export  class NumberFormat {
    /**
     * Returns the formatter function for given skeleton.
     * @param {string} culture -  Specifies the culture name to be which formatting.
     * @param {NumberFormatOptions} option - Specific the format in which number  will format.
     * @param {Object} object- Specifies the global cldr data collection.
     * @return Function.
     */
    static numberFormatter(culture: string, option: NumberFormatOptions, cldr: Object): Function;
    /**
     * Returns grouping details for the pattern provided
     * @param {string} pattern
     * @returns {GroupDetails}
     */
    static getGroupingDetails(pattern: string): GroupDetails;
    /**
     * Returns if the provided integer range is valid.
     * @param {number} val1
     * @param {number} val2
     * @param {boolean} checkbothExist
     * @param {boolean} isFraction
     * @returns {boolean}
     */
    private static checkValueRange(val1, val2, checkbothExist, isFraction?);
    /**
     * Check if the provided fraction range is valid
     * @param {number} val
     * @param {string} text
     * @param {boolean} isFraction
     * @returns {void}
     */
    private static checkRange(val, text, isFraction?);
    /**
     * Returns formatted numeric string for provided formatting options
     * @param {number} value
     * @param {base.GenericFormatOptions} fOptions
     * @param {CommonOptions} dOptions
     * @returns {string}
     */
    private static intNumberFormatter(value, fOptions, dOptions);
    /**
     * Returns significant digits processed numeric string
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @returns {string}
     */
    private static processSignificantDigits(value, min, max);
    /**
     * Returns grouped numeric string
     * @param {string} val
     * @param {number} level1
     * @param {string} sep
     * @param {string} decimalSymbol
     * @param {number} level2
     * @returns {string}
     */
    private static groupNumbers(val, level1, sep, decimalSymbol, level2?);
    /**
     * Returns fraction processed numeric string
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @returns {string}
     */
    private static processFraction(value, min, max);
    /**
     * Returns integer processed numeric string
     * @param {string} value
     * @param {number} min
     * @returns {string}
     */
    private static processMinimumIntegers(value, min);
}
/**
 * interface for Numeric Formatting Parts
 */
export interface NumericParts {
    symbolRegex?: RegExp;
    nData?: base.IntlBase.NegativeData;
    pData?: base.IntlBase.NegativeData;
    infinity?: string;
    type?: string;
    fractionDigits?: number;
    isAccount?: boolean;
    custom?: boolean;
}
/**
 * Module for Number Parser.
 * @private
 */
export  class NumberParser {
    /**
     * Returns the parser function for given skeleton.
     * @param {string} -  Specifies the culture name to be which formatting.
     * @param {NumberFormatOptions} - Specific the format in which number  will parsed.
     * @param {cldr} - Specifies the global cldr data collection.
     * @return Function.
     */
    static numberParser(culture: string, option: NumberFormatOptions, cldr: Object): Function;
    /**
     * Returns parsed number for the provided formatting options
     * @param {string} value
     * @param {NumericParts} options
     * @param {NumericOptions} numOptions
     * @returns {number}
     */
    private static getParsedNumber(value, options, numOptions);
}
/**
 * Interface for numeric Options
 */
export interface NumericOptions {
    numericPair?: Object;
    numericRegex?: string;
    numberParseRegex?: RegExp;
    symbolNumberSystem?: Object;
    symbolMatch?: Object;
    numberSystem?: string;
}
/**
 * Interface for numeric object
 */
export interface NumericObject {
    obj?: Object;
    nSystem?: string;
}
/**
 * Interface for number mapper
 */
export interface NumberMapper {
    mapper?: Object;
    timeSeparator?: string;
    numberSymbols?: Object;
    numberSystem?: string;
}
/**
 * Interface for parser base
 * @private
 */
export  class ParserBase {
    static nPair: string;
    static nRegex: string;
    static numberingSystems: Object;
    /**
     * Returns the cldr object for the culture specifies
     * @param {Object} obj - Specifies the object from which culture object to be acquired.
     * @param {string} cName - Specifies the culture name.
     * @returns {Object}
     */
    static getMainObject(obj: Object, cName: string): Object;
    /**
     * Returns the numbering system object from given cldr data.
     * @param {Object} obj - Specifies the object from which number system is acquired.
     * @returns {Object}
     */
    static getNumberingSystem(obj: Object): Object;
    /**
     * Returns the reverse of given object keys or keys specified.
     * @param {Object} prop - Specifies the object to be reversed.
     * @param {number[]} keys - Optional parameter specifies the custom keyList for reversal.
     * @returns {Object}
     */
    static reverseObject(prop: Object, keys?: number[]): Object;
    /**
     * Returns the symbol regex by skipping the escape sequence.
     * @param {string[]} props - Specifies the array values to be skipped.
     * @returns {RegExp}
     */
    static getSymbolRegex(props: string[]): RegExp;
    private static getSymbolMatch(prop);
    /**
     * Returns regex string for provided value
     * @param {string} val
     * @returns {string}
     */
    private static constructRegex(val);
    /**
     * Returns the replaced value of matching regex and obj mapper.
     * @param {string} value - Specifies the  values to be replaced.
     * @param {RegExp} regex - Specifies the  regex to search.
     * @param {Object} obj - Specifies the  object matcher to be replace value parts.
     * @returns {string}
     */
    static convertValueParts(value: string, regex: RegExp, obj: Object): string;
    /**
     * Returns default numbering system object for formatting from cldr data
     * @param {Object} obj
     * @returns {NumericObject}
     */
    static getDefaultNumberingSystem(obj: Object): NumericObject;
    /**
     * Returns the replaced value of matching regex and obj mapper.
     */
    static getCurrentNumericOptions(curObj: Object, numberSystem: Object, needSymbols?: boolean): Object;
    /**
     * Returns number mapper object for the provided cldr data
     * @param {Object} curObj
     * @param {Object} numberSystem
     * @param {boolean} isNumber
     * @returns {NumberMapper}
     */
    static getNumberMapper(curObj: Object, numberSystem: Object, isNumber?: boolean): NumberMapper;
}
/**
 * Interface for a class KeyboardEvents
 */
export interface KeyboardEventsModel {
    /**
     * Specifies key combination and it respective action name.
     * @default null
     */
    keyConfigs?: { [key: string]: string };
    /**
     * Specifies on which event keyboardEvents class should listen for key press. For ex., `keyup`, `keydown` or `keypress`
     * @default keyup
     */
    eventName?: string;
    /**
     * Specifies the listener when keyboard actions is performed. 
     * @event
     */
    keyAction?: EmitType<KeyboardEventArgs>;
}
/**
 * KeyboardEvents
 */
export interface KeyboardEventArgs extends KeyboardEvent {
    /**
     * action of the KeyboardEvent
     */
    action: string;
}
/**
 * KeyboardEvents class enables you to bind key action desired key combinations for ex., Ctrl+A, Delete, Alt+Space etc.
 * ```html
 * <div id='testEle'>  </div>;
 * <script>
 *   let node: HTMLElement = document.querySelector('#testEle');
 *   let kbInstance = new KeyboardEvents({
 *       element: node,
 *       keyConfigs:{ selectAll : 'ctrl+a' },
 *       keyAction: function (e:KeyboardEvent, action:string) {
 *           // handler function code
 *       }
 *   });
 * </script>
 * ```
 */
export  class KeyboardEvents extends Base<HTMLElement> implements INotifyPropertyChanged {
    /**
     * Specifies key combination and it respective action name.
     * @default null
     */
    keyConfigs: {
        [key: string]: string;
    };
    /**
     * Specifies on which event keyboardEvents class should listen for key press. For ex., `keyup`, `keydown` or `keypress`
     * @default keyup
     */
    eventName: string;
    /**
     * Specifies the listener when keyboard actions is performed.
     * @event
     */
    keyAction: EmitType<KeyboardEventArgs>;
    /**
     * Initializes the KeyboardEvents
     * @param {HTMLElement} element
     * @param {KeyboardEventsModel} options
     */
    constructor(element: HTMLElement, options?: KeyboardEventsModel);
    /**
     * Unwire bound events and destroy the instance.
     * @return {void}
     */
    destroy(): void;
    /**
     * Function can be used to specify certain action if a property is changed
     * @param newProp
     * @param oldProp
     * @returns {void}
     * @private
     */
    onPropertyChanged(newProp: KeyboardEventsModel, oldProp?: KeyboardEventsModel): void;
    protected bind(): void;
    /**
     * To get the module name, returns 'keyboard'.
     * @private
     */
    getModuleName(): string;
    /**
     * Wiring event handlers to events
     */
    private wireEvents();
    /**
     * Unwiring event handlers to events
     */
    private unwireEvents();
    /**
     * To handle a key press event returns null
     */
    private keyPressHandler;
    private static configCache;
    /**
     * To get the key configuration data
     * @param {string} config - configuration data
     * returns {KeyData}
     */
    private static getKeyConfigData(config);
    private static getKeyCode(keyVal);
}
/**
 * L10n modules provides localized text for different culture.
 * ```typescript
 * //load global locale object common for all components.
 * L10n.load({
 *    'fr-BE': {
 *       'button': {
 *            'check': 'vérifié'
 *        }
 *    }
 * });
 * //set globale default locale culture.
 * ts-base-library.setCulture('fr-BE');
 * let instance: L10n = new L10n('button', {
 *    check: 'checked'
 * });
 * //Get locale text for current property.
 * instance.getConstant('check');
 * //Change locale culture in a component.
 * instance.setLocale('en-US');
 * ```
 */
export  class L10n {
    private static locale;
    private controlName;
    private localeStrings;
    private currentLocale;
    /**
     * Constructor
     */
    constructor(controlName: string, localeStrings: Object, locale?: string);
    /**
     * Sets the locale text
     * @param {string} locale
     * @returns {void}
     */
    setLocale(locale: string): void;
    /**
     * Sets the global locale for all components.
     * @param {Object} localeObject - specifies the localeObject to be set as global locale.
     */
    static load(localeObject: Object): void;
    /**
     * Returns current locale text for the property based on the culture name and control name.
     * @param {string} propertyName - specifies the property for which localize text to be returned.
     * @return string
     */
    getConstant(prop: string): string;
    /**
     * Returns the control constant object for current object and the locale specified.
     * @param {Object} curObject
     * @param {string} locale
     * @returns {Object}
     */
    private intGetControlConstant(curObject, locale);
}
export interface ModuleDeclaration {
    args: Object[];
    member: string;
    isProperty?: boolean;
}
export interface IParent {
    [key: string]: any;
}
export  class ModuleLoader {
    private parent;
    private loadedModules;
    constructor(parent: IParent);
    /**
     * Inject required modules in component library
     * @return {void}
     * @param {ModuleDeclaration[]} requiredModules - Array of modules to be required
     * @param {Function[]} moduleList - Array of modules to be injected from sample side
     */
    inject(requiredModules: ModuleDeclaration[], moduleList: Function[]): void;
    /**
     * To remove the created object while destroying the control
     * @return {void}
     */
    clean(): void;
    /**
     * Removes all unused modules
     * @param {ModuleDeclaration[]} moduleList
     * @returns {void}
     */
    private clearUnusedModule(moduleList);
    /**
     * To get the name of the member.
     * @param {string} name
     * @returns {string}
     */
    private getMemberName(name);
    /**
     * Returns boolean based on whether the module specified is loaded or not
     * @param {string} modName
     * @returns {boolean}
     */
    private isModuleLoaded(modName);
}
/**
 * Method used to create property. General syntax below.
 * @param  {T} defaultValue? - Specifies the default value of property.
 * ```
 * @Property('TypeScript')
 * propertyName: Type;
 * ```
 * @private
 */
export  function Property<T>(defaultValue?: T | Object): PropertyDecorator;
/**
 * Method used to create complex property. General syntax below.
 * @param  {T} defaultValue - Specifies the default value of property.
 * @param  {Function} type - Specifies the class type of complex object.
 * ```
 * @Complex<Type>({},Type)
 * propertyName: Type;
 * ```
 * @private
 */
export  function Complex<T>(defaultValue: T, type: Function): PropertyDecorator;
/**
 * Method used to create complex Factory property. General syntax below.
 * @param  {Function} defaultType - Specifies the default value of property.
 * @param  {Function} type - Specifies the class factory type of complex object.
 * ```
 * @ComplexFactory(defaultType, factoryFunction)
 * propertyName: Type1 | Type2;
 * ```
 * @private
 */
export  function ComplexFactory(type: Function): PropertyDecorator;
/**
 * Method used to create complex array property. General syntax below.
 * @param  {T[]} defaultValue - Specifies the default value of property.
 * @param  {Function} type - Specifies the class type of complex object.
 * ```
 * @Collection([], Type);
 * propertyName: Type;
 * ```
 * @private
 */
export  function Collection<T>(defaultValue: T[], type: Function): PropertyDecorator;
/**
 * Method used to create complex factory array property. General syntax below.
 * @param  {T[]} defaultType - Specifies the default type of property.
 * @param  {Function} type - Specifies the class type of complex object.
 * ```
 * @Collection([], Type);
 * propertyName: Type;
 * ```
 * @private
 */
export  function CollectionFactory(type: Function): PropertyDecorator;
/**
 * Method used to create event property. General syntax below.
 * @param  {Function} defaultValue? - Specifies the default value of property.
 * @param  {boolean} isComplex? - Specifies the whether it is complex object.
 * ```
 * @Event(()=>{return true;})
 * ```
 * @private
 */
export  function Event(): PropertyDecorator;
/**
 * NotifyPropertyChanges is triggers the call back when the property has been changed.
 *
 * ```
 *  @NotifyPropertyChanges
 * class DemoClass implements INotifyPropertyChanged {
 *
 *     @Property()
 *     property1: string;
 *
 *     dataBind: () => void;
 *
 *     constructor() { }
 *
 *     onPropertyChanged(newProp: any, oldProp: any) {
 *         // Called when property changed
 *     }
 * }
 * ```
 * @private
 */
export  function NotifyPropertyChanges(classConstructor: Function): void;
/**
 * Interface to notify the changed properties
 */
export interface INotifyPropertyChanged {
    onPropertyChanged(newProperties: Object, oldProperties?: Object): void;
}
/**
 * Method used to create builder for the components
 * @param {any} component -specifies the target component for which builder to be created.
 * @private
 */
export  function CreateBuilder<T>(component: T): Object;
/**
 * Observer is used to perform event handling based the object.
 * ```
 * //Creating observer instance.
 * let observer:Observer = Observer(this);
 * let handler: Function = (a:number, b: number): number => {return a + b; }
 * //add handler to event.
 * observe.on('eventname', handler);
 * //remove handler from event.
 * observe.off('eventname', handler);
 * //notify the handlers in event.
 * observe.notify('eventname');
 * ```
 *
 */
export interface BoundOptions {
    handler?: Function;
    context?: Object;
    event?: string;
}
export  class Observer {
    private context;
    private boundedEvents;
    constructor(context?: Object);
    /**
     * To attach handler for given property in current context.
     * @param {string} property - specifies the name of the event.
     * @param {Function} handler - Specifies the handler function to be called while event notified.
     * @param {Object} context - Specifies the context binded to the handler.
     * @return {void}
     */
    on(property: string, handler: Function, context?: Object): void;
    /**
     * To remove handlers from a event attached using on() function.
     * @param {string} eventName - specifies the name of the event.
     * @param {Function} handler - Optional argument specifies the handler function to be called while event notified.
     * @return {void}
     */
    off(property: string, handler?: Function): void;
    /**
     * To notify the handlers in the specified event.
     * @param {string} property - Specifies the event to be notify.
     *  @param {Object} args - Additional parameters to pass while calling the handler.
     * @return {void}
     */
    notify(property: string, argument?: Object): void;
    /**
     * To destroy handlers in the event
     */
    destroy(): void;
    /**
     * Returns if the property exists.
     */
    private notExist(prop);
    /**
     * Returns if the handler is present.
     */
    private isHandlerPresent(boundedEvents, handler);
}
/**
 * This has the basic properties required for SvgRenderer and CanvasRenderer
 */
export interface BaseAttibutes {
    /**
     * Specifies the ID of an element 
     */
    id?: string;
    /**
     * Specifies the fill color value 
     */
    fill?: string;
    /**
     * Specifies the border color value
     */
    stroke?: string;
    /**
     * Specifies the width of the border
     */
    'stroke-width'?: number;
    /**
     * Specifies the opacity value of an element
     */
    opacity?: number;
    /**
     * Height of the element
     */
    height?: number;
    /**
     * Width of the element
     */
    width?: number;
    /**
     * X value of the element 
     */
    x?: number;
    /**
     * Y value of the element 
     */
    y?: number;
    /**
     * Specifies the dash array value of an element
     */
    'stroke-dasharray'?: string;
    /**
     * Property to specify CSS styles for the elements
     */
    style?: string;
    /**
     * Color of the element 
     */
    color?: string;
    /**
     * Specifies the name of the class
     */
    className?: string;
    /**
     * Specifies the transformation value 
     */
    transform?: string;
    /**
     * Specifies the fill opacity of a shape/element
     */
    'fill-opacity'?: number;
    /**
     * Type of pointer for an element 
     */
    pointer?: string;
    /**
     * Specifies the plot value 
     */
    plot?: string;
    /**
     * Visibility of an element 
     */
    visibility?: string;
    /**
     * Specifies the clip path of an element
     */
    'clip-path'?: string;
}
/**
 * This has the properties for a SVG element
 */
export interface SVGAttributes extends BaseAttibutes {
    /**
     * View box property of an element
     */
    viewBox?: string;
    /**
     * Specifies the xmlns link property of a SVG element 
     */
    xmlns?: string;
}
/**
 * Properties required to render a circle
 */
export interface CircleAttributes extends BaseAttibutes {
    /**
     * Center x value of a circle
     */
    cx?: number;
    /**
     * Center y value of a circle
     */
    cy?: number;
    /**
     * Radius value of a circle
     */
    r?: number;
}
/**
 * Properties required to render a line
 */
export interface LineAttributes extends BaseAttibutes {
    /**
     * Specifies the value of x1
     */
    x1?: number;
    /**
     * Specifies the value of x2
     */
    x2?: number;
    /**
     * Specifies the value of y1
     */
    y1?: number;
    /**
     * Specifies the value of y2
     */
    y2?: number;
}
/**
 * Properties required to render a rectangle
 */
export interface RectAttributes extends BaseAttibutes {
    /**
     * Corner radius value of a rectangle
     */
    rx?: number;
}
/**
 * Properties required to render path
 */
export interface PathAttributes extends BaseAttibutes {
    /**
     * Specifies the d value of a path
     */
    d?: string;
    /**
     * Inner radius value of a path
     */
    innerR?: number;
    /**
     * Value of cx in path
     */
    cx?: number;
    /**
     * Value of cy in path
     */
    cy?: number;
    /**
     * Radius value of a path
     */
    r?: number;
    /**
     * Specifies the start value
     */
    start?: number;
    /**
     * Specifies the end value
     */
    end?: number;
    /**
     * Specifies the radius value
     */
    radius?: number;
    /**
     * Specifies the direction of path
     */
    counterClockWise?: boolean;
}
/**
 * Properties required to render a polyline
 */
export interface PolylineAttributes extends BaseAttibutes {
    /**
     * Points required to draw a polyline
     */
    points?: string;
}
/**
 * Properties required to render ellipse
 */
export interface EllipseAttributes extends CircleAttributes {
    /**
     * Specifies the rx value
     */
    rx?: number;
    /**
     * Specifies the ry value
     */
    ry?: number;
}
/**
 * Properties required to render a pattern
 * @private
 */
export interface PatternAttributes extends BaseAttibutes {
    /**
     * Units to render a pattern
     */
    patternUnits?: string;
}
/**
 * Properties required to render an image
 */
export interface ImageAttributes extends BaseAttibutes {
    /**
     * Specifies the link to render it as image
     */
    href?: string;
    /**
     * Ratio value to render an image
     */
    preserveAspectRatio?: string;
}
/**
 * Properties required to render text
 */
export interface TextAttributes extends BaseAttibutes {
    /**
     * Size of the text
     */
    'font-size'?: string;
    /**
     * Font family of the text
     */
    'font-family'?: string;
    /**
     * Font style of the text
     */
    'font-style'?: string;
    /**
     * Weight of the text
     */
    'font-weight'?: string;
    /**
     * Specifies the text anchor value
     */
    'text-anchor'?: string;
    /**
     * Specifies the baseline value
     */
    'baseline'?: string;
    /**
     * Angle of rotation
     */
    'labelRotation'?: number;
}
/**
 * Properties required to render radial gradient
 */
export interface RadialGradient {
    /**
     * Specifies the id of the radial gradient
     */
    id?: string;
    /**
     * Specifies the cx value
     */
    cx?: string;
    /**
     * Specifies the cy value
     */
    cy?: string;
    /**
     * Specifies the radius value
     */
    r?: string;
    /**
     * Specifies the fx value
     */
    fx?: string;
    /**
     * Specifies the fy value
     */
    fy?: string;
}
/**
 * Properties required to render linear gradient
 */
export interface LinearGradient {
    /**
     * Id of the linear gradient
     */
    id?: string;
    /**
     * Specifies the x1 value
     */
    x1?: string;
    /**
     * Specifies the x2 value
     */
    x2?: string;
    /**
     * Specifies the y1 value
     */
    y1?: string;
    /**
     * Specifies the y2 value
     */
    y2?: string;
}
/**
 * Properties required to render a circle
 */
export interface SVGCanvasAttributes {
    /**
     * To specify a new property
     */
    [key: string]: string;
}
/**
 * Properties required to render a gradient
 * @private
 */
export interface GradientColor {
    /**
     * Specifies the color value of the gradient
     */
    color?: string;
    /**
     * Specifies the colorstop value of the gradient
     */
    colorStop?: string;
}
export  class SvgRenderer {
    private svgLink;
    private svgObj;
    private rootId;
    /**
     * Specifies the height of the canvas element.
     * @default null
     */
    height: number;
    /**
     * Specifies the width of the canvas element.
     * @default null
     */
    width: number;
    constructor(rootID: string);
    private getOptionValue<T>(options, key);
    /**
     * To create a Html5 SVG element
     * @param {SVGAttributes} options - Options to create SVG
     * @return {Element}
     */
    createSvg(options: SVGAttributes): Element;
    private setSVGSize(width, height);
    /**
     * To draw a path
     * @param {PathAttributes} options - Options to draw a path in SVG
     * @return {Element}
     */
    drawPath(options: PathAttributes): Element;
    /**
     * To draw a line
     * @param {LineAttributes} options - Options to draw a line in SVG
     * @return {Element}
     */
    drawLine(options: LineAttributes): Element;
    /**
     * To draw a rectangle
     * @param {BaseAttibutes} options - Required options to draw a rectangle in SVG
     * @return {Element}
     */
    drawRectangle(options: RectAttributes): Element;
    /**
     * To draw a circle
     * @param {CircleAttributes} options - Required options to draw a circle in SVG
     * @return {Element}
     */
    drawCircle(options: CircleAttributes): Element;
    /**
     * To draw a polyline
     * @param {PolylineAttributes} options - Options required to draw a polyline
     * @return {Element}
     */
    drawPolyline(options: PolylineAttributes): Element;
    /**
     * To draw an ellipse
     * @param {EllipseAttributes} options - Options required to draw an ellipse
     * @return {Element}
     */
    drawEllipse(options: EllipseAttributes): Element;
    /**
     * To draw a polygon
     * @param {PolylineAttributes} options - Options needed to draw a polygon in SVG
     * @return {Element}
     */
    drawPolygon(options: PolylineAttributes): Element;
    /**
     * To draw an image
     * @param {ImageAttributes} options - Required options to draw an image in SVG
     * @return {Element}
     */
    drawImage(options: ImageAttributes): Element;
    /**
     * To draw a text
     * @param {TextAttributes} options - Options needed to draw a text in SVG
     * @return {Element}
     */
    createText(options: TextAttributes, label: string): Element;
    /**
     * To create a tSpan
     * @param {TextAttributes} options - Options to create tSpan
     * @param {string} label - The text content which is to be rendered in the tSpan
     * @return {Element}
     */
    createTSpan(options: TextAttributes, label: string): Element;
    /**
     * To create a title
     * @param {string} text - The text content which is to be rendered in the title
     * @return {Element}
     */
    createTitle(text: string): Element;
    /**
     * To create defs element in SVG
     * @return {Element}
     */
    createDefs(): Element;
    /**
     * To create clip path in SVG
     * @param {BaseAttibutes} options - Options needed to create clip path
     * @return {Element}
     */
    createClipPath(options: BaseAttibutes): Element;
    /**
     * To create foreign object in SVG
     * @param {BaseAttibutes} options - Options needed to create foreign object
     * @return {Element}
     */
    createForeignObject(options: BaseAttibutes): Element;
    /**
     * To create group element in SVG
     * @param {BaseAttibutes} options - Options needed to create group
     * @return {Element}
     */
    createGroup(options: BaseAttibutes): Element;
    /**
     * To create pattern in SVG
     * @param {PatternAttributes} options - Required options to create pattern in SVG
     * @param {string} type - Specifies the name of the pattern
     * @return {Element}
     */
    createPattern(options: PatternAttributes, element: string): Element;
    /**
     * To create radial gradient in SVG
     * @param {string[]} colors - Specifies the colors required to create radial gradient
     * @param {string[]} colorStop - Specifies the colorstop required to create radial gradient
     * @param {string} name - Specifies the name of the gradient
     * @param {RadialGradient} options - value for radial gradient
     * @return {string}
     */
    createRadialGradient(colors: GradientColor[], name: string, options: RadialGradient): string;
    /**
     * To create linear gradient in SVG
     * @param {string[]} colors - Array of string specifies the values for color
     * @param {string[]} colors - Array of string specifies the values for colorStop
     * @param {string} name - Specifies the name of the gradient
     * @param {LinearGradient} options - Specifies the options for gradient
     * @return {string}
     */
    createLinearGradient(colors: GradientColor[], name: string, options: LinearGradient): string;
    /**
     * To render the gradient element in SVG
     * @param {string} gradientType - Specifies the type of the gradient
     * @param {RadialGradient | LinearGradient} options - Options required to render a gradient
     * @param {string[]} colors - Array of string specifies the values for color
     * @param {string[]} colorStop - Array of string specifies the values for colorStop
     * @return {Element}
     */
    drawGradient(gradientType: string, options: RadialGradient | LinearGradient, colors: GradientColor[]): Element;
    /**
     * To render a clip path
     * @param {BaseAttibutes} options - Options required to render a clip path
     * @return {Element}
     */
    drawClipPath(options: BaseAttibutes): Element;
    /**
     * To create circular clip path in SVG
     * @param {CircleAttributes} options - Options required to create circular clip path
     * @return {Element}
     */
    drawCircularClipPath(options: CircleAttributes): Element;
    /**
     * To set the attributes to the element
     * @param {SVGCanvasAttributes} options - Attributes to set for the element
     * @param {Element} element - The element to which the attributes need to be set
     * @return {Element}
     */
    setElementAttributes(options: SVGCanvasAttributes, element: Element): Element;
}
/**
 * Interface for Template Engine.
 */
export interface ITemplateEngine {
    compile: (templateString: string, helper?: Object) => (data: Object | JSON) => string;
}
/**
 * Compile the template string into template function.
 * @param  {string} templateString - The template string which is going to convert.
 * @param  {Object} helper? - Helper functions as an object.
 * @private
 */
export  function compile(templateString: string, helper?: Object): (data: Object | JSON, component?: any, propName?: any) => HTMLCollection;
/**
 * Set your custom template engine for template rendering.
 * @param  {ITemplateEngine} classObj - Class object for custom template.
 * @private
 */
export  function setTemplateEngine(classObj: ITemplateEngine): void;
/**
 * Get current template engine for template rendering.
 * @param  {ITemplateEngine} classObj - Class object for custom template.
 * @private
 */
export  function getTemplateEngine(): (template: string, helper?: Object) => (data: Object | JSON) => string;
/**
 * The function to set regular expression for template expression string.
 * @param  {RegExp} value - Value expression.
 * @private
 */
export  function expression(value?: RegExp): RegExp;
/**
 * Compile the template string into template function.
 * @param  {string} template - The template string which is going to convert.
 * @param  {Object} helper? - Helper functions as an object.
 * @private
 */
export  function compile(template: string, helper?: Object): () => string;
/**
 * Interface for a class SwipeSettings
 * @private
 */
export interface SwipeSettingsModel {
    /**
     * Property specifies minimum distance of swipe moved.
     */
    swipeThresholdDistance?: number;
}
/**
 * Interface for a class Touch
 */
export interface TouchModel {
    /**
     * Specifies the callback function for tap event.
     * @event
     */
    tap?: EmitType<TapEventArgs>;
    /**
     * Specifies the callback function for tapHold event.
     * @event
     */
    tapHold?: EmitType<TapEventArgs>;
    /**
     * Specifies the callback function for swipe event.
     * @event
     */
    swipe?: EmitType<SwipeEventArgs>;
    /**
     * Specifies the callback function for scroll event.
     * @event
     */
    scroll?: EmitType<ScrollEventArgs>;
    /**
     * Specifies the time delay for tap.
     * @default 350
     */
    tapThreshold?: number;
    /**
     * Specifies the time delay for tap hold.
     * @default 750
     */
    tapHoldThreshold?: number;
    /**
     * Customize the swipe event configuration.
     * @default { swipeThresholdDistance: 50 }
     */
    swipeSettings?: SwipeSettingsModel;
}
/**
 * SwipeSettings is a framework module that provides support to handle swipe event like swipe up, swipe right, etc..,
 * @private
 */
export  class SwipeSettings extends ChildProperty<SwipeSettings> {
    /**
     * Property specifies minimum distance of swipe moved.
     */
    swipeThresholdDistance: number;
}
/**
 * Touch class provides support to handle the touch event like tap, double tap, tap hold, etc..,
 * ```typescript
 *    let node: HTMLElement;
 * let touchObj: Touch = new Touch({
 *    element: node,
 *    tap: function (e) {
 *        // tap handler function code
 *    }
 *    tapHold: function (e) {
 *        // tap hold handler function code
 *    }
 *    scroll: function (e) {
 *        // scroll handler function code
 *    }
 *    swipe: function (e) {
 *        // swipe handler function code
 *    }
 * });
 * ```
 */
export  class Touch extends Base<HTMLElement> implements INotifyPropertyChanged {
    private isTouchMoved;
    private startPoint;
    private movedPoint;
    private endPoint;
    private startEventData;
    private lastTapTime;
    private lastMovedPoint;
    private scrollDirection;
    private hScrollLocked;
    private vScrollLocked;
    private defaultArgs;
    private distanceX;
    private distanceY;
    private movedDirection;
    private tStampStart;
    private touchAction;
    private timeOutTap;
    private modeClear;
    private timeOutTapHold;
    /**
     * Specifies the callback function for tap event.
     * @event
     */
    tap: EmitType<TapEventArgs>;
    /**
     * Specifies the callback function for tapHold event.
     * @event
     */
    tapHold: EmitType<TapEventArgs>;
    /**
     * Specifies the callback function for swipe event.
     * @event
     */
    swipe: EmitType<SwipeEventArgs>;
    /**
     * Specifies the callback function for scroll event.
     * @event
     */
    scroll: EmitType<ScrollEventArgs>;
    /**
     * Specifies the time delay for tap.
     * @default 350
     */
    tapThreshold: number;
    /**
     * Specifies the time delay for tap hold.
     * @default 750
     */
    tapHoldThreshold: number;
    /**
     * Customize the swipe event configuration.
     * @default { swipeThresholdDistance: 50 }
     */
    swipeSettings: SwipeSettingsModel;
    private tapCount;
    constructor(element: HTMLElement, options?: TouchModel);
    /**
     * @private
     * @param newProp
     * @param oldProp
     */
    onPropertyChanged(newProp: TouchModel, oldProp: TouchModel): void;
    protected bind(): void;
    /**
     * To destroy the touch instance.
     * @return {void}
     */
    destroy(): void;
    private wireEvents();
    private unwireEvents();
    /**
     * Returns module name as touch
     * @returns {string}
     * @private
     */
    getModuleName(): string;
    /**
     * Returns if the HTML element is Scrollable.
     * @param {HTMLElement} element - HTML Element to check if Scrollable.
     * @returns {boolean}
     */
    private isScrollable(element);
    private startEvent;
    private moveEvent;
    private cancelEvent;
    private tapHoldEvent(evt);
    private endEvent;
    private calcPoints(evt);
    private calcScrollPoints(evt);
    private getVelocity(pnt);
    private checkSwipe(ele, flag);
}
/**
 * The argument type of `Tap` Event
 */
export interface TapEventArgs extends BaseEventArgs {
    /**
     * Original native event Object.
     */
    originalEvent: TouchEventArgs | MouseEventArgs;
    /**
     * Tap Count.
     */
    tapCount?: number;
}
/**
 * The argument type of `Scroll` Event
 */
export interface ScrollEventArgs extends BaseEventArgs {
    /**
     * Event argument for start event.
     */
    startEvents: TouchEventArgs | MouseEventArgs;
    /**
     * Original native event object for scroll.
     */
    originalEvent: TouchEventArgs | MouseEventArgs;
    /**
     * X position when scroll started.
     */
    startX: number;
    /**
     * Y position when scroll started.
     */
    startY: number;
    /**
     * The direction scroll.
     */
    scrollDirection: string;
    /**
     * The total traveled distance from X position
     */
    distanceX: number;
    /**
     * The total traveled distance from Y position
     */
    distanceY: number;
    /**
     * The velocity of scroll.
     */
    velocity: number;
}
/**
 * The argument type of `Swipe` Event
 */
export interface SwipeEventArgs extends BaseEventArgs {
    /**
     * Event argument for start event.
     */
    startEvents: TouchEventArgs | MouseEventArgs;
    /**
     * Original native event object  for swipe.
     */
    originalEvent: TouchEventArgs | MouseEventArgs;
    /**
     * X position when swipe started.
     */
    startX: number;
    /**
     * Y position when swipe started.
     */
    startY: number;
    /**
     * The direction swipe.
     */
    swipeDirection: string;
    /**
     * The total traveled distance from X position
     */
    distanceX: number;
    /**
     * The total traveled distance from Y position
     */
    distanceY: number;
    /**
     * The velocity of swipe.
     */
    velocity: number;
}
export interface TouchEventArgs extends MouseEvent {
    /**
     * A TouchList with touched points.
     */
    changedTouches: MouseEventArgs[] | TouchEventArgs[];
    /**
     * Cancel the default action.
     */
    preventDefault(): void;
    /**
     * The horizontal coordinate point of client area.
     */
    clientX: number;
    /**
     * The vertical coordinate point of client area.
     */
    clientY: number;
}
export interface MouseEventArgs extends MouseEvent {
    /**
     * A TouchList with touched points.
     */
    changedTouches: MouseEventArgs[] | TouchEventArgs[];
    /**
     * Cancel the default action.
     */
    preventDefault(): void;
    /**
     * The horizontal coordinate point of client area.
     */
    clientX: number;
    /**
     * The vertical coordinate point of client area.
     */
    clientY: number;
}
/**
 * Common utility methods
 */
export interface IKeyValue extends CSSStyleDeclaration {
    [key: string]: any;
}
/**
 * Create Instance from constructor function with desired parameters.
 * @param {Function} classFunction - Class function to which need to create instance
 * @param {any[]} params - Parameters need to passed while creating instance
 * @return {any}
 * @private
 */
export  function createInstance(classFunction: Function, params: any[]): any;
/**
 * To run a callback function immediately after the browser has completed other operations.
 * @param {Function} handler - callback function to be triggered.
 * @return {Function}
 * @private
 */
export  function setImmediate(handler: Function): Function;
/**
 * To get nameSpace value from the desired object.
 * @param {string} nameSpace - String value to the get the inner object
 * @param {any} obj - Object to get the inner object value.
 * @return {any}
 * @private
 */
export  function getValue(nameSpace: string, obj: any): any;
/**
 * To set value for the nameSpace in desired object.
 * @param {string} nameSpace - String value to the get the inner object
 * @param {any} value - Value that you need to set.
 * @param {any} obj - Object to get the inner object value.
 * @return {void}
 * @private
 */
export  function setValue(nameSpace: string, value: any, obj: any): any;
/**
 * Delete an item from Object
 * @param {any} obj - Object in which we need to delete an item.
 * @param {string} params - String value to the get the inner object
 * @return {void}
 * @private
 */
export  function deleteObject(obj: any, key: string): void;
/**
 * Check weather the given argument is only object.
 * @param {any} obj - Object which is need to check.
 * @return {boolean}
 * @private
 */
export  function isObject(obj: any): boolean;
/**
 * To get enum value by giving the string.
 * @param {any} enumObject - Enum object.
 * @param {string} enumValue - Enum value to be searched
 * @return {any}
 * @private
 */
export  function getEnumValue(enumObject: any, enumValue: string | number): any;
/**
 * Merge the source object into destination object.
 * @param {any} source - source object which is going to merge with destination object
 * @param {any} destination - object need to be merged
 * @return {void}
 * @private
 */
export  function merge(source: Object, destination: Object): void;
/**
 * Extend the two object with newer one.
 * @param {any} copied - Resultant object after merged
 * @param {Object} first - First object need to merge
 * @param {Object} second - Second object need to merge
 * @return {Object}
 * @private
 */
export  function extend(copied: Object, first: Object, second?: Object, deep?: boolean): Object;
/**
 * To check whether the object is null or undefined.
 * @param {Object} value - To check the object is null or undefined
 * @return {boolean}
 * @private
 */
export  function isNullOrUndefined(value: Object): boolean;
/**
 * To check whether the object is undefined.
 * @param {Object} value - To check the object is undefined
 * @return {boolean}
 * @private
 */
export  function isUndefined(value: Object): boolean;
/**
 * To return the generated unique name
 * @param {string} definedName - To concatenate the unique id to provided name
 * @return {string}
 * @private
 */
export  function getUniqueID(definedName?: string): string;
/**
 * It limits the rate at which a function can fire. The function will fire only once every provided second instead of as quickly.
 * @param {Function} eventFunction - Specifies the function to run when the event occurs
 * @param {number} delay - A number that specifies the milliseconds for function delay call option
 * @return {Function}
 * @private
 */
export  function debounce(eventFunction: Function, delay: number): Function;
/**
 * To convert the object to string for query url
 * @param  {Object} data
 * @returns string
 * @private
 */
export  function queryParams(data: any): string;
/**
 * To check whether the given array contains object.
 * @param {T[]} value- Specifies the T type array to be checked.
 * @private
 */
export  function isObjectArray<T>(value: T[]): boolean;
/**
 * To check whether the  child element is descendant to parent element or parent and child are same element.
 * @param{Element} - Specifies the child element to compare with parent.
 * @param{Element} - Specifies the parent element.
 * @return boolean
 * @private
 */
export  function compareElementParent(child: Element, parent: Element): boolean;
/**
 * To throw custom error message.
 * @param{string} - Specifies the error message to be thrown.
 * @private
 */
export  function throwError(message: string): void;
/**
 * This function is used to print given element
 * @param{Element} element - Specifies the print content element.
 * @param{Window} printWindow - Specifies the print window.
 * @private
 */
export  function print(element: Element, printWindow?: Window): Window;
/**
 * Function to normalize the units applied to the element.
 * @param  {number|string} value
 * @return {string} result
 * @private
 */
export  function formatUnit(value: number | string): string;
/**
 * Function to fetch the Instances of a HTML element for the given component.
 * @param {string | HTMLElement} element
 * @param {any} component
 * @return {Object} inst
 * @private
 */
export  function getInstance(element: string | HTMLElement, component: any): Object;
/**
 * Function to add instances for the given element.
 * @param {string | HTMLElement} element
 * @param {Object} instance
 * @return {void}
 * @private
 */
export  function addInstance(element: string | HTMLElement, instance: Object): void;
 }
export namespace buttons { 

/**
 * Interface for a class Button
 */
export interface ButtonModel extends base.ComponentModel{
    /**
     * Positions the icon before/after the text content in the Button.
     * The possible values are:
     * * Left: The icon will be positioned to the left of the text content.
     * * Right: The icon will be positioned to the right of the text content.
     * @default "left"
     */
    iconPosition?: IconPosition;
    /**
     * Defines class/multiple classes separated by a space for the Button that is used to include an icon.
     * Buttons can also include font icon and sprite image.
     * @default ""
     */
    iconCss?: string;
    /**
     * Specifies a value that indicates whether the Button is `disabled` or not.
     * @default false.
     */
    disabled?: boolean;
    /**
     * Allows the appearance of the Button to be enhanced and visually appealing when set to `true`.
     * @default false
     */
    isPrimary?: boolean;
    /**
     * Defines class/multiple classes separated by a space in the Button element. The Button types, styles, and
     * size can be defined by using
     * [`this`](http://ej2.syncfusion.com/documentation/button/howto.html?lang=typescript#create-a-block-button).
     * @default ""
     */
    cssClass?: string;
    /**
     * Defines the `content` of the Button element that can either be a text or HTML elements.
     * @default ""
     */
    content?: string;
    /**
     * Makes the Button toggle, when set to `true`. When you click it, the state changes from normal to active.
     * @default false
     */
    isToggle?: boolean;
}
export  type IconPosition = 'Left' | 'Right';
/**
 * The Button is a graphical user interface element that triggers an event on its click action. It can contain a text, an image, or both.
 * ```html
 * <button id="button">Button</button>
 * ```
 * ```typescript
 * <script>
 * var btnObj = new Button();
 * btnObj.appendTo("#button");
 * </script>
 * ```
 */
export  class Button extends base.Component<HTMLButtonElement> implements base.INotifyPropertyChanged {
    /**
     * Positions the icon before/after the text content in the Button.
     * The possible values are:
     * * Left: The icon will be positioned to the left of the text content.
     * * Right: The icon will be positioned to the right of the text content.
     * @default "left"
     */
    iconPosition: IconPosition;
    /**
     * Defines class/multiple classes separated by a space for the Button that is used to include an icon.
     * Buttons can also include font icon and sprite image.
     * @default ""
     */
    iconCss: string;
    /**
     * Specifies a value that indicates whether the Button is `disabled` or not.
     * @default false.
     */
    disabled: boolean;
    /**
     * Allows the appearance of the Button to be enhanced and visually appealing when set to `true`.
     * @default false
     */
    isPrimary: boolean;
    /**
     * Defines class/multiple classes separated by a space in the Button element. The Button types, styles, and
     * size can be defined by using
     * [`this`](http://ej2.syncfusion.com/documentation/button/howto.html?lang=typescript#create-a-block-button).
     * @default ""
     */
    cssClass: string;
    /**
     * Defines the `content` of the Button element that can either be a text or HTML elements.
     * @default ""
     */
    content: string;
    /**
     * Makes the Button toggle, when set to `true`. When you click it, the state changes from normal to active.
     * @default false
     */
    isToggle: boolean;
    /**
     * Constructor for creating the widget
     * @param  {ButtonModel} options?
     * @param  {string|HTMLButtonElement} element?
     */
    constructor(options?: ButtonModel, element?: string | HTMLButtonElement);
    protected preRender(): void;
    /**
     * Initialize the control rendering
     * @returns void
     * @private
     */
    render(): void;
    private initialize();
    private controlStatus(disabled);
    private setIconCss();
    protected wireEvents(): void;
    protected unWireEvents(): void;
    private btnClickHandler();
    /**
     * Destroys the widget.
     * @returns void
     */
    destroy(): void;
    /**
     * Get component name.
     * @returns string
     * @private
     */
    getModuleName(): string;
    /**
     * Get the properties to be maintained in the persisted state.
     * @returns string
     */
    getPersistData(): string;
    /**
     * Called internally if any of the property value changed.
     * @param  {Button} newProp
     * @param  {Button} oldProp
     * @returns void
     * @private
     */
    onPropertyChanged(newProp: Button, oldProp: Button): void;
}
/**
 * Button modules
 */
/**
 * Interface for a class CheckBox
 */
export interface CheckBoxModel extends base.ComponentModel{
    /**
     * Triggers when the CheckBox state has been changed by user interaction.
     * @event
     */
    change?: base.EmitType<ChangeEventArgs>;
    /**
     * Specifies a value that indicates whether the CheckBox is `checked` or not.
     * When set to `true`, the CheckBox will be in `checked` state.
     * @default false
     */
    checked?: boolean;
    /**
     * Defines class/multiple classes separated by a space in the CheckBox element.
     * You can add custom styles to the CheckBox by using this property.
     * @default ''
     */
    cssClass?: string;
    /**
     * Specifies a value that indicates whether the CheckBox is `disabled` or not.
     * When set to `true`, the CheckBox will be in `disabled` state.
     * @default false
     */
    disabled?: boolean;
    /**
     * Specifies a value that indicates whether the CheckBox is in `indeterminate` state or not.
     * When set to `true`, the CheckBox will be in `indeterminate` state.
     * @default false
     */
    indeterminate?: boolean;
    /**
     * Defines the caption for the CheckBox, that describes the purpose of the CheckBox.
     * @default ''
     */
    label?: string;
    /**
     * Positions label `before`/`after` the CheckBox.
     * The possible values are:
     * * Before - The label is positioned to left of the CheckBox.
     * * After - The label is positioned to right of the CheckBox.
     * @default 'After'
     */
    labelPosition?: LabelPosition;
    /**
     * Defines `name` attribute for the CheckBox.
     * It is used to reference form data (CheckBox value) after a form is submitted.
     * @default ''
     */
    name?: string;
    /**
     * Defines `value` attribute for the CheckBox.
     * It is a form data passed to the server when submitting the form.
     * @default ''
     */
    value?: string;
}
export  type LabelPosition = 'After' | 'Before';
/**
 * The CheckBox is a graphical user interface element that allows you to select one or more options from the choices.
 * It contains checked, unchecked, and indeterminate states.
 * ```html
 * <input type="checkbox" id="checkbox"/>
 * <script>
 * var checkboxObj = new CheckBox({ label: "Default" });
 * checkboxObj.appendTo("#checkbox");
 * </script>
 * ```
 */
export  class CheckBox extends base.Component<HTMLInputElement> implements base.INotifyPropertyChanged {
    private tagName;
    private isKeyPressed;
    private keyboardModule;
    /**
     * Triggers when the CheckBox state has been changed by user interaction.
     * @event
     */
    change: base.EmitType<ChangeEventArgs>;
    /**
     * Specifies a value that indicates whether the CheckBox is `checked` or not.
     * When set to `true`, the CheckBox will be in `checked` state.
     * @default false
     */
    checked: boolean;
    /**
     * Defines class/multiple classes separated by a space in the CheckBox element.
     * You can add custom styles to the CheckBox by using this property.
     * @default ''
     */
    cssClass: string;
    /**
     * Specifies a value that indicates whether the CheckBox is `disabled` or not.
     * When set to `true`, the CheckBox will be in `disabled` state.
     * @default false
     */
    disabled: boolean;
    /**
     * Specifies a value that indicates whether the CheckBox is in `indeterminate` state or not.
     * When set to `true`, the CheckBox will be in `indeterminate` state.
     * @default false
     */
    indeterminate: boolean;
    /**
     * Defines the caption for the CheckBox, that describes the purpose of the CheckBox.
     * @default ''
     */
    label: string;
    /**
     * Positions label `before`/`after` the CheckBox.
     * The possible values are:
     * * Before - The label is positioned to left of the CheckBox.
     * * After - The label is positioned to right of the CheckBox.
     * @default 'After'
     */
    labelPosition: LabelPosition;
    /**
     * Defines `name` attribute for the CheckBox.
     * It is used to reference form data (CheckBox value) after a form is submitted.
     * @default ''
     */
    name: string;
    /**
     * Defines `value` attribute for the CheckBox.
     * It is a form data passed to the server when submitting the form.
     * @default ''
     */
    value: string;
    /**
     * Constructor for creating the widget
     * @private
     */
    constructor(options?: CheckBoxModel, element?: string | HTMLInputElement);
    private changeState(state?);
    private clickHandler(event);
    /**
     * Destroys the widget.
     * @returns void
     */
    destroy(): void;
    private focusHandler();
    private focusOutHandler();
    /**
     * Gets the module name.
     * @private
     */
    protected getModuleName(): string;
    /**
     * Gets the properties to be maintained in the persistence state.
     * @private
     */
    getPersistData(): string;
    private getWrapper();
    private initialize();
    private initWrapper();
    private keyDownHandler();
    private labelMouseHandler(e);
    private mouseDownHandler();
    /**
     * Called internally if any of the property value changes.
     * @private
     */
    onPropertyChanged(newProp: CheckBoxModel, oldProp: CheckBoxModel): void;
    /**
     * Initialize Angular, React and Unique ID support.
     * @private
     */
    protected preRender(): void;
    /**
     * Initialize the control rendering
     * @private
     */
    protected render(): void;
    private setDisabled();
    private setText(text);
    protected unWireEvents(): void;
    protected wireEvents(): void;
}
export interface ChangeEventArgs extends base.BaseEventArgs {
    /** Returns the event parameters of the CheckBox. */
    event?: Event;
    /** Returns the checked value of the CheckBox. */
    checked?: boolean;
}
/**
 * CheckBox modules
 */
/**
 * Initialize wrapper element for angular.
 * @private
 */
export  function wrapperInitialize(tag: string, type: string, element: HTMLInputElement, WRAPPER: string): HTMLInputElement;
export  function getTextNode(element: HTMLElement): Node;
/**
 * Creates CheckBox component UI with theming and ripple support.
 * @private
 */
export  function createCheckBox(enableRipple?: boolean, options?: CheckBoxUtilModel): Element;
export  function rippleMouseHandler(e: MouseEvent, rippleSpan: Element): void;
export interface CheckBoxUtilModel {
    checked?: boolean;
    label?: string;
    enableRtl?: boolean;
    cssClass?: string;
}
/**
 * Common modules
 */
/**
 * Button all modules
 */
/**
 * RadioButton modules
 */
/**
 * Interface for a class RadioButton
 */
export interface RadioButtonModel extends base.ComponentModel{
    /**
     * Event trigger when the RadioButton state has been changed by user interaction.
     * @event
     */
    change?: base.EmitType<ChangeArgs>;
    /**
     * Specifies a value that indicates whether the RadioButton is `checked` or not.
     * When set to `true`, the RadioButton will be in `checked` state.
     * @default false
     */
    checked?: boolean;
    /**
     * Defines class/multiple classes separated by a space in the RadioButton element.
     * You can add custom styles to the RadioButton by using this property.
     * @default ''
     */
    cssClass?: string;
    /**
     * Specifies a value that indicates whether the RadioButton is `disabled` or not.
     * When set to `true`, the RadioButton will be in `disabled` state.
     * @default false
     */
    disabled?: boolean;
    /**
     * Defines the caption for the RadioButton, that describes the purpose of the RadioButton.
     * @default ''
     */
    label?: string;
    /**
     * Positions label `before`/`after` the RadioButton.
     * The possible values are:
     * * Before: The label is positioned to left of the RadioButton.
     * * After: The label is positioned to right of the RadioButton.
     * @default 'After'
     */
    labelPosition?: RadioLabelPosition;
    /**
     * Defines `name` attribute for the RadioButton.
     * It is used to reference form data (RadioButton value) after a form is submitted.
     * @default ''
     */
    name?: string;
    /**
     * Defines `value` attribute for the RadioButton.
     * It is a form data passed to the server when submitting the form.
     * @default ''
     */
    value?: string;
}
export  type RadioLabelPosition = 'After' | 'Before';
/**
 * The RadioButton is a graphical user interface element that allows you to select one option from the choices.
 * It contains checked and unchecked states.
 * ```html
 * <input type="radio" id="radio"/>
 * <script>
 * var radioObj = new RadioButton({ label: "Default" });
 * radioObj.appendTo("#radio");
 * </script>
 * ```
 */
export  class RadioButton extends base.Component<HTMLInputElement> implements base.INotifyPropertyChanged {
    private tagName;
    private isKeyPressed;
    /**
     * Event trigger when the RadioButton state has been changed by user interaction.
     * @event
     */
    change: base.EmitType<ChangeArgs>;
    /**
     * Specifies a value that indicates whether the RadioButton is `checked` or not.
     * When set to `true`, the RadioButton will be in `checked` state.
     * @default false
     */
    checked: boolean;
    /**
     * Defines class/multiple classes separated by a space in the RadioButton element.
     * You can add custom styles to the RadioButton by using this property.
     * @default ''
     */
    cssClass: string;
    /**
     * Specifies a value that indicates whether the RadioButton is `disabled` or not.
     * When set to `true`, the RadioButton will be in `disabled` state.
     * @default false
     */
    disabled: boolean;
    /**
     * Defines the caption for the RadioButton, that describes the purpose of the RadioButton.
     * @default ''
     */
    label: string;
    /**
     * Positions label `before`/`after` the RadioButton.
     * The possible values are:
     * * Before: The label is positioned to left of the RadioButton.
     * * After: The label is positioned to right of the RadioButton.
     * @default 'After'
     */
    labelPosition: RadioLabelPosition;
    /**
     * Defines `name` attribute for the RadioButton.
     * It is used to reference form data (RadioButton value) after a form is submitted.
     * @default ''
     */
    name: string;
    /**
     * Defines `value` attribute for the RadioButton.
     * It is a form data passed to the server when submitting the form.
     * @default ''
     */
    value: string;
    /**
     * Constructor for creating the widget
     * @private
     */
    constructor(options?: RadioButtonModel, element?: string | HTMLInputElement);
    private changeHandler(event);
    private updateChange(state);
    /**
     * Destroys the widget.
     * @returns void
     */
    destroy(): void;
    private focusHandler();
    private focusOutHandler();
    protected getModuleName(): string;
    /**
     * Gets the properties to be maintained in the persistence state.
     * @private
     */
    getPersistData(): string;
    private getLabel();
    private initialize();
    private initWrapper();
    private keyDownHandler();
    private labelRippleHandler(e);
    private mouseDownHandler();
    /**
     * Called internally if any of the property value changes.
     * @private
     */
    onPropertyChanged(newProp: RadioButtonModel, oldProp: RadioButtonModel): void;
    /**
     * Initialize checked Property, Angular and React and Unique ID support.
     * @private
     */
    protected preRender(): void;
    /**
     * Initialize the control rendering
     * @private
     */
    protected render(): void;
    private setDisabled();
    private setText(text);
    protected unWireEvents(): void;
    protected wireEvents(): void;
}
export interface ChangeArgs extends base.BaseEventArgs {
    /** Returns the value of the RadioButton. */
    value?: string;
    /** Returns the event parameters of the RadioButton. */
    event?: Event;
}
 }
export namespace calendars { 

/**
 * Interface for a class Calendar
 */
export interface CalendarModel extends base.ComponentModel{
    /**
     * Gets or sets the selected date of the Calendar.
     * @default null
     */
    value?: Date;
    /**
     * Gets or sets the minimum date that can be selected in the Calendar.
     * @default new Date(1900, 00, 01)
     */
    min?: Date;
    /**
     * Gets or sets the maximum date that can be selected in the Calendar.
     * @default new Date(2099, 11, 31)
     */
    max?: Date;
    /**
     * Gets or sets the Calendar's first day of the week. By default, the first day of the week will be based on the current culture.
     * @default 0
     */
    firstDayOfWeek?: number;
    /**
     * Specifies the initial view of the Calendar when it is opened.
     * With the help of this property, initial view can be changed to year or decade view.
     * @default month
     */
    start?: CalendarView;
    /**
     * Sets the maximum level of view (month, year, decade) in the Calendar.
     * Depth view should be smaller than the start view to restrict its view navigation.
     * @default month
     */
    depth?: CalendarView;
    /**
     * Determines whether the week number of the Calendar is to be displayed or not.
     * The week number is displayed in every week row.
     * @default false
     */
    weekNumber?: boolean;
    /**
     * Specifies whether the today button is displayed or not.
     * @default true
     */
    showTodayButton?: boolean;
    /**
     * Triggers when Calendar is created.
     * @event 
     */
    created?: base.EmitType<Object>;
    /**
     * Triggers when Calendar is destroyed.
     * @event 
     */
    destroyed?: base.EmitType<Object>;
    /**
     * Triggers when the Calendar value is changed.
     * @event  
     */
    change?: base.EmitType<ChangedEventArgs>;
    /**
     * Triggers when the Calendar is navigated to another level or within the same level of view.
     * @event
     */
    navigated?: base.EmitType<NavigatedEventArgs>;
    /**
     * Triggers when each day cell of the Calendar is rendered.
     * @event
     */
    renderDayCell?: base.EmitType<RenderDayCellEventArgs>;
}
/**
 * Specifies the view of the calendar.
 */
export  type CalendarView = 'Month' | 'Year' | 'Decade';
/**
 * Represents the Calendar component that allows the user to select a date.
 * ```html
 * <div id="calendar"/>
 * ```
 * ```typescript
 * <script>
 *   var calendarObj = new Calendar({ value: new Date() });
 *   calendarObj.appendTo("#calendar");
 * </script>
 * ```
 */
export  class Calendar extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    protected headerElement: HTMLElement;
    protected contentElement: HTMLElement;
    protected table: HTMLElement;
    protected tableHeadElement: HTMLElement;
    protected tableBodyElement: Element;
    protected nextIcon: HTMLElement;
    protected previousIcon: HTMLElement;
    protected headerTitleElement: HTMLElement;
    protected todayElement: HTMLElement;
    protected footer: HTMLElement;
    protected keyboardModule: base.KeyboardEvents;
    protected globalize: base.Internationalization;
    protected currentDate: Date;
    protected changedArgs: ChangedEventArgs;
    protected navigatedArgs: NavigatedEventArgs;
    private renderDaycellArg;
    private effect;
    protected previousDate: Date;
    protected changeHandler: Function;
    protected navigateHandler: Function;
    protected navigatePreviousHandler: Function;
    protected navigateNextHandler: Function;
    private l10;
    protected todayDisabled: boolean;
    protected todayDate: Date;
    protected calendarElement: HTMLElement;
    protected keyConfigs: {
        [key: string]: string;
    };
    /**
     * Gets or sets the selected date of the Calendar.
     * @default null
     */
    value: Date;
    /**
     * Gets or sets the minimum date that can be selected in the Calendar.
     * @default new Date(1900, 00, 01)
     */
    min: Date;
    /**
     * Gets or sets the maximum date that can be selected in the Calendar.
     * @default new Date(2099, 11, 31)
     */
    max: Date;
    /**
     * Gets or sets the Calendar's first day of the week. By default, the first day of the week will be based on the current culture.
     * @default 0
     */
    firstDayOfWeek: number;
    /**
     * Specifies the initial view of the Calendar when it is opened.
     * With the help of this property, initial view can be changed to year or decade view.
     * @default month
     */
    start: CalendarView;
    /**
     * Sets the maximum level of view (month, year, decade) in the Calendar.
     * Depth view should be smaller than the start view to restrict its view navigation.
     * @default month
     */
    depth: CalendarView;
    /**
     * Determines whether the week number of the Calendar is to be displayed or not.
     * The week number is displayed in every week row.
     * @default false
     */
    weekNumber: boolean;
    /**
     * Specifies whether the today button is displayed or not.
     * @default true
     */
    showTodayButton: boolean;
    /**
     * Triggers when Calendar is created.
     * @event
     */
    created: base.EmitType<Object>;
    /**
     * Triggers when Calendar is destroyed.
     * @event
     */
    destroyed: base.EmitType<Object>;
    /**
     * Triggers when the Calendar value is changed.
     * @event
     */
    change: base.EmitType<ChangedEventArgs>;
    /**
     * Triggers when the Calendar is navigated to another level or within the same level of view.
     * @event
     */
    navigated: base.EmitType<NavigatedEventArgs>;
    /**
     * Triggers when each day cell of the Calendar is rendered.
     * @event
     */
    renderDayCell: base.EmitType<RenderDayCellEventArgs>;
    /**
     * Initialized new instance of Calendar Class.
     * Constructor for creating the widget
     * @param  {CalendarModel} options?
     * @param  {string|HTMLElement} element?
     */
    constructor(options?: CalendarModel, element?: string | HTMLElement);
    /**
     * To Initialize the control rendering.
     * @returns void
     * @private
     */
    protected render(): void;
    protected processDate(): void;
    private validateDate();
    private minMaxUpdate();
    protected header(): void;
    protected content(): void;
    private getCultureValues();
    private contentHdr();
    private contentBody();
    private updateFooter();
    private contentFooter();
    protected wireEvents(): void;
    protected todayButtonClick(): void;
    protected keyActionHandle(e: base.KeyboardEventArgs): void;
    protected KeyboardNavigate(number: number, currentView: number, e: KeyboardEvent, max: Date, min: Date): void;
    /**
     * Initialize the event handler
     * @private
     */
    protected preRender(): void;
    private minMaxDate(localDate);
    protected renderMonths(e?: Event): void;
    private renderDays(currentDate, e?);
    private renderYears(e?);
    private renderDecades(e?);
    private dayCell(localDate);
    protected firstDay(date: Date): Date;
    protected lastDay(date: Date): Date;
    protected checkDateValue(value: Date): Date;
    private findlastDay(date);
    private removeTheadEle();
    private renderTemplate(elements, numCells, classNm, e?);
    private clickHandler(e);
    private contentClick(e, view, ele);
    private switchView(view, e?);
    /**
     * To get component name
     * @private
     */
    protected getModuleName(): string;
    /**
     * Gets the properties to be maintained upon browser refresh.
     * @returns string
     */
    getPersistData(): string;
    /**
     * Called internally if any of the property value changed.
     * returns void
     * @private
     */
    onPropertyChanged(newProp: CalendarModel, oldProp: CalendarModel): void;
    private setvalue();
    private titleUpdate(date, view);
    protected setActiveDescendant(): string;
    private iconHandler();
    /**
     * Destroys the widget.
     * @returns void
     */
    destroy(): void;
    private title(e?);
    private getViewNumber(stringVal);
    private navTitle(e?);
    private previous();
    protected navigatePrevious(e: MouseEvent | KeyboardEvent): void;
    private next();
    protected navigateNext(eve: MouseEvent | KeyboardEvent): void;
    /**
     * This method is used to navigate to the month/year/decade view of the Calendar.
     * @param  {string} view - Specifies the view of the Calendar.
     * @param  {Date} date - Specifies the focused date in a view.
     * @returns void
     */
    navigateTo(view: CalendarView, date: Date): void;
    /**
     * Gets the current view of the Calendar.
     * @returns string
     */
    currentView(): string;
    private getDateVal(date);
    private getCultureObjects(ld, c);
    private getWeek(d);
    private setTime(date, time);
    protected addMonths(date: Date, i: number): void;
    protected addYears(date: Date, i: number): void;
    protected getIdValue(e: MouseEvent, element: Element): Date;
    private selectDate(e, date, element);
    private setAriaActivedescendant();
    protected previousIconHandler(disabled: boolean): void;
    protected renderDayCellEvent(args: RenderDayCellEventArgs): void;
    protected navigatedEvent(eve: MouseEvent | KeyboardEvent): void;
    private triggerNavigate(event);
    protected changeEvent(e: Event): void;
    private triggerChange(e);
    protected nextIconHandler(disabled: boolean): void;
    private compare(startDate, endDate, modifier);
    protected isMinMaxRange(date: Date): boolean;
    private compareYear(start, end);
    private compareDecade(start, end);
    private shiftArray(array, i);
    protected addDay(date: Date, i: number, e: KeyboardEvent, max: Date, min: Date): void;
    private findNextTD(date, column, max, min);
    private getMaxDays(d);
    private setDateDecade(date, year);
    private setDateYear(date, value);
    private compareMonth(start, end);
}
export interface RenderDayCellEventArgs extends base.BaseEventArgs {
    /** Specifies whether to disable the current date or not. */
    isDisabled?: boolean;
    /** Specifies the day cell element. */
    element?: HTMLElement;
    /** Defines the current date of the Calendar. */
    date?: Date;
    /** Defines whether the current date is out of range (less than min or greater than max) or not. */
    isOutOfRange?: boolean;
}
export interface ChangedEventArgs extends base.BaseEventArgs {
    /** Defines the selected date of the Calendar. */
    value?: Date;
    /** Defines the event of the Calendar. */
    event?: KeyboardEvent | MouseEvent | Event;
}
export interface NavigatedEventArgs extends base.BaseEventArgs {
    /** Defines the current view of the Calendar. */
    view?: string;
    /** Defines the focused date in a view. */
    date?: Date;
    /** Defines the event of the Calendar. */
    event?: KeyboardEvent | MouseEvent;
}
/**
 * Calendar modules
 */
/**
 * Interface for a class DatePicker
 */
export interface DatePickerModel extends CalendarModel{
    /**
     * Specifies the width of the DatePicker component.
     * @default null
     */
    width?: number | string;
    /**
     * Specifies the root CSS class of the DatePicker that allows to
     * customize the appearance by overriding the styles.
     * @default null
     */
    cssClass?: string;
    /**
     * Specifies the component to act as strict. So that, it allows to enter only a valid date value within a specified range or else it 
     * will resets to previous value. By default, strictMode is in false.
     * @default false
     */
    strictMode?: boolean;
    /**
     * Specifies the format of the value that to be displayed in component. By default, the format is
     * based on the culture. 
     * @default null
     */
    format?: string;
    /**
     * Specifies the component to be disabled or not.
     * @default true
     */
    enabled?: boolean;
    /**
     * Specifies whether to show or hide the clear Icon
     * @default true
     */
    showClearButton?: boolean;
    /**
     * specifies the z-index value of the datePicker popup element.
     * @default 1000
     */
    zIndex?: number;
    /**
     * Specifies the component in readonly state. 
     * @default false
     */
    readonly?: boolean;
    /**
     * Specifies the placeholder text that displayed in textbox.
     * @default null
     */
    placeholder?: string;
    /**
     * Specifies the placeholder text to be floated.
     * @default Never
     */
    floatLabelType?: inputs.FloatLabelType;
    /**
     * Triggers when the popup gets open.
     * @event 
     */
    open?: base.EmitType<PreventableEventArgs | PopupObjectArgs>;
    /**
     * Triggers when the popup gets close.
     * @event 
     */
    close?: base.EmitType<PreventableEventArgs | PopupObjectArgs>;
    /**
     * Triggers when the control loses the focus.
     * @event 
     */
    blur?: base.EmitType<Object>;
    /**
     *  Triggers when the control gets focus.
     * @event 
     */
    focus?: base.EmitType<Object>;
    /**
     * Triggers when the component is created.
     * @event 
     */
    created?: base.EmitType<Object>;
    /**
     * Triggers when the component is destroyed.
     * @event 
     */
    destroyed?: base.EmitType<Object>;
}

/**
 * Represents the DatePicker component that allows user to select
 * or enter a date value.
 * ```html
 * <input id="datepicker"/>
 * ````
 * ````typescript
 * <script>
 *   var datePickerObject = new DatePicker({ value: new Date() });
 *   datePickerObject.appendTo("#datepicker");
 * </script>
 * ```
 */
export  class DatePicker extends Calendar implements inputs.IInput {
    private popupObj;
    protected inputWrapper: inputs.InputObject;
    private modal;
    protected inputElement: HTMLInputElement;
    protected popupWrapper: HTMLElement;
    protected changedArgs: ChangedEventArgs;
    protected previousDate: Date;
    private keyboardModules;
    private calendarKeyboardModules;
    private previousEleValue;
    private ngTag;
    protected dateTimeFormat: string;
    private inputEleCopy;
    protected l10n: base.L10n;
    private preventArgs;
    private isDateIconClicked;
    private index;
    protected keyConfigs: {
        [key: string]: string;
    };
    protected calendarKeyConfigs: {
        [key: string]: string;
    };
    /**
     * Specifies the width of the DatePicker component.
     * @default null
     */
    width: number | string;
    /**
     * Specifies the root CSS class of the DatePicker that allows to
     * customize the appearance by overriding the styles.
     * @default null
     */
    cssClass: string;
    /**
     * Specifies the component to act as strict. So that, it allows to enter only a valid date value within a specified range or else it
     * will resets to previous value. By default, strictMode is in false.
     * @default false
     */
    strictMode: boolean;
    /**
     * Specifies the format of the value that to be displayed in component. By default, the format is
     * based on the culture.
     * @default null
     */
    format: string;
    /**
     * Specifies the component to be disabled or not.
     * @default true
     */
    enabled: boolean;
    /**
     * Specifies whether to show or hide the clear Icon
     * @default true
     */
    showClearButton: boolean;
    /**
     * specifies the z-index value of the datePicker popup element.
     * @default 1000
     */
    zIndex: number;
    /**
     * Specifies the component in readonly state.
     * @default false
     */
    readonly: boolean;
    /**
     * Specifies the placeholder text that displayed in textbox.
     * @default null
     */
    placeholder: string;
    /**
     * Specifies the placeholder text to be floated.
     * @default Never
     */
    floatLabelType: inputs.FloatLabelType;
    /**
     * Triggers when the popup gets open.
     * @event
     */
    open: base.EmitType<PreventableEventArgs | PopupObjectArgs>;
    /**
     * Triggers when the popup gets close.
     * @event
     */
    close: base.EmitType<PreventableEventArgs | PopupObjectArgs>;
    /**
     * Triggers when the control loses the focus.
     * @event
     */
    blur: base.EmitType<Object>;
    /**
     *  Triggers when the control gets focus.
     * @event
     */
    focus: base.EmitType<Object>;
    /**
     * Triggers when the component is created.
     * @event
     */
    created: base.EmitType<Object>;
    /**
     * Triggers when the component is destroyed.
     * @event
     */
    destroyed: base.EmitType<Object>;
    /**
     * Constructor for creating the widget.
     */
    constructor(options?: DatePickerModel, element?: string | HTMLInputElement);
    /**
     * To Initialize the control rendering.
     * @return void
     * @private
     */
    render(): void;
    private initialize();
    private createInput();
    protected updateInput(): void;
    protected bindEvents(): void;
    private bindClearEvent();
    protected resetHandler(e?: MouseEvent): void;
    private clear(event);
    private dateIconHandler(e?);
    private CalendarKeyActionHandle(e);
    private inputFocusHandler();
    private inputBlurHandler();
    private documentHandler(e);
    protected inputKeyActionHandle(e: base.KeyboardEventArgs): void;
    protected strictModeUpdate(): void;
    private createCalendar();
    private modelHeader();
    protected changeTrigger(): void;
    protected navigatedEvent(): void;
    protected changeEvent(e?: Event): void;
    protected selectCalendar(e?: Event): void;
    protected isCalendar(): boolean;
    protected setWidth(width: number | string): void;
    /**
     * Shows the Calendar.
     * @returns void
     */
    show(): void;
    /**
     * Hide the Calendar.
     * @returns void
     */
    hide(): void;
    /**
     * Sets the focus to widget for interaction.
     * @returns void
     */
    focusIn(triggerEvent?: boolean): void;
    /**
     * Remove the focus from widget, if the widget is in focus state.
     * @returns void
     */
    focusOut(): void;
    /**
     * Gets the current view of the DatePicker.
     * @returns string
     */
    currentView(): string;
    /**
     * This method used to navigate to the month/year/decade view of the DatePicker.
     * @param  {string} view - Specifies the view of the calendar.
     * @param  {Date} date - Specifies the focused date in a view.
     * @returns void
     */
    navigateTo(view: CalendarView, date: Date): void;
    /**
     * To destroy the widget.
     * @returns void
     */
    destroy(): void;
    /**
     * Initialize the event handler
     * @private
     */
    protected preRender(): void;
    private checkHtmlAttributes();
    /**
     * To get component name.
     * @private
     */
    protected getModuleName(): string;
    private disabledDates();
    private setAriaAttributes();
    protected errorClass(): void;
    /**
     * Called internally if any of the property value changed.
     * returns void
     * @private
     */
    onPropertyChanged(newProp: DatePickerModel, oldProp: DatePickerModel): void;
}
export interface PopupObjectArgs {
    /** Defines the DatePicker popup element. */
    popup: popups.Popup;
}
export interface PreventableEventArgs {
    /** Prevents the default action */
    preventDefault?: Function;
}
/**
 * Datepicker modules
 */
/**
 * Interface for a class Presets
 */
export interface PresetsModel {
    /**
     * Defines the label string of the preset range. 
     */
    label?: string;
    /**
     * Defines the start date of the preset range 
     */
    start?: Date;
    /**
     * Defines the end date of the preset range 
     */
    end?: Date;
}
/**
 * Interface for a class DateRangePicker
 */
export interface DateRangePickerModel extends CalendarModel{
    /**
     * Gets or sets the start date of the date range selection.
     * @default null
     */
    startDate?: Date;
    /**
     * Gets or sets the end date of the date range selection.
     * @default null
     */
    endDate?: Date;
    /**
     * Set the predefined ranges which let the user pick required range easily in a component.
     * @default null
     */
    presets?: PresetsModel[];
    /**
     * Specifies the width of the DateRangePicker component.
     * @default ''
     */
    width?: number | string;
    /**
     * specifies the z-index value of the dateRangePicker popup element.
     * @default 1000
     */
    zIndex?: number;
    /**
     * Specifies whether to show or hide the clear Icon
     * @default true
     */
    showClearButton?: boolean;
    /**
     *  Sets the root CSS class to the DateRangePicker which allows you to customize the appearance.
     * @default ''    
     */
    cssClass?: string;
    /**
     * Sets or gets the string that used between the start and end date string. 
     * @default '-'
     */
    separator?: string;
    /**
     *  Specifies the minimum span that can be allowed in date range selection.
     * @default null    
     */
    minDays?: number;
    /**
     *  Specifies the maximum span that can be allowed in a date range selection.
     * @default null
     */
    maxDays?: number;
    /**
     * Specifies the component to act as strict which allows entering only a valid date range in a DateRangePicker.
     * @default false
     */
    strictMode?: boolean;
    /**
     * Sets or gets the required date format to the start and end date string.
     * @default null
     */
    format?: string;
    /**
     * Specifies the component to be disabled which prevents the DateRangePicker from user interactions. 
     * @default true
     */
    enabled?: boolean;
    /**
     * Denies the editing the ranges in the DateRangePicker component. 
     * @default false
     */
    readonly?: boolean;
    /**
     * Specifies the placeholder text that need to be displayed in the DateRangePicker component.
     * @default ''
     */
    placeholder?: string;
    /**
     * Specifies the initial view of the base.Calendar when it is opened.
     * With the help of this property, initial view can be changed to year or decade view.
     * @default month
     * @hidden
     */
    start?: CalendarView;
    /**
     * Sets the maximum level of view (month, year, decade) in the base.Calendar.
     * Depth view should be smaller than the start view to restrict its view navigation.
     * @default month
     * @hidden
     */
    depth?: CalendarView;
    /**
     * Gets or sets the selected date of the base.Calendar
     * @default null
     * @hidden
     */
    value?: Date;
    /**
     * Triggers when the DateRangePicker is created
     * @event 
     */
    created?: base.EmitType<Object>;
    /**
     * Triggers when the DateRangePicker is destroyed.
     * @event 
     */
    destroyed?: base.EmitType<Object>;
    /**
     * Triggers when the DateRangePicker is opened.
     * @event 
     */
    open?: base.EmitType<Object>;
    /**
     * Triggers when the DateRangePicker is closed.
     * @event 
     */
    close?: base.EmitType<Object>;
    /**
     * Triggers when the date range value is changed in DateRangePicker.
     * @event 
     */
    change?: base.EmitType<Object>;
    /**
     * Triggers when the base.Calendar is navigated to another level or within the same level of view.
     * @event
     * @hidden
     */
    navigated?: base.EmitType<NavigatedEventArgs>;
    /**
     * Triggers on selecting the start and end date.
     * @event 
     */
    select?: base.EmitType<Object>;
}

export  class Presets extends base.ChildProperty<Presets> {
    /**
     * Defines the label string of the preset range.
     */
    label: string;
    /**
     * Defines the start date of the preset range
     */
    start: Date;
    /**
     * Defines the end date of the preset range
     */
    end: Date;
}
export interface RangeEventArgs extends base.BaseEventArgs {
    /** Defines the value string in the input element */
    value: string;
    /** Defines the start date  */
    startDate: Date;
    /** Defines the end date  */
    endDate: Date;
    /** Defines the day span between the range */
    daySpan: number;
}
export interface RangePopupEventArgs extends base.BaseEventArgs {
    /** Defines the range string in the input element */
    date: string;
    /** Defines the DateRangePicker model */
    model: DateRangePickerModel;
    /** Defines the popup element */
    popup: popups.Popup;
}
/**
 * Represents the DateRangePicker component that allows user to select the date range from the calendar
 * or entering the range through the input element.
 * ```html
 * <input id="daterangepicker"/>
 * ```
 * ```typescript
 * <script>
 *   var dateRangePickerObj = new DateRangePicker({ startDate: new Date("05/07/2017"), endDate: new Date("10/07/2017") });
 *   dateRangePickerObj.appendTo("#daterangepicker");
 * </script>
 * ```
 */
export  class DateRangePicker extends Calendar {
    private popupObj;
    private inputWrapper;
    private popupWrapper;
    private rightCalendar;
    private leftCalendar;
    private deviceCalendar;
    private leftCalCurrentDate;
    private rightCalCurrentDate;
    private leftCalPrevIcon;
    private leftCalNextIcon;
    private rightCalPrevIcon;
    private rightCalNextIcon;
    private inputKeyboardModule;
    protected leftKeyboardModule: base.KeyboardEvents;
    protected rightKeyboardModule: base.KeyboardEvents;
    private previousStartValue;
    private previousEndValue;
    private applyButton;
    private cancelButton;
    private startButton;
    private endButton;
    private cloneElement;
    private l10n;
    private isCustomRange;
    private isCustomWindow;
    private presetsItem;
    private liCollections;
    private activeIndex;
    private presetElement;
    private previousEleValue;
    private targetElement;
    private isTab;
    private disabledDayCnt;
    private angularTag;
    private inputElement;
    private modal;
    private isKeyPopup;
    private dateDisabled;
    private navNextFunction;
    private navPrevFunction;
    private deviceNavNextFunction;
    private deviceNavPrevFunction;
    private isRangeIconClicked;
    private isMaxDaysClicked;
    private popupKeyboardModule;
    private presetKeyboardModule;
    private btnKeyboardModule;
    private virtualRenderCellArgs;
    private disabledDays;
    private isMobile;
    private presetKeyConfig;
    private keyInputConfigs;
    private defaultConstant;
    /**
     * Gets or sets the start date of the date range selection.
     * @default null
     */
    startDate: Date;
    /**
     * Gets or sets the end date of the date range selection.
     * @default null
     */
    endDate: Date;
    /**
     * Set the predefined ranges which let the user pick required range easily in a component.
     * @default null
     */
    presets: PresetsModel[];
    /**
     * Specifies the width of the DateRangePicker component.
     * @default ''
     */
    width: number | string;
    /**
     * specifies the z-index value of the dateRangePicker popup element.
     * @default 1000
     */
    zIndex: number;
    /**
     * Specifies whether to show or hide the clear Icon
     * @default true
     */
    showClearButton: boolean;
    /**
     *  Sets the root CSS class to the DateRangePicker which allows you to customize the appearance.
     * @default ''
     */
    cssClass: string;
    /**
     * Sets or gets the string that used between the start and end date string.
     * @default '-'
     */
    separator: string;
    /**
     *  Specifies the minimum span that can be allowed in date range selection.
     * @default null
     */
    minDays: number;
    /**
     *  Specifies the maximum span that can be allowed in a date range selection.
     * @default null
     */
    maxDays: number;
    /**
     * Specifies the component to act as strict which allows entering only a valid date range in a DateRangePicker.
     * @default false
     */
    strictMode: boolean;
    /**
     * Sets or gets the required date format to the start and end date string.
     * @default null
     */
    format: string;
    /**
     * Specifies the component to be disabled which prevents the DateRangePicker from user interactions.
     * @default true
     */
    enabled: boolean;
    /**
     * Denies the editing the ranges in the DateRangePicker component.
     * @default false
     */
    readonly: boolean;
    /**
     * Specifies the placeholder text that need to be displayed in the DateRangePicker component.
     * @default ''
     */
    placeholder: string;
    /**
     * Specifies the initial view of the Calendar when it is opened.
     * With the help of this property, initial view can be changed to year or decade view.
     * @default month
     * @hidden
     */
    start: CalendarView;
    /**
     * Sets the maximum level of view (month, year, decade) in the Calendar.
     * Depth view should be smaller than the start view to restrict its view navigation.
     * @default month
     * @hidden
     */
    depth: CalendarView;
    /**
     * Gets or sets the selected date of the Calendar
     * @default null
     * @hidden
     */
    value: Date;
    /**
     * Triggers when the DateRangePicker is created
     * @event
     */
    created: base.EmitType<Object>;
    /**
     * Triggers when the DateRangePicker is destroyed.
     * @event
     */
    destroyed: base.EmitType<Object>;
    /**
     * Triggers when the DateRangePicker is opened.
     * @event
     */
    open: base.EmitType<Object>;
    /**
     * Triggers when the DateRangePicker is closed.
     * @event
     */
    close: base.EmitType<Object>;
    /**
     * Triggers when the date range value is changed in DateRangePicker.
     * @event
     */
    change: base.EmitType<Object>;
    /**
     * Triggers when the Calendar is navigated to another level or within the same level of view.
     * @event
     * @hidden
     */
    navigated: base.EmitType<NavigatedEventArgs>;
    /**
     * Triggers on selecting the start and end date.
     * @event
     */
    select: base.EmitType<Object>;
    /**
     * Constructor for creating the widget
     */
    constructor(options?: DateRangePickerModel, element?: string | HTMLInputElement);
    /**
     * To Initialize the control rendering.
     * @return void
     * @private
     */
    protected render(): void;
    /**
     * Initialize the event handler
     * @returns void
     * @private
     */
    protected preRender(): void;
    private initProperty();
    private initialize();
    private processPresets();
    protected bindEvents(): void;
    private bindClearEvent();
    protected resetHandler(e: MouseEvent): void;
    private clear();
    private rangeIconHandler(e);
    private checkHtmlAttributes();
    private createPopup();
    private renderControl();
    private clearCalendarEvents();
    private updateNavIcons();
    private calendarIconEvent();
    private bindCalendarEvents();
    private calendarIconRipple();
    private deviceCalendarEvent();
    private deviceNavNext(e);
    private deviceNavPrevious(e);
    private updateDeviceCalendar(calendar);
    private deviceHeaderClick(event);
    private inputBlurHandler();
    private clearRange();
    private errorClass();
    private keyCalendarUpdate(isLeftCalendar, ele);
    private navInCalendar(e, isLeftCalendar, leftLimit, rightLimit, ele);
    private keyInputHandler(e);
    private keyNavigation(calendar, e);
    private inputHandler(e);
    private bindCalendarCellEvents(calendar?);
    private removeFocusedDate();
    private hoverSelection(event, element);
    private updateRange(elementCollection);
    private checkMinMaxDays();
    private rangeArgs();
    private otherMonthSelect(ele, isStartDate, sameDate?);
    private selectRange(event, element);
    private selectableDates();
    private updateMinMaxDays(calendar);
    private removeClassDisabled();
    private updateHeader();
    private removeSelection();
    private addSelectedAttributes(ele, date, isStartDate, sameDate?);
    private removeSelectedAttributes();
    private updateCalendarElement(calendar);
    private navPreviousMonth(event);
    private deviceNavigation(ele?);
    private updateControl(calendar);
    private navNextMonth(event);
    private compareMonths(start, end);
    private isPopupOpen();
    private createHeader();
    private disableInput();
    private validateMinMax();
    private validateDates();
    private validateRangeStrict();
    private validateRange();
    private validateMinMaxDays();
    private renderCalendar();
    private isSameMonth(start, end);
    private selectNextMonth();
    private selectStartMonth();
    private createCalendar();
    private createControl();
    private cancelFunction(eve?);
    private deviceHeaderUpdate();
    private applyFunction(eve?);
    private onMouseClick(event, item?);
    private onMouseOver(event);
    private onMouseLeave(event);
    private setListSelection(li, event);
    private removeListSelection();
    private applyPresetRange(values);
    private renderCustomPopup();
    private listRippleEffect();
    private createPresets();
    private wireListEvents();
    private unWireListEvents();
    private renderPopup();
    private calendarFocus();
    private presetHeight();
    private presetKeyActionHandler(e);
    private listMoveDown(e);
    private listMoveUp(e);
    private getHoverLI();
    private getActiveLI();
    private popupKeyBoardHandler();
    private setScrollPosition();
    private popupKeyActionHandle(e);
    private iconBlurHandler();
    private removeIconTabindex();
    private addIconTabindex();
    private documentHandler(e);
    private createInput();
    private refreshControl();
    private updateInput();
    private isDateDisabled(date);
    private disabledDateRender();
    private virtualRenderCellEvent(args);
    private disabledDates();
    private changeTrigger();
    /**
     * This method is used to navigate to the month/year/decade view of the Calendar.
     * @param  {string} view - Specifies the view of the Calendar.
     * @param  {Date} date - Specifies the focused date in a view.
     * @returns void
     * @hidden
     */
    navigateTo(view: CalendarView, value: Date): void;
    /**
     * To destroy the widget.
     * @returns void
     */
    destroy(): void;
    /**
     * To get component name
     * @returns string
     * @private
     */
    protected getModuleName(): string;
    /**
     * Return the properties that are maintained upon browser refresh.
     * @returns string
     */
    getPersistData(): string;
    /**
     * Return the selected range and day span in the DateRangePicker.
     * @returns Object
     */
    getSelectedRange(): Object;
    /**
     * To open the popups.Popup container in the DateRangePicker component.
     * @returns void
     */
    show(element?: HTMLElement): void;
    /**
     * To close the popups.Popup container in the DateRangePicker component.
     * @returns void
     */
    hide(): void;
    private setLocale();
    /**
     * Called internally if any of the property value changed.
     * returns void
     * @private
     */
    onPropertyChanged(newProp: DateRangePickerModel, oldProp: DateRangePickerModel): void;
}
/**
 * DateRangePicker modules
 */
/**
 * Interface for a class DateTimePicker
 */
export interface DateTimePickerModel extends DatePickerModel{
    /**
     * Specifies the format of the time value that to be displayed in time popup list.
     * @default null
     */
    timeFormat?: string;
    /**
     * Specifies the time interval between the two adjacent time values in the time popup list . 
     * @default 30
     */
    step?: number;
    /**
     * specifies the z-index value of the popup element.
     * @default 1000
     */
    zIndex?: number;
    /**
     * Specifies whether to show or hide the clear icon in textbox.
     * @default false
     */
    showClearButton?: boolean;
    /**
     * Specifies the placeholder text that to be is displayed in textbox.
     * @default null
     */
    placeholder?: string;
    /**
     * Specifies the component whether to act as strict or not. So that, it allows to enter only a valid datetime value
     * or else it will resets to previous value. By default, strictMode is in false.
     * @default false
     */
    strictMode?: boolean;
    /**
     * Triggers when popup is opened.
     * @event 
     */
    open?: base.EmitType<Object>;
    /**
     * Triggers when popup is closed.
     * @event 
     */
    close?: base.EmitType<Object>;
    /**
     * Triggers when input loses the focus.
     * @event 
     */
    blur?: base.EmitType<Object>;
    /**
     * Triggers when input gets focus.
     * @event 
     */
    focus?: base.EmitType<Object>;
    /**
     * Triggers when DateTimePicker is created.
     * @event 
     */
    created?: base.EmitType<Object>;
    /**
     * Triggers when DateTimePicker is destroyed.
     * @event 
     */
    destroyed?: base.EmitType<Object>;
}

/**
 * Represents the DateTimePicker component that allows user to select
 * or enter a date time value.
 * ```html
 * <input id="dateTimePicker"/>
 * ````
 * ````typescript
 * <script>
 *   var dateTimePickerObject = new DateTimePicker({ value: new Date() });
 *   dateTimePickerObject.appendTo("#dateTimePicker");
 * </script>
 * ```
 */
export  class DateTimePicker extends DatePicker {
    private timeIcon;
    private cloneElement;
    private dateTimeWrapper;
    private rippleFn;
    private listWrapper;
    private liCollections;
    private timeCollections;
    private listTag;
    private selectedElement;
    private containerStyle;
    private popupObject;
    protected timeModal: HTMLElement;
    private isNavigate;
    private timeValue;
    protected l10n: base.L10n;
    private keyboardHandler;
    protected inputEvent: base.KeyboardEvents;
    private activeIndex;
    private valueWithMinutes;
    private previousDateTime;
    private initValue;
    private isValidState;
    protected timekeyConfigure: {
        [key: string]: string;
    };
    /**
     * Specifies the format of the time value that to be displayed in time popup list.
     * @default null
     */
    timeFormat: string;
    /**
     * Specifies the time interval between the two adjacent time values in the time popup list .
     * @default 30
     */
    step: number;
    /**
     * specifies the z-index value of the popup element.
     * @default 1000
     */
    zIndex: number;
    /**
     * Specifies whether to show or hide the clear icon in textbox.
     * @default false
     */
    showClearButton: boolean;
    /**
     * Specifies the placeholder text that to be is displayed in textbox.
     * @default null
     */
    placeholder: string;
    /**
     * Specifies the component whether to act as strict or not. So that, it allows to enter only a valid datetime value
     * or else it will resets to previous value. By default, strictMode is in false.
     * @default false
     */
    strictMode: boolean;
    /**
     * Triggers when popup is opened.
     * @event
     */
    open: base.EmitType<Object>;
    /**
     * Triggers when popup is closed.
     * @event
     */
    close: base.EmitType<Object>;
    /**
     * Triggers when input loses the focus.
     * @event
     */
    blur: base.EmitType<Object>;
    /**
     * Triggers when input gets focus.
     * @event
     */
    focus: base.EmitType<Object>;
    /**
     * Triggers when DateTimePicker is created.
     * @event
     */
    created: base.EmitType<Object>;
    /**
     * Triggers when DateTimePicker is destroyed.
     * @event
     */
    destroyed: base.EmitType<Object>;
    /**
     * Constructor for creating the widget
     */
    constructor(options?: DateTimePickerModel, element?: string | HTMLInputElement);
    /**
     * Sets the focus to widget for interaction.
     * @returns void
     */
    focusIn(): void;
    /**
     * Remove the focus from widget, if the widget is in focus state.
     * @returns void
     */
    focusOut(): void;
    /**
     * To destroy the widget.
     * @returns void
     */
    destroy(): void;
    /**
     * To Initialize the control rendering.
     * @return void
     * @private
     */
    render(): void;
    private setValue();
    private validateMinMaxRange(value);
    private checkValidState(value);
    private checkErrorState();
    private validateValue(value);
    private disablePopupButton(isDisable);
    private getFormattedValue(value);
    private isDateObject(value);
    private createInputElement();
    private renderTimeIcon();
    private bindInputEvents();
    private unBindInputEvents();
    private cldrTimeFormat();
    private cldrDateTimeFormat();
    private getCldrFormat(type);
    private isNullOrEmpty(value);
    protected getCultureTimeObject(ld: Object, c: string): Object;
    private timeHandler(e?);
    private dateHandler(e?);
    show(type?: string): void;
    toggle(): void;
    private listCreation();
    private popupCreation(type);
    private openPopup();
    private documentClickHandler(event);
    private isTimePopupOpen();
    private isDatePopupOpen();
    private renderPopup();
    private setPopupWidth();
    protected wireTimeListEvents(): void;
    protected unWireTimeListEvents(): void;
    private onMouseOver(event);
    private onMouseLeave();
    private setTimeHover(li, className);
    protected getPopupHeight(): number;
    protected changeEvent(): void;
    private updateValue();
    private setTimeScrollPosition();
    private setInputValue(type);
    private getFullDateTime();
    private combineDateTime(value);
    private onMouseClick(event);
    private setSelection(li, event);
    private setTimeActiveClass();
    private setTimeActiveDescendant();
    protected addTimeSelection(): void;
    protected removeTimeSelection(): void;
    protected removeTimeHover(className: string): void;
    protected getTimeHoverItem(className: string): Element[];
    protected isValidLI(li: Element | HTMLElement): boolean;
    private calculateStartEnd(value, range, method);
    private startTime(date);
    private endTime(date);
    hide(): void;
    private closePopup();
    protected preRender(): void;
    protected getProperty(date: DateTimePickerModel, val: string): void;
    protected checkAttributes(): void;
    private getTimeActiveElement();
    protected createDateObj(val: Date | string): Date;
    private getDateObject(text);
    protected findNextTimeElement(event: base.KeyboardEventArgs): void;
    protected setTimeValue(date: Date, value: Date): Date;
    protected timeElementValue(value: Date): Date;
    protected timeKeyHandler(event: base.KeyboardEventArgs): void;
    protected TimeKeyActionHandle(event: base.KeyboardEventArgs): void;
    protected inputKeyAction(event: base.KeyboardEventArgs): void;
    onPropertyChanged(newProp: DateTimePickerModel, oldProp: DateTimePickerModel): void;
    /**
     * To get component name.
     * @private
     */
    protected getModuleName(): string;
}
/**
 * DateTimePicker modules
 */
/**
 * Calendar all modules
 */
/**
 * TimePicker modules
 */
/**
 * Interface for a class TimePicker
 */
export interface TimePickerModel extends base.ComponentModel{
    /**
     * Gets or sets the width of the TimePicker component. The width of the popup is based on the width of the component.
     * @default '100%'
     */
    width?: string | number;
    /**
     * Specifies the root CSS class of the TimePicker that allows to
     * customize the appearance by overriding the styles.
     * @default null
     */
    cssClass?: string;
    /**
     * Specifies the component to act as strict so that, it allows to enter only a valid time value within a specified range or else 
     * resets to previous value. By default, strictMode is in false.
     * @default false
     */
    strictMode?: boolean;
    /**
     * Specifies the format of value that is to be displayed in component. By default, the format is
     * based on the culture. 
     * @default null
     */
    format?: string;
    /**
     * Specifies whether the component to be disabled or not.
     * @default true
     */
    enabled?: boolean;
    /**
     * Specifies the component in readonly state. 
     * @default false
     */
    readonly?: boolean;
    /**
     * Specifies the placeholder text to be floated.
     */
    floatLabelType?: inputs.FloatLabelType;
    /**
     * Specifies the placeholder text that is displayed in textbox.
     * @default null
     */
    placeholder?: string;
    /**
     * specifies the z-index value of the timePicker popup element.
     * @default 1000
     */
    zIndex?: number;
    /**
     * Specifies whether to show or hide the clear Icon
     * @default true
     */
    showClearButton?: boolean;
    /**
     * Specifies the time interval between the two adjacent time values in the popup list . 
     * @default 30
     */
    step?: number;
    /**
     * Specifies the scroll bar position if there is no value is selected in the popup list or
     *  the given value is not present in the popup list. 
     * @default null
     */
    scrollTo?: Date;
    /**
     * Gets or sets the value of the component. The value is parsed based on the format. 
     * @default null
     */
    value?: Date;
    /**
     * Gets or sets the minimum time value that can be allowed to select in TimePicker.
     * @default 00:00
     */
    min?: Date;
    /**
     * Gets or sets the maximum time value that can be allowed to select in TimePicker.
     * @default 00:00
     */
    max?: Date;
    /**
     * Specifies the component to be rendered in right-to-left direction.
     * @default false
     */
    enableRtl?: boolean;
    /**
     * Triggers when the value is changed.
     * @event  
     */
    change?: base.EmitType<ChangeEventArgs>;
    /**
     * Triggers when the component is created.
     * @event
     */
    created?: base.EmitType<Object>;
    /**
     * Triggers when the component is destroyed.
     * @event
     */
    destroyed?: base.EmitType<Object>;
    /**
     * Triggers when the popup is opened.
     * @event
     */
    open?: base.EmitType<PopupEventArgs>;
    /**
     * Triggers while rendering the each popup list item.
     * @event
     */
    itemRender?: base.EmitType<ItemEventArgs>;
    /**
     * Triggers when the popup is closed.
     * @event
     */
    close?: base.EmitType<PopupEventArgs>;
    /**
     * Triggers when the control loses the focus.
     * @event
     */
    blur?: base.EmitType<Object>;
    /**
     * Triggers when the control gets focused.
     * @event
     */
    focus?: base.EmitType<Object>;
}
export interface ChangeEventArgs {
    /** Defines the boolean that returns true when the value is changed by user interaction, otherwise returns false. */
    isInteracted: boolean;
    /** Defines the selected time value of the TimePicker. */
    value: Date;
    /** Defines the selected time value as string. */
    text: string;
    /** Defines the type of the event. */
    e: base.KeyboardEventArgs | FocusEvent | MouseEvent;
}
/**
 * Interface for before list item render .
 * @private
 */
export interface ItemEventArgs extends base.BaseEventArgs {
    /** Defines the created LI element. */
    element: HTMLElement;
    /** Defines the displayed text value in a popup list. */
    text: string;
    /** Defines the Date object of displayed text in a popup list. */
    value: Date;
    /** Specifies whether to disable the current time value or not. */
    isDisabled: Boolean;
}
export interface CursorPositionDetails {
    /** Defines the text selection starting position. */
    start: number;
    /** Defines the text selection end position. */
    end: number;
}
export interface MeridianText {
    /** Defines the culture specific meridian text for AM. */
    am: string;
    /** Defines the culture specific meridian text for PM. */
    pm: string;
}
export interface PopupEventArgs {
    /** Defines the TimePicker popup element. */
    popup: popups.Popup;
}
export  namespace TimePickerBase {
    function createListItems(min: Date, max: Date, globalize: base.Internationalization, timeFormat: string, step: number): {
        collection: number[];
        list: HTMLElement;
    };
}
/**
 * TimePicker is an intuitive interface component which provides an options to select a time value
 * from popup list or to set a desired time value.
 * ```
 * <input id='timepicker' type='text'/>
 * <script>
 *   var timePickerObj = new TimePicker({ value: new Date() });
 *   timePickerObj.appendTo('#timepicker');
 * </script>
 * ```
 */
export  class TimePicker extends base.Component<HTMLElement> implements inputs.IInput {
    private inputWrapper;
    private popupWrapper;
    private cloneElement;
    private listWrapper;
    private listTag;
    private selectedElement;
    private liCollections;
    protected inputElement: HTMLInputElement;
    private popupObj;
    protected inputEvent: base.KeyboardEvents;
    protected globalize: base.Internationalization;
    private defaultCulture;
    private containerStyle;
    private rippleFn;
    private l10n;
    private cursorDetails;
    private activeIndex;
    private timeCollections;
    private isNavigate;
    private disableItemCollection;
    protected isPreventBlur: boolean;
    private isTextSelected;
    private prevValue;
    private inputStyle;
    private angularTag;
    private valueWithMinutes;
    private prevDate;
    private initValue;
    private initMin;
    private initMax;
    protected keyConfigure: {
        [key: string]: string;
    };
    /**
     * Gets or sets the width of the TimePicker component. The width of the popup is based on the width of the component.
     * @default '100%'
     */
    width: string | number;
    /**
     * Specifies the root CSS class of the TimePicker that allows to
     * customize the appearance by overriding the styles.
     * @default null
     */
    cssClass: string;
    /**
     * Specifies the component to act as strict so that, it allows to enter only a valid time value within a specified range or else
     * resets to previous value. By default, strictMode is in false.
     * @default false
     */
    strictMode: boolean;
    /**
     * Specifies the format of value that is to be displayed in component. By default, the format is
     * based on the culture.
     * @default null
     */
    format: string;
    /**
     * Specifies whether the component to be disabled or not.
     * @default true
     */
    enabled: boolean;
    /**
     * Specifies the component in readonly state.
     * @default false
     */
    readonly: boolean;
    /**
     * Specifies the placeholder text to be floated.
     */
    floatLabelType: inputs.FloatLabelType;
    /**
     * Specifies the placeholder text that is displayed in textbox.
     * @default null
     */
    placeholder: string;
    /**
     * specifies the z-index value of the timePicker popup element.
     * @default 1000
     */
    zIndex: number;
    /**
     * Specifies whether to show or hide the clear Icon
     * @default true
     */
    showClearButton: boolean;
    /**
     * Specifies the time interval between the two adjacent time values in the popup list .
     * @default 30
     */
    step: number;
    /**
     * Specifies the scroll bar position if there is no value is selected in the popup list or
     *  the given value is not present in the popup list.
     * @default null
     */
    scrollTo: Date;
    /**
     * Gets or sets the value of the component. The value is parsed based on the format.
     * @default null
     */
    value: Date;
    /**
     * Gets or sets the minimum time value that can be allowed to select in TimePicker.
     * @default 00:00
     */
    min: Date;
    /**
     * Gets or sets the maximum time value that can be allowed to select in TimePicker.
     * @default 00:00
     */
    max: Date;
    /**
     * Specifies the component to be rendered in right-to-left direction.
     * @default false
     */
    enableRtl: boolean;
    /**
     * Triggers when the value is changed.
     * @event
     */
    change: base.EmitType<ChangeEventArgs>;
    /**
     * Triggers when the component is created.
     * @event
     */
    created: base.EmitType<Object>;
    /**
     * Triggers when the component is destroyed.
     * @event
     */
    destroyed: base.EmitType<Object>;
    /**
     * Triggers when the popup is opened.
     * @event
     */
    open: base.EmitType<PopupEventArgs>;
    /**
     * Triggers while rendering the each popup list item.
     * @event
     */
    itemRender: base.EmitType<ItemEventArgs>;
    /**
     * Triggers when the popup is closed.
     * @event
     */
    close: base.EmitType<PopupEventArgs>;
    /**
     * Triggers when the control loses the focus.
     * @event
     */
    blur: base.EmitType<Object>;
    /**
     * Triggers when the control gets focused.
     * @event
     */
    focus: base.EmitType<Object>;
    /**
     * Constructor for creating the widget
     */
    constructor(options?: TimePickerModel, element?: string | HTMLInputElement);
    /**
     * Initialize the event handler
     * @private
     */
    protected preRender(): void;
    protected render(): void;
    private validateDisable();
    private initialize();
    private checkDateValue(value);
    private createInputElement();
    destroy(): void;
    private popupCreation();
    protected getPopupHeight(): number;
    private generateList();
    private popupCalculation();
    private isEmptyList();
    private renderPopup();
    private getFormattedValue(value);
    private getDateObject(text);
    private checkErrorState(val);
    private validateInterval();
    private disableTimeIcon();
    private disableElement(element);
    private enableElement(element);
    private selectInputText();
    private getMeridianText();
    private getCursorSelection();
    private getActiveElement();
    private isNullOrEmpty(value);
    private setWidth();
    private setScrollPosition();
    private findScrollTop(element);
    private setScrollTo();
    private getText();
    private getValue(value);
    private cldrDateFormat();
    private cldrTimeFormat();
    private dateToNumeric();
    private getExactDateTime(value);
    private setValue(value);
    private updatePlaceHolder();
    private popupHandler();
    private mouseDownHandler();
    private mouseUpHandler(event);
    private focusSelection();
    private inputHandler(event);
    private onMouseClick(event);
    private closePopup(delay?);
    private checkValueChange(event, isNavigation);
    private onMouseOver(event);
    private setHover(li, className);
    private setSelection(li, event);
    private onMouseLeave();
    private scrollHandler();
    private setMinMax(minVal, maxVal);
    protected validateMinMax(dateVal: Date | string, minVal: Date, maxVal: Date): Date | string;
    private valueIsDisable(value);
    protected validateState(val: string | Date): boolean;
    protected strictOperation(minimum: Date, maximum: Date, dateVal: Date | string, val: Date): Date | string;
    protected bindEvents(): void;
    protected unBindEvents(): void;
    private bindClearEvent();
    protected clearHandler(e: MouseEvent): void;
    private clear(event);
    protected setZIndex(): void;
    protected checkAttributes(): void;
    protected setCurrentDate(value: Date): Date;
    protected getSeparator(): string;
    protected getTextFormat(): number;
    protected updateValue(value: string | Date, event: base.KeyboardEventArgs | FocusEvent): void;
    protected previousState(date: Date): string;
    protected resetState(): void;
    protected objToString(val: Date): string;
    protected checkValue(value: string | Date): string;
    protected validateValue(date: Date, value: string | Date): string;
    protected findNextElement(event: base.KeyboardEventArgs): void;
    protected elementValue(value: Date): void;
    private validLiElement(index, backward?);
    protected keyHandler(event: base.KeyboardEventArgs): void;
    protected setPopupPosition(): number;
    protected getCultureTimeObject(ld: Object, c: string): Object;
    protected getCultureDateObject(ld: Object, c: string): Object;
    protected wireListEvents(): void;
    protected unWireListEvents(): void;
    protected valueProcess(event: base.KeyboardEventArgs | FocusEvent | MouseEvent, value: Date): void;
    protected changeEvent(event: base.KeyboardEventArgs | FocusEvent | MouseEvent): void;
    protected updateInput(isUpdate: boolean, date: Date): void;
    protected setActiveDescendant(): void;
    protected removeSelection(): void;
    protected removeHover(className: string): void;
    protected getHoverItem(className: string): Element[];
    private setActiveClass();
    protected addSelection(): void;
    protected isValidLI(li: Element | HTMLElement): boolean;
    protected createDateObj(val: Date | string): Date;
    protected TimeParse(today: string, val: Date | string): Date;
    protected createListItems(): void;
    private documentClickHandler(event);
    protected setEnableRtl(): void;
    protected setEnable(): void;
    protected getProperty(date: TimePickerModel, val: string): void;
    /**
     * Focuses out the TimePicker textbox element.
     * @returns void
     */
    focusOut(): void;
    private isPopupOpen();
    /**
     * Focused the TimePicker textbox element.
     * @returns void
     */
    focusIn(): void;
    /**
     * Hides the TimePicker popup.
     * @returns void
     */
    hide(): void;
    /**
     * Opens the popup to show the list items.
     * @returns void
     */
    show(): void;
    /**
     * Gets the properties to be maintained upon browser refresh.
     * @returns string
     */
    getPersistData(): string;
    /**
     * To get component name
     * @private
     */
    protected getModuleName(): string;
    /**
     * Called internally if any of the property value changed.
     * returns void
     * @private
     */
    onPropertyChanged(newProp: TimePickerModel, oldProp: TimePickerModel): void;
}
 }
export namespace charts { 

/**
 * Interface for a class AccumulationChart
 */
export interface AccumulationChartModel extends base.ComponentModel{
    /**
     * The width of the chart as a string in order to provide input as both like '100px' or '100%'.
     * If specified as '100%, chart will render to the full width of its parent element.
     * @default null
     */
    width?: string;
    /**
     * The height of the chart as a string in order to provide input as both like '100px' or '100%'.
     * If specified as '100%, chart will render to the full height of its parent element.
     * @default null
     */
    height?: string;
    /**
     * Title for accumulation chart
     * @default null
     */
    title?: string;
    /**
     * Options for customizing the `title` of accumulation chart.
     */
    titleStyle?: FontModel;
    /**
     * Options for customizing the legend of accumulation chart.
     */
    legendSettings?: LegendSettingsModel;
    /**
     * Options for customizing the tooltip of accumulation chart.
     */
    tooltip?:  TooltipSettingsModel;
    /**
     * Specifies whether point has to get selected or not. Takes value either 'None 'or 'Point'
     * @default None
     */
    selectionMode?: AccumulationSelectionMode;
    /**
     * If set true, enables the multi selection in accumulation chart. It requires `selectionMode` to be `Point`.
     * @default false
     */
    isMultiSelect?: boolean;
    /**
     * Specifies the point indexes to be selected while loading a accumulation chart.
     * It requires `selectionMode` to be `Point`.
     * ```html
     * <div id='Pie'></div>
     * ```
     * ```typescript
     * let pie: AccumulationChart = new AccumulationChart({
     * ...
     *   selectionMode: 'Point',
     *   selectedDataIndexes: [ { series: 0, point: 1},
     *                          { series: 2, point: 3} ],
     * ...
     * });
     * pie.appendTo('#Pie');
     * ```
     * @default []
     */
    selectedDataIndexes?: IndexesModel[];
    /**
     *  Options to customize the left, right, top and bottom margins of accumulation chart.
     */
    margin?: MarginModel;
    /**
     * If set true, labels for the point will be placed smartly without overlapping.
     * @default true
     */
    enableSmartLabels?: boolean;
    /**
     * Options for customizing the color and width of the chart border.
     */
    border?: BorderModel;
    /**
     * The background color of the chart, which accepts value in hex, rgba as a valid CSS color string.
     * @default null
     */
    background?: string;
    /**
     * The configuration for series in accumulation chart.
     */
    series?: AccumulationSeriesModel[];
    /**
     * The configuration for annotation in chart.
     */
    annotations?: AccumulationAnnotationSettingsModel[];
    /**
     * Specifies the theme for accumulation chart.
     * @default 'Material'
     */
    theme?: AccumulationTheme;
    /**
     * Triggers after accumulation chart loaded.
     * @event
     */
    loaded?: base.EmitType<IAccLoadedEventArgs>;
    /**
     * Triggers before accumulation chart base.load.
     * @event
     */
    load?: base.EmitType<IAccLoadedEventArgs>;
    /**
     * Triggers before the series gets rendered.
     * @event
     */
    seriesRender?: base.EmitType<IAccSeriesRenderEventArgs>;
    /**
     * Triggers before the legend gets rendered.
     * @event
     */
    legendRender?: base.EmitType<ILegendRenderEventArgs>;
    /**
     * Triggers before the data label for series gets rendered.
     * @event
     */
    textRender?: base.EmitType<IAccTextRenderEventArgs>;
    /**
     * Triggers before the tooltip for series gets rendered.
     * @event
     */
    tooltipRender?: base.EmitType<IAccTooltipRenderEventArgs>;
    /**
     * Triggers before each points for series gets rendered.
     * @event
     */
    pointRender?: base.EmitType<IAccPointRenderEventArgs>;
    /**
     * Triggers before the annotation gets rendered.
     * @event
     */
    annotationRender?: base.EmitType<IAnnotationRenderEventArgs>;
    /**
     * Triggers before the prints gets started.
     * @event
     */
    beforePrint?: base.EmitType<IPrintEventArgs>;
    /**
     * Triggers on hovering the accumulation chart.
     * @event
     */
    chartMouseMove?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on clicking the accumulation chart.
     * @event
     */
    chartMouseClick?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on point click.
     * @event
     */
    pointClick?: base.EmitType<IPointEventArgs>;
    /**
     * Triggers on point move.
     * @event
     */
    pointMove?: base.EmitType<IPointEventArgs>;
    /**
     * Triggers after animation gets completed for series.
     * @event
     */
    animationComplete?: base.EmitType<IAccAnimationCompleteEventArgs>;
    /**
     * Triggers on mouse down.
     * @event
     */
    chartMouseDown?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers while cursor leaves the accumulation chart.
     * @event
     */
    chartMouseLeave?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on mouse up.
     * @event
     */
    chartMouseUp?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers after window resize.
     * @event
     */
    resized?: base.EmitType<IResizeEventArgs>;
    /**
     * Defines the currencyCode format of the accumulation chart
     * @private
     */
    currencyCode?: string;
}
/**
 * AccumulationChart file
 */
/**
 * Represents the AccumulationChart control.
 * ```html
 * <div id="accumulation"/>
 * <script>
 *   var accObj = new AccumulationChart({ });
 *   accObj.appendTo("#accumulation");
 * </script>
 * ```
 */
export  class AccumulationChart extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /**
     * `accBaseModue` is used to define the common functionalities of accumulation series
     * @private
     */
    accBaseModule: AccumulationBase;
    /**
     * `pieSeriesModule` is used to render pie series.
     * @private
     */
    pieSeriesModule: PieSeries;
    /**
     * `funnelSeriesModule` is used to render funnel series.
     * @private
     */
    funnelSeriesModule: FunnelSeries;
    /**
     * `pyramidSeriesModule` is used to render funnel series.
     * @private
     */
    pyramidSeriesModule: PyramidSeries;
    /**
     * `accumulationLegendModule` is used to manipulate and add legend in accumulation chart.
     */
    accumulationLegendModule: AccumulationLegend;
    /**
     * `accumulationDataLabelModule` is used to manipulate and add dataLabel in accumulation chart.
     */
    accumulationDataLabelModule: AccumulationDataLabel;
    /**
     * `accumulationTooltipModule` is used to manipulate and add tooltip in accumulation chart.
     */
    accumulationTooltipModule: AccumulationTooltip;
    /**
     * `accumulationSelectionModule` is used to manipulate and add selection in accumulation chart.
     */
    accumulationSelectionModule: AccumulationSelection;
    /**
     * `annotationModule` is used to manipulate and add annotation in chart.
     */
    annotationModule: AccumulationAnnotation;
    /**
     * The width of the chart as a string in order to provide input as both like '100px' or '100%'.
     * If specified as '100%, chart will render to the full width of its parent element.
     * @default null
     */
    width: string;
    /**
     * The height of the chart as a string in order to provide input as both like '100px' or '100%'.
     * If specified as '100%, chart will render to the full height of its parent element.
     * @default null
     */
    height: string;
    /**
     * Title for accumulation chart
     * @default null
     */
    title: string;
    /**
     * Options for customizing the `title` of accumulation chart.
     */
    titleStyle: FontModel;
    /**
     * Options for customizing the legend of accumulation chart.
     */
    legendSettings: LegendSettingsModel;
    /**
     * Options for customizing the tooltip of accumulation chart.
     */
    tooltip: TooltipSettingsModel;
    /**
     * Specifies whether point has to get selected or not. Takes value either 'None 'or 'Point'
     * @default None
     */
    selectionMode: AccumulationSelectionMode;
    /**
     * If set true, enables the multi selection in accumulation chart. It requires `selectionMode` to be `Point`.
     * @default false
     */
    isMultiSelect: boolean;
    /**
     * Specifies the point indexes to be selected while loading a accumulation chart.
     * It requires `selectionMode` to be `Point`.
     * ```html
     * <div id='Pie'></div>
     * ```
     * ```typescript
     * let pie: AccumulationChart = new AccumulationChart({
     * ...
     *   selectionMode: 'Point',
     *   selectedDataIndexes: [ { series: 0, point: 1},
     *                          { series: 2, point: 3} ],
     * ...
     * });
     * pie.appendTo('#Pie');
     * ```
     * @default []
     */
    selectedDataIndexes: IndexesModel[];
    /**
     *  Options to customize the left, right, top and bottom margins of accumulation chart.
     */
    margin: MarginModel;
    /**
     * If set true, labels for the point will be placed smartly without overlapping.
     * @default true
     */
    enableSmartLabels: boolean;
    /**
     * Options for customizing the color and width of the chart border.
     */
    border: BorderModel;
    /**
     * The background color of the chart, which accepts value in hex, rgba as a valid CSS color string.
     * @default null
     */
    background: string;
    /**
     * The configuration for series in accumulation chart.
     */
    series: AccumulationSeriesModel[];
    /**
     * The configuration for annotation in chart.
     */
    annotations: AccumulationAnnotationSettingsModel[];
    /**
     * Specifies the theme for accumulation chart.
     * @default 'Material'
     */
    theme: AccumulationTheme;
    /**
     * Triggers after accumulation chart loaded.
     * @event
     */
    loaded: base.EmitType<IAccLoadedEventArgs>;
    /**
     * Triggers before accumulation chart load.
     * @event
     */
    load: base.EmitType<IAccLoadedEventArgs>;
    /**
     * Triggers before the series gets rendered.
     * @event
     */
    seriesRender: base.EmitType<IAccSeriesRenderEventArgs>;
    /**
     * Triggers before the legend gets rendered.
     * @event
     */
    legendRender: base.EmitType<ILegendRenderEventArgs>;
    /**
     * Triggers before the data label for series gets rendered.
     * @event
     */
    textRender: base.EmitType<IAccTextRenderEventArgs>;
    /**
     * Triggers before the tooltip for series gets rendered.
     * @event
     */
    tooltipRender: base.EmitType<IAccTooltipRenderEventArgs>;
    /**
     * Triggers before each points for series gets rendered.
     * @event
     */
    pointRender: base.EmitType<IAccPointRenderEventArgs>;
    /**
     * Triggers before the annotation gets rendered.
     * @event
     */
    annotationRender: base.EmitType<IAnnotationRenderEventArgs>;
    /**
     * Triggers before the prints gets started.
     * @event
     */
    beforePrint: base.EmitType<IPrintEventArgs>;
    /**
     * Triggers on hovering the accumulation chart.
     * @event
     */
    chartMouseMove: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on clicking the accumulation chart.
     * @event
     */
    chartMouseClick: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on point click.
     * @event
     */
    pointClick: base.EmitType<IPointEventArgs>;
    /**
     * Triggers on point move.
     * @event
     */
    pointMove: base.EmitType<IPointEventArgs>;
    /**
     * Triggers after animation gets completed for series.
     * @event
     */
    animationComplete: base.EmitType<IAccAnimationCompleteEventArgs>;
    /**
     * Triggers on mouse down.
     * @event
     */
    chartMouseDown: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers while cursor leaves the accumulation chart.
     * @event
     */
    chartMouseLeave: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on mouse up.
     * @event
     */
    chartMouseUp: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers after window resize.
     * @event
     */
    resized: base.EmitType<IResizeEventArgs>;
    /**
     * Defines the currencyCode format of the accumulation chart
     * @private
     */
    private currencyCode;
    /** @private */
    svgObject: Element;
    /** @private */
    initialClipRect: Rect;
    /** @private */
    availableSize: Size;
    /** @private */
    renderer: base.SvgRenderer;
    /** @private */
    intl: base.Internationalization;
    /** @private */
    visibleSeries: AccumulationSeries[];
    /** @private */
    seriesCounts: number;
    /** @private explode radius internal property */
    explodeDistance: number;
    /** @private Mouse position x */
    mouseX: number;
    /** @private Mouse position y */
    mouseY: number;
    private resizeTo;
    /** @private */
    center: ChartLocation;
    /** @private */
    readonly type: AccumulationType;
    /** @private */
    isTouch: boolean;
    /** @private */
    animateSeries: boolean;
    private titleCollection;
    /** @private */
    themeStyle: IThemeStyle;
    /**
     * Constructor for creating the AccumulationChart widget
     * @private
     */
    constructor(options?: AccumulationChartModel, element?: string | HTMLElement);
    /**
     *  To create svg object, renderer and binding events for the container.
     */
    protected preRender(): void;
    /**
     * Themeing for chart goes here
     */
    private setTheme();
    /**
     * To render the accumulation chart elements
     */
    protected render(): void;
    /**
     * Method to unbind events for accumulation chart
     */
    private unWireEvents();
    /**
     * Method to bind events for the accumulation chart
     */
    private wireEvents();
    /**
     * Method to set mouse x, y from events
     */
    private setMouseXY(e);
    /**
     * Handles the mouse end.
     * @return {boolean}
     * @private
     */
    accumulationMouseEnd(e: PointerEvent): boolean;
    /**
     * Handles the mouse start.
     * @return {boolean}
     * @private
     */
    accumulationMouseStart(e: PointerEvent): boolean;
    /**
     * Handles the accumulation chart resize.
     * @return {boolean}
     * @private
     */
    accumulationResize(e: Event): boolean;
    /**
     * Handles the export method for chart control.
     */
    export(type: ExportType, fileName: string, orientation?: pdfexport.PdfPageOrientation): void;
    /**
     * Handles the print method for accumulation chart control.
     */
    print(id?: string[] | string | Element): void;
    /**
     * Applying styles for accumulation chart element
     */
    private setStyle(element);
    /**
     * Method to set the annotation content dynamically for accumulation.
     */
    setAnnotationValue(annotationIndex: number, content: string): void;
    /**
     * Handles the mouse move on accumulation chart.
     * @return {boolean}
     * @private
     */
    accumulationMouseMove(e: PointerEvent): boolean;
    titleTooltip(event: Event, x: number, y: number, isTouch?: boolean): void;
    /**
     * Handles the mouse click on accumulation chart.
     * @return {boolean}
     * @private
     */
    accumulationOnMouseClick(e: PointerEvent): boolean;
    private triggerPointEvent(event, element);
    /**
     * Handles the mouse right click on accumulation chart.
     * @return {boolean}
     * @private
     */
    accumulationRightClick(event: MouseEvent | PointerEvent): boolean;
    /**
     * Handles the mouse leave on accumulation chart.
     * @return {boolean}
     * @private
     */
    accumulationMouseLeave(e: PointerEvent): boolean;
    /**
     * Method to set culture for chart
     */
    private setCulture();
    /**
     * Method to create SVG element for accumulation chart.
     */
    private createPieSvg();
    /**
     * To Remove the SVG from accumulation chart.
     * @return {boolean}
     * @private
     */
    removeSvg(): void;
    /**
     * Method to create the secondary element for tooltip, datalabel and annotaitons.
     */
    private createSecondaryElement();
    /**
     * Method to find visible series based on series types
     */
    private calculateVisibleSeries();
    /**
     * To find points from dataSource
     */
    private processData();
    /**
     * To refresh the accumulation chart
     * @private
     */
    refreshChart(): void;
    /**
     * Method to find groupped points
     */
    private doGrouppingProcess();
    /**
     * Method to calculate bounds for accumulation chart
     */
    private calculateBounds();
    calculateLegendBounds();
    /**
     * To render elements for accumulation chart
     * @private
     */
    renderElements(): void;
    /**
     * To set the left and top position for data label template for center aligned chart
     */
    setSecondaryElementPosition();
    /**
     * To render the annotaitions for accumulation series.
     */
    renderAnnotation();
    /**
     * Method to process the explode in accumulation chart
     */
    processExplode();
    /**
     * Method to render series for accumulation chart
     */
    renderSeries();
    /**
     * Method to render border for accumulation chart
     */
    renderBorder();
    /**
     * Method to render legend for accumulation chart
     */
    renderLegend();
    /**
     * To process the selection in accumulation chart
     */
    processSelection();
    /**
     * To render title for accumulation chart
     */
    renderTitle();
    /**
     * To get the series parent element
     * @private
     */
    getSeriesElement(): Element;
    /**
     * To refresh the all visible series points
     * @private
     */
    refreshSeries(): void;
    /**
     * To refresh points label region and visible
     * @private
     */
    refreshPoints(points: AccPoints[]): void;
    /**
     * To get Module name
     *  @private
     */
    getModuleName(): string;
    /**
     * To destroy the accumulationcharts
     * @private
     */
    destroy(): void;
    /**
     * To provide the array of modules needed for control rendering
     * @return {base.ModuleDeclaration[]}
     * @private
     */
    requiredModules(): base.ModuleDeclaration[];
    /**
     * To find datalabel visibility in series
     */
    findDatalabelVisibility();
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    getPersistData(): string;
    /**
     * Called internally if any of the property value changed.
     * @private
     */
    onPropertyChanged(newProp: AccumulationChartModel, oldProp: AccumulationChartModel): void;
}
/**
 * AccumulationChart annotation properties
 */
/**
 * `AccumulationAnnotation` module handles the annotation for accumulation chart.
 */
export  class AccumulationAnnotation extends AnnotationBase {
    private pie;
    private annotations;
    private parentElement;
    /**
     * Constructor for accumulation chart annotation.
     * @private.
     */
    constructor(control: AccumulationChart, annotations: AccumulationAnnotationSettings[]);
    /**
     * Method to render the annotation for accumulation chart
     * @param element
     */
    renderAnnotations(element: Element): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the annotation.
     * @return {void}
     * @private
     */
    destroy(control: AccumulationChart): void;
}
/**
 * Pie Component items exported
 */
/**
 * Interface for a class AccumulationAnnotationSettings
 */
export interface AccumulationAnnotationSettingsModel {
    /**
     * Content of the annotation, which accepts the id of the custom element.
     * @default null
     */
    content?: string;
    /**
     * if set coordinateUnit as `Pixel` X specifies the axis value
     * else is specifies pixel or percentage of coordinate
     * @default 0
     */
    x?: string | Date | number;
    /**
     * if set coordinateUnit as `Pixel` Y specifies the axis value
     * else is specifies pixel or percentage of coordinate
     * @default 0
     */
    y?: string | number;
    /**
     * Specifies the coordinate units of the annotation. They are
     * * Pixel - Annotation renders based on x and y pixel value.
     * * Point - Annotation renders based on x and y axis value.
     * @default 'Pixel'
     */
    coordinateUnits?: Units;
    /**
     * Specifies the regions of the annotation. They are
     * * Chart - Annotation renders based on chart coordinates.
     * * Series - Annotation renders based on series coordinates.
     * @default 'Chart'
     */
    region?: Regions;
    /**
     * Specifies the position of the annotation. They are
     * * Top - Align the annotation element as top side.
     * * Bottom - Align the annotation element as bottom side.
     * * Middle - Align the annotation element as mid point.
     * @default 'Middle'
     */
    verticalAlignment?: base.Position;
    /**
     * Specifies the alignment of the annotation. They are
     * * Near - Align the annotation element as top side.
     * * Far - Align the annotation element as bottom side.
     * * Center - Align the annotation element as mid point.
     * @default 'Center'
     */
    horizontalAlignment?: Alignment;
    /**
     * Information about annotation for assistive technology.
     * @default null
     */
    description?: string;
}
/**
 * Interface for a class AccumulationDataLabelSettings
 */
export interface AccumulationDataLabelSettingsModel {
    /**
     * If set true, data label for series gets render.
     * @default false
     */
    visible?: boolean;
    /**
     * The DataSource field which contains the data label value.
     * @default null
     */
    name?: string;
    /**
     * The background color of the data label, which accepts value in hex, rgba as a valid CSS color string.
     * @default 'transparent'
     */
    fill?: string;
    /**
     * Specifies the position of data label. They are.
     * * Outside - Places label outside the point.
     * * Inside - Places label inside the point.
     * @default 'Inside'
     */
    position?: AccumulationLabelPosition;
    /**
     * The roundedCornerX for the data label. It requires `border` values not to be null.
     * @default 5
     */
    rx?: number;
    /**
     * The roundedCornerY for the data label. It requires `border` values not to be null.
     * @default 5
     */
    ry?: number;
    /**
     * Option for customizing the border lines.
     */
    border?: BorderModel;
    /**
     * Option for customizing the data label text.
     */
    font?: FontModel;
    /**
     * Options for customize the connector line in series.
     * This property is applicable for Pie, Funnel and Pyramid series.
     * The default connector length for Pie series is '4%'. For other series, it is null.
     */
    connectorStyle?: ConnectorModel;
    /**
     * Custom template to format the data label content. Use ${point.x} and ${point.y} as a placeholder
     * text to display the corresponding data point.
     * @default null
     */
    template?: string;
}
/**
 * Interface for a class AccPoints
 */
export interface AccPointsModel {
}
/**
 * Interface for a class AccumulationSeries
 */
export interface AccumulationSeriesModel {
    /**
     * Specifies the dataSource for the series. It can be an array of JSON objects or an instance of data.DataManager.
     * ```html
     * <div id='Pie'></div> 
     * ```
     * ```typescript
     * let dataManager: data.DataManager = new data.DataManager({
     *         url: 'http://mvc.syncfusion.com/Services/Northwnd.svc/Tasks/'
     * });
     * let query: data.Query = new data.Query().take(50).where('Estimate', 'greaterThan', 0, false);
     * let pie: base.AccumulationChart = new base.AccumulationChart({
     * ...
     *     series: [{
     *        dataSource: dataManager,
     *        xName: 'Id',
     *        yName: 'Estimate',
     *        query: query
     *    }],
     * ...
     * });
     * pie.appendTo('#Pie');
     * ```
     * @default ''
     */
    dataSource?: Object | data.DataManager;
    /**
     * Specifies data.Query to select data from dataSource. This property is applicable only when the dataSource is `ej.data.DataManager`.
     * @default null
     */
    query?: data.Query;
    /**
     * The DataSource field which contains the x value.
     * @default ''
     */
    xName?: string;
    /**
     * Specifies the series name
     * @default ''
     */
    name?: string;
    /**
     * The DataSource field which contains the y value.
     * @default ''
     */
    yName?: string;
    /**
     * Specifies the series visibility.
     * @default true
     */
    visible?: boolean;
    /**
     * Options for customizing the border of the series.
     */
    border?: BorderModel;
    /**
     * Options for customizing the animation for series.
     */
    animation?: base.AnimationModel;
    /**
     * The shape of the legend. Each series has its own legend shape. They are
     * * Circle - Renders a circle.
     * * Rectangle - Renders a rectangle.
     * * Triangle - Renders a triangle.
     * * Diamond - Renders a diamond.
     * * Cross - Renders a cross.
     * * HorizontalLine - Renders a horizontalLine.
     * * VerticalLine - Renders a verticalLine.
     * * Pentagon - Renders a pentagon.
     * * InvertedTriangle - Renders a invertedTriangle.
     * * SeriesType -Render a legend shape based on series type. 
     * @default 'SeriesType'
     */
    legendShape?: LegendShape;
    /**
     * The DataSource field that contains the color value of point
     * It is applicable for series
     * @default ''
     */
    pointColorMapping?: string;
    /**
     * Custom style for the selected series or points.
     * @default null
     */
    selectionStyle?: string;
    /**
     * AccumulationSeries y values less than groupTo are combined into single slice named others
     * @default null
     */
    groupTo?: string;
    /**
     * The data label for the series.
     */
    dataLabel?: AccumulationDataLabelSettingsModel;
    /**
     * Palette for series points.
     * @default []
     */
    palettes?: string[];
    /**
     * Start angle for a series.
     * @default 0
     */
    startAngle?: number;
    /**
     * End angle for a series.
     * @default 360
     */
    endAngle?: number;
    /**
     * Radius of the pie series and its values in percentage.
     * @default '80%'
     */
    radius?: string;
    /**
     * When the innerRadius value is greater than 0 percentage, a donut will appear in pie series. It takes values only in percentage.
     * @default '0'
     */
    innerRadius?: string;
    /**
     * Specify the type of the series in accumulation chart. 
     * @default 'Pie'
     */
    type?: AccumulationType;
    /**
     * To enable or disable tooltip for a series.
     * @default true
     */
    enableTooltip?: boolean;
    /**
     * If set true, series points will be exploded on mouse click or touch.
     * @default false
     */
    explode?: boolean;
    /**
     * Distance of the point from the center, which takes values in both pixels and percentage. 
     * @default '30%'
     */
    explodeOffset?: string;
    /**
     * If set true, all the points in the series will get exploded on load.
     * @default false
     */
    explodeAll?: boolean;
    /**
     * base.Index of the point, to be exploded on load. 
     * @default null
     */
    explodeIndex?: number;
    /**
     * options to customize the empty points in series
     */
    emptyPointSettings?: EmptyPointSettingsModel;
    /**
     * Defines the distance between the segments of a funnel/pyramid series. The range will be from 0 to 1
     * @default 0
     */
    gapRatio?: number;
    /**
     * Defines the width of the funnel/pyramid with respect to the chart area
     * @default '80%'
     */
    width?: string;
    /**
     * Defines the height of the funnel/pyramid with respect to the chart area
     * @default '80%'
     */
    height?: string;
    /**
     * Defines the width of the funnel neck with respect to the chart area
     * @default '20%'
     */
    neckWidth?: string;
    /**
     * Defines the height of the funnel neck with respect to the chart area
     * @default '20%'
     */
    neckHeight?: string;
    /**
     * Defines how the values have to be reflected, whether through height/surface of the segments
     * @default 'Linear'
     */
    pyramidMode?: PyramidModes;
    /**
     * The opacity of the series.
     * @default 1.
     */
    opacity?: number;
}
/**
 * AccumulationChart base file
 */
/**
 * Annotation for accumulation series
 */
export  class AccumulationAnnotationSettings extends base.ChildProperty<AccumulationAnnotationSettings> {
    /**
     * Content of the annotation, which accepts the id of the custom element.
     * @default null
     */
    content: string;
    /**
     * if set coordinateUnit as `Pixel` X specifies the axis value
     * else is specifies pixel or percentage of coordinate
     * @default 0
     */
    x: string | Date | number;
    /**
     * if set coordinateUnit as `Pixel` Y specifies the axis value
     * else is specifies pixel or percentage of coordinate
     * @default 0
     */
    y: string | number;
    /**
     * Specifies the coordinate units of the annotation. They are
     * * Pixel - Annotation renders based on x and y pixel value.
     * * Point - Annotation renders based on x and y axis value.
     * @default 'Pixel'
     */
    coordinateUnits: Units;
    /**
     * Specifies the regions of the annotation. They are
     * * Chart - Annotation renders based on chart coordinates.
     * * Series - Annotation renders based on series coordinates.
     * @default 'Chart'
     */
    region: Regions;
    /**
     * Specifies the position of the annotation. They are
     * * Top - Align the annotation element as top side.
     * * Bottom - Align the annotation element as bottom side.
     * * Middle - Align the annotation element as mid point.
     * @default 'Middle'
     */
    verticalAlignment: Position;
    /**
     * Specifies the alignment of the annotation. They are
     * * Near - Align the annotation element as top side.
     * * Far - Align the annotation element as bottom side.
     * * Center - Align the annotation element as mid point.
     * @default 'Center'
     */
    horizontalAlignment: Alignment;
    /**
     * Information about annotation for assistive technology.
     * @default null
     */
    description: string;
}
/**
 * Configures the dataLabel in accumulation chart.
 */
export  class AccumulationDataLabelSettings extends base.ChildProperty<AccumulationDataLabelSettings> {
    /**
     * If set true, data label for series gets render.
     * @default false
     */
    visible: boolean;
    /**
     * The DataSource field which contains the data label value.
     * @default null
     */
    name: string;
    /**
     * The background color of the data label, which accepts value in hex, rgba as a valid CSS color string.
     * @default 'transparent'
     */
    fill: string;
    /**
     * Specifies the position of data label. They are.
     * * Outside - Places label outside the point.
     * * Inside - Places label inside the point.
     * @default 'Inside'
     */
    position: AccumulationLabelPosition;
    /**
     * The roundedCornerX for the data label. It requires `border` values not to be null.
     * @default 5
     */
    rx: number;
    /**
     * The roundedCornerY for the data label. It requires `border` values not to be null.
     * @default 5
     */
    ry: number;
    /**
     * Option for customizing the border lines.
     */
    border: BorderModel;
    /**
     * Option for customizing the data label text.
     */
    font: FontModel;
    /**
     * Options for customize the connector line in series.
     * This property is applicable for Pie, Funnel and Pyramid series.
     * The default connector length for Pie series is '4%'. For other series, it is null.
     */
    connectorStyle: ConnectorModel;
    /**
     * Custom template to format the data label content. Use ${point.x} and ${point.y} as a placeholder
     * text to display the corresponding data point.
     * @default null
     */
    template: string;
}
/**
 * Points model for the series.
 */
export  class AccPoints {
    x: Object;
    y: number;
    visible: boolean;
    text: string;
    originalText: string;
    /** @private */
    label: string;
    color: string;
    symbolLocation: ChartLocation;
    index: number;
    /** @private */
    midAngle: number;
    /** @private */
    endAngle: number;
    /** @private */
    labelAngle: number;
    /** @private */
    region: Rect;
    /** @private */
    labelRegion: Rect;
    /** @private */
    labelVisible: boolean;
    /** @private */
    labelPosition: AccumulationLabelPosition;
    /** @private */
    yRatio: number;
    /** @private */
    heightRatio: number;
    /** @private */
    labelOffset: ChartLocation;
    regions: Rect[];
}
/**
 *  Configures the series in accumulation chart.
 */
export  class AccumulationSeries extends base.ChildProperty<AccumulationSeries> {
    /**
     * Specifies the dataSource for the series. It can be an array of JSON objects or an instance of data.DataManager.
     * ```html
     * <div id='Pie'></div>
     * ```
     * ```typescript
     * let dataManager: data.DataManager = new data.DataManager({
     *         url: 'http://mvc.syncfusion.com/Services/Northwnd.svc/Tasks/'
     * });
     * let query: data.Query = new data.Query().take(50).where('Estimate', 'greaterThan', 0, false);
     * let pie: AccumulationChart = new AccumulationChart({
     * ...
     *     series: [{
     *        dataSource: dataManager,
     *        xName: 'Id',
     *        yName: 'Estimate',
     *        query: query
     *    }],
     * ...
     * });
     * pie.appendTo('#Pie');
     * ```
     * @default ''
     */
    dataSource: Object | data.DataManager;
    /**
     * Specifies data.Query to select data from dataSource. This property is applicable only when the dataSource is `ej.data.DataManager`.
     * @default null
     */
    query: data.Query;
    /**
     * The DataSource field which contains the x value.
     * @default ''
     */
    xName: string;
    /**
     * Specifies the series name
     * @default ''
     */
    name: string;
    /**
     * The DataSource field which contains the y value.
     * @default ''
     */
    yName: string;
    /**
     * Specifies the series visibility.
     * @default true
     */
    visible: boolean;
    /**
     * Options for customizing the border of the series.
     */
    border: BorderModel;
    /**
     * Options for customizing the animation for series.
     */
    animation: AnimationModel;
    /**
     * The shape of the legend. Each series has its own legend shape. They are
     * * Circle - Renders a circle.
     * * Rectangle - Renders a rectangle.
     * * Triangle - Renders a triangle.
     * * Diamond - Renders a diamond.
     * * Cross - Renders a cross.
     * * HorizontalLine - Renders a horizontalLine.
     * * VerticalLine - Renders a verticalLine.
     * * Pentagon - Renders a pentagon.
     * * InvertedTriangle - Renders a invertedTriangle.
     * * SeriesType -Render a legend shape based on series type.
     * @default 'SeriesType'
     */
    legendShape: LegendShape;
    /**
     * The DataSource field that contains the color value of point
     * It is applicable for series
     * @default ''
     */
    pointColorMapping: string;
    /**
     * Custom style for the selected series or points.
     * @default null
     */
    selectionStyle: string;
    /**
     * AccumulationSeries y values less than groupTo are combined into single slice named others
     * @default null
     */
    groupTo: string;
    /**
     * The data label for the series.
     */
    dataLabel: AccumulationDataLabelSettingsModel;
    /**
     * Palette for series points.
     * @default []
     */
    palettes: string[];
    /**
     * Start angle for a series.
     * @default 0
     */
    startAngle: number;
    /**
     * End angle for a series.
     * @default 360
     */
    endAngle: number;
    /**
     * Radius of the pie series and its values in percentage.
     * @default '80%'
     */
    radius: string;
    /**
     * When the innerRadius value is greater than 0 percentage, a donut will appear in pie series. It takes values only in percentage.
     * @default '0'
     */
    innerRadius: string;
    /**
     * Specify the type of the series in accumulation chart.
     * @default 'Pie'
     */
    type: AccumulationType;
    /**
     * To enable or disable tooltip for a series.
     * @default true
     */
    enableTooltip: boolean;
    /**
     * If set true, series points will be exploded on mouse click or touch.
     * @default false
     */
    explode: boolean;
    /**
     * Distance of the point from the center, which takes values in both pixels and percentage.
     * @default '30%'
     */
    explodeOffset: string;
    /**
     * If set true, all the points in the series will get exploded on load.
     * @default false
     */
    explodeAll: boolean;
    /**
     * Index of the point, to be exploded on load.
     * @default null
     */
    explodeIndex: number;
    /**
     * options to customize the empty points in series
     */
    emptyPointSettings: EmptyPointSettingsModel;
    /**
     * Defines the distance between the segments of a funnel/pyramid series. The range will be from 0 to 1
     * @default 0
     */
    gapRatio: number;
    /**
     * Defines the width of the funnel/pyramid with respect to the chart area
     * @default '80%'
     */
    width: string;
    /**
     * Defines the height of the funnel/pyramid with respect to the chart area
     * @default '80%'
     */
    height: string;
    /**
     * Defines the width of the funnel neck with respect to the chart area
     * @default '20%'
     */
    neckWidth: string;
    /**
     * Defines the height of the funnel neck with respect to the chart area
     * @default '20%'
     */
    neckHeight: string;
    /**
     * Defines how the values have to be reflected, whether through height/surface of the segments
     * @default 'Linear'
     */
    pyramidMode: PyramidModes;
    /**
     * The opacity of the series.
     * @default 1.
     */
    opacity: number;
    /** @private */
    points: AccPoints[];
    /** @private */
    dataModule: Data;
    /** @private */
    sumOfPoints: number;
    /** @private */
    index: number;
    private sumOfClub;
    /** @private */
    resultData: Object;
    /** @private */
    lastGroupTo: string;
    /** @private */
    isRectSeries: boolean;
    /** @private */
    clipRect: Rect;
    /**
     * To find the max bounds of the data label to place smart legend
     *  @private
     */
    labelBound: Rect;
    /**
     * To find the max bounds of the accumulation segment to place smart legend
     *  @private
     */
    accumulationBound: Rect;
    /**
     * Defines the funnel size
     * @private
     */
    triangleSize: Size;
    /**
     * Defines the size of the funnel neck
     * @private
     */
    neckSize: Size;
    /** @private To refresh the Datamanager for series */
    refreshDataManager(accumulation: AccumulationChart): void;
    /**
     * To get points on dataManager is success
     * @private
     */
    dataManagerSuccess(e: {
        result: Object;
        count: number;
    }, accumulation: AccumulationChart): void;
    /** @private To find points from result data */
    getPoints(result: Object, accumulation: AccumulationChart): void;
    /**
     * Method to set point index and color
     */
    private pushPoints(point, colors);
    /**
     * Method to find club point
     */
    private isClub(point, clubValue);
    /**
     * Method to find sum of points in the series
     */
    private findSumOfPoints(result);
    /**
     * Method to set points x, y and text from data source
     */
    private setPoints(data, i, colors);
    /**
     * Method render the series elements for accumulation chart
     * @private
     */
    renderSeries(accumulation: AccumulationChart): void;
    /**
     * Method render the points elements for accumulation chart series.
     */
    private renderPoints(accumulation, seriesGroup);
    /**
     * Method render the datalabel elements for accumulation chart.
     */
    private renderDataLabel(accumulation, datalabelGroup);
    /**
     * To find maximum bounds for smart legend placing
     * @private
     */
    findMaxBounds(totalbound: Rect, bound: Rect): void;
    /**
     * To set empty point value for null points
     * @private
     */
    setAccEmptyPoint(point: AccPoints, i: number, data: Object, colors: string[]): void;
    /**
     * To find point is empty
     */
    private isEmpty(point);
}
/**
 * method to get series from index
 * @private
 */
export  function getSeriesFromIndex(index: number, visibleSeries: AccumulationSeries[]): AccumulationSeries;
/**
 * method to get point from index
 * @private
 */
export  function pointByIndex(index: number, points: AccPoints[]): AccPoints;
/**
 * Accumulation charts Enum file
 */
/**
 * Defines the Accumulation Chart series type.
 */
export  type AccumulationType = 'Pie' | 'Funnel' | 'Pyramid';
/**
 * Defines the AccumulationLabelPosition. They are
 * * Inside - Define the data label position for the accumulation series Inside.
 * * Outside - Define the data label position for the accumulation series Outside.
 * *
 */
export  type AccumulationLabelPosition = 'Inside' | 'Outside';
/**
 * Defines the ConnectorType. They are
 * * Line - Accumulation series Connector line type as Straight line.
 * * Curve - Accumulation series Connector line type as Curved line.
 * *
 */
export  type ConnectorType = 'Line' | 'Curve';
/**
 * Defines the SelectionMode, They are.
 * * none - Disable the selection.
 * * point - To select a point.
 */
export  type AccumulationSelectionMode = 'None' | 'Point';
/**
 * Defines Theme of the accumulation chart. They are
 * * Material - Render a accumulation chart with Material theme.
 * * Fabric - Render a accumulation chart with fabric theme.
 */
export  type AccumulationTheme = 'Material' | 'Fabric' | 'Bootstrap' | 'Highcontrast';
/**
 * Defines the empty point mode of the chart.
 * * Zero - Used to display empty points as zero.
 * * Drop - Used to ignore the empty point while rendering.
 * * Average - Used to display empty points as previous and next point average.
 */
export  type AccEmptyPointMode = 'Zero' | 'Drop' | 'Average';
/**
 * Defines the mode of the pyramid
 * * Linear - Height of the pyramid segments reflects the values
 * * Surface - Surface/Area of the  pyramid segments reflects the values
 */
export  type PyramidModes = 'Linear' | 'Surface';
/**
 * Interface for Accumulation chart
 */
/**
 * Accumulation Chart SeriesRender event arguments.
 */
export interface IAccSeriesRenderEventArgs {
    /** Defines the current series */
    series: AccumulationSeries;
    /** Defines the current data object */
    data: Object;
    /** Defines the current series name */
    name: string;
}
/**
 * Accumulation Chart TextRender event arguments.
 */
export interface IAccTextRenderEventArgs extends IChartEventArgs {
    /** Defines the current series */
    series: AccumulationSeriesModel;
    /** Defines the current point */
    point: AccPoints;
    /** Defines the current text */
    text: string;
    /** Defines the current fill color */
    color: string;
    /** Defines the current label border */
    border: BorderModel;
    /** Defines the current text template */
    template: string;
}
/**
 * Accumulation Chart TooltipRender event arguments.
 */
export interface IAccTooltipRenderEventArgs extends IChartEventArgs {
    /** Defines the current tooltip content */
    content?: string | HTMLElement;
    /** Defines the current tooltip text style */
    textStyle?: FontModel;
    /** Defines the current tooltip series */
    series: AccumulationSeries;
    /** Defines the current tooltip point */
    point: AccPoints;
}
/**
 * Accumulation Chart AnimationComplete event arguments.
 */
export interface IAccAnimationCompleteEventArgs extends IChartEventArgs {
    /** Defines the current animation series */
    series: AccumulationSeries;
    /** Defines the accumulation chart instance */
    accumulation: AccumulationChart;
}
/**
 * Accumulation Chart PointRender event arguments.
 */
export interface IAccPointRenderEventArgs extends IChartEventArgs {
    /** Defines the current series of the point */
    series: AccumulationSeries;
    /** Defines the current point */
    point: AccPoints;
    /** Defines the current point fill color */
    fill: string;
    /** Defines the current point border color */
    border: BorderModel;
    /** Defines the current point height */
    height?: number;
    /** Defines the current point width */
    width?: number;
}
/**
 * Accumulation Chart Load or Loaded event arguments.
 */
export interface IAccLoadedEventArgs extends IChartEventArgs {
    /** Defines the accumulation chart instance */
    accumulation: AccumulationChart;
}
/**
 * Accumulation Base used to do some base calculation for accumulation chart.
 */
export  class AccumulationBase {
    /** @private */
    constructor(accumulation: AccumulationChart);
    private pieCenter;
    /**
     * Gets the center of the pie
     * @private
     */
    /**
     * Sets the center of the pie
     * @private
     */
    center: ChartLocation;
    private pieRadius;
    /**
     * Gets the radius of the pie
     * @private
     */
    /**
     * Sets the radius of the pie
     * @private
     */
    radius: number;
    private pieLabelRadius;
    /**
     * Gets the label radius of the pie
     * @private
     */
    /**
     * Sets the label radius of the pie
     * @private
     */
    labelRadius: number;
    /** @private */
    protected accumulation: AccumulationChart;
    /**
     * Checks whether the series is circular or not
     * @private
     */
    protected isCircular(): boolean;
    /**
     * To process the explode on accumulation chart loading
     * @private
     */
    processExplode(event: Event): void;
    /**
     * To invoke the explode on accumulation chart loading
     * @private
     */
    invokeExplode(): void;
    /**
     * To deExplode all points in the series
     */
    private deExplodeAll(index);
    /**
     * To explode point by index
     * @private
     */
    explodePoints(index: number, chart: AccumulationChart, explode?: boolean): void;
    /**
     * To check point is exploded by id
     */
    private isExplode(id);
    /**
     * To deExplode the point by index
     */
    private deExplodeSlice(index, sliceId, center);
    /**
     * To translate the point elements by index and position
     */
    private setTranslate(index, sliceId, position);
    /**
     * To translate the point element by id and position
     */
    private setElementTransform(id, position);
    /**
     * To translate the point elements by index position
     */
    private explodeSlice(index, translate, sliceId, center);
}
/**
 * AccumulationDataLabel module used to render `dataLabel`.
 */
export  class AccumulationDataLabel extends AccumulationBase {
    /** @private */
    titleRect: Rect;
    /** @private */
    areaRect: Rect;
    /** @private */
    clearTooltip: number;
    private id;
    marginValue: number;
    constructor(accumulation: AccumulationChart);
    /**
     * Method to get datalabel text location.
     * @private
     */
    getDataLabelPosition(point: AccPoints, dataLabel: AccumulationDataLabelSettingsModel, textSize: Size, points: AccPoints[], parent: Element, id: string): void;
    /**
     * Method to get datalabel bound.
     */
    private getLabelRegion(point, position, textSize, labelRadius, margin, endAngle?);
    /**
     * Method to get datalabel smart position.
     */
    private getSmartLabel(point, dataLabel, textSize, points, parent, id);
    /**
     * To find trimmed datalabel tooltip needed.
     * @return {void}
     * @private
     */
    move(e: Event, x: number, y: number, isTouch?: boolean): void;
    /**
     * To find previous valid label point
     */
    private findPreviousPoint(points, index, position);
    /**
     * To find current point datalabel is overlapping with other points
     */
    private isOverlapping(currentPoint, points);
    /**
     * To get text trimmed while exceeds the accumulation chart area.
     */
    private textTrimming(point, rect, font, position);
    /**
     * To set point label visible and region to disable.
     */
    private setPointVisibileFalse(point);
    /**
     * To set datalabel angle position for outside labels
     */
    private setOuterSmartLabel(previousPoint, point, border, labelRadius, textsize, margin);
    /**
     * Sets smart label positions for funnel and pyramid series
     */
    private setSmartLabelForSegments(point, prevPoint, distance, textSize, margin);
    /**
     * To find connector line overlapping.
     */
    private isConnectorLineOverlapping(point, previous);
    /**
     * To find two rectangle intersect
     */
    private isLineRectangleIntersect(line1, line2, rect);
    /**
     * To find two line intersect
     */
    private isLinesIntersect(point1, point2, point11, point12);
    /**
     * To get two rectangle overlapping angles.
     */
    private getOverlappedAngle(first, second, angle, padding);
    /**
     * To get connector line path
     */
    private getConnectorPath(label, point, dataLabel, end?);
    /**
     * Finds the curved path for funnel/pyramid data label connectors
     */
    private getPolyLinePath(start, end);
    /**
     * Finds the bezier point for funnel/pyramid data label connectors
     */
    private getBezierPoint(t, controlPoints, index, count);
    /**
     * To get label edges based on the center and label rect position.
     */
    private getEdgeOfLabel(labelshape, angle, middle, border?);
    /**
     * Finds the distance between the label position and the edge/center of the funnel/pyramid
     */
    private getLabelDistance(point, dataLabel);
    /**
     * Finds the label position / beginning of the connector(ouside funnel labels)
     */
    private getLabelLocation(point, position?);
    /**
     * Finds the beginning of connector line
     */
    private getConnectorStartPoint(point, connector);
    /**
     * To find area rect based on margin, available size.
     * @private
     */
    findAreaRect(): void;
    /**
     * To render the data labels from series points.
     */
    renderDataLabel(point: AccPoints, dataLabel: AccumulationDataLabelSettingsModel, parent: Element, points: AccPoints[], series: number, templateElement?: HTMLElement): void;
    /**
     * To find the template element size
     * @param element
     * @param point
     * @param argsData
     */
    private getTemplateSize(element, point, argsData);
    /**
     * To set the template element style
     * @param childElement
     * @param point
     * @param parent
     * @param labelColor
     * @param fill
     */
    private setTemplateStyle(childElement, point, parent, labelColor, fill);
    /**
     * To find saturated color for datalabel
     */
    private getSaturatedColor(point, color);
    /**
     * Animates the data label template.
     * @return {void}.
     * @private
     */
    doTemplateAnimation(accumulation: AccumulationChart, element: Element): void;
    /**
     * To find background color for the datalabel
     */
    private getLabelBackground(point);
    /**
     * To correct the padding between datalabel regions.
     */
    private correctLabelRegion(labelRegion, textSize, padding?);
    /**
     * To get the dataLabel module name
     */
    protected getModuleName(): string;
    /**
     * To destroy the data label.
     * @return {void}
     * @private
     */
    destroy(accumulation: AccumulationChart): void;
}
/**
 * Defines the behavior of a funnel series
 */
/**
 * FunnelSeries module used to render `Funnel` Series.
 */
export  class FunnelSeries extends TriangularBase {
    /**
     * Defines the path of a funnel segment
     */
    private getSegmentData(point, series, chart);
    /**
     * Renders a funnel segment
     * @private
     */
    renderPoint(point: AccPoints, series: AccumulationSeries, chart: AccumulationChart, options: PathOption): void;
    /**
     * To get the module name of the funnel series.
     */
    protected getModuleName(): string;
    /**
     * To destroy the funnel series.
     * @return {void}
     * @private
     */
    destroy(accumulation: AccumulationChart): void;
}
/**
 * AccumulationLegend module used to render `Legend` for Accumulation chart.
 */
export  class AccumulationLegend extends BaseLegend {
    titleRect: Rect;
    private totalRowCount;
    private maxColumnWidth;
    /**
     * Constructor for Accumulation Legend.
     * @param chart
     */
    constructor(chart: AccumulationChart);
    /**
     * Get the legend options.
     * @return {void}
     * @private
     */
    getLegendOptions(chart: AccumulationChart, series: AccumulationSeries[]): void;
    /**
     * To find legend bounds for accumulation chart.
     * @private
     */
    getLegendBounds(availableSize: Size, legendBounds: Rect, legend: LegendSettingsModel): void;
    /**
     * To find maximum column size for legend
     */
    private getMaxColumn(columns, width, padding, rowWidth);
    /**
     * To find available width from legend x position.
     */
    private getAvailWidth(tx, width, legendX);
    /**
     * To find legend rendering locations from legend options.
     * @private
     */
    getRenderPoint(legendOption: LegendOptions, start: ChartLocation, textPadding: number, prevLegend: LegendOptions, rect: Rect, count: number, firstLegend: number): void;
    /**
     * finding the smart legend place according to positions.
     * @return {void}
     * @private
     */
    getSmartLegendLocation(labelBound: Rect, legendBound: Rect, margin: MarginModel): void;
    /**
     * To get title rect.
     */
    private getTitleRect(accumulation);
    /**
     * To get legend by index
     */
    private legendByIndex(index, legendCollections);
    /**
     * To show or hide the legend on clicking the legend.
     * @return {void}
     */
    click(event: Event): void;
    /**
     * Get module name
     */
    protected getModuleName(): string;
    /**
     * To destroy the Legend.
     * @return {void}
     * @private
     */
    destroy(chart: AccumulationChart): void;
}
/**
 * PieBase class used to do pie base calculations.
 */
export  class PieBase extends AccumulationBase {
    protected startAngle: number;
    protected totalAngle: number;
    protected innerRadius: number;
    center: ChartLocation;
    radius: number;
    labelRadius: number;
    /**
     * To initialize the property values.
     * @private
     */
    initProperties(chart: AccumulationChart, series: AccumulationSeries): void;
    /**
     * To find the center of the accumulation.
     * @private
     */
    findCenter(accumulation: AccumulationChart, series: AccumulationSeries): void;
    /**
     * To find angles from series.
     */
    private initAngles(series);
    /**
     * To calculate data-label bound
     * @private
     */
    defaultLabelBound(series: AccumulationSeries, visible: boolean, position: AccumulationLabelPosition): void;
    /**
     * To calculate series bound
     * @private
     */
    getSeriesBound(series: AccumulationSeries): Rect;
    /**
     * To get rect location size from angle
     */
    private getRectFromAngle(angle);
    /**
     * To get path arc direction
     */
    protected getPathArc(center: ChartLocation, start: number, end: number, radius: number, innerRadius: number): string;
    /**
     * To get pie direction
     */
    protected getPiePath(center: ChartLocation, start: ChartLocation, end: ChartLocation, radius: number, clockWise: number): string;
    /**
     * To get doughnut direction
     */
    protected getDoughnutPath(center: ChartLocation, start: ChartLocation, end: ChartLocation, radius: number, innerStart: ChartLocation, innerEnd: ChartLocation, innerRadius: number, clockWise: number): string;
    /**
     * Method to start animation for pie series.
     */
    protected doAnimation(slice: Element, series: AccumulationSeries): void;
}
/**
 * AccumulationChart series file
 */
/**
 * PieSeries module used to render `Pie` Series.
 */
export  class PieSeries extends PieBase {
    /**
     * To get path option, degree, symbolLocation from the point.
     * @private
     */
    renderPoint(point: AccPoints, series: AccumulationSeries, chart: AccumulationChart, option: PathOption): PathOption;
    /**
     * To get path option from the point.
     */
    private getPathOption(point, degree);
    /**
     * To animate the pie series.
     * @private
     */
    animateSeries(accumulation: AccumulationChart, option: AnimationModel, series: AccumulationSeries, slice: Element): void;
    /**
     * To get the module name of the Pie series.
     */
    protected getModuleName(): string;
    /**
     * To destroy the pie series.
     * @return {void}
     * @private
     */
    destroy(accumulation: AccumulationChart): void;
}
/**
 * Defines the behavior of a pyramid series
 */
/**
 * PyramidSeries module used to render `Pyramid` Series.
 */
export  class PyramidSeries extends TriangularBase {
    /**
     * Defines the path of a pyramid segment
     */
    private getSegmentData(point, series, chart);
    /**
     * Initializes the size of the pyramid segments
     * @private
     */
    protected initializeSizeRatio(points: AccPoints[], series: AccumulationSeries): void;
    /**
     * Defines the size of the pyramid segments, the surface of that will reflect the values
     */
    private calculateSurfaceSegments(series);
    /**
     * Finds the height of pyramid segment
     */
    private getSurfaceHeight(y, surface);
    /**
     * Solves quadratic equation
     */
    private solveQuadraticEquation(a, b, c);
    /**
     * Renders a pyramid segment
     */
    private renderPoint(point, series, chart, options);
    /**
     * To get the module name of the Pyramid series.
     */
    protected getModuleName(): string;
    /**
     * To destroy the pyramid series
     * @return {void}
     * @private
     */
    destroy(accumulation: AccumulationChart): void;
}
/**
 * Defines the common behavior of funnel and pyramid series
 */
/**
 * TriangularBase is used to calculate base functions for funnel/pyramid series.
 */
export  class TriangularBase extends AccumulationBase {
    /**
     * Initializes the properties of funnel/pyramid series
     * @private
     */
    initProperties(chart: AccumulationChart, series: AccumulationSeries): void;
    /**
     * Initializes the size of the pyramid/funnel segments
     * @private
     */
    protected initializeSizeRatio(points: AccPoints[], series: AccumulationSeries, reverse?: boolean): void;
    /**
     * Marks the label location from the set of points that forms a pyramid/funnel segment
     * @private
     */
    protected setLabelLocation(series: AccumulationSeries, point: AccPoints, points: ChartLocation[]): void;
    /**
     * Finds the path to connect the list of points
     * @private
     */
    protected findPath(locations: ChartLocation[]): string;
    /**
     * To calculate data-label bounds
     * @private
     */
    defaultLabelBound(series: AccumulationSeries, visible: boolean, position: AccumulationLabelPosition, chart: AccumulationChart): void;
}
/**
 * `AccumulationSelection` module handles the selection for accumulation chart.
 * @private
 */
export  class AccumulationSelection extends BaseSelection {
    private renderer;
    /** @private */
    rectPoints: Rect;
    selectedDataIndexes: Indexes[];
    private series;
    constructor(accumulation: AccumulationChart);
    /**
     * To initialize the private variables
     */
    private initPrivateVariables(accumulation);
    /**
     * Invoke selection for rendered chart.
     * @param  {AccumulationChart} chart - Define the chart to invoke the selection.
     * @return {void}
     */
    invokeSelection(accumulation: AccumulationChart): void;
    /**
     * To get series selection style by series.
     */
    private generateStyle(series);
    /**
     * To get elements by index, series
     */
    private findElements(accumulation, series, index);
    /**
     * To get series point element by index
     */
    private getElementByIndex(index);
    /**
     * To calculate selected elements on mouse click or touch
     * @private
     */
    calculateSelectedElements(accumulation: AccumulationChart, event: Event): void;
    /**
     * To perform the selection process based on index and element.
     */
    private performSelection(index, accumulation, element?);
    /**
     * To select the element by index. Adding or removing selection style class name.
     */
    private selection(accumulation, index, selectedElements);
    /**
     * To redraw the selection process on accumulation chart refresh.
     * @private
     */
    redrawSelection(accumulation: AccumulationChart, oldMode: AccumulationSelectionMode): void;
    /**
     * To remove the selected elements style classes by indexes.
     */
    private removeSelectedElements(accumulation, indexes);
    /**
     * To perform the selection for legend elements.
     * @private
     */
    legendSelection(accumulation: AccumulationChart, series: number, pointIndex: number): void;
    /**
     * To select the element by selected data indexes.
     */
    private selectDataIndex(indexes, accumulation);
    /**
     * To remove the selection styles for multi selection process.
     */
    private removeMultiSelectEelments(accumulation, index, currentIndex, seriesCollection);
    /**
     * To apply the opacity effect for accumulation chart series elements.
     */
    private blurEffect(pieId, visibleSeries);
    /**
     * To check selection elements by style class name.
     */
    private checkSelectionElements(element, className, visibility);
    /**
     * To apply selection style for elements.
     */
    private applyStyles(elements, index);
    /**
     * To get selection style class name by id
     */
    private getSelectionClass(id);
    /**
     * To remove selection style for elements.
     */
    private removeStyles(elements, index);
    /**
     * To apply or remove selected elements index.
     */
    private addOrRemoveIndex(indexes, index, add?);
    /**
     * To check two index, point and series are equal
     */
    private checkEquals(first, second);
    /**
     * To check selected points are visibility
     */
    private checkPointVisibility(selectedDataIndexes);
    /**
     * Get module name.
     */
    getModuleName(): string;
    /**
     * To destroy the selection.
     * @return {void}
     * @private
     */
    destroy(accumulation: AccumulationChart): void;
}
/**
 * `AccumulationTooltip` module is used to render tooltip for accumulation chart.
 */
export  class AccumulationTooltip extends BaseTooltip {
    accumulation: AccumulationChart;
    constructor(accumulation: AccumulationChart);
    /**
     * @hidden
     */
    private addEventListener();
    private mouseLeaveHandler(e);
    private mouseUpHandler(e);
    private mouseMoveHandler(e);
    /**
     * Renders the tooltip.
     * @param  {PointerEvent} event - Mouse move event.
     * @return {void}
     */
    tooltip(event: PointerEvent | TouchEvent): void;
    private renderSeriesTooltip(e, chart, isFirst, tooltipDiv);
    private drawMarker(isBottom, size);
    private getPieData(e, chart, x, y);
    /**
     * To get series from index
     */
    private getSeriesFromIndex(index, visibleSeries);
    private getTemplateText(data);
    private getTooltipText(data, tooltip);
    private findHeader(data);
    private parseTemplate(point, series, format);
    /**
     * Removes the tooltip on mouse leave.
     * @return {void}
     * @private
     */
    removeTooltip(duration: number): void;
    /**
     * Get module name
     */
    protected getModuleName(): string;
    /**
     * To destroy the Tooltip.
     * @return {void}
     * @private
     */
    destroy(chart: AccumulationChart): void;
}
/**
 * `ChartAnnotation` module handles the annotation for chart.
 */
export  class ChartAnnotation extends AnnotationBase {
    private chart;
    private annotations;
    private parentElement;
    /**
     * Constructor for chart annotation.
     * @private.
     */
    constructor(control: Chart, annotations: ChartAnnotationSettings[]);
    /**
     * Method to render the annotation for chart
     * @param element
     * @private
     */
    renderAnnotations(element: Element): void;
    /**
     * To destroy the annotation.
     * @return {void}
     * @private
     */
    destroy(control: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * Common axis classes
 * @private
 */
export  class NiceInterval extends Double {
    /**
     * Method to calculate numeric datetime interval
     */
    calculateDateTimeNiceInterval(axis: Axis, size: Size, start: number, end: number): number;
    /**
     * To get the skeleton for the DateTime axis.
     * @return {string}
     *  @private
     */
    getSkeleton(axis: Axis): string;
}
/**
 * Interface for a class Row
 */
export interface RowModel {
    /**
     * The height of the row as a string accept input both as '100px' and '100%'.
     * If specified as '100%, row renders to the full height of its chart.
     * @default '100%'
     */
    height?: string;
    /**
     * Options to customize the border of the rows.
     */
    border?: BorderModel;
}
/**
 * Interface for a class Column
 */
export interface ColumnModel {
    /**
     * The width of the column as a string accepts input both as like '100px' or '100%'.
     * If specified as '100%, column renders to the full width of its chart.
     * @default '100%'
     */
    width?: string;
    /**
     * Options to customize the border of the columns.
     */
    border?: BorderModel;
}
/**
 * Interface for a class MajorGridLines
 */
export interface MajorGridLinesModel {
    /**
     * The width of the line in pixels.
     * @default 1
     */
    width?: number;
    /**
     * The dash array of the grid lines.
     * @default ''
     */
    dashArray?: string;
    /**
     * The color of the major grid line that accepts value in hex and rgba as a valid CSS color string.
     * @default null
     */
    color?: string;
}
/**
 * Interface for a class MinorGridLines
 */
export interface MinorGridLinesModel {
    /**
     * The width of the line in pixels.
     * @default 0.7
     */
    width?: number;
    /**
     * The dash array of grid lines.
     * @default ''
     */
    dashArray?: string;
    /**
     * The color of the minor grid line that accepts value in hex and rgba as a valid CSS color string.
     * @default null
     */
    color?: string;
}
/**
 * Interface for a class AxisLine
 */
export interface AxisLineModel {
    /**
     * The width of the line in pixels.
     * @default 1
     */
    width?: number;
    /**
     * The dash array of the axis line.
     * @default ''
     */
    dashArray?: string;
    /**
     * The color of the axis line that accepts value in hex and rgba as a valid CSS color string.
     * @default null
     */
    color?: string;
}
/**
 * Interface for a class MajorTickLines
 */
export interface MajorTickLinesModel {
    /**
     * The width of the tick lines in pixels.
     * @default 1
     */
    width?: number;
    /**
     * The height of the ticks in pixels.
     * @default 5
     */
    height?: number;
    /**
     * The color of the major tick line that accepts value in hex and rgba as a valid CSS color string.
     * @default null
     */
    color?: string;
}
/**
 * Interface for a class MinorTickLines
 */
export interface MinorTickLinesModel {
    /**
     * The width of the tick line in pixels.
     * @default 0.7
     */
    width?: number;
    /**
     * The height of the ticks in pixels.
     * @default 5
     */
    height?: number;
    /**
     * The color of the minor tick line that accepts value in hex and rgba as a valid CSS color string.
     * @default null
     */
    color?: string;
}
/**
 * Interface for a class CrosshairTooltip
 */
export interface CrosshairTooltipModel {
    /**
     * If set to true, crosshair ToolTip will be visible.
     *  @default false
     */
    enable?: Boolean;
    /**
     * The fill color of the ToolTip accepts value in hex and rgba as a valid CSS color string.
     * @default null
     */
    fill?: string;
    /**
     * Options to customize the crosshair ToolTip text.
     */
    textStyle?: FontModel;
}
/**
 * Interface for a class Axis
 */
export interface AxisModel {
    /**
     * Options to customize the axis label.
     */
    labelStyle?: FontModel;
    /**
     * Options to customize the crosshair ToolTip.
     */
    crosshairTooltip?: CrosshairTooltipModel;
    /**
     * Specifies the title of an axis.
     * @default ''
     */
    title?: string;
    /**
     * Options for customizing the axis title.
     */
    titleStyle?: FontModel;
    /**
     * Used to format the axis label that accepts any global string format like 'C', 'n1', 'P' etc.
     * It also accepts placeholder like '{value}°C' in which value represent the axis label, e.g, 20°C.
     * @default ''
     */
    labelFormat?: string;
    /**
     * Specifies the skeleton format in which the dateTime format will process.
     * @default ''
     */
    skeleton?: string;
    /**
     * It specifies the type of format to be used in dateTime format process.
     * @default 'DateTime'
     */
    skeletonType?: SkeletonType;
    /**
     * Left and right padding for the plot area in pixels.
     * @default 0
     */
    plotOffset?: number;
    /**
     * Specifies indexed category  axis.
     * @default false
     */
    isIndexed?: boolean;
    /**
     * The base value for logarithmic axis. It requires `valueType` to be `Logarithmic`.
     * @default 10
     */
    logBase?: number;
    /**
     * Specifies the index of the column where the axis is associated,
     * when the chart area is divided into multiple plot areas by using `columns`.
     * ```html 
     * <div id='Chart'></div>
     * ```
     * ```typescript
     * let chart: Chart = new Chart({
     * ...
     *     columns: [{ width: '50%' },
     *               { width: '50%' }],
     *     axes: [{
     *                name: 'xAxis 1',
     *                columnIndex: 1,
     *     }],
     * ... 
     * });
     * chart.appendTo('#Chart');
     * ```
     * @default 0
     */
    columnIndex?: number;
    /**
     * Specifies the index of the row where the axis is associated, when the chart area is divided into multiple plot areas by using `rows`.
     * ```html 
     * <div id='Chart'></div>
     * ```
     * ```typescript
     * let chart: Chart = new Chart({
     * ...
     *     rows: [{ height: '50%' },
     *            { height: '50%' }],
     *     axes: [{
     *                name: 'yAxis 1',
     *                rowIndex: 1,
     *      }],
     * ...
     * });
     * chart.appendTo('#Chart');
     * ```
     * @default 0
     */
    rowIndex?: number;
    /**
     * Specifies the number of `columns` or `rows` an axis has to span horizontally or vertically.
     * @default 1
     */
    span?: number;
    /**
     * With this property, you can request axis to calculate intervals approximately equal to your specified interval.
     * @default null
     */
    desiredIntervals?: number;
    /**
     * The maximum number of label count per 100 pixels with respect to the axis length.
     * @default 3
     */
    maximumLabels?: number;
    /**
     * The axis is scaled by this factor. When zoomFactor is 0.5, the chart is scaled by 200% along this axis. Value ranges from 0 to 1.
     * @default 1
     */
    zoomFactor?: number;
    /**
     * Position of the zoomed axis. Value ranges from 0 to 1.
     * @default 0
     */
    zoomPosition?: number;
    /**
     * If set to true, the axis will render at the opposite side of its default position.
     * @default false
     */
    opposedPosition?: boolean;
    /**
     * If set to true, axis interval will be calculated automatically with respect to the zoomed range.
     * @default true
     */
    enableAutoIntervalOnZooming?: boolean;
    /**
     * Specifies the padding for the axis range in terms of interval.They are,
     * * none: Padding cannot be applied to the axis.
     * * normal: Padding is applied to the axis based on the range calculation.
     * * additional: Interval of the axis is added as padding to the minimum and maximum values of the range.
     * * round: Axis range is rounded to the nearest possible value divided by the interval.
     * @default 'Auto'
     */
    rangePadding?: ChartRangePadding;
    /**
     * Specifies the type of data the axis is handling.
     * * Double:  Renders a numeric axis.
     * * DateTime: Renders a dateTime axis.
     * * Category: Renders a category axis.
     * * Logarithmic: Renders a log axis.
     * @default 'Double'
     */
    valueType?: ValueType;
    /**
     * Specifies the position of labels at the edge of the axis.They are,
     * * None: No action will be performed.
     * * Hide: Edge label will be hidden.
     * * Shift: Shifts the edge labels.
     * @default 'None'
     */
    edgeLabelPlacement?: EdgeLabelPlacement;
    /**
     * Specifies the types like `Years`, `Months`, `Days`, `Hours`, `Minutes`, `Seconds` in date time axis.They are,
     * * Auto: Defines the interval of the axis based on data.
     * * Years: Defines the interval of the axis in years.
     * * Months: Defines the interval of the axis in months.
     * * Days: Defines the interval of the axis in days.
     * * Hours: Defines the interval of the axis in hours.
     * * Minutes: Defines the interval of the axis in minutes.
     * @default 'Auto'
     */
    intervalType?: IntervalType;
    /**
     * Specifies the placement of a label for category axis. They are,
     * * betweenTicks: Renders the label between the ticks.
     * * onTicks: Renders the label on the ticks.
     * @default 'BetweenTicks'
     */
    labelPlacement?: LabelPlacement;
    /**
     * Specifies the placement of a ticks to the axis line. They are,
     * * inside: Renders the ticks inside to the axis line.
     * * outside: Renders the ticks outside to the axis line.
     * @default 'Outside'
     */
    tickPosition?: AxisPosition;
    /**
     * Specifies the placement of a labels to the axis line. They are,
     * * inside: Renders the labels inside to the axis line.
     * * outside: Renders the labels outside to the axis line.
     * @default 'Outside'
     */
    labelPosition?: AxisPosition;
    /**
     * Unique identifier of an axis.
     * To associate an axis with the series, set this name to the xAxisName/yAxisName properties of the series.
     * @default ''
     */
    name?: string;
    /**
     * If set to true, axis label will be visible.
     * @default true
     */
    visible?: boolean;
    /**
     * Specifies the number of minor ticks per interval.
     * @default 0
     */
    minorTicksPerInterval?: number;
    /**
     * The angle to which the axis label gets rotated.
     * @default 0
     */
    labelRotation?: number;
    /**
     * Specifies the value at which the axis line has to be intersect with the vertical axis or vice versa.
     * @default null
     */
    crossesAt?: Object;
    /**
     * Specifies whether axis elements like axis labels, axis title, etc has to be crossed with axis line
     * @default true
     */
    placeNextToAxisLine?: boolean;
    /**
     * Specifies axis name with which the axis line has to be crossed
     * @default null
     */
    crossesInAxis?: string;
    /**
     * Specifies the minimum range of an axis.
     * @default null
     */
    minimum?: Object;
    /**
     * Specifies the maximum range of an axis.
     * @default null
     */
    maximum?: Object;
    /**
     * Specifies the interval for an axis.
     * @default null
     */
    interval?: number;
    /**
     * Options for customizing major tick lines.
     */
    majorTickLines?: MajorTickLinesModel;
    /**
     * Options for customizing minor tick lines.
     */
    minorTickLines?: MinorTickLinesModel;
    /**
     * Options for customizing major grid lines.
     */
    majorGridLines?: MajorGridLinesModel;
    /**
     * Options for customizing minor grid lines.
     */
    minorGridLines?: MinorGridLinesModel;
    /**
     * Options for customizing axis lines.
     */
    lineStyle?: AxisLineModel;
    /**
     * Specifies the actions like `Hide`, `Rotate45`, and `Rotate90` when the axis labels intersect with each other.They are,
     * * None: Shows all the labels.
     * * Hide: Hides the label when it intersects.
     * * Rotate45: Rotates the label to 45 degree when it intersects.
     * * Rotate90: Rotates the label to 90 degree when it intersects.
     * @default Hide
     */
    labelIntersectAction?: LabelIntersectAction;
    /**
     * It specifies whether the axis to be rendered in inversed manner or not.
     * @default false
     */
    isInversed?: boolean;
    /**
     * The polar radar radius position.
     * @default 100
     */
    coefficient?: number;
    /**
     * The start angle for the series.
     * @default 0
     */
    startAngle?: number;
    /**
     * Description for axis and its element.
     * @default null
     */
    description?: string;
    /**
     * TabIndex value for the axis.
     * @default 2
     */
    tabIndex?: number;
    /**
     * Specifies the stripLine collection for the axis
     */
    stripLines?: StripLineSettingsModel[];
    /**
     * Specifies the multi level labels collection for the axis
     */
    multiLevelLabels?: MultiLevelLabelsModel[];
    /**
     * Border of the multi level labels.
     */
    border?: LabelBorderModel;
}
/**
 * Interface for a class VisibleLabels
 * @private
 */
export interface VisibleLabelsModel {
}
/**
 * Configures the `rows` of the chart.
 */
export  class Row extends base.ChildProperty<Row> {
    /**
     * The height of the row as a string accept input both as '100px' and '100%'.
     * If specified as '100%, row renders to the full height of its chart.
     * @default '100%'
     */
    height: string;
    /**
     * Options to customize the border of the rows.
     */
    border: BorderModel;
    /** @private */
    axes: Axis[];
    /** @private */
    computedHeight: number;
    /** @private */
    computedTop: number;
    /** @private */
    nearSizes: number[];
    /** @private */
    farSizes: number[];
    /**
     * Measure the row size
     * @return {void}
     * @private
     */
    computeSize(axis: Axis, clipRect: Rect): void;
}
/**
 * Configures the `columns` of the chart.
 */
export  class Column extends base.ChildProperty<Column> {
    /**
     * The width of the column as a string accepts input both as like '100px' or '100%'.
     * If specified as '100%, column renders to the full width of its chart.
     * @default '100%'
     */
    width: string;
    /**
     * Options to customize the border of the columns.
     */
    border: BorderModel;
    /** @private */
    axes: Axis[];
    /** @private */
    computedWidth: number;
    /** @private */
    computedLeft: number;
    /** @private */
    nearSizes: number[];
    /** @private */
    farSizes: number[];
    /** @private */
    private padding;
    /**
     * Measure the column size
     * @return {void}
     * @private
     */
    computeSize(axis: Axis, clipRect: Rect): void;
}
/**
 * Configures the major grid lines in the `axis`.
 */
export  class MajorGridLines extends base.ChildProperty<MajorGridLines> {
    /**
     * The width of the line in pixels.
     * @default 1
     */
    width: number;
    /**
     * The dash array of the grid lines.
     * @default ''
     */
    dashArray: string;
    /**
     * The color of the major grid line that accepts value in hex and rgba as a valid CSS color string.
     * @default null
     */
    color: string;
}
/**
 * Configures the minor grid lines in the `axis`.
 */
export  class MinorGridLines extends base.ChildProperty<MinorGridLines> {
    /**
     * The width of the line in pixels.
     * @default 0.7
     */
    width: number;
    /**
     * The dash array of grid lines.
     * @default ''
     */
    dashArray: string;
    /**
     * The color of the minor grid line that accepts value in hex and rgba as a valid CSS color string.
     * @default null
     */
    color: string;
}
/**
 * Configures the axis line of a chart.
 */
export  class AxisLine extends base.ChildProperty<AxisLine> {
    /**
     * The width of the line in pixels.
     * @default 1
     */
    width: number;
    /**
     * The dash array of the axis line.
     * @default ''
     */
    dashArray: string;
    /**
     * The color of the axis line that accepts value in hex and rgba as a valid CSS color string.
     * @default null
     */
    color: string;
}
/**
 * Configures the major tick lines.
 */
export  class MajorTickLines extends base.ChildProperty<MajorTickLines> {
    /**
     * The width of the tick lines in pixels.
     * @default 1
     */
    width: number;
    /**
     * The height of the ticks in pixels.
     * @default 5
     */
    height: number;
    /**
     * The color of the major tick line that accepts value in hex and rgba as a valid CSS color string.
     * @default null
     */
    color: string;
}
/**
 * Configures the minor tick lines.
 */
export  class MinorTickLines extends base.ChildProperty<MinorTickLines> {
    /**
     * The width of the tick line in pixels.
     * @default 0.7
     */
    width: number;
    /**
     * The height of the ticks in pixels.
     * @default 5
     */
    height: number;
    /**
     * The color of the minor tick line that accepts value in hex and rgba as a valid CSS color string.
     * @default null
     */
    color: string;
}
/**
 * Configures the crosshair ToolTip.
 */
export  class CrosshairTooltip extends base.ChildProperty<CrosshairTooltip> {
    /**
     * If set to true, crosshair ToolTip will be visible.
     *  @default false
     */
    enable: Boolean;
    /**
     * The fill color of the ToolTip accepts value in hex and rgba as a valid CSS color string.
     * @default null
     */
    fill: string;
    /**
     * Options to customize the crosshair ToolTip text.
     */
    textStyle: FontModel;
}
/**
 * Configures the axes in the chart.
 */
export  class Axis extends base.ChildProperty<Axis> {
    /**
     * Options to customize the axis label.
     */
    labelStyle: FontModel;
    /**
     * Options to customize the crosshair ToolTip.
     */
    crosshairTooltip: CrosshairTooltipModel;
    /**
     * Specifies the title of an axis.
     * @default ''
     */
    title: string;
    /**
     * Options for customizing the axis title.
     */
    titleStyle: FontModel;
    /**
     * Used to format the axis label that accepts any global string format like 'C', 'n1', 'P' etc.
     * It also accepts placeholder like '{value}°C' in which value represent the axis label, e.g, 20°C.
     * @default ''
     */
    labelFormat: string;
    /**
     * Specifies the skeleton format in which the dateTime format will process.
     * @default ''
     */
    skeleton: string;
    /**
     * It specifies the type of format to be used in dateTime format process.
     * @default 'DateTime'
     */
    skeletonType: SkeletonType;
    /**
     * Left and right padding for the plot area in pixels.
     * @default 0
     */
    plotOffset: number;
    /**
     * Specifies indexed category  axis.
     * @default false
     */
    isIndexed: boolean;
    /**
     * The base value for logarithmic axis. It requires `valueType` to be `Logarithmic`.
     * @default 10
     */
    logBase: number;
    /**
     * Specifies the index of the column where the axis is associated,
     * when the chart area is divided into multiple plot areas by using `columns`.
     * ```html
     * <div id='Chart'></div>
     * ```
     * ```typescript
     * let chart: Chart = new Chart({
     * ...
     *     columns: [{ width: '50%' },
     *               { width: '50%' }],
     *     axes: [{
     *                name: 'xAxis 1',
     *                columnIndex: 1,
     *     }],
     * ...
     * });
     * chart.appendTo('#Chart');
     * ```
     * @default 0
     */
    columnIndex: number;
    /**
     * Specifies the index of the row where the axis is associated, when the chart area is divided into multiple plot areas by using `rows`.
     * ```html
     * <div id='Chart'></div>
     * ```
     * ```typescript
     * let chart: Chart = new Chart({
     * ...
     *     rows: [{ height: '50%' },
     *            { height: '50%' }],
     *     axes: [{
     *                name: 'yAxis 1',
     *                rowIndex: 1,
     *      }],
     * ...
     * });
     * chart.appendTo('#Chart');
     * ```
     * @default 0
     */
    rowIndex: number;
    /**
     * Specifies the number of `columns` or `rows` an axis has to span horizontally or vertically.
     * @default 1
     */
    span: number;
    /**
     * With this property, you can request axis to calculate intervals approximately equal to your specified interval.
     * @default null
     */
    desiredIntervals: number;
    /**
     * The maximum number of label count per 100 pixels with respect to the axis length.
     * @default 3
     */
    maximumLabels: number;
    /**
     * The axis is scaled by this factor. When zoomFactor is 0.5, the chart is scaled by 200% along this axis. Value ranges from 0 to 1.
     * @default 1
     */
    zoomFactor: number;
    /**
     * Position of the zoomed axis. Value ranges from 0 to 1.
     * @default 0
     */
    zoomPosition: number;
    /**
     * If set to true, the axis will render at the opposite side of its default position.
     * @default false
     */
    opposedPosition: boolean;
    /**
     * If set to true, axis interval will be calculated automatically with respect to the zoomed range.
     * @default true
     */
    enableAutoIntervalOnZooming: boolean;
    /**
     * Specifies the padding for the axis range in terms of interval.They are,
     * * none: Padding cannot be applied to the axis.
     * * normal: Padding is applied to the axis based on the range calculation.
     * * additional: Interval of the axis is added as padding to the minimum and maximum values of the range.
     * * round: Axis range is rounded to the nearest possible value divided by the interval.
     * @default 'Auto'
     */
    rangePadding: ChartRangePadding;
    /**
     * Specifies the type of data the axis is handling.
     * * Double:  Renders a numeric axis.
     * * DateTime: Renders a dateTime axis.
     * * Category: Renders a category axis.
     * * Logarithmic: Renders a log axis.
     * @default 'Double'
     */
    valueType: ValueType;
    /**
     * Specifies the position of labels at the edge of the axis.They are,
     * * None: No action will be performed.
     * * Hide: Edge label will be hidden.
     * * Shift: Shifts the edge labels.
     * @default 'None'
     */
    edgeLabelPlacement: EdgeLabelPlacement;
    /**
     * Specifies the types like `Years`, `Months`, `Days`, `Hours`, `Minutes`, `Seconds` in date time axis.They are,
     * * Auto: Defines the interval of the axis based on data.
     * * Years: Defines the interval of the axis in years.
     * * Months: Defines the interval of the axis in months.
     * * Days: Defines the interval of the axis in days.
     * * Hours: Defines the interval of the axis in hours.
     * * Minutes: Defines the interval of the axis in minutes.
     * @default 'Auto'
     */
    intervalType: IntervalType;
    /**
     * Specifies the placement of a label for category axis. They are,
     * * betweenTicks: Renders the label between the ticks.
     * * onTicks: Renders the label on the ticks.
     * @default 'BetweenTicks'
     */
    labelPlacement: LabelPlacement;
    /**
     * Specifies the placement of a ticks to the axis line. They are,
     * * inside: Renders the ticks inside to the axis line.
     * * outside: Renders the ticks outside to the axis line.
     * @default 'Outside'
     */
    tickPosition: AxisPosition;
    /**
     * Specifies the placement of a labels to the axis line. They are,
     * * inside: Renders the labels inside to the axis line.
     * * outside: Renders the labels outside to the axis line.
     * @default 'Outside'
     */
    labelPosition: AxisPosition;
    /**
     * Unique identifier of an axis.
     * To associate an axis with the series, set this name to the xAxisName/yAxisName properties of the series.
     * @default ''
     */
    name: string;
    /**
     * If set to true, axis label will be visible.
     * @default true
     */
    visible: boolean;
    /**
     * Specifies the number of minor ticks per interval.
     * @default 0
     */
    minorTicksPerInterval: number;
    /**
     * The angle to which the axis label gets rotated.
     * @default 0
     */
    labelRotation: number;
    /**
     * Specifies the value at which the axis line has to be intersect with the vertical axis or vice versa.
     * @default null
     */
    crossesAt: Object;
    /**
     * Specifies whether axis elements like axis labels, axis title, etc has to be crossed with axis line
     * @default true
     */
    placeNextToAxisLine: boolean;
    /**
     * Specifies axis name with which the axis line has to be crossed
     * @default null
     */
    crossesInAxis: string;
    /**
     * Specifies the minimum range of an axis.
     * @default null
     */
    minimum: Object;
    /**
     * Specifies the maximum range of an axis.
     * @default null
     */
    maximum: Object;
    /**
     * Specifies the interval for an axis.
     * @default null
     */
    interval: number;
    /**
     * Options for customizing major tick lines.
     */
    majorTickLines: MajorTickLinesModel;
    /**
     * Options for customizing minor tick lines.
     */
    minorTickLines: MinorTickLinesModel;
    /**
     * Options for customizing major grid lines.
     */
    majorGridLines: MajorGridLinesModel;
    /**
     * Options for customizing minor grid lines.
     */
    minorGridLines: MinorGridLinesModel;
    /**
     * Options for customizing axis lines.
     */
    lineStyle: AxisLineModel;
    /**
     * Specifies the actions like `Hide`, `Rotate45`, and `Rotate90` when the axis labels intersect with each other.They are,
     * * None: Shows all the labels.
     * * Hide: Hides the label when it intersects.
     * * Rotate45: Rotates the label to 45 degree when it intersects.
     * * Rotate90: Rotates the label to 90 degree when it intersects.
     * @default Hide
     */
    labelIntersectAction: LabelIntersectAction;
    /**
     * It specifies whether the axis to be rendered in inversed manner or not.
     * @default false
     */
    isInversed: boolean;
    /**
     * The polar radar radius position.
     * @default 100
     */
    coefficient: number;
    /**
     * The start angle for the series.
     * @default 0
     */
    startAngle: number;
    /**
     * Description for axis and its element.
     * @default null
     */
    description: string;
    /**
     * TabIndex value for the axis.
     * @default 2
     */
    tabIndex: number;
    /**
     * Specifies the stripLine collection for the axis
     */
    stripLines: StripLineSettingsModel[];
    /**
     * Specifies the multi level labels collection for the axis
     */
    multiLevelLabels: MultiLevelLabelsModel[];
    /**
     * Border of the multi level labels.
     */
    border: LabelBorderModel;
    /** @private */
    visibleRange: VisibleRangeModel;
    /** @private */
    visibleLabels: VisibleLabels[];
    /** @private */
    actualRange: VisibleRangeModel;
    /** @private */
    series: Series[];
    /** @private */
    doubleRange: DoubleRange;
    /** @private */
    maxLabelSize: Size;
    /** @private */
    rotatedLabel: string;
    /** @private */
    rect: Rect;
    /** @private */
    axisBottomLine: BorderModel;
    /** @private */
    orientation: Orientation;
    /** @private */
    intervalDivs: number[];
    /** @private */
    actualIntervalType: IntervalType;
    /** @private */
    labels: string[];
    /** @private */
    format: Function;
    /** @private */
    baseModule: Double | DateTime | Category | DateTimeCategory;
    /** @private */
    startLabel: string;
    /** @private */
    endLabel: string;
    /** @private */
    angle: number;
    /** @private */
    dateTimeInterval: number;
    /** @private */
    isStack100: boolean;
    /** @private */
    crossInAxis: this;
    /** @private */
    crossAt: number;
    /** @private */
    updatedRect: Rect;
    /** @private */
    multiLevelLabelHeight: number;
    /**
     * The function used to find tick size.
     * @return {number}
     * @private
     */
    findTickSize(crossAxis: Axis): number;
    /**
     * The function used to find axis position.
     * @return {number}
     * @private
     */
    isInside(range: VisibleRangeModel): boolean;
    /**
     * The function used to find label Size.
     * @return {number}
     * @private
     */
    findLabelSize(crossAxis: Axis, innerPadding: number): number;
    /**
     * The function used to find axis position.
     * @return {number}
     * @private
     */
    updateCrossValue(chart: Chart): void;
    private findDifference(crossAxis);
    /**
     * The function used to find whether the range is set.
     * @return {boolean}
     * @private
     */
    setRange(): boolean;
    /**
     * Calculate visible range for axis.
     * @return {void}
     * @private
     */
    calculateVisibleRange(size: Size): void;
    /**
     * Calculate desired interval for the axis.
     * @return {void}
     * @private
     */
    getActualDesiredIntervalsCount(availableSize: Size): number;
    /**
     * Triggers the event.
     * @return {void}
     * @private
     */
    triggerLabelRender(chart: Chart, tempInterval: number, text: string, labelStyle: FontModel): void;
    /**
     * Triggers the event.
     * @return {void}
     * @private
     */
    triggerRangeRender(chart: Chart, minimum: number, maximum: number, interval: number): void;
    /**
     * Calculate padding for the axis.
     * @return {string}
     * @private
     */
    getRangePadding(chart: Chart): string;
    /**
     * Calculate maximum label width for the axis.
     * @return {void}
     * @private
     */
    getMaxLabelWidth(chart: Chart): void;
    /**
     * Finds the multiple rows for axis.
     * @return {void}
     */
    private findMultiRows(length, currentX, currentLabel);
    /**
     * Finds the default module for axis.
     * @return {void}
     * @private
     */
    getModule(chart: Chart): void;
}
/** @private */
export interface VisibleRangeModel {
    min?: number;
    max?: number;
    interval?: number;
    delta?: number;
}
/** @private */
export  class VisibleLabels {
    text: string | string[];
    value: number;
    labelStyle: FontModel;
    size: Size;
    index: number;
    originalText: string;
    constructor(text: string | string[], value: number, labelStyle: FontModel, size?: Size, index?: number);
}
export  class CartesianAxisLayoutPanel {
    private chart;
    private initialClipRect;
    private htmlObject;
    private element;
    private padding;
    /** @private */
    leftSize: number;
    /** @private */
    rightSize: number;
    /** @private */
    topSize: number;
    /** @private */
    bottomSize: number;
    /** @private */
    seriesClipRect: Rect;
    /** @private */
    constructor(chartModule?: Chart);
    /**
     * Measure the axis size.
     * @return {void}
     * @private
     */
    measureAxis(rect: Rect): void;
    private measureRowAxis(chart, rect);
    private measureColumnAxis(chart, rect);
    /**
     * Measure the column and row in chart.
     * @return {void}
     * @private
     */
    measureDefinition(definition: Row | Column, chart: Chart, size: Size, clipRect: Rect): void;
    /**
     * Measure the axis.
     * @return {void}
     * @private
     */
    private calculateAxisSize(rect);
    /**
     * Measure the axis.
     * @return {void}
     * @private
     */
    measure(): void;
    private crossAt(chart);
    private updateCrossAt(axis, crossAt);
    private pushAxis(definition, axis);
    private arrangeAxis(definition);
    private getActualColumn(axis);
    private getActualRow(axis);
    /**
     * Measure the row size.
     * @return {void}
     */
    private calculateRowSize(rect);
    /**
     * Measure the row size.
     * @return {void}
     */
    private calculateColumnSize(rect);
    /**
     * To render the axis element.
     * @return {void}
     * @private
     */
    renderAxes(): Element;
    private findAxisPosition(axis);
    private drawBottomLine(definition, index, isRow);
    private drawAxisLine(axis, index, plotX, plotY, parent, rect);
    private drawYAxisGridLine(axis, index, parent, rect);
    private isBorder(axis, index, value);
    /**
     * To render the axis label.
     * @return {void}
     * @private
     */
    drawYAxisLabels(axis: Axis, index: number, parent: Element, rect: Rect): void;
    /**
     * To render the axis label border.
     * @return {void}
     * @private
     */
    private drawYAxisBorder(axis, index, parent, rect);
    private drawYAxisTitle(axis, index, parent, rect);
    private drawXAxisGridLine(axis, index, parent, rect);
    private drawAxisMinorLine(axis, tempInterval, minorGird, minorTick, rect, labelIndex);
    private findLogNumeric(axis, logPosition, logInterval, value, labelIndex);
    /**
     * To render the axis label.
     * @return {void}
     * @private
     */
    drawXAxisLabels(axis: Axis, index: number, parent: Element, rect: Rect): void;
    /**
     * To render the axis label border.
     * @return {void}
     * @private
     */
    private drawXAxisBorder(axis, index, parent, axisRect);
    /**
     * To create border element for axis.
     * @return {void}
     * @private
     */
    private createAxisBorderElement(axis, index, labelBorder, parent);
    private findAxisLabel(axis, label, width);
    private drawXAxisTitle(axis, index, parent, rect);
    private renderTickLine(axis, index, majorTick, minorTick, parent);
    private renderGridLine(axis, index, majorGrid, minorGird);
    private findParentNode(chart, label, axis, index);
    private createZoomingLabel(chart, labelElement, axis, index, rect);
}
/**
 * `Category` module is used to render category axis.
 */
export  class Category extends NiceInterval {
    /**
     * Constructor for the category module.
     * @private
     */
    constructor(chart: Chart);
    /**
     * The function to calculate the range and labels for the axis.
     * @return {void}
     */
    calculateRangeAndInterval(size: Size, axis: Axis): void;
    /**
     * Actual Range for the axis.
     * @private
     */
    protected getActualRange(axis: Axis, size: Size): void;
    /**
     * Padding for the axis.
     * @private
     */
    protected applyRangePadding(axis: Axis, size: Size): void;
    /**
     * Calculate label for the axis.
     * @private
     */
    protected calculateVisibleLabels(axis: Axis): void;
    /**
     * Get module name
     */
    protected getModuleName(): string;
    /**
     * To destroy the category axis.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * `DateTime` module is used to render datetime axis.
 */
export  class DateTime extends NiceInterval {
    private start;
    private end;
    /**
     * Constructor for the dateTime module.
     * @private
     */
    constructor(chart: Chart);
    /**
     * The function to calculate the range and labels for the axis.
     * @return {void}
     */
    calculateRangeAndInterval(size: Size, axis: Axis): void;
    /**
     * Actual Range for the axis.
     * @private
     */
    protected getActualRange(axis: Axis, size: Size): void;
    /**
     * Apply padding for the range.
     * @private
     */
    protected applyRangePadding(axis: Axis, size: Size): void;
    private getYear(minimum, maximum, rangePadding, interval);
    private getMonth(minimum, maximum, rangePadding, interval);
    private getDay(minimum, maximum, rangePadding, interval);
    private getHour(minimum, maximum, rangePadding, interval);
    /**
     * Calculate visible range for axis.
     * @private
     */
    protected calculateVisibleRange(size: Size, axis: Axis): void;
    /**
     * Calculate visible labels for the axis.
     * @private
     */
    protected calculateVisibleLabels(axis: Axis): void;
    /** @private */
    increaseDateTimeInterval(axis: Axis, value: number, interval: number): Date;
    private alignRangeStart(axis, sDate, intervalSize, intervalType);
    /**
     * Get module name
     */
    protected getModuleName(): string;
    /**
     * To destroy the category axis.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * Category module is used to render category axis.
 */
export  class DateTimeCategory extends Category {
    private axisSize;
    /**
     * Constructor for the category module.
     * @private
     */
    constructor(chart: Chart);
    /**
     * The function to calculate the range and labels for the axis.
     * @return {void}
     * @private
     */
    calculateRangeAndInterval(size: Size, axis: Axis): void;
    /**
     * Calculate label for the axis.
     * @private
     */
    protected calculateVisibleLabels(axis: Axis): void;
    /**
     * get same interval
     */
    private sameInterval(currentDate, previousDate, type, index);
    /**
     * Get module name
     */
    protected getModuleName(): string;
    /**
     * To destroy the category axis.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * Numeric module is used to render numeric axis.
 */
export  class Double {
    /** @private */
    chart: Chart;
    /** @private */
    min: Object;
    /** @private */
    max: Object;
    private paddingInterval;
    /**
     * Constructor for the dateTime module.
     * @private
     */
    constructor(chart: Chart);
    /**
     * Numeric Nice Interval for the axis.
     * @private
     */
    protected calculateNumericNiceInterval(axis: Axis, delta: number, size: Size): number;
    /**
     * Actual Range for the axis.
     * @private
     */
    protected getActualRange(axis: Axis, size: Size): void;
    /**
     * Range for the axis.
     * @private
     */
    protected initializeDoubleRange(axis: Axis): void;
    /**
     * The function to calculate the range and labels for the axis.
     * @return {void}
     * @private
     */
    calculateRangeAndInterval(size: Size, axis: Axis): void;
    /**
     * Calculate Range for the axis.
     * @private
     */
    protected calculateRange(axis: Axis, size: Size): void;
    private findMinMax(min, max);
    /**
     * Apply padding for the range.
     * @private
     */
    protected applyRangePadding(axis: Axis, size: Size): void;
    private updateActualRange(axis, minimum, maximum, interval);
    private findAdditional(axis, start, end, interval);
    private findNormal(axis, start, end, interval, size);
    /**
     * Calculate visible range for axis.
     * @private
     */
    protected calculateVisibleRange(size: Size, axis: Axis): void;
    /**
     * Calculate label for the axis.
     * @private
     */
    protected calculateVisibleLabels(axis: Axis, chart: Chart): void;
    /**
     * Format of the axis label.
     * @private
     */
    protected getFormat(axis: Axis): string;
    /**
     * Formatted the axis label.
     * @private
     */
    protected formatValue(axis: Axis, isCustom: boolean, format: string, tempInterval: number): string;
}
/**
 * `Logarithmic` module is used to render log axis.
 */
export  class Logarithmic extends Double {
    /**
     * Constructor for the logerithmic module.
     * @private
     */
    constructor(chart: Chart);
    /**
     * The method to calculate the range and labels for the axis.
     * @return {void}
     */
    calculateRangeAndInterval(size: Size, axis: Axis): void;
    /**
     * Calculates actual range for the axis.
     * @private
     */
    protected getActualRange(axis: Axis, size: Size): void;
    /**
     * Calculates visible range for the axis.
     * @private
     */
    protected calculateVisibleRange(size: Size, axis: Axis): void;
    /**
     * Calculates log iInteval for the axis.
     * @private
     */
    protected calculateLogNiceInterval(delta: number, size: Size, axis: Axis): number;
    /**
     * Calculates labels for the axis.
     * @private
     */
    protected calculateVisibleLabels(axis: Axis, chart: Chart): void;
    /**
     * Get module name
     */
    protected getModuleName(): string;
    /**
     * To destroy the category axis.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * MultiLevel Labels src
 */
/**
 * `MultiLevelLabel` module is used to render the multi level label in chart.
 */
export  class MultiLevelLabel {
    /** @private */
    chart: Chart;
    /** @private */
    xAxisPrevHeight: number[];
    /** @private */
    xAxisMultiLabelHeight: number[];
    /** @private */
    yAxisPrevHeight: number[];
    /** @private */
    yAxisMultiLabelHeight: number[];
    /** @private */
    multiElements: Element;
    /**
     * Constructor for the logerithmic module.
     * @private
     */
    constructor(chart: Chart);
    /**
     * Finds multilevel label height
     * @return {void}
     */
    getMultilevelLabelsHeight(axis: Axis): void;
    /**
     * render x axis multi level labels
     * @private
     * @return {void}
     */
    renderXAxisMultiLevelLabels(axis: Axis, index: number, parent: Element, axisRect: Rect): void;
    /**
     * render x axis multi level labels border
     * @private
     * @return {void}
     */
    private renderXAxisLabelBorder(labelIndex, gap, axis, startX, startY, labelSize, textOptions, axisRect, alignment, path, isOutside, opposedPosition);
    /**
     * render y axis multi level labels
     * @private
     * @return {void}
     */
    renderYAxisMultiLevelLabels(axis: Axis, index: number, parent: Element, rect: Rect): void;
    /**
     * render y axis multi level labels border
     * @private
     * @return {void}
     */
    private renderYAxisLabelBorder(labelIndex, gap, axis, endY, startX, startY, labelSize, textOptions, rect, alignment, path, isOutside, opposedPosition);
    /**
     * create cliprect
     * @return {void}
     * @private
     */
    createClipRect(x: number, y: number, height: number, width: number, clipId: string, axisId: string): void;
    /**
     * create borer element
     * @return {void}
     * @private
     */
    createBorderElement(borderIndex: number, axisIndex: number, axis: Axis, path: string): void;
    /**
     * Triggers the event.
     * @return {void}
     * @private
     */
    triggerMultiLabelRender(axis: Axis, text: string, textStyle: FontModel, textAlignment: Alignment): IAxisMultiLabelRenderEventArgs;
    /**
     * To get the module name for `MultiLevelLabel`.
     * @private
     */
    getModuleName(): string;
    /**
     * To destroy the `MultiLevelLabel` module.
     * @private
     */
    destroy(): void;
}
export  class PolarRadarPanel extends LineBase {
    private initialClipRect;
    private htmlObject;
    private element;
    private centerX;
    private centerY;
    private startAngle;
    /** @private */
    seriesClipRect: Rect;
    /**
     * Measure the polar radar axis size.
     * @return {void}
     * @private
     */
    measureAxis(rect: Rect): void;
    private measureRowAxis(chart, rect);
    private measureColumnAxis(chart, rect);
    /**
     * Measure the column and row in chart.
     * @return {void}
     * @private
     */
    measureDefinition(definition: Row | Column, chart: Chart, size: Size, clipRect: Rect): void;
    /**
     * Measure the axis.
     * @return {void}
     * @private
     */
    private calculateAxisSize();
    /**
     * Measure the axis.
     * @return {void}
     * @private
     */
    measure(): void;
    /**
     * Measure the row size.
     * @return {void}
     */
    private calculateRowSize(rect);
    /**
     * Measure the row size.
     * @return {void}
     */
    private calculateColumnSize(rect);
    /**
     * To render the axis element.
     * @return {void}
     * @private
     */
    renderAxes(): Element;
    private drawYAxisLine(axis, index, plotX, plotY);
    drawYAxisLabels(axis: Axis, index: number): void;
    private drawYAxisGridLine(axis, index);
    private drawXAxisGridLine(axis, index);
    private drawAxisMinorLine(axis, tempInterval, minorGird, minorTick);
    /**
     * To render the axis label.
     * @return {void}
     * @private
     */
    drawXAxisLabels(axis: Axis, index: number): void;
    private renderTickLine(axis, index, majorTickLine, minorTickLine?);
    private renderGridLine(axis, index, majorGrid, minorGird);
}
/**
 * `StripLine` module is used to render the stripLine in chart.
 */
export  class StripLine {
    private measureStripLine(axis, stripline, seriesClipRect);
    /**
     * To get from to value from start, end, size, start from axis
     */
    private getFromTovalue(start, end, size, startFromAxis, axis);
    private getToValue(to, from, size, axis, end);
    private findValue(value, axis);
    /**
     * To render striplines based start and end.
     * @private
     * @param chart
     * @param position
     * @param axes
     */
    renderStripLine(chart: Chart, position: ZIndex, axes: Axis[]): void;
    private renderRectangle(stripline, rect, id, parent, chart);
    private renderText(stripline, rect, id, parent, chart, axis);
    private invertAlignment(anchor);
    private factor(anchor);
    private getTextStart(xy, size, textAlignment);
    /**
     * To get the module name for `StripLine`.
     * @private
     */
    getModuleName(): string;
    /**
     * To destroy the `StripLine` module.
     * @private
     */
    destroy(): void;
}
/**
 * Interface for a class CrosshairSettings
 */
export interface CrosshairSettingsModel {
    /**
     * If set to true, crosshair line becomes visible.
     * @default false
     */
    enable?: boolean;
    /**
     * Options to customize the crosshair line.
     */
    line?: BorderModel;
    /**
     * Specifies the line type. Horizontal mode enables the horizontal line and Vertical mode enables the vertical line. They are,
     * * None: Hides both vertical and horizontal crosshair lines.
     * * Both: Shows both vertical and horizontal crosshair lines.
     * * Vertical: Shows the vertical line.
     * * Horizontal: Shows the horizontal line.
     * @default Both
     */
    lineType?: LineType;
}
/**
 * Interface for a class ZoomSettings
 */
export interface ZoomSettingsModel {
    /**
     * If set to true, chart can be zoomed by a rectangular selecting region on the plot area.
     * @default false
     */
    enableSelectionZooming?: boolean;
    /**
     * If to true, chart can be pinched to zoom in / zoom out.
     * @default false
     */
    enablePinchZooming?: boolean;
    /**
     * If set to true, chart can be zoomed by using mouse wheel.
     * @default false
     */
    enableMouseWheelZooming?: boolean;
    /**
     * If set to true, zooming will be performed on mouse up. It requires `enableSelectionZooming` to be true.
     * ```html 
     * <div id='Chart'></div>
     * ```
     * ```typescript
     * let chart: Chart = new Chart({
     * ...
     *    zoomSettings: {
     *      enableSelectionZooming: true,
     *      enableDeferredZooming: false
     *    }
     * ...
     * });
     * chart.appendTo('#Chart');
     * ```
     * @default true
     */
    enableDeferredZooming?: boolean;
    /**
     * Specifies whether to allow zooming vertically or horizontally or in both ways. They are,
     * * x,y: Chart can be zoomed both vertically and horizontally.
     * * x: Chart can be zoomed horizontally.
     * * y: Chart can be zoomed  vertically.
     *  It requires `enableSelectionZooming` to be true.
     * ```html 
     * <div id='Chart'></div>
     * ```
     * ```typescript
     * let chart: Chart = new Chart({
     * ...
     *    zoomSettings: {
     *      enableSelectionZooming: true,
     *      mode: 'XY'
     *    }
     * ...
     * });
     * chart.appendTo('#Chart');
     * ```
     * @default 'XY'
     */
    mode?: ZoomMode;
    /**
     * Specifies the toolkit options for the zooming as follows:
     * * base.Zoom
     * * ZoomIn
     * * ZoomOut
     * * Pan
     * * Reset
     * @default '["base.Zoom", "ZoomIn", "ZoomOut", "Pan", "Reset"]' 
     */
    toolbarItems?: ToolbarItems[];
    /**
     * Specifies whether chart needs to be panned by default.
     * @default false.
     */
    enablePan?: boolean;
}
/**
 * Interface for a class Chart
 */
export interface ChartModel extends base.ComponentModel{
    /**
     * The width of the chart as a string accepts input as both like '100px' or '100%'.
     * If specified as '100%, chart renders to the full width of its parent element.
     * @default null
     */
    width?: string;
    /**
     * The height of the chart as a string accepts input both as '100px' or '100%'.
     * If specified as '100%, chart renders to the full height of its parent element.
     * @default null
     */
    height?: string;
    /**
     * Title of the chart
     * @default ''
     */
    title?: string;
    /**
     * Options for customizing the title of the Chart.
     */
    titleStyle?: FontModel;
    /**
     *  Options to customize left, right, top and bottom margins of the chart.
     */
    margin?: MarginModel;
    /**
     * Options for customizing the color and width of the chart border.
     */
    border?: BorderModel;
    /**
     * The background color of the chart that accepts value in hex and rgba as a valid CSS color string.
     * @default null
     */
    background?: string;
    /**
     * Options for configuring the border and background of the chart area.
     */
    chartArea?: ChartAreaModel;
    /**
     * Options to configure the horizontal axis.
     */
    primaryXAxis?: AxisModel;
    /**
     * Options to configure the vertical axis.
     */
    primaryYAxis?: AxisModel;
    /**
     * Options to split Chart into multiple plotting areas horizontally.
     * Each object in the collection represents a plotting area in the Chart.
     */
    rows?: RowModel[];
    /**
     * Options to split chart into multiple plotting areas vertically.
     * Each object in the collection represents a plotting area in the chart.
     */
    columns?: ColumnModel[];
    /**
     * Secondary axis collection for the chart.
     */
    axes?: AxisModel[];
    /**
     * The configuration for series in the chart.
     */
    series?: SeriesModel[];
    /**
     * The configuration for annotation in chart.
     */
    annotations?: ChartAnnotationSettingsModel[];
    /**
     * Palette for the chart series.
     * @default []
     */
    palettes?: string[];
    /**
     * Specifies the theme for the chart.
     * @default 'Material'
     */
    theme?: ChartTheme;
    /**
     * Options for customizing the tooltip of the chart.
     */
    tooltip?: TooltipSettingsModel;
    /**
     * Options for customizing the crosshair of the chart.
     */
    crosshair?: CrosshairSettingsModel;
    /**
     * Options for customizing the legend of the chart.
     */
    legendSettings?: LegendSettingsModel;
    /**
     * Options to enable the zooming feature in the chart.
     */
    zoomSettings?: ZoomSettingsModel;
    /**
     * Specifies whether series or data point has to be selected. They are,
     * * none: Disables the selection.
     * * series: selects a series.
     * * point: selects a point.
     * * cluster: selects a cluster of point
     * * dragXY: selects points by dragging with respect to both horizontal and vertical axes
     * * dragX: selects points by dragging with respect to horizontal axis.
     * * dragY: selects points by dragging with respect to vertical axis.
     * @default None
     */
    selectionMode?: SelectionMode;
    /**
     * If set true, enables the multi selection in chart. It requires `selectionMode` to be `Point` | `base.Series` | or `Cluster`.
     * @default false
     */
    isMultiSelect?: boolean;
    /**
     * Specifies the point indexes to be selected while loading a chart.
     * It requires `selectionMode` to be `Point` | `base.Series` | or `Cluster`.
     * ```html
     * <div id='Chart'></div>
     * ```
     * ```typescript
     * let chart: Chart = new Chart({
     * ...
     *   selectionMode: 'Point',
     *   selectedDataIndexes: [ { series: 0, point: 1},
     *                          { series: 2, point: 3} ],
     * ...
     * });
     * chart.appendTo('#Chart');
     * ```
     * @default []
     */
    selectedDataIndexes?: IndexesModel[];
    /**
     * Specifies whether a grouping separator should be used for a number.
     * @default false
     */
    useGroupingSeparator?: boolean;
    /**
     * It specifies whether the chart should be render in transposed manner or not.
     * @default false
     */
    isTransposed?: boolean;
    /**
     * Defines the collection of technical indicators, that are used in financial markets
     */
    indicators?: TechnicalIndicatorModel[];
    /**
     * Description for chart.
     * @default null
     */
    description?: string;
    /**
     * TabIndex value for the chart.
     * @default 1
     */
    tabIndex?: number;
    /**
     * To enable the side by side placing the points for column type series.
     * @default true
     */
    enableSideBySidePlacement?: boolean;
    /**
     * Triggers after resizing of chart
     * @event
     */
    resized?: base.EmitType<IResizeEventArgs>;
    /**
     * Triggers before the annotation gets rendered.
     * @event
     */
    annotationRender?: base.EmitType<IAnnotationRenderEventArgs>;
    /**
     * Triggers before the prints gets started.
     * @event
     */
    beforePrint?: base.EmitType<IPrintEventArgs>;
    /**
     * Triggers after chart base.load.
     * @event
     */
    loaded?: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers before chart base.load.
     * @event
     */
    load?: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers after animation is completed for the series.
     * @event
     */
    animationComplete?: base.EmitType<IAnimationCompleteEventArgs>;
    /**
     * Triggers before the legend is rendered.
     * @event
     */
    legendRender?: base.EmitType<ILegendRenderEventArgs>;
    /**
     * Triggers before the data label for series is rendered.
     * @event
     */
    textRender?: base.EmitType<ITextRenderEventArgs>;
    /**
     * Triggers before each points for the series is rendered.
     * @event
     */
    pointRender?: base.EmitType<IPointRenderEventArgs>;
    /**
     * Triggers before the series is rendered.
     * @event
     */
    seriesRender?: base.EmitType<ISeriesRenderEventArgs>;
    /**
     * Triggers before each axis label is rendered.
     * @event
     */
    axisLabelRender?: base.EmitType<IAxisLabelRenderEventArgs>;
    /**
     * Triggers before each axis range is rendered.
     * @event
     */
    axisRangeCalculated?: base.EmitType<IAxisRangeCalculatedEventArgs>;
    /**
     * Triggers before each axis multi label is rendered.
     * @event
     */
    axisMultiLabelRender?: base.EmitType<IAxisMultiLabelRenderEventArgs>;
    /**
     * Triggers before the tooltip for series is rendered.
     * @event
     */
    tooltipRender?: base.EmitType<ITooltipRenderEventArgs>;
    /**
     * Triggers on hovering the chart.
     * @event
     */
    chartMouseMove?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on clicking the chart.
     * @event
     */
    chartMouseClick?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on point click.
     * @event
     */
    pointClick?: base.EmitType<IPointEventArgs>;
    /**
     * Triggers on point move.
     * @event
     */
    pointMove?: base.EmitType<IPointEventArgs>;
    /**
     * Triggers when cursor leaves the chart.
     * @event
     */
    chartMouseLeave?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on mouse down.
     * @event
     */
    chartMouseDown?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on mouse up.
     * @event
     */
    chartMouseUp?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers after the drag selection is completed.
     * @event
     */
    dragComplete?: base.EmitType<IDragCompleteEventArgs>;
    /**
     * Triggers after the zoom selection is completed.
     * @event
     */
    zoomComplete?: base.EmitType<IZoomCompleteEventArgs>;
    /**
     * Defines the currencyCode format of the chart
     * @private
     */
    currencyCode?: string;
}
/**
 * Configures the crosshair in the chart.
 */
export  class CrosshairSettings extends base.ChildProperty<CrosshairSettings> {
    /**
     * If set to true, crosshair line becomes visible.
     * @default false
     */
    enable: boolean;
    /**
     * Options to customize the crosshair line.
     */
    line: BorderModel;
    /**
     * Specifies the line type. Horizontal mode enables the horizontal line and Vertical mode enables the vertical line. They are,
     * * None: Hides both vertical and horizontal crosshair lines.
     * * Both: Shows both vertical and horizontal crosshair lines.
     * * Vertical: Shows the vertical line.
     * * Horizontal: Shows the horizontal line.
     * @default Both
     */
    lineType: LineType;
}
/**
 * Configures the zooming behavior for the chart.
 */
export  class ZoomSettings extends base.ChildProperty<ZoomSettings> {
    /**
     * If set to true, chart can be zoomed by a rectangular selecting region on the plot area.
     * @default false
     */
    enableSelectionZooming: boolean;
    /**
     * If to true, chart can be pinched to zoom in / zoom out.
     * @default false
     */
    enablePinchZooming: boolean;
    /**
     * If set to true, chart can be zoomed by using mouse wheel.
     * @default false
     */
    enableMouseWheelZooming: boolean;
    /**
     * If set to true, zooming will be performed on mouse up. It requires `enableSelectionZooming` to be true.
     * ```html
     * <div id='Chart'></div>
     * ```
     * ```typescript
     * let chart: Chart = new Chart({
     * ...
     *    zoomSettings: {
     *      enableSelectionZooming: true,
     *      enableDeferredZooming: false
     *    }
     * ...
     * });
     * chart.appendTo('#Chart');
     * ```
     * @default true
     */
    enableDeferredZooming: boolean;
    /**
     * Specifies whether to allow zooming vertically or horizontally or in both ways. They are,
     * * x,y: Chart can be zoomed both vertically and horizontally.
     * * x: Chart can be zoomed horizontally.
     * * y: Chart can be zoomed  vertically.
     *  It requires `enableSelectionZooming` to be true.
     * ```html
     * <div id='Chart'></div>
     * ```
     * ```typescript
     * let chart: Chart = new Chart({
     * ...
     *    zoomSettings: {
     *      enableSelectionZooming: true,
     *      mode: 'XY'
     *    }
     * ...
     * });
     * chart.appendTo('#Chart');
     * ```
     * @default 'XY'
     */
    mode: ZoomMode;
    /**
     * Specifies the toolkit options for the zooming as follows:
     * * Zoom
     * * ZoomIn
     * * ZoomOut
     * * Pan
     * * Reset
     * @default '["Zoom", "ZoomIn", "ZoomOut", "Pan", "Reset"]'
     */
    toolbarItems: ToolbarItems[];
    /**
     * Specifies whether chart needs to be panned by default.
     * @default false.
     */
    enablePan: boolean;
}
/**
 * Represents the Chart control.
 * ```html
 * <div id="chart"/>
 * <script>
 *   var chartObj = new Chart({ isResponsive : true });
 *   chartObj.appendTo("#chart");
 * </script>
 * ```
 */
export  class Chart extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /**
     * `lineSeriesModule` is used to add line series to the chart.
     */
    lineSeriesModule: LineSeries;
    /**
     * `multiColoredLineSeriesModule` is used to add multi colored line series to the chart.
     */
    multiColoredLineSeriesModule: MultiColoredLineSeries;
    /**
     * `multiColoredAreaSeriesModule` is used to add multi colored area series to the chart.
     */
    multiColoredAreaSeriesModule: MultiColoredAreaSeries;
    /**
     * `columnSeriesModule` is used to add column series to the chart.
     */
    columnSeriesModule: ColumnSeries;
    /**
     * `areaSeriesModule` is used to add area series in the chart.
     */
    areaSeriesModule: AreaSeries;
    /**
     * `barSeriesModule` is used to add bar series to the chart.
     */
    barSeriesModule: BarSeries;
    /**
     * `stackingColumnSeriesModule` is used to add stacking column series in the chart.
     */
    stackingColumnSeriesModule: StackingColumnSeries;
    /**
     * `stackingAreaSeriesModule` is used to add stacking area series to the chart.
     */
    stackingAreaSeriesModule: StackingAreaSeries;
    /**
     * 'CandleSeriesModule' is used to add candle series in the chart.
     */
    candleSeriesModule: CandleSeries;
    /**
     * `stackingBarSeriesModule` is used to add stacking bar series to the chart.
     */
    stackingBarSeriesModule: StackingBarSeries;
    /**
     * `stepLineSeriesModule` is used to add step line series to the chart.
     */
    stepLineSeriesModule: StepLineSeries;
    /**
     * `stepAreaSeriesModule` is used to add step area series to the chart.
     */
    stepAreaSeriesModule: StepAreaSeries;
    /**
     * `polarSeriesModule` is used to add polar series in the chart.
     */
    polarSeriesModule: PolarSeries;
    /**
     *  `radarSeriesModule` is used to add radar series in the chart.
     */
    radarSeriesModule: RadarSeries;
    /**
     * `splineSeriesModule` is used to add spline series to the chart.
     */
    splineSeriesModule: SplineSeries;
    /**
     * `splineAreaSeriesModule` is used to add spline area series to the chart.
     */
    splineAreaSeriesModule: SplineAreaSeries;
    /**
     * `scatterSeriesModule` is used to add scatter series to the chart.
     */
    scatterSeriesModule: ScatterSeries;
    /**
     * `boxAndWhiskerSeriesModule` is used to add line series to the chart.
     */
    boxAndWhiskerSeriesModule: BoxAndWhiskerSeries;
    /**
     * `rangeColumnSeriesModule` is used to add rangeColumn series to the chart.
     */
    rangeColumnSeriesModule: RangeColumnSeries;
    /**
     * hiloSeriesModule is used to add hilo series in chart
     */
    hiloSeriesModule: HiloSeries;
    /**
     * hiloOpenCloseSeriesModule is used to add hilo series in chart
     */
    hiloOpenCloseSeriesModule: HiloOpenCloseSeries;
    /**
     * `waterfallSeries` is used to add waterfall series in chart.
     */
    waterfallSeriesModule: WaterfallSeries;
    /**
     * `bubbleSeries` is used to add bubble series in chart.
     */
    bubbleSeriesModule: BubbleSeries;
    /**
     * `rangeAreaSeriesModule` is used to add rangeArea series in chart.
     */
    rangeAreaSeriesModule: RangeAreaSeries;
    /**
     * `tooltipModule` is used to manipulate and add tooltip to the series.
     */
    tooltipModule: Tooltip;
    /**
     * `crosshairModule` is used to manipulate and add crosshair to the chart.
     */
    crosshairModule: Crosshair;
    /**
     * `errorBarModule` is used to manipulate and add errorBar for series.
     */
    errorBarModule: ErrorBar;
    /**
     * `dataLabelModule` is used to manipulate and add data label to the series.
     */
    dataLabelModule: DataLabel;
    /**
     * `datetimeModule` is used to manipulate and add dateTime axis to the chart.
     */
    dateTimeModule: DateTime;
    /**
     * `categoryModule` is used to manipulate and add category axis to the chart.
     */
    categoryModule: Category;
    /**
     * `dateTimeCategoryModule` is used to manipulate date time and category axis
     */
    dateTimeCategoryModule: DateTimeCategory;
    /**
     * `logarithmicModule` is used to manipulate and add log axis to the chart.
     */
    logarithmicModule: Logarithmic;
    /**
     * `legendModule` is used to manipulate and add legend to the chart.
     */
    legendModule: Legend;
    /**
     * `zoomModule` is used to manipulate and add zooming to the chart.
     */
    zoomModule: Zoom;
    /**
     * `selectionModule` is used to manipulate and add selection to the chart.
     */
    selectionModule: Selection;
    /**
     * `annotationModule` is used to manipulate and add annotation in chart.
     */
    annotationModule: ChartAnnotation;
    /**
     * `stripLineModule` is used to manipulate and add stripLine in chart.
     */
    stripLineModule: StripLine;
    /**
     * `multiLevelLabelModule` is used to manipulate and add multiLevelLabel in chart.
     */
    multiLevelLabelModule: MultiLevelLabel;
    /**
     * 'TrendlineModule' is used to predict the market trend using trendlines
     */
    trendLineModule: Trendlines;
    /**
     * `sMAIndicatorModule` is used to predict the market trend using SMA approach
     */
    sMAIndicatorModule: SmaIndicator;
    /**
     * `eMAIndicatorModule` is used to predict the market trend using EMA approach
     */
    eMAIndicatorModule: EmaIndicator;
    /**
     * `tMAIndicatorModule` is used to predict the market trend using TMA approach
     */
    tMAIndicatorModule: TmaIndicator;
    /**
     * `accumulationDistributionIndicatorModule` is used to predict the market trend using Accumulation Distribution approach
     */
    accumulationDistributionIndicatorModule: AccumulationDistributionIndicator;
    /**
     * `atrIndicatorModule` is used to predict the market trend using ATR approach
     */
    atrIndicatorModule: AtrIndicator;
    /**
     * `rSIIndicatorModule` is used to predict the market trend using RSI approach
     */
    rsiIndicatorModule: RsiIndicator;
    /**
     * `macdIndicatorModule` is used to predict the market trend using Macd approach
     */
    macdIndicatorModule: MacdIndicator;
    /**
     * `stochasticIndicatorModule` is used to predict the market trend using Stochastic approach
     */
    stochasticIndicatorModule: StochasticIndicator;
    /**
     * `momentumIndicatorModule` is used to predict the market trend using Momentum approach
     */
    momentumIndicatorModule: MomentumIndicator;
    /**
     * `bollingerBandsModule` is used to predict the market trend using Bollinger approach
     */
    bollingerBandsModule: BollingerBands;
    /**
     * The width of the chart as a string accepts input as both like '100px' or '100%'.
     * If specified as '100%, chart renders to the full width of its parent element.
     * @default null
     */
    width: string;
    /**
     * The height of the chart as a string accepts input both as '100px' or '100%'.
     * If specified as '100%, chart renders to the full height of its parent element.
     * @default null
     */
    height: string;
    /**
     * Title of the chart
     * @default ''
     */
    title: string;
    /**
     * Options for customizing the title of the Chart.
     */
    titleStyle: FontModel;
    /**
     *  Options to customize left, right, top and bottom margins of the chart.
     */
    margin: MarginModel;
    /**
     * Options for customizing the color and width of the chart border.
     */
    border: BorderModel;
    /**
     * The background color of the chart that accepts value in hex and rgba as a valid CSS color string.
     * @default null
     */
    background: string;
    /**
     * Options for configuring the border and background of the chart area.
     */
    chartArea: ChartAreaModel;
    /**
     * Options to configure the horizontal axis.
     */
    primaryXAxis: AxisModel;
    /**
     * Options to configure the vertical axis.
     */
    primaryYAxis: AxisModel;
    /**
     * Options to split Chart into multiple plotting areas horizontally.
     * Each object in the collection represents a plotting area in the Chart.
     */
    rows: RowModel[];
    /**
     * Options to split chart into multiple plotting areas vertically.
     * Each object in the collection represents a plotting area in the chart.
     */
    columns: ColumnModel[];
    /**
     * Secondary axis collection for the chart.
     */
    axes: AxisModel[];
    /**
     * The configuration for series in the chart.
     */
    series: SeriesModel[];
    /**
     * The configuration for annotation in chart.
     */
    annotations: ChartAnnotationSettingsModel[];
    /**
     * Palette for the chart series.
     * @default []
     */
    palettes: string[];
    /**
     * Specifies the theme for the chart.
     * @default 'Material'
     */
    theme: ChartTheme;
    /**
     * Options for customizing the tooltip of the chart.
     */
    tooltip: TooltipSettingsModel;
    /**
     * Options for customizing the crosshair of the chart.
     */
    crosshair: CrosshairSettingsModel;
    /**
     * Options for customizing the legend of the chart.
     */
    legendSettings: LegendSettingsModel;
    /**
     * Options to enable the zooming feature in the chart.
     */
    zoomSettings: ZoomSettingsModel;
    /**
     * Specifies whether series or data point has to be selected. They are,
     * * none: Disables the selection.
     * * series: selects a series.
     * * point: selects a point.
     * * cluster: selects a cluster of point
     * * dragXY: selects points by dragging with respect to both horizontal and vertical axes
     * * dragX: selects points by dragging with respect to horizontal axis.
     * * dragY: selects points by dragging with respect to vertical axis.
     * @default None
     */
    selectionMode: SelectionMode;
    /**
     * If set true, enables the multi selection in chart. It requires `selectionMode` to be `Point` | `Series` | or `Cluster`.
     * @default false
     */
    isMultiSelect: boolean;
    /**
     * Specifies the point indexes to be selected while loading a chart.
     * It requires `selectionMode` to be `Point` | `Series` | or `Cluster`.
     * ```html
     * <div id='Chart'></div>
     * ```
     * ```typescript
     * let chart: Chart = new Chart({
     * ...
     *   selectionMode: 'Point',
     *   selectedDataIndexes: [ { series: 0, point: 1},
     *                          { series: 2, point: 3} ],
     * ...
     * });
     * chart.appendTo('#Chart');
     * ```
     * @default []
     */
    selectedDataIndexes: IndexesModel[];
    /**
     * Specifies whether a grouping separator should be used for a number.
     * @default false
     */
    useGroupingSeparator: boolean;
    /**
     * It specifies whether the chart should be render in transposed manner or not.
     * @default false
     */
    isTransposed: boolean;
    /**
     * Defines the collection of technical indicators, that are used in financial markets
     */
    indicators: TechnicalIndicatorModel[];
    /**
     * Description for chart.
     * @default null
     */
    description: string;
    /**
     * TabIndex value for the chart.
     * @default 1
     */
    tabIndex: number;
    /**
     * To enable the side by side placing the points for column type series.
     * @default true
     */
    enableSideBySidePlacement: boolean;
    /**
     * Triggers after resizing of chart
     * @event
     */
    resized: base.EmitType<IResizeEventArgs>;
    /**
     * Triggers before the annotation gets rendered.
     * @event
     */
    annotationRender: base.EmitType<IAnnotationRenderEventArgs>;
    /**
     * Triggers before the prints gets started.
     * @event
     */
    beforePrint: base.EmitType<IPrintEventArgs>;
    /**
     * Triggers after chart load.
     * @event
     */
    loaded: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers before chart load.
     * @event
     */
    load: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers after animation is completed for the series.
     * @event
     */
    animationComplete: base.EmitType<IAnimationCompleteEventArgs>;
    /**
     * Triggers before the legend is rendered.
     * @event
     */
    legendRender: base.EmitType<ILegendRenderEventArgs>;
    /**
     * Triggers before the data label for series is rendered.
     * @event
     */
    textRender: base.EmitType<ITextRenderEventArgs>;
    /**
     * Triggers before each points for the series is rendered.
     * @event
     */
    pointRender: base.EmitType<IPointRenderEventArgs>;
    /**
     * Triggers before the series is rendered.
     * @event
     */
    seriesRender: base.EmitType<ISeriesRenderEventArgs>;
    /**
     * Triggers before each axis label is rendered.
     * @event
     */
    axisLabelRender: base.EmitType<IAxisLabelRenderEventArgs>;
    /**
     * Triggers before each axis range is rendered.
     * @event
     */
    axisRangeCalculated: base.EmitType<IAxisRangeCalculatedEventArgs>;
    /**
     * Triggers before each axis multi label is rendered.
     * @event
     */
    axisMultiLabelRender: base.EmitType<IAxisMultiLabelRenderEventArgs>;
    /**
     * Triggers before the tooltip for series is rendered.
     * @event
     */
    tooltipRender: base.EmitType<ITooltipRenderEventArgs>;
    /**
     * Triggers on hovering the chart.
     * @event
     */
    chartMouseMove: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on clicking the chart.
     * @event
     */
    chartMouseClick: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on point click.
     * @event
     */
    pointClick: base.EmitType<IPointEventArgs>;
    /**
     * Triggers on point move.
     * @event
     */
    pointMove: base.EmitType<IPointEventArgs>;
    /**
     * Triggers when cursor leaves the chart.
     * @event
     */
    chartMouseLeave: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on mouse down.
     * @event
     */
    chartMouseDown: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on mouse up.
     * @event
     */
    chartMouseUp: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers after the drag selection is completed.
     * @event
     */
    dragComplete: base.EmitType<IDragCompleteEventArgs>;
    /**
     * Triggers after the zoom selection is completed.
     * @event
     */
    zoomComplete: base.EmitType<IZoomCompleteEventArgs>;
    /**
     * Defines the currencyCode format of the chart
     * @private
     */
    private currencyCode;
    private htmlObject;
    private getElement;
    private elementSize;
    private isLegend;
    /**
     * localization object
     * @private
     */
    localeObject: base.L10n;
    /**
     * It contains default values of localization values
     */
    private defaultLocalConstants;
    /**
     * Gets the current visible axis of the Chart.
     * @hidden
     */
    axisCollections: Axis[];
    /**
     * Gets the current visible series of the Chart.
     * @hidden
     */
    visibleSeries: Series[];
    /**
     * Render panel for chart.
     * @hidden
     */
    chartAxisLayoutPanel: CartesianAxisLayoutPanel | PolarRadarPanel;
    /**
     * Gets all the horizontal axis of the Chart.
     * @hidden
     */
    horizontalAxes: Axis[];
    /**
     * Gets all the vertical axis of the Chart.
     * @hidden
     */
    verticalAxes: Axis[];
    /**
     * Gets the inverted chart.
     * @hidden
     */
    requireInvertedAxis: boolean;
    /** @private */
    svgObject: Element;
    /** @private */
    isTouch: boolean;
    /** @private */
    renderer: base.SvgRenderer;
    /** @private */
    initialClipRect: Rect;
    /** @private */
    seriesElements: Element;
    /** @private */
    indicatorElements: Element;
    /** @private */
    trendLineElements: Element;
    /** @private */
    visibleSeriesCount: number;
    /** @private */
    intl: base.Internationalization;
    /** @private */
    dataLabelCollections: Rect[];
    /** @private */
    dataLabelElements: Element;
    /** @private */
    mouseX: number;
    /** @private */
    mouseY: number;
    /** @private */
    animateSeries: boolean;
    /** @private */
    availableSize: Size;
    /** @private */
    delayRedraw: boolean;
    /** @private */
    isDoubleTap: boolean;
    /** @private */
    mouseDownX: number;
    /** @private */
    mouseDownY: number;
    /** @private */
    previousMouseMoveX: number;
    /** @private */
    previousMouseMoveY: number;
    /** @private */
    private threshold;
    /** @private */
    isChartDrag: boolean;
    private resizeTo;
    /** @private */
    disableTrackTooltip: boolean;
    /** @private */
    startMove: boolean;
    /** @private */
    yAxisElements: Element;
    /** @private */
    radius: number;
    /** @private */
    chartAreaType: string;
    /**
     * `markerModule` is used to manipulate and add marker to the series.
     * @private
     */
    markerRender: Marker;
    private titleCollection;
    /** @private */
    themeStyle: IThemeStyle;
    /**
     * Constructor for creating the widget
     * @hidden
     */
    constructor(options?: ChartModel, element?: string | HTMLElement);
    /**
     * Initialize the event handler.
     */
    protected preRender(): void;
    private initPrivateVariable();
    /**
     * To Initialize the control rendering.
     */
    protected render(): void;
    /**
     * Gets the localized label by locale keyword.
     * @param  {string} key
     * @return {string}
     */
    getLocalizedLabel(key: string): string;
    /**
     * Refresh the chart bounds.
     * @private
     */
    refreshBound(): void;
    private renderElements();
    /**
     * To render the legend
     */
    private renderAxes();
    /**
     * To render the legend
     */
    private renderLegend();
    /**
     * To set the left and top position for data label template for center aligned chart
     */
    private setSecondaryElementPosition();
    private initializeModuleElements();
    private hasTrendlines();
    private renderSeriesElements(axisElement);
    private renderSeries();
    private initializeIndicator();
    private initializeTrendLine();
    private appendElementsAfterSeries(axisElement);
    private applyZoomkit();
    private renderAnnotation();
    private performSelection();
    private processData();
    private initializeDataModule(series);
    private calculateBounds();
    /**
     * Handles the print method for chart control.
     */
    print(id?: string[] | string | Element): void;
    /**
     * Handles the export method for chart control.
     * @param type
     * @param fileName
     */
    export(type: ExportType, fileName: string, orientation?: pdfexport.PdfPageOrientation): void;
    /**
     * Defines the trendline initialization
     */
    private initTrendLines();
    private calculateAreaType();
    private calculateVisibleAxis();
    private initAxis(series, axis, isSeries);
    private initTechnicalIndicators();
    /** @private */
    refreshTechnicalIndicator(series: SeriesBase): void;
    private calculateVisibleSeries();
    private renderTitle();
    private renderBorder();
    private renderAreaBorder();
    /**
     * To add series for the chart
     * @param {SeriesModel[]} seriesCollection - Defines the series collection to be added in chart.
     * @return {void}.
     */
    addSeries(seriesCollection: SeriesModel[]): void;
    /**
     * To Remove series for the chart
     * @param index - Defines the series index to be remove in chart series
     * @return {void}
     */
    removeSeries(index: number): void;
    /**
     * To destroy the widget
     * @method destroy
     * @return {void}.
     * @member of Chart
     */
    destroy(): void;
    /**
     * Get component name
     */
    getModuleName(): string;
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    getPersistData(): string;
    /**
     * Method to create SVG element.
     */
    private createChartSvg();
    /**
     * Method to bind events for chart
     */
    private unWireEvents();
    private wireEvents();
    private chartRightClick(event);
    private setStyle(element);
    /**
     * Finds the orientation.
     * @return {boolean}
     * @private
     */
    isOrientation(): boolean;
    /**
     * Handles the long press on chart.
     * @return {boolean}
     * @private
     */
    longPress(e?: base.TapEventArgs): boolean;
    /**
     * To find mouse x, y for aligned chart element svg position
     */
    private setMouseXY(pageX, pageY);
    /**
     * Handles the chart resize.
     * @return {boolean}
     * @private
     */
    chartResize(e: Event): boolean;
    /**
     * Handles the mouse move.
     * @return {boolean}
     * @private
     */
    mouseMove(e: PointerEvent): boolean;
    /**
     * Handles the mouse leave.
     * @return {boolean}
     * @private
     */
    mouseLeave(e: PointerEvent): boolean;
    /**
     * Handles the mouse leave on chart.
     * @return {boolean}
     * @private
     */
    chartOnMouseLeave(e: PointerEvent | TouchEvent): boolean;
    /**
     * Handles the mouse click on chart.
     * @return {boolean}
     * @private
     */
    chartOnMouseClick(e: PointerEvent | TouchEvent): boolean;
    private triggerPointEvent(event);
    /**
     * Handles the mouse move on chart.
     * @return {boolean}
     * @private
     */
    chartOnMouseMove(e: PointerEvent | TouchEvent): boolean;
    private titleTooltip(event, x, y, isTouch?);
    private axisTooltip(event, x, y, isTouch?);
    private findAxisLabel(text);
    /**
     * Handles the mouse down on chart.
     * @return {boolean}
     * @private
     */
    chartOnMouseDown(e: PointerEvent): boolean;
    /**
     * Handles the mouse up.
     * @return {boolean}
     * @private
     */
    mouseEnd(e: PointerEvent): boolean;
    /**
     * Handles the mouse up.
     * @return {boolean}
     * @private
     */
    chartOnMouseUp(e: PointerEvent | TouchEvent): boolean;
    /**
     * Method to set culture for chart
     */
    private setCulture();
    /**
     * Method to set the annotation content dynamically for chart.
     */
    setAnnotationValue(annotationIndex: number, content: string): void;
    /**
     * Method to set locale constants
     */
    private setLocaleConstants();
    /**
     * Theming for chart
     */
    private setTheme();
    /**
     * To provide the array of modules needed for control rendering
     * @return {base.ModuleDeclaration[]}
     * @private
     */
    requiredModules(): base.ModuleDeclaration[];
    private findAxisModule(modules);
    private findIndicatorModules(modules);
    private findTrendLineModules(modules);
    private findStriplineVisibility(striplines);
    /**
     * To Remove the SVG.
     * @return {boolean}
     * @private
     */
    removeSvg(): void;
    private refreshDefinition(definitions);
    /**
     * Refresh the axis default value.
     * @return {boolean}
     * @private
     */
    refreshAxis(): void;
    private axisChange(axis);
    /**
     * Called internally if any of the property value changed.
     * @private
     */
    onPropertyChanged(newProp: ChartModel, oldProp: ChartModel): void;
}
/**
 * Chart component exported items
 */
/**
 * `Legend` module is used to render legend for the chart.
 */
export  class Legend extends BaseLegend {
    constructor(chart: Chart);
    /**
     * Binding events for legend module.
     */
    private addEventListener();
    /**
     * UnBinding events for legend module.
     */
    private removeEventListener();
    /**
     * To handle mosue move for legend module
     */
    private mouseMove(e);
    /**
     * To handle mosue end for legend module
     */
    private mouseEnd(e);
    /**
     * Get the legend options.
     * @return {void}
     * @private
     */
    getLegendOptions(visibleSeriesCollection: Series[], chart: Chart): void;
    /** @private */
    getLegendBounds(availableSize: Size, legendBounds: Rect, legend: LegendSettingsModel): void;
    /** @private */
    getRenderPoint(legendOption: LegendOptions, start: ChartLocation, textPadding: number, prevLegend: LegendOptions, rect: Rect, count: number, firstLegend: number): void;
    /** @private */
    LegendClick(seriesIndex: number): void;
    private refreshSeries(seriesCollection);
    /**
     * To show the tooltip for the trimmed text in legend.
     * @return {void}
     */
    click(event: Event): void;
    /**
     * Get module name
     */
    protected getModuleName(): string;
    /**
     * To destroy the Legend.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * Interface for a class ChartAnnotationSettings
 */
export interface ChartAnnotationSettingsModel {
    /**
     * if set coordinateUnit as `Pixel` X specifies the axis value
     * else is specifies pixel or percentage of coordinate
     * @default 0
     */
    x?: string | Date | number;
    /**
     * if set coordinateUnit as `Pixel` Y specifies the axis value
     * else is specifies pixel or percentage of coordinate
     * @default 0
     */
    y?: string | number;
    /**
     * Content of the annotation, which accepts the id of the custom element.
     * @default null
     */
    content?: string;
    /**
     * Specifies the alignment of the annotation. They are
     * * Near - Align the annotation element as left side.
     * * Far - Align the annotation element as right side.
     * * Center - Align the annotation element as mid point.
     * @default 'Center'
     */
    horizontalAlignment?: Alignment;
    /**
     * Specifies the coordinate units of the annotation. They are
     * * Pixel - Annotation renders based on x and y pixel value.
     * * Point - Annotation renders based on x and y axis value.
     * @default 'Pixel'
     */
    coordinateUnits?: Units;
    /**
     * Specifies the regions of the annotation. They are
     * * Chart - Annotation renders based on chart coordinates.
     * * Series - Annotation renders based on series coordinates.
     * @default 'Chart'
     */
    region?: Regions;
    /**
     * Specifies the position of the annotation. They are
     * * Top - Align the annotation element as top side.
     * * Bottom - Align the annotation element as bottom side.
     * * Middle - Align the annotation element as mid point.
     * @default 'Middle'
     */
    verticalAlignment?: base.Position;
    /**
     * The name of horizontal axis associated with the annotation.
     * It requires `axes` of chart.
     * @default null
     */
    xAxisName?: string;
    /**
     * The name of vertical axis associated with the annotation.
     * It requires `axes` of chart.
     * @default null
     */
    yAxisName?: string;
    /**
     * Information about annotation for assistive technology.
     * @default null
     */
    description?: string;
}
/**
 * Interface for a class LabelBorder
 */
export interface LabelBorderModel {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default ''
     */
    color?: string;
    /**
     * The width of the border in pixels.
     * @default 1
     */
    width?: number;
    /**
     * base.Border type for labels
     * * Rectangle 
     * * Without Top base.Border
     * * Without Top and BottomBorder
     * * Without base.Border
     * * Brace
     * * CurlyBrace
     * @default 'Rectangle'
     */
    type?: BorderType;
}
/**
 * Interface for a class MultiLevelCategories
 */
export interface MultiLevelCategoriesModel {
    /**
     * Start value of the multi level labels
     * @default null
     */
    start?: number | Date | string;
    /**
     * End value of the multi level labels
     * @default null
     */
    end?: number | Date | string;
    /**
     * multi level labels text.
     * @default ''
     */
    text?: string;
    /**
     * Maximum width of the text for multi level labels.
     * @default null
     */
    maximumTextWidth?: number;
}
/**
 * Interface for a class StripLineSettings
 */
export interface StripLineSettingsModel {
    /**
     * If set true, strip line for axis renders.
     * @default true
     */
    visible?: boolean;
    /**
     *  If set true, strip line get render from axis origin.
     *  @default false
     */
    startFromAxis?: boolean;
    /**
     * Start value of the strip line.
     * @default null
     */
    start?: number | Date | string;
    /**
     * End value of the strip line.
     * @default null
     */
    end?: number | Date | string;
    /**
     * Size of the strip line, when it starts from the origin.
     * @default null
     */
    size?: number;
    /**
     * Color of the strip line.
     * @default '#808080'
     */
    color?: string;
    /**
     * base.Border of the strip line.
     */
    border?: BorderModel;
    /**
     * Strip line text.
     * @default ''
     */
    text?: string;
    /**
     * The angle to which the strip line text gets rotated.
     * @default null
     */
    rotation?: number;
    /**
     * Defines the position of the strip line text horizontally. They are, 
     * * Start: Places the strip line text at the start.
     * * Middle: Places the strip line text in the middle.
     * * End: Places the strip line text at the end.
     * @default 'Middle'
     */
    horizontalAlignment?: Anchor;
    /**
     * Defines the position of the strip line text vertically. They are, 
     * * Start: Places the strip line text at the start.
     * * Middle: Places the strip line text in the middle.
     * * End: Places the strip line text at the end.
     * @default 'Middle'
     */
    verticalAlignment?: Anchor;
    /**
     * Options to customize the strip line text.
     */
    textStyle?: FontModel;
    /**
     * Specifies the order of the strip line. They are,
     * * Behind: Places the strip line behind the series elements.
     * * Over: Places the strip line over the series elements.
     * @default 'Behind'
     */
    zIndex?: ZIndex;
    /**
     * Strip line Opacity
     * @default 1
     */
    opacity?: number;
}
/**
 * Interface for a class MultiLevelLabels
 */
export interface MultiLevelLabelsModel {
    /**
     * Defines the position of the multi level labels. They are, 
     * * Near: Places the multi level labels at Near.
     * * Center: Places the multi level labels at Center.
     * * Far: Places the multi level labels at Far.
     * @default 'Center'
     */
    alignment?: Alignment;
    /**
     * Defines the textOverFlow for multi level labels. They are, 
     * * Trim: Trim textOverflow for multi level labels.
     * * Wrap: Wrap textOverflow for multi level labels.
     * * none: None textOverflow for multi level labels.
     * @default 'Wrap'
     */
    overflow?: TextOverflow;
    /**
     * Options to customize the multi level labels.
     */
    textStyle?: FontModel;
    /**
     * base.Border of the multi level labels.
     */
    border?: LabelBorderModel;
    /**
     * multi level categories for multi level labels.
     */
    categories?: MultiLevelCategoriesModel[];
}
/**
 * Configures the Annotation for chart.
 */
export  class ChartAnnotationSettings extends base.ChildProperty<ChartAnnotationSettings> {
    /**
     * if set coordinateUnit as `Pixel` X specifies the axis value
     * else is specifies pixel or percentage of coordinate
     * @default 0
     */
    x: string | Date | number;
    /**
     * if set coordinateUnit as `Pixel` Y specifies the axis value
     * else is specifies pixel or percentage of coordinate
     * @default 0
     */
    y: string | number;
    /**
     * Content of the annotation, which accepts the id of the custom element.
     * @default null
     */
    content: string;
    /**
     * Specifies the alignment of the annotation. They are
     * * Near - Align the annotation element as left side.
     * * Far - Align the annotation element as right side.
     * * Center - Align the annotation element as mid point.
     * @default 'Center'
     */
    horizontalAlignment: Alignment;
    /**
     * Specifies the coordinate units of the annotation. They are
     * * Pixel - Annotation renders based on x and y pixel value.
     * * Point - Annotation renders based on x and y axis value.
     * @default 'Pixel'
     */
    coordinateUnits: Units;
    /**
     * Specifies the regions of the annotation. They are
     * * Chart - Annotation renders based on chart coordinates.
     * * Series - Annotation renders based on series coordinates.
     * @default 'Chart'
     */
    region: Regions;
    /**
     * Specifies the position of the annotation. They are
     * * Top - Align the annotation element as top side.
     * * Bottom - Align the annotation element as bottom side.
     * * Middle - Align the annotation element as mid point.
     * @default 'Middle'
     */
    verticalAlignment: Position;
    /**
     * The name of horizontal axis associated with the annotation.
     * It requires `axes` of chart.
     * @default null
     */
    xAxisName: string;
    /**
     * The name of vertical axis associated with the annotation.
     * It requires `axes` of chart.
     * @default null
     */
    yAxisName: string;
    /**
     * Information about annotation for assistive technology.
     * @default null
     */
    description: string;
}
/**
 * label border properties.
 */
export  class LabelBorder extends base.ChildProperty<LabelBorder> {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default ''
     */
    color: string;
    /**
     * The width of the border in pixels.
     * @default 1
     */
    width: number;
    /**
     * Border type for labels
     * * Rectangle
     * * Without Top Border
     * * Without Top and BottomBorder
     * * Without Border
     * * Brace
     * * CurlyBrace
     * @default 'Rectangle'
     */
    type: BorderType;
}
/**
 * categories for multi level labels
 */
export  class MultiLevelCategories extends base.ChildProperty<MultiLevelCategories> {
    /**
     * Start value of the multi level labels
     * @default null
     */
    start: number | Date | string;
    /**
     * End value of the multi level labels
     * @default null
     */
    end: number | Date | string;
    /**
     * multi level labels text.
     * @default ''
     */
    text: string;
    /**
     * Maximum width of the text for multi level labels.
     * @default null
     */
    maximumTextWidth: number;
}
/**
 * Strip line properties
 */
export  class StripLineSettings extends base.ChildProperty<StripLineSettings> {
    /**
     * If set true, strip line for axis renders.
     * @default true
     */
    visible: boolean;
    /**
     *  If set true, strip line get render from axis origin.
     *  @default false
     */
    startFromAxis: boolean;
    /**
     * Start value of the strip line.
     * @default null
     */
    start: number | Date | string;
    /**
     * End value of the strip line.
     * @default null
     */
    end: number | Date | string;
    /**
     * Size of the strip line, when it starts from the origin.
     * @default null
     */
    size: number;
    /**
     * Color of the strip line.
     * @default '#808080'
     */
    color: string;
    /**
     * Border of the strip line.
     */
    border: BorderModel;
    /**
     * Strip line text.
     * @default ''
     */
    text: string;
    /**
     * The angle to which the strip line text gets rotated.
     * @default null
     */
    rotation: number;
    /**
     * Defines the position of the strip line text horizontally. They are,
     * * Start: Places the strip line text at the start.
     * * Middle: Places the strip line text in the middle.
     * * End: Places the strip line text at the end.
     * @default 'Middle'
     */
    horizontalAlignment: Anchor;
    /**
     * Defines the position of the strip line text vertically. They are,
     * * Start: Places the strip line text at the start.
     * * Middle: Places the strip line text in the middle.
     * * End: Places the strip line text at the end.
     * @default 'Middle'
     */
    verticalAlignment: Anchor;
    /**
     * Options to customize the strip line text.
     */
    textStyle: FontModel;
    /**
     * Specifies the order of the strip line. They are,
     * * Behind: Places the strip line behind the series elements.
     * * Over: Places the strip line over the series elements.
     * @default 'Behind'
     */
    zIndex: ZIndex;
    /**
     * Strip line Opacity
     * @default 1
     */
    opacity: number;
}
/**
 * MultiLevelLabels properties
 */
export  class MultiLevelLabels extends base.ChildProperty<MultiLevelLabels[]> {
    /**
     * Defines the position of the multi level labels. They are,
     * * Near: Places the multi level labels at Near.
     * * Center: Places the multi level labels at Center.
     * * Far: Places the multi level labels at Far.
     * @default 'Center'
     */
    alignment: Alignment;
    /**
     * Defines the textOverFlow for multi level labels. They are,
     * * Trim: Trim textOverflow for multi level labels.
     * * Wrap: Wrap textOverflow for multi level labels.
     * * none: None textOverflow for multi level labels.
     * @default 'Wrap'
     */
    overflow: TextOverflow;
    /**
     * Options to customize the multi level labels.
     */
    textStyle: FontModel;
    /**
     * Border of the multi level labels.
     */
    border: LabelBorderModel;
    /**
     * multi level categories for multi level labels.
     */
    categories: MultiLevelCategoriesModel[];
}
/**
 * `AreaSeries` module is used to render the area series.
 */
export  class AreaSeries extends MultiColoredSeries {
    /**
     * Render Area series.
     * @return {void}
     * @private
     */
    render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
    /**
     * To destroy the area series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name
     */
    protected getModuleName(): string;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
}
/**
 * `BarSeries` module is used to render the bar series.
 */
export  class BarSeries extends ColumnBase {
    /**
     * Render Bar series.
     * @return {void}
     * @private
     */
    render(series: Series): void;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * To destroy the bar series.
     * @return {void}
     * @private
     */
    protected destroy(chart: Chart): void;
    /**
     * Get module name
     */
    protected getModuleName(): string;
}
/**
 * `BoxAndWhiskerSeries` module is used to render the box and whisker series.
 */
export  class BoxAndWhiskerSeries extends ColumnBase {
    /**
     * Render BoxAndWhisker series.
     * @return {void}
     * @private
     */
    render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
    /**
     * update the tip region fo box plot
     * @param series
     * @param point
     * @param sideBySideInfo
     */
    private updateTipRegion(series, point, sideBySideInfo);
    /**
     * Update tip size to tip regions
     * @param series
     * @param point
     * @param region
     * @param isInverted
     */
    private updateTipSize(series, point, region, isInverted);
    /**
     * Calculation for path direction performed here
     * @param point
     * @param series
     * @param median
     * @param average
     */
    getPathString(point: Points, series: Series, median: ChartLocation, average: ChartLocation): string;
    /**
     * Rendering for box and whisker append here.
     * @param series
     * @param point
     * @param rect
     * @param argsData
     * @param direction
     */
    renderBoxAndWhisker(series: Series, point: Points, rect: Rect, argsData: IPointRenderEventArgs, direction: string): void;
    /**
     * To find the box plot values
     * @param yValues
     * @param point
     * @param mode
     */
    findBoxPlotValues(yValues: number[], point: Points, mode: BoxPlotMode): void;
    /**
     * to find the exclusive quartile values
     * @param yValues
     * @param count
     * @param percentile
     */
    private getExclusiveQuartileValue(yValues, count, percentile);
    /**
     * to find the inclusive quartile values
     * @param yValues
     * @param count
     * @param percentile
     */
    private getInclusiveQuartileValue(yValues, count, percentile);
    /**
     * To find the quartile values
     * @param yValues
     * @param count
     * @param lowerQuartile
     * @param upperQuartile
     */
    private getQuartileValues(yValues, count, quartile);
    /**
     * To find the min, max and outlier values
     * @param yValues
     * @param lowerQuartile
     * @param upperQuartile
     * @param minimum
     * @param maximum
     * @param outliers
     */
    private getMinMaxOutlier(yValues, count, quartile);
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the candle series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * `BubbleSeries` module is used to render the bubble series.
 */
export  class BubbleSeries {
    /**
     * Render the Bubble series.
     * @return {void}
     * @private
     */
    render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
    /**
     * To destroy the Bubble.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
}
/**
 * `CandleSeries` module is used to render the candle series.
 */
export  class CandleSeries extends ColumnBase {
    /**
     * Render Candle series.
     * @return {void}
     * @private
     */
    render(series: Series): void;
    /**
     * Trigger point rendering event
     */
    protected triggerPointRenderEvent(series: Series, point: Points): IPointRenderEventArgs;
    /**
     * Find the color of the candle
     * @param series
     * @private
     */
    private getCandleColor(point, series);
    /**
     * Finds the path of the candle shape
     * @param Series
     * @private
     */
    getPathString(topRect: Rect, midRect: Rect, series: Series): string;
    /**
     * Draws the candle shape
     * @param series
     * @private
     */
    drawCandle(series: Series, point: Points, rect: Rect, argsData: IPointRenderEventArgs, direction: string): void;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the candle series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * Interface for a class DataLabelSettings
 */
export interface DataLabelSettingsModel {
    /**
     * If set true, data label for series renders.
     * @default false
     */
    visible?: boolean;
    /**
     * The DataSource field that contains the data label value.
     * @default null
     */
    name?: string;
    /**
     * The background color of the data label accepts value in hex and rgba as a valid CSS color string.
     * @default 'transparent'
     */
    fill?: string;
    /**
     * The opacity for the background.
     * @default 1
     */
    opacity?: number;
    /**
     * Specifies the position of the data label. They are,
     * * Outer: Positions the label outside the point.
     * * top: Positions the label on top of the point.
     * * Bottom: Positions the label at the bottom of the point.
     * * Middle: Positions the label to the middle of the point.
     * * Auto: Positions the label based on series.
     * @default 'Auto'
     */
    position?: LabelPosition;
    /**
     * The roundedCornerX for the data label. It requires `border` values not to be null.
     * @default 5
     */
    rx?: number;
    /**
     * The roundedCornerY for the data label. It requires `border` values not to be null.
     * @default 5
     */
    ry?: number;
    /**
     * Specifies the alignment for data Label. They are,
     * * Near: Aligns the label to the left of the point.
     * * Center: Aligns the label to the center of the point.
     * * Far: Aligns the label to the right of the point.
     * @default 'Center'
     */
    alignment?: Alignment;
    /**
     * Option for customizing the border lines.
     */
    border?: BorderModel;
    /**
     * base.Margin configuration for the data label.
     */
    margin?: MarginModel;
    /**
     * Option for customizing the data label text.
     */
    font?: FontModel;
    /**
     * Custom template to show the data label. Use ${point.x} and ${point.y} as a placeholder
     * text to display the corresponding data point.
     * @default null
     */
    template?: string;
}
/**
 * Interface for a class MarkerSettings
 */
export interface MarkerSettingsModel {
    /**
     * If set to true the marker for series is rendered. This is applicable only for line and area type series.
     * @default false
     */
    visible?: boolean;
    /**
     * The different shape of a marker:
     * * Circle
     * * Rectangle
     * * Triangle
     * * Diamond
     * * HorizontalLine
     * * VerticalLine
     * * Pentagon
     * * InvertedTriangle
     * * Image
     * @default 'Circle'
     */
    shape?: ChartShape;
    /**
     * The URL for the Image that is to be displayed as a marker.  It requires marker `shape` value to be an `Image`.
     * @default ''
     */
    imageUrl?: string;
    /**
     * The height of the marker in pixels.
     * @default 5
     */
    height?: number;
    /**
     * The width of the marker in pixels.
     * @default 5
     */
    width?: number;
    /**
     * Options for customizing the border of a marker.
     */
    border?: BorderModel;
    /**
     *  The fill color of the marker that accepts value in hex and rgba as a valid CSS color string. By default, it will take series' color.
     * @default null
     */
    fill?: string;
    /**
     * The opacity of the marker.
     * @default 1
     */
    opacity?: number;
    /**
     * The data label for the series.
     */
    dataLabel?: DataLabelSettingsModel;
}
/**
 * Interface for a class Points
 * @private
 */
export interface PointsModel {
}
/**
 * Interface for a class Trendline
 */
export interface TrendlineModel {
    /**
     * Defines the name of trendline
     * @default ''
     */
    name?: string;
    /**
     * Defines the type of the trendline
     * @default 'Linear'
     */
    type?: TrendlineTypes;
    /**
     * Defines the period, the price changes over which will be considered to predict moving average trend line
     * @default 2
     */
    period?: number;
    /**
     * Defines the polynomial order of the polynomial trendline
     * @default 2
     */
    polynomialOrder?: number;
    /**
     * Defines the period, by which the trend has to backward forecast
     * @default 0
     */
    backwardForecast?: number;
    /**
     * Defines the period, by which the trend has to forward forecast
     * @default 0
     */
    forwardForecast?: number;
    /**
     * Options to customize the animation for trendlines
     */
    animation?: AnimationModel;
    /**
     * Options to customize the marker for trendlines
     */
    marker?: MarkerSettingsModel;
    /**
     * Enables/disables tooltip for trendlines
     * @default true
     */
    enableTooltip?: boolean;
    /**
     * Defines the intercept of the trendline
     * @default null
     */
    intercept?: number;
    /**
     * Defines the fill color of trendline
     * @default ''
     */
    fill?: string;
    /**
     * Defines the width of the trendline
     * @default 1
     */
    width?: number;
    /**
     * Sets the legend shape of the trendline
     * @default 'SeriesType'
     */
    legendShape?: LegendShape;
}
/**
 * Interface for a class ErrorBarCapSettings
 */
export interface ErrorBarCapSettingsModel {
    /**
     * The width of the error bar in pixels.
     * @default 1
     */
    width?: number;
    /**
     * The length of the error bar in pixels.
     * @default 10
     */
    length?: number;
    /**
     *  The stroke color of the cap, which accepts value in hex, rgba as a valid CSS color string.
     * @default null
     */
    color?: string;
    /**
     * The opacity of the cap.
     * @default 1
     */
    opacity?: number;
}
/**
 * Interface for a class ChartSegment
 */
export interface ChartSegmentModel {
    /**
     * Defines the starting point of region.
     * @default null
     */
    value?: Object;
    /**
     * Defines the color of a region.
     * @default null
     */
    color?: string;
    /**
     * Defines the pattern of dashes and gaps to stroke.
     * @default '0'
     */
    dashArray?: string;
}
/**
 * Interface for a class ErrorBarSettings
 * @private
 */
export interface ErrorBarSettingsModel {
    /**
     * If set true, error bar for data gets rendered.
     * @default false
     */
    visible?: boolean;
    /**
     * The type of the error bar . They are
     * * Fixed -  Renders a fixed type error bar.
     * * Percentage - Renders a percentage type error bar.
     * * StandardDeviation - Renders a standard deviation type error bar.
     * * StandardError -Renders a standard error type error bar.
     * * Custom -Renders a custom type error bar.
     * @default 'Fixed'
     */
    type?: ErrorBarType;
    /**
     * The direction of the error bar . They are
     * * both -  Renders both direction of error bar.
     * * minus - Renders minus direction of error bar.
     * * plus - Renders plus direction error bar.
     * @default 'Both'
     */
    direction?: ErrorBarDirection;
    /**
     * The mode of the error bar . They are
     * * Vertical -  Renders a vertical error bar.
     * * Horizontal - Renders a horizontal error bar.
     * * Both - Renders both side error bar.
     * @default 'Vertical'
     */
    mode?: ErrorBarMode;
    /**
     *  The color for stroke of the error bar, which accepts value in hex, rgba as a valid CSS color string.
     * @default null
     */
    color?: string;
    /**
     * The vertical error of the error bar.
     * @default 1
     */
    verticalError?: number;
    /**
     * The stroke width of the error bar..
     * @default 1
     */
    width?: number;
    /**
     * The horizontal error of the error bar.
     * @default 1
     */
    horizontalError?: number;
    /**
     * The vertical positive error of the error bar.
     * @default 3
     */
    verticalPositiveError?: number;
    /**
     * The vertical negative error of the error bar.
     * @default 3
     */
    verticalNegativeError?: number;
    /**
     * The horizontal positive error of the error bar.
     * @default 1
     */
    horizontalPositiveError?: number;
    /**
     * The horizontal negative error of the error bar.
     * @default 1
     */
    horizontalNegativeError?: number;
    /**
     * Options for customizing the cap of the error bar.
     */
    errorBarCap?: ErrorBarCapSettingsModel;
}
/**
 * Interface for a class SeriesBase
 */
export interface SeriesBaseModel {
    /**
     * The DataSource field that contains the x value.
     * It is applicable for series and technical indicators
     * @default ''
     */
    xName?: string;
    /**
     * The DataSource field that contains the high value of y
     * It is applicable for series and technical indicators
     * @default ''
     */
    high?: string;
    /**
     * The DataSource field that contains the low value of y
     * It is applicable for series and technical indicators
     * @default ''
     */
    low?: string;
    /**
     * The DataSource field that contains the open value of y
     * It is applicable for series and technical indicators
     * @default ''
     */
    open?: string;
    /**
     * The DataSource field that contains the close value of y
     * It is applicable for series and technical indicators
     * @default ''
     */
    close?: string;
    /**
     * Defines the data source field that contains the volume value in candle charts
     * It is applicable for financial series and technical indicators
     * @default ''
     */
    volume?: string;
    /**
     * The DataSource field that contains the color value of point
     * It is applicable for series
     * @default ''
     */
    pointColorMapping?: string;
    /**
     * The name of the horizontal axis associated with the series. It requires `axes` of the chart.
     * It is applicable for series and technical indicators
     * ```html
     * <div id='base.Chart'></div>
     * ```
     * ```typescript
     * let chart: base.Chart = new base.Chart({
     * ...
     *     columns: [{ width: '50%' },
     *               { width: '50%' }],
     *     axes: [{
     *                name: 'xAxis 1',
     *                columnIndex: 1,
     *            }],
     *     series: [{
     *                dataSource: data,
     *                xName: 'x', yName: 'y',
     *                xAxisName: 'xAxis 1',
     *     }],
     * });
     * chart.appendTo('#base.Chart');
     * ```
     * @default null
     */
    xAxisName?: string;
    /**
     * The name of the vertical axis associated with the series. It requires `axes` of the chart.
     * It is applicable for series and technical indicators
     * ```html
     * <div id='base.Chart'></div>
     * ```
     * ```typescript
     * let chart: base.Chart = new base.Chart({
     * ...
     *     rows: [{ height: '50%' },
     *            { height: '50%' }],
     *     axes: [{
     *                name: 'yAxis 1',
     *                rowIndex: 1,
     *            }],
     *     series: [{
     *                dataSource: data,
     *                xName: 'x', yName: 'y',
     *                yAxisName: 'yAxis 1'
     *     }],
     * });
     * chart.appendTo('#base.Chart');
     * ```
     * @default null
     */
    yAxisName?: string;
    /**
     * Options to customizing animation for the series.
     */
    animation?: AnimationModel;
    /**
     * The fill color for the series that accepts value in hex and rgba as a valid CSS color string.
     * It also represents the color of the signal lines in technical indicators.
     * For technical indicators, the default value is 'blue' and for series, it has null.
     * @default null
     */
    fill?: string;
    /**
     * The stroke width for the series that is applicable only for `Line` type series.
     * It also represents the stroke width of the signal lines in technical indicators.
     * @default 1
     */
    width?: number;
    /**
     * Defines the pattern of dashes and gaps to stroke the lines in `Line` type series.
     * @default '0'
     */
    dashArray?: string;
    /**
     * Specifies the DataSource for the series. It can be an array of JSON objects or an instance of data.DataManager.
     * ```html
     * <div id='base.Chart'></div>
     * ```
     * ```typescript
     * let dataManager: data.DataManager = new data.DataManager({
     *         url: 'http://mvc.syncfusion.com/Services/Northwnd.svc/Tasks/'
     * });
     * let query: data.Query = new data.Query().take(50).where('Estimate', 'greaterThan', 0, false);
     * let chart: base.Chart = new base.Chart({
     * ...
     *     series: [{
     *        dataSource: dataManager,
     *        xName: 'Id',
     *        yName: 'Estimate',
     *        query: query
     *    }],
     * ...
     * });
     * chart.appendTo('#base.Chart');
     * ```
     * @default ''
     */
    dataSource?: Object | data.DataManager;
    /**
     * Specifies query to select data from DataSource. This property is applicable only when the DataSource is `ej.data.DataManager`.
     * @default null
     */
    query?: data.Query;
    /**
     * Defines the collection of regions that helps to differentiate a line series.
     */
    segments?: ChartSegmentModel[];
    /**
     * Defines the axis, based on which the line series will be split.
     */
    segmentAxis?: Segment;
}
/**
 * Interface for a class Series
 */
export interface SeriesModel extends SeriesBaseModel{
    /**
     * The name of the series visible in legend.
     * @default ''
     */
    name?: string;
    /**
     * The DataSource field that contains the y value.
     * @default ''
     */
    yName?: string;
    /**
     * Type of series to be drawn in radar or polar series. They are
     *  'Line'
     *  'base.Column'
     *  'Area'
     *  'Scatter'
     *  'Spline'
     *  'StackingColumn'
     *  'StackingArea'
     *  'RangeColumn'
     *  'SplineArea'
     * @default 'Line'
     */
    drawType?: ChartDrawType;
    /**
     * Specifies whether to join start and end point of a line/area series used in polar/radar chart to form a closed path.
     * @default true
     */
    isClosed?: boolean;
    /**
     * This property is used in financial charts to visualize the price movements in stock.
     * It defines the color of the candle/point, when the opening price is less than the closing price.
     * @default '#2ecd71'
     */
    bearFillColor?: string;
    /**
     * This property is used in financial charts to visualize the price movements in stock.
     * It defines the color of the candle/point, when the opening price is higher than the closing price.
     * @default '#e74c3d'
     */
    bullFillColor?: string;
    /**
     * This property is applicable for candle series.
     * It enables/disables to visually compare the current values with the previous values in stock.
     * @default false
     */
    enableSolidCandles?: boolean;
    /**
     * The DataSource field that contains the size value of y
     * @default ''
     */
    size?: string;
    /**
     * This property allows grouping series in `stacked column / bar` charts.
     * Any string value can be provided to the stackingGroup property.
     * If any two or above series have the same value, those series will be grouped together.
     * @default ''
     */
    stackingGroup?: string;
    /**
     * Specifies the visibility of series.
     * @default true
     */
    visible?: boolean;
    /**
     * Options to customizing the border of the series. This is applicable only for `base.Column` and `Bar` type series.
     */
    border?: BorderModel;
    /**
     * The opacity of the series.
     * @default 1
     */
    opacity?: number;
    /**
     * The type of the series are
     * * Line
     * * base.Column
     * * Area
     * * Bar
     * * StackingColumn
     * * StackingArea
     * * StackingBar
     * * StepLine
     * * StepArea
     * * Scatter
     * * Spline
     * * StackingColumn100
     * * StackingBar100
     * * StackingArea100
     * * RangeColumn
     * * Hilo
     * * HiloOpenClose
     * * Waterfall
     * * RangeArea
     * * Bubble
     * * Candle
     * * Polar
     * * Radar
     * * BoxAndWhisker
     * @default 'Line'
     */
    type?: ChartSeriesType;
    /**
     * Options for displaying and customizing error bar for individual point in a series.
     */
    errorBar?: ErrorBarSettingsModel;
    /**
     * Options for displaying and customizing markers for individual points in a series.
     */
    marker?: MarkerSettingsModel;
    /**
     * Defines the collection of trendlines that are used to predict the trend
     */
    trendlines?: TrendlineModel[];
    /**
     * If set true, the Tooltip for series will be visible.
     * @default true
     */
    enableTooltip?: boolean;
    /**
     * The shape of the legend. Each series has its own legend shape. They are,
     * * Circle
     * * Rectangle
     * * Triangle
     * * Diamond
     * * Cross
     * * HorizontalLine
     * * VerticalLine
     * * Pentagon
     * * InvertedTriangle
     * * SeriesType
     * @default 'SeriesType'
     */
    legendShape?: LegendShape;
    /**
     * Custom style for the selected series or points.
     * @default null
     */
    selectionStyle?: string;
    /**
     * Minimum radius
     * @default 1
     */
    minRadius?: number;
    /**
     * Maximum radius
     * @default 3
     */
    maxRadius?: number;
    /**
     * Defines type of spline to be rendered.
     * @default 'Natural'
     */
    splineType?: SplineType;
    /**
     * It defines tension of cardinal spline types
     * @default 0.5
     */
    cardinalSplineTension?: number;
    /**
     * options to customize the empty points in series
     */
    emptyPointSettings?: EmptyPointSettingsModel;
    /**
     * If set true, the mean value for box and whisker will be visible.
     * @default true
     */
    showMean?: boolean;
    /**
     * The mode of the box and whisker char series. They are,
     * Exclusive
     * Inclusive
     * Normal
     * @default 'Normal'
     */
    boxPlotMode?: BoxPlotMode;
    /**
     * To render the column series points with particular column width.
     * @default 0.7
     */
    columnWidth?: number;
    /**
     * To render the column series points with particular column spacing. It takes value from 0 - 1.
     * @default 0
     */
    columnSpacing?: number;
    /**
     * Defines the visual representation of the negative changes in waterfall charts.
     * @default '#C64E4A'
     */
    negativeFillColor?: string;
    /**
     * Defines the visual representation of the summaries in waterfall charts.
     * @default '#4E81BC'
     */
    summaryFillColor?: string;
    /**
     * Defines the collection of indexes of the intermediate summary columns in waterfall charts.
     * @default []
     */
    intermediateSumIndexes?: number[];
    /**
     * Defines the collection of indexes of the overall summary columns in waterfall charts.
     * @default []
     */
    sumIndexes?: number[];
    /**
     * Defines the appearance of line connecting adjacent points in waterfall charts.
     */
    connector?: ConnectorModel;
    /**
     * To render the column series points with particular rounded corner.
     */
    cornerRadius?: CornerRadiusModel;
}
/**
 * Configures the data label in the series.
 */
export  class DataLabelSettings extends base.ChildProperty<DataLabelSettings> {
    /**
     * If set true, data label for series renders.
     * @default false
     */
    visible: boolean;
    /**
     * The DataSource field that contains the data label value.
     * @default null
     */
    name: string;
    /**
     * The background color of the data label accepts value in hex and rgba as a valid CSS color string.
     * @default 'transparent'
     */
    fill: string;
    /**
     * The opacity for the background.
     * @default 1
     */
    opacity: number;
    /**
     * Specifies the position of the data label. They are,
     * * Outer: Positions the label outside the point.
     * * top: Positions the label on top of the point.
     * * Bottom: Positions the label at the bottom of the point.
     * * Middle: Positions the label to the middle of the point.
     * * Auto: Positions the label based on series.
     * @default 'Auto'
     */
    position: LabelPosition;
    /**
     * The roundedCornerX for the data label. It requires `border` values not to be null.
     * @default 5
     */
    rx: number;
    /**
     * The roundedCornerY for the data label. It requires `border` values not to be null.
     * @default 5
     */
    ry: number;
    /**
     * Specifies the alignment for data Label. They are,
     * * Near: Aligns the label to the left of the point.
     * * Center: Aligns the label to the center of the point.
     * * Far: Aligns the label to the right of the point.
     * @default 'Center'
     */
    alignment: Alignment;
    /**
     * Option for customizing the border lines.
     */
    border: BorderModel;
    /**
     * Margin configuration for the data label.
     */
    margin: MarginModel;
    /**
     * Option for customizing the data label text.
     */
    font: FontModel;
    /**
     * Custom template to show the data label. Use ${point.x} and ${point.y} as a placeholder
     * text to display the corresponding data point.
     * @default null
     */
    template: string;
}
/**
 *  Configures the marker in the series.
 */
export  class MarkerSettings extends base.ChildProperty<MarkerSettings> {
    /**
     * If set to true the marker for series is rendered. This is applicable only for line and area type series.
     * @default false
     */
    visible: boolean;
    /**
     * The different shape of a marker:
     * * Circle
     * * Rectangle
     * * Triangle
     * * Diamond
     * * HorizontalLine
     * * VerticalLine
     * * Pentagon
     * * InvertedTriangle
     * * Image
     * @default 'Circle'
     */
    shape: ChartShape;
    /**
     * The URL for the Image that is to be displayed as a marker.  It requires marker `shape` value to be an `Image`.
     * @default ''
     */
    imageUrl: string;
    /**
     * The height of the marker in pixels.
     * @default 5
     */
    height: number;
    /**
     * The width of the marker in pixels.
     * @default 5
     */
    width: number;
    /**
     * Options for customizing the border of a marker.
     */
    border: BorderModel;
    /**
     *  The fill color of the marker that accepts value in hex and rgba as a valid CSS color string. By default, it will take series' color.
     * @default null
     */
    fill: string;
    /**
     * The opacity of the marker.
     * @default 1
     */
    opacity: number;
    /**
     * The data label for the series.
     */
    dataLabel: DataLabelSettingsModel;
}
/**
 * Points model for the series.
 * @private
 */
export  class Points {
    x: Object;
    y: Object;
    visible: boolean;
    text: string;
    color: string;
    open: Object;
    close: Object;
    symbolLocations: ChartLocation[];
    xValue: number;
    yValue: number;
    index: number;
    regions: Rect[];
    percent: string;
    high: Object;
    low: Object;
    volume: Object;
    size: Object;
    isEmpty: boolean;
    regionData: PolarArc;
    minimum: number;
    maximum: number;
    upperQuartile: number;
    lowerQuartile: number;
    median: number;
    outliers: number[];
    average: number;
    error: number;
    interior: string;
    marker: MarkerSettingsModel;
}
/**
 * Defines the behavior of the Trendlines
 */
export  class Trendline extends base.ChildProperty<Trendline> {
    /**
     * Defines the name of trendline
     * @default ''
     */
    name: string;
    /**
     * Defines the type of the trendline
     * @default 'Linear'
     */
    type: TrendlineTypes;
    /**
     * Defines the period, the price changes over which will be considered to predict moving average trend line
     * @default 2
     */
    period: number;
    /**
     * Defines the polynomial order of the polynomial trendline
     * @default 2
     */
    polynomialOrder: number;
    /**
     * Defines the period, by which the trend has to backward forecast
     * @default 0
     */
    backwardForecast: number;
    /**
     * Defines the period, by which the trend has to forward forecast
     * @default 0
     */
    forwardForecast: number;
    /**
     * Options to customize the animation for trendlines
     */
    animation: AnimationModel;
    /**
     * Options to customize the marker for trendlines
     */
    marker: MarkerSettingsModel;
    /**
     * Enables/disables tooltip for trendlines
     * @default true
     */
    enableTooltip: boolean;
    /**
     * Defines the intercept of the trendline
     * @default null
     */
    intercept: number;
    /**
     * Defines the fill color of trendline
     * @default ''
     */
    fill: string;
    /**
     * Defines the width of the trendline
     * @default 1
     */
    width: number;
    /**
     * Sets the legend shape of the trendline
     * @default 'SeriesType'
     */
    legendShape: LegendShape;
    /** @private */
    targetSeries: Series;
    /** @private */
    trendLineElement: Element;
    /** @private */
    points: Points[];
    /** @private */
    clipRectElement: Element;
    /** @private */
    clipRect: Rect;
    /** @private */
    polynomialSlopes: number[];
    /** @private */
    sourceIndex: number;
    /** @private */
    index: number;
    /** @private */
    setDataSource(series: Series, chart: Chart): void;
}
/**
 * Configures Error bar in series.
 */
export  class ErrorBarCapSettings extends base.ChildProperty<ErrorBarCapSettings> {
    /**
     * The width of the error bar in pixels.
     * @default 1
     */
    width: number;
    /**
     * The length of the error bar in pixels.
     * @default 10
     */
    length: number;
    /**
     *  The stroke color of the cap, which accepts value in hex, rgba as a valid CSS color string.
     * @default null
     */
    color: string;
    /**
     * The opacity of the cap.
     * @default 1
     */
    opacity: number;
}
export  class ChartSegment extends base.ChildProperty<ChartSegment> {
    /**
     * Defines the starting point of region.
     * @default null
     */
    value: Object;
    /**
     * Defines the color of a region.
     * @default null
     */
    color: string;
    /**
     * Defines the pattern of dashes and gaps to stroke.
     * @default '0'
     */
    dashArray: string;
    /** @private */
    startValue: number;
    /** @private */
    endValue: number;
}
export  class ErrorBarSettings extends base.ChildProperty<ErrorBarSettings> {
    /**
     * If set true, error bar for data gets rendered.
     * @default false
     */
    visible: boolean;
    /**
     * The type of the error bar . They are
     * * Fixed -  Renders a fixed type error bar.
     * * Percentage - Renders a percentage type error bar.
     * * StandardDeviation - Renders a standard deviation type error bar.
     * * StandardError -Renders a standard error type error bar.
     * * Custom -Renders a custom type error bar.
     * @default 'Fixed'
     */
    type: ErrorBarType;
    /**
     * The direction of the error bar . They are
     * * both -  Renders both direction of error bar.
     * * minus - Renders minus direction of error bar.
     * * plus - Renders plus direction error bar.
     * @default 'Both'
     */
    direction: ErrorBarDirection;
    /**
     * The mode of the error bar . They are
     * * Vertical -  Renders a vertical error bar.
     * * Horizontal - Renders a horizontal error bar.
     * * Both - Renders both side error bar.
     * @default 'Vertical'
     */
    mode: ErrorBarMode;
    /**
     *  The color for stroke of the error bar, which accepts value in hex, rgba as a valid CSS color string.
     * @default null
     */
    color: string;
    /**
     * The vertical error of the error bar.
     * @default 1
     */
    verticalError: number;
    /**
     * The stroke width of the error bar..
     * @default 1
     */
    width: number;
    /**
     * The horizontal error of the error bar.
     * @default 1
     */
    horizontalError: number;
    /**
     * The vertical positive error of the error bar.
     * @default 3
     */
    verticalPositiveError: number;
    /**
     * The vertical negative error of the error bar.
     * @default 3
     */
    verticalNegativeError: number;
    /**
     * The horizontal positive error of the error bar.
     * @default 1
     */
    horizontalPositiveError: number;
    /**
     * The horizontal negative error of the error bar.
     * @default 1
     */
    horizontalNegativeError: number;
    /**
     * Options for customizing the cap of the error bar.
     */
    errorBarCap: ErrorBarCapSettingsModel;
}
/**
 * Defines the common behavior of Series and Technical Indicators
 */
export  class SeriesBase extends base.ChildProperty<SeriesBase> {
    /**
     * The DataSource field that contains the x value.
     * It is applicable for series and technical indicators
     * @default ''
     */
    xName: string;
    /**
     * The DataSource field that contains the high value of y
     * It is applicable for series and technical indicators
     * @default ''
     */
    high: string;
    /**
     * The DataSource field that contains the low value of y
     * It is applicable for series and technical indicators
     * @default ''
     */
    low: string;
    /**
     * The DataSource field that contains the open value of y
     * It is applicable for series and technical indicators
     * @default ''
     */
    open: string;
    /**
     * The DataSource field that contains the close value of y
     * It is applicable for series and technical indicators
     * @default ''
     */
    close: string;
    /**
     * Defines the data source field that contains the volume value in candle charts
     * It is applicable for financial series and technical indicators
     * @default ''
     */
    volume: string;
    /**
     * The DataSource field that contains the color value of point
     * It is applicable for series
     * @default ''
     */
    pointColorMapping: string;
    /**
     * The name of the horizontal axis associated with the series. It requires `axes` of the chart.
     * It is applicable for series and technical indicators
     * ```html
     * <div id='Chart'></div>
     * ```
     * ```typescript
     * let chart: Chart = new Chart({
     * ...
     *     columns: [{ width: '50%' },
     *               { width: '50%' }],
     *     axes: [{
     *                name: 'xAxis 1',
     *                columnIndex: 1,
     *            }],
     *     series: [{
     *                dataSource: data,
     *                xName: 'x', yName: 'y',
     *                xAxisName: 'xAxis 1',
     *     }],
     * });
     * chart.appendTo('#Chart');
     * ```
     * @default null
     */
    xAxisName: string;
    /**
     * The name of the vertical axis associated with the series. It requires `axes` of the chart.
     * It is applicable for series and technical indicators
     * ```html
     * <div id='Chart'></div>
     * ```
     * ```typescript
     * let chart: Chart = new Chart({
     * ...
     *     rows: [{ height: '50%' },
     *            { height: '50%' }],
     *     axes: [{
     *                name: 'yAxis 1',
     *                rowIndex: 1,
     *            }],
     *     series: [{
     *                dataSource: data,
     *                xName: 'x', yName: 'y',
     *                yAxisName: 'yAxis 1'
     *     }],
     * });
     * chart.appendTo('#Chart');
     * ```
     * @default null
     */
    yAxisName: string;
    /**
     * Options to customizing animation for the series.
     */
    animation: AnimationModel;
    /**
     * The fill color for the series that accepts value in hex and rgba as a valid CSS color string.
     * It also represents the color of the signal lines in technical indicators.
     * For technical indicators, the default value is 'blue' and for series, it has null.
     * @default null
     */
    fill: string;
    /**
     * The stroke width for the series that is applicable only for `Line` type series.
     * It also represents the stroke width of the signal lines in technical indicators.
     * @default 1
     */
    width: number;
    /**
     * Defines the pattern of dashes and gaps to stroke the lines in `Line` type series.
     * @default '0'
     */
    dashArray: string;
    /**
     * Specifies the DataSource for the series. It can be an array of JSON objects or an instance of data.DataManager.
     * ```html
     * <div id='Chart'></div>
     * ```
     * ```typescript
     * let dataManager: data.DataManager = new data.DataManager({
     *         url: 'http://mvc.syncfusion.com/Services/Northwnd.svc/Tasks/'
     * });
     * let query: data.Query = new data.Query().take(50).where('Estimate', 'greaterThan', 0, false);
     * let chart: Chart = new Chart({
     * ...
     *     series: [{
     *        dataSource: dataManager,
     *        xName: 'Id',
     *        yName: 'Estimate',
     *        query: query
     *    }],
     * ...
     * });
     * chart.appendTo('#Chart');
     * ```
     * @default ''
     */
    dataSource: Object | data.DataManager;
    /**
     * Specifies query to select data from DataSource. This property is applicable only when the DataSource is `ej.data.DataManager`.
     * @default null
     */
    query: data.Query;
    /**
     * Defines the collection of regions that helps to differentiate a line series.
     */
    segments: ChartSegmentModel[];
    /**
     * Defines the axis, based on which the line series will be split.
     */
    segmentAxis: Segment;
    /**
     * Process data for the series.
     * @hidden
     */
    processJsonData(): void;
    private pushData(point, i);
    /** @private */
    protected dataPoint(i: number, textMappingName: string): Points;
    /**
     * To set empty point value based on empty point mode
     * @private
     */
    setEmptyPoint(point: Points, i: number): void;
    private findVisibility(point);
    /**
     * To get Y min max for the provided point seriesType XY
     */
    private setXYMinMax(yValue);
    /**
     * To get Y min max for the provided point seriesType XY
     */
    private setHiloMinMax(high, low);
    /**
     * Finds the type of the series
     * @private
     */
    private getSeriesType();
    /** @private */
    protected pushCategoryData(point: Points, index: number, pointX: string): void;
    /**
     * To find average of given property
     */
    private getAverage(member, i, data?);
    /**
     * To find the control points for spline.
     * @return {void}
     * @private
     */
    refreshDataManager(chart: Chart): void;
    private dataManagerSuccess(e, chart, isRemoteData?);
    private refreshChart(isRemoteData);
    /** @private */
    xMin: number;
    /** @private */
    xMax: number;
    /** @private */
    yMin: number;
    /** @private */
    yMax: number;
    /** @private */
    xAxis: Axis;
    /** @private */
    yAxis: Axis;
    /** @private */
    chart: Chart;
    /** @private */
    currentViewData: Object;
    /** @private */
    clipRect: Rect;
    /** @private */
    xData: number[];
    /** @private */
    yData: number[];
    /** @private */
    index: number;
    /** @private */
    dataModule: Data;
    /** @private */
    points: Points[];
    /** @private */
    seriesType: SeriesValueType;
    /** @private */
    sizeMax: number;
    /** @private */
    private recordsCount;
}
/**
 *  Configures the series in charts.
 */
export  class Series extends SeriesBase {
    /**
     * The name of the series visible in legend.
     * @default ''
     */
    name: string;
    /**
     * The DataSource field that contains the y value.
     * @default ''
     */
    yName: string;
    /**
     * Type of series to be drawn in radar or polar series. They are
     *  'Line'
     *  'Column'
     *  'Area'
     *  'Scatter'
     *  'Spline'
     *  'StackingColumn'
     *  'StackingArea'
     *  'RangeColumn'
     *  'SplineArea'
     * @default 'Line'
     */
    drawType: ChartDrawType;
    /**
     * Specifies whether to join start and end point of a line/area series used in polar/radar chart to form a closed path.
     * @default true
     */
    isClosed: boolean;
    /**
     * This property is used in financial charts to visualize the price movements in stock.
     * It defines the color of the candle/point, when the opening price is less than the closing price.
     * @default '#2ecd71'
     */
    bearFillColor: string;
    /**
     * This property is used in financial charts to visualize the price movements in stock.
     * It defines the color of the candle/point, when the opening price is higher than the closing price.
     * @default '#e74c3d'
     */
    bullFillColor: string;
    /**
     * This property is applicable for candle series.
     * It enables/disables to visually compare the current values with the previous values in stock.
     * @default false
     */
    enableSolidCandles: boolean;
    /**
     * The DataSource field that contains the size value of y
     * @default ''
     */
    size: string;
    /**
     * This property allows grouping series in `stacked column / bar` charts.
     * Any string value can be provided to the stackingGroup property.
     * If any two or above series have the same value, those series will be grouped together.
     * @default ''
     */
    stackingGroup: string;
    /**
     * Specifies the visibility of series.
     * @default true
     */
    visible: boolean;
    /**
     * Options to customizing the border of the series. This is applicable only for `Column` and `Bar` type series.
     */
    border: BorderModel;
    /**
     * The opacity of the series.
     * @default 1
     */
    opacity: number;
    /**
     * The type of the series are
     * * Line
     * * Column
     * * Area
     * * Bar
     * * StackingColumn
     * * StackingArea
     * * StackingBar
     * * StepLine
     * * StepArea
     * * Scatter
     * * Spline
     * * StackingColumn100
     * * StackingBar100
     * * StackingArea100
     * * RangeColumn
     * * Hilo
     * * HiloOpenClose
     * * Waterfall
     * * RangeArea
     * * Bubble
     * * Candle
     * * Polar
     * * Radar
     * * BoxAndWhisker
     * @default 'Line'
     */
    type: ChartSeriesType;
    /**
     * Options for displaying and customizing error bar for individual point in a series.
     */
    errorBar: ErrorBarSettingsModel;
    /**
     * Options for displaying and customizing markers for individual points in a series.
     */
    marker: MarkerSettingsModel;
    /**
     * Defines the collection of trendlines that are used to predict the trend
     */
    trendlines: TrendlineModel[];
    /**
     * If set true, the Tooltip for series will be visible.
     * @default true
     */
    enableTooltip: boolean;
    /**
     * The shape of the legend. Each series has its own legend shape. They are,
     * * Circle
     * * Rectangle
     * * Triangle
     * * Diamond
     * * Cross
     * * HorizontalLine
     * * VerticalLine
     * * Pentagon
     * * InvertedTriangle
     * * SeriesType
     * @default 'SeriesType'
     */
    legendShape: LegendShape;
    /**
     * Custom style for the selected series or points.
     * @default null
     */
    selectionStyle: string;
    /**
     * Minimum radius
     * @default 1
     */
    minRadius: number;
    /**
     * Maximum radius
     * @default 3
     */
    maxRadius: number;
    /**
     * Defines type of spline to be rendered.
     * @default 'Natural'
     */
    splineType: SplineType;
    /**
     * It defines tension of cardinal spline types
     * @default 0.5
     */
    cardinalSplineTension: number;
    /**
     * options to customize the empty points in series
     */
    emptyPointSettings: EmptyPointSettingsModel;
    /**
     * If set true, the mean value for box and whisker will be visible.
     * @default true
     */
    showMean: boolean;
    /**
     * The mode of the box and whisker char series. They are,
     * Exclusive
     * Inclusive
     * Normal
     * @default 'Normal'
     */
    boxPlotMode: BoxPlotMode;
    /**
     * To render the column series points with particular column width.
     * @default 0.7
     */
    columnWidth: number;
    /**
     * To render the column series points with particular column spacing. It takes value from 0 - 1.
     * @default 0
     */
    columnSpacing: number;
    /**
     * Defines the visual representation of the negative changes in waterfall charts.
     * @default '#C64E4A'
     */
    negativeFillColor: string;
    /**
     * Defines the visual representation of the summaries in waterfall charts.
     * @default '#4E81BC'
     */
    summaryFillColor: string;
    /**
     * Defines the collection of indexes of the intermediate summary columns in waterfall charts.
     * @default []
     */
    intermediateSumIndexes: number[];
    /**
     * Defines the collection of indexes of the overall summary columns in waterfall charts.
     * @default []
     */
    sumIndexes: number[];
    /**
     * Defines the appearance of line connecting adjacent points in waterfall charts.
     */
    connector: ConnectorModel;
    /**
     * To render the column series points with particular rounded corner.
     */
    cornerRadius: CornerRadiusModel;
    visibleSeriesCount: number;
    /** @private */
    position: number;
    /** @private */
    rectCount: number;
    /** @private */
    seriesElement: Element;
    /** @private */
    errorBarElement: Element;
    /** @private */
    symbolElement: Element;
    /** @private */
    shapeElement: Element;
    /** @private */
    textElement: Element;
    /** @private */
    pathElement: Element;
    /** @private */
    sourceIndex: number;
    /** @private */
    category: SeriesCategories;
    /** @private */
    isRectSeries: boolean;
    /** @private */
    clipRectElement: Element;
    /** @private */
    stackedValues: StackValues;
    /** @private */
    interior: string;
    /** @private */
    drawPoints: ControlPoints[];
    /** @private */
    delayedAnimation: boolean;
    constructor(parent: any, propName: string, defaultValue: Object, isArray?: boolean);
    /**
     * Refresh the axis label.
     * @return {boolean}
     * @private
     */
    refreshAxisLabel(): void;
    /**
     * To get the series collection.
     * @return {void}
     * @private
     */
    findSeriesCollection(column: Column, row: Row, isStack: boolean): Series[];
    /**
     * To get the column type series.
     * @return {void}
     * @private
     */
    private rectSeriesInChart(series, isStack);
    /**
     * To calculate the stacked values.
     * @return {void}
     * @private
     */
    calculateStackedValue(isStacking100: boolean, chart: Chart): void;
    private calculateStackingValues(seriesCollection, isStacking100);
    private findFrequencies(seriesCollection);
    /**
     * To find the log values.
     * @return {void}
     * @private
     */
    logWithIn(value: number, axis: Axis): number;
    /** @private */
    renderSeries(chart: Chart, index: number): void;
    /**
     * To create seris element.
     * @return {void}
     * @private
     */
    createSeriesElements(chart: Chart): void;
    /**
     * To append the series.
     * @return {void}
     * @private
     */
    appendSeriesElement(element: Element, chart: Chart): void;
    /**
     * To perform animation for chart series.
     * @return {void}
     * @private
     */
    performAnimation(chart: Chart, type: string, errorBar: ErrorBarSettingsModel, marker: MarkerSettingsModel, dataLabel: DataLabelSettingsModel): void;
    /**
     * To set border color for empty point
     * @private
     */
    setPointColor(point: Points, color: string): string;
    /**
     * To set border color for empty point
     * @private
     */
    setBorderColor(point: Points, border: BorderModel): BorderModel;
}
/**
 * Column Series Base
 */
export  class ColumnBase {
    /**
     * To get the position of the column series.
     * @return {DoubleRange}
     * @private
     */
    protected getSideBySideInfo(series: Series): DoubleRange;
    /**
     * To get the rect values.
     * @return {Rect}
     * @private
     */
    protected getRectangle(x1: number, y1: number, x2: number, y2: number, series: Series): Rect;
    /**
     * To get the position of each series.
     * @return {void}
     * @private
     */
    private getSideBySidePositions(series);
    private findRectPosition(seriesCollection);
    /**
     * Updates the symbollocation for points
     * @return void
     * @private
     */
    protected updateSymbolLocation(point: Points, rect: Rect, series: Series): void;
    /**
     * Update the region for the point.
     * @return {void}
     * @private
     */
    protected updateXRegion(point: Points, rect: Rect, series: Series): void;
    /**
     * Update the region for the point in bar series.
     * @return {void}
     * @private
     */
    protected updateYRegion(point: Points, rect: Rect, series: Series): void;
    /**
     * To trigger the point rendering event.
     * @return {void}
     * @private
     */
    protected triggerEvent(series: Series, point: Points, fill: string, border: BorderModel): IPointRenderEventArgs;
    /**
     * To draw the rectangle for points.
     * @return {void}
     * @private
     */
    protected drawRectangle(series: Series, point: Points, rect: Rect, argsData: IPointRenderEventArgs): void;
    /**
     * To animate the series.
     * @return {void}
     * @private
     */
    animate(series: Series): void;
    /**
     * To animate the series.
     * @return {void}
     * @private
     */
    private animateRect(element, series, point);
    /**
     * To get rounded rect path direction
     */
    private calculateRoundedRectPath(rect, topLeft, topRight, bottomLeft, bottomRight);
}
export interface RectPosition {
    position: number;
    rectCount: number;
}
/**
 * `ColumnSeries` Module used to render the column series.
 */
export  class ColumnSeries extends ColumnBase {
    /**
     * Render Column series.
     * @return {void}
     * @private
     */
    render(series: Series): void;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the column series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * `DataLabel` module is used to render data label for the data point.
 */
export  class DataLabel {
    private chart;
    private margin;
    private isShape;
    private locationX;
    private locationY;
    private fontBackground;
    private borderWidth;
    private markerHeight;
    private commonId;
    private yAxisInversed;
    private inverted;
    private errorHeight;
    private chartBackground;
    /**
     * Constructor for the data label module.
     * @private
     */
    constructor(chart: Chart);
    private initPrivateVariables(series, marker);
    private calculateErrorHeight(series, position);
    private isRectSeries(series);
    /**
     * Render the data label for series.
     * @return {void}
     */
    render(series: Series, chart: Chart, dataLabel: DataLabelSettingsModel): void;
    /**
     * Render the data label template.
     * @return {void}
     * @private
     */
    private createDataLabelTemplate(parentElement, series, dataLabel, point, data, labelIndex);
    private calculateTextPosition(point, series, textSize, dataLabel, labelIndex);
    private calculatePolarRectPosition(location, position, series, point, size, labelIndex);
    /**
     * Get the label location
     */
    private getLabelLocation(point, series, textSize, labelIndex);
    private calculateRectPosition(labelLocation, rect, isMinus, position, series, textSize, labelIndex, point);
    private calculatePathPosition(labelLocation, position, series, point, size, labelIndex);
    private isDataLabelShape(style);
    private calculateRectActualPosition(labelLocation, rect, isMinus, series, size, labelIndex, point);
    private calculateAlignment(value, labelLocation, alignment, isMinus);
    private calculateTopAndOuterPosition(location, rect, position, series, index, extraSpace, isMinus);
    /**
     * Updates the label location
     */
    private updateLabelLocation(position, location, extraSpace, margin, rect, top, inside?);
    private calculatePathActualPosition(y, markerSize, series, point, size, labelIndex);
    /**
     * Animates the data label.
     * @param  {Series} series - Data label of the series gets animated.
     * @return {void}
     */
    doDataLabelAnimation(series: Series, element?: Element): void;
    private getPosition(index);
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the dataLabel for series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * `ErrorBar` module is used to render the error bar for series.
 */
export  class ErrorBar {
    private chart;
    errorHeight: number;
    error: number;
    positiveHeight: number;
    negativeHeight: number;
    /**
     * Constructor for the error bar module.
     * @private
     */
    constructor(chart: Chart);
    /**
     * Render the error bar for series.
     * @return {void}
     */
    render(series: Series): void;
    private renderErrorBar(series);
    private findLocation(point, series, isInverted, x1, y1);
    private calculateFixedValue(point, series, isInverted, errorX, errorY, xAxis, yAxis);
    private calculatePercentageValue(point, series, isInverted, errorX, errorY, xAxis, yAxis);
    private calculateStandardDeviationValue(point, series, isInverted, errorX, errorY, xAxis, yAxis);
    private calculateStandardErrorValue(point, series, isInverted, errorX, errorY, xAxis, yAxis);
    private calculateCustomValue(point, series, isInverted, errorX, errorY, xAxis, yAxis);
    private getHorizontalDirection(start, mid, end, direction, errorMode, capLength);
    private getVerticalDirection(start, mid, end, direction, errorMode, capLength);
    private getBothDirection(start, mid, end, direction, errorMode, capLength);
    private getErrorDirection(start, mid, end, series, isInverted);
    meanCalculation(series: Series, mode: ErrorBarMode): Mean;
    private createElement(series);
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doErrorBarAnimation(series: Series): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the errorBar for series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * `HiloOpenCloseSeries` module is used to render the hiloOpenClose series.
 */
export  class HiloOpenCloseSeries extends ColumnBase {
    /**
     * Render HiloOpenCloseSeries series.
     * @return {void}
     * @private
     */
    render(series: Series): void;
    /**
     * Updates the tick region
     */
    private updateTickRegion(horizontal, region, borderWidth);
    /**
     * Trigger point rendering event
     */
    private triggerPointRenderEvent(series, point);
    /**
     * To draw the rectangle for points.
     * @return {void}
     * @private
     */
    protected drawHiloOpenClosePath(series: Series, point: Points, open: ChartLocation, close: ChartLocation, rect: Rect, argsData: IPointRenderEventArgs): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * To destroy the column series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * `HiloSeries` module is used to render the hilo series.
 */
export  class HiloSeries extends ColumnBase {
    /**
     * Render Hiloseries.
     * @return {void}
     * @private
     */
    render(series: Series): void;
    /**
     * To trigger the point rendering event.
     * @return {void}
     * @private
     */
    private triggerPointRenderEvent(series, point);
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * To destroy the Hilo series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * Base for line type series.
 */
export  class LineBase {
    chart: Chart;
    private padding;
    /** @private */
    constructor(chartModule?: Chart);
    /**
     * To improve the chart performance.
     * @return {void}
     * @private
     */
    improveChartPerformance(series: Series): Points[];
    /**
     * To generate the line path direction
     * @param firstPoint
     * @param secondPoint
     * @param series
     * @param isInverted
     * @param getPointLocation
     * @param startPoint
     */
    getLineDirection(firstPoint: Points, secondPoint: Points, series: Series, isInverted: Boolean, getPointLocation: Function, startPoint: string): string;
    /**
     * To append the line path.
     * @return {void}
     * @private
     */
    appendLinePath(options: PathOption, series: Series, clipRect: string): void;
    /**
     * To render the marker for the series.
     * @return {void}
     * @private
     */
    renderMarker(series: Series): void;
    /**
     * To do the progressive animation.
     * @return {void}
     * @private
     */
    doProgressiveAnimation(series: Series, option: AnimationModel): void;
    /**
     * To store the symbol location and region
     * @param point
     * @param series
     * @param isInverted
     * @param getLocation
     */
    storePointLocation(point: Points, series: Series, isInverted: boolean, getLocation: Function): void;
    /**
     * To do the linear animation.
     * @return {void}
     * @private
     */
    doLinearAnimation(series: Series, animation: AnimationModel): void;
}
/**
 * `LineSeries` module used to render the line series.
 */
export  class LineSeries extends LineBase {
    /**
     * Render Line Series.
     * @return {void}.
     * @private
     */
    render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the line series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * Marker Module used to render the marker for line type series.
 */
export  class MarkerExplode extends ChartData {
    private markerExplode;
    private isRemove;
    /** @private */
    elementId: string;
    /**
     * Constructor for the marker module.
     * @private
     */
    constructor(chart: Chart);
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    /**
     * @hidden
     */
    private mouseUpHandler();
    /**
     * @hidden
     */
    private mouseMoveHandler();
    private markerMove(remove);
    private drawTrackBall(series, point, location, index);
    /**
     * @hidden
     */
    removeHighlightedMarker(): void;
}
/**
 * Marker module used to render the marker for line type series.
 */
export  class Marker extends MarkerExplode {
    /**
     * Constructor for the marker module.
     * @private
     */
    constructor(chart: Chart);
    /**
     * Render the marker for series.
     * @return {void}
     * @private
     */
    render(series: Series): void;
    private renderMarker(series, point, location, index);
    createElement(series: Series): void;
    private getRangeLowPoint(region, series);
    /**
     * Animates the marker.
     * @return {void}.
     * @private
     */
    doMarkerAnimation(series: Series): void;
}
/**
 * `MultiColoredAreaSeries` module used to render the area series with multi color.
 */
export  class MultiColoredAreaSeries extends MultiColoredSeries {
    /**
     * Render Area series.
     * @return {void}
     * @private
     */
    render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
    /**
     * To Store the path directions of the area
     */
    private generatePathOption(options, series, point, direction, id);
    /**
     * To destroy the area series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name
     */
    protected getModuleName(): string;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
}
/**
 * Base class for multi colored series
 */
export  class MultiColoredSeries extends LineBase {
    /**
     * To Generate the area path direction
     * @param xValue
     * @param yValue
     * @param series
     * @param isInverted
     * @param getPointLocation
     * @param startPoint
     * @param startPath
     */
    getAreaPathDirection(xValue: number, yValue: number, series: Series, isInverted: boolean, getPointLocation: Function, startPoint: ChartLocation, startPath: string): string;
    /**
     * To Generate the empty point direction
     * @param firstPoint
     * @param secondPoint
     * @param series
     * @param isInverted
     * @param getPointLocation
     */
    getAreaEmptyDirection(firstPoint: ChartLocation, secondPoint: ChartLocation, series: Series, isInverted: boolean, getPointLocation: Function): string;
    /**
     * To set point color
     * @param points
     */
    setPointColor(currentPoint: Points, previous: Points, series: Series, isXSegment: boolean, segments: ChartSegmentModel[]): boolean;
    sortSegments(series: Series, chartSegments: ChartSegmentModel[]): ChartSegmentModel[];
    /**
     * Segment calculation performed here
     * @param series
     * @param options
     * @param chartSegments
     */
    applySegmentAxis(series: Series, options: PathOption[], segments: ChartSegmentModel[]): void;
    private includeSegment(segments, axis, series, length);
    /**
     * To create clip rect for segment axis
     * @param startValue
     * @param endValue
     * @param series
     * @param index
     * @param isX
     * @param chart
     */
    createClipRect(startValue: number, endValue: number, series: Series, index: number, isX: boolean): string;
    /**
     * To get exact value from segment value
     * @param segmentValue
     * @param axis
     * @param chart
     */
    getAxisValue(segmentValue: Object, axis: Axis, chart: Chart): number;
}
/**
 * `MultiColoredLineSeries` used to render the line series with multi color.
 */
export  class MultiColoredLineSeries extends MultiColoredSeries {
    /**
     * Render Line Series.
     * @return {void}.
     * @private
     */
    render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the line series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * `PolarSeries` module is used to render the polar series.
 */
export  class PolarSeries extends PolarRadarPanel {
    /**
     * Render Polar Series.
     * @return {void}.
     * @private
     */
    render(series: Series): void;
    /**
     * Render Column DrawType.
     * @return {void}.
     * @private
     */
    columnDrawTypeRender(series: Series): void;
    /**
     * To trigger the point rendering event.
     * @return {void}
     * @private
     */
    triggerEvent(chart: Chart, series: Series, point: Points): IPointRenderEventArgs;
    /** get position for column drawtypes
     * @return {void}.
     * @private
     */
    getSeriesPosition(series: Series): void;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * To do the Polar Radar draw type column animation.
     * @return {void}
     * @private
     */
    doPolarRadarAnimation(animateElement: Element, delay: number, duration: number, series: Series): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the polar series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * `RadarSeries` module is used to render the radar series.
 */
export  class RadarSeries extends PolarSeries {
    /**
     * Render radar Series.
     * @return {void}.
     * @private
     */
    render(series: Series): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the radar series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * `RangeAreaSeries` module is used to render the range area series.
 */
export  class RangeAreaSeries extends LineBase {
    /**
     * Render RangeArea Series.
     * @return {void}.
     * @private
     */
    render(series: Series): void;
    /**
     * path for rendering the low points
     * @return {void}.
     * @private
     */
    protected closeRangeAreaPath(visiblePoints: Points[], point: Points, series: Series, direction: string, i: number): string;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the line series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * `RangeColumnSeries` module is used to render the range column series.
 */
export  class RangeColumnSeries extends ColumnBase {
    /**
     * Render Range Column series.
     * @return {void}
     * @private
     */
    render(series: Series): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * To destroy the range column series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * `ScatterSeries` module is used to render the scatter series.
 */
export  class ScatterSeries {
    /**
     * Render the scatter series.
     * @return {void}
     * @private
     */
    render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the scatter.
     * @return {void}
     */
    destroy(chart: Chart): void;
}
/**
 * `SplineAreaSeries` module used to render the spline area series.
 */
export  class SplineAreaSeries extends SplineBase {
    /**
     * Render the splineArea series.
     * @return {void}
     * @private
     */
    render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the spline.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * render Line series
 */
export  class SplineBase extends LineBase {
    private splinePoints;
    /** @private */
    constructor(chartModule?: Chart);
    /**
     * To find the control points for spline.
     * @return {void}
     * @private
     */
    findSplinePoint(series: Series): void;
    protected getPreviousIndex(points: Points[], i: number, series: Series): number;
    getNextIndex(points: Points[], i: number, series: Series): number;
    filterEmptyPoints(series: Series): Points[];
    /**
     * To find the natural spline.
     * @return {void}
     * @private
     */
    findSplineCoefficients(points: Points[], series: Series): number[];
    /**
     * To find the control points for spline.
     * @return {void}
     * @private
     */
    getControlPoints(point1: Points, point2: Points, ySpline1: number, ySpline2: number, series: Series): ControlPoints;
    /**
     * calculate datetime interval in hours
     *
     */
    protected dateTimeInterval(series: Series): number;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
}
/**
 * `SplineSeries` module is used to render the spline series.
 */
export  class SplineSeries extends SplineBase {
    /**
     * Render the spline series.
     * @return {void}
     * @private
     */
    render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the spline.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * `StackingAreaSeries` module used to render the Stacking Area series.
 */
export  class StackingAreaSeries extends LineBase {
    /**
     * Render the Stacking area series.
     * @return {void}
     * @private
     */
    render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * To destroy the stacking area.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To find previous visible series
     */
    private getPreviousSeries(series);
}
/**
 * `StackingBarSeries` module is used to render the stacking bar series.
 */
export  class StackingBarSeries extends ColumnBase {
    /**
     * Render the Stacking bar series.
     * @return {void}
     * @private
     */
    render(series: Series): void;
    /**
     * To destroy the stacking bar.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
}
/**
 * `StackingColumnSeries` module used to render the stacking column series.
 */
export  class StackingColumnSeries extends ColumnBase {
    /**
     * Render the Stacking column series.
     * @return {void}
     * @private
     */
    render(series: Series): void;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * To destroy the stacking column.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * `StepAreaSeries` Module used to render the step area series.
 */
export  class StepAreaSeries extends LineBase {
    /**
     * Render StepArea series.
     * @return {void}
     * @private
     */
    render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * To destroy the step Area series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * `StepLineSeries` module is used to render the step line series.
 */
export  class StepLineSeries extends LineBase {
    /**
     * Render the Step line series.
     * @return {void}
     * @private
     */
    render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * To destroy the step line series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * `WaterfallSeries` module is used to render the waterfall series.
 */
export  class WaterfallSeries extends ColumnBase {
    /**
     * Render waterfall series.
     * @return {void}
     * @private
     */
    render(series: Series): void;
    /**
     * To check intermediateSumIndex in waterfall series.
     * @return boolean
     * @private
     */
    private isIntermediateSum(series, index);
    /**
     * To check sumIndex in waterfall series.
     * @return boolean
     * @private
     */
    private isSumIndex(series, index);
    /**
     * To trigger the point rendering event for waterfall series.
     * @return IPointRenderEventArgs
     * @private
     */
    private triggerPointRenderEvent(series, point);
    /**
     * Add sumIndex and intermediateSumIndex data.
     * @return {object[]}
     * @private
     */
    processWaterfallData(json: Object[], series: Series): Object[];
    /**
     * Animates the series.
     * @param  {Series} series - Defines the series to animate.
     * @return {void}
     */
    doAnimation(series: Series): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the waterfall series.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * `AccumulationDistributionIndicator` module is used to render accumulation distribution indicator.
 */
export  class AccumulationDistributionIndicator extends TechnicalAnalysis {
    /**
     * Defines the predictions using accumulation distribution approach
     * @private
     */
    initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     *  Calculates the Accumulation Distribution values
     * @private
     */
    private calculateADPoints(indicator, validData);
    /**
     * To destroy the Accumulation Distribution Technical Indicator.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * `AtrIndicator` module is used to render ATR indicator.
 */
export  class AtrIndicator extends TechnicalAnalysis {
    /**
     * Defines the predictions using Average True Range approach
     * @private
     */
    initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     *  To calculate Average True Range indicator points
     * @private
     */
    private calculateATRPoints(indicator, validData);
    /**
     * To destroy the Average true range indicator.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * `BollingerBands` module is used to render bollinger band indicator.
 */
export  class BollingerBands extends TechnicalAnalysis {
    /**
     * Initializes the series collection to represent bollinger band
     */
    initSeriesCollection(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     * Defines the predictions using Bollinger Band Approach
     * @private
     */
    initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     * To destroy the Bollinger Band.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * `EmaIndicator` module is used to render EMA indicator.
 */
export  class EmaIndicator extends TechnicalAnalysis {
    /**
     * Defines the predictions based on EMA approach
     * @private
     */
    initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     * To destroy the EMA Indicator
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * Technical Analysis module helps to predict the market trend
 */
export  class TechnicalAnalysis extends LineBase {
    /**
     * Defines the collection of series, that are used to represent the given technical indicator
     * @private
     */
    initSeriesCollection(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     * Initializes the properties of the given series
     * @private
     */
    protected setSeriesProperties(series: Series, indicator: TechnicalIndicator, name: string, fill: string, width: number, chart: Chart): void;
    /**
     * Creates the elements of a technical indicator
     * @private
     */
    createIndicatorElements(chart: Chart, indicator: TechnicalIndicator, index: number): void;
    protected getDataPoint(x: Object, y: Object, sourcePoint: Points, series: Series, index: number, indicator?: TechnicalIndicator): Points;
    protected getRangePoint(x: Object, high: Object, low: Object, sourcePoint: Points, series: Series, index: number, indicator?: TechnicalIndicator): Points;
    protected setSeriesRange(points: Points[], indicator: TechnicalIndicator, series?: Series): void;
}
/**
 * `MacdIndicator` module is used to render MACD indicator.
 */
export  class MacdIndicator extends TechnicalAnalysis {
    /**
     * Defines the collection of series to represent the MACD indicator
     * @private
     */
    initSeriesCollection(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     * Defines the predictions using MACD approach
     * @private
     */
    initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     * Calculates the EMA values for the given period
     */
    private calculateEMAValues(period, validData, field);
    /**
     * Defines the MACD Points
     */
    private getMACDPoints(indicator, macdPoints, validData, series);
    /**
     * Calculates the signal points
     */
    private getSignalPoints(indicator, signalEma, validData, series);
    /**
     * Calculates the MACD values
     */
    private getMACDVales(indicator, shortEma, longEma);
    /**
     * Calculates the Histogram Points
     */
    private getHistogramPoints(indicator, macdPoints, signalEma, validData, series);
    /**
     * To destroy the MACD Indicator.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * `MomentumIndicator` module is used to render Momentum indicator.
 */
export  class MomentumIndicator extends TechnicalAnalysis {
    /**
     * Defines the collection of series to represent a momentum indicator
     * @private
     */
    initSeriesCollection(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     * Defines the predictions using momentum approach
     * @private
     */
    initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     * To destroy the momentum indicator
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * `RsiIndicator` module is used to render RSI indicator.
 */
export  class RsiIndicator extends TechnicalAnalysis {
    /**
     * Initializes the series collection to represent the RSI Indicator
     * @private
     */
    initSeriesCollection(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     * Defines the predictions using RSI approach
     * @private
     */
    initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     * To destroy the RSI Indicator.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * `SmaIndicator` module is used to render SMA indicator.
 */
export  class SmaIndicator extends TechnicalAnalysis {
    /**
     * Defines the predictions based on SMA approach
     * @private
     */
    initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     * To destroy the SMA indicator
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * `StochasticIndicator` module is used to render stochastic indicator.
 */
export  class StochasticIndicator extends TechnicalAnalysis {
    /**
     * Defines the collection of series that represents the stochastic indicator
     * @private
     */
    initSeriesCollection(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     * Defines the predictions based on stochastic approach
     * @private
     */
    initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     * Calculates the SMA Values
     * @private
     */
    private smaCalculation(period, kPeriod, data, sourceSeries);
    /**
     * Calculates the period line values.
     * @private
     */
    private calculatePeriod(period, kPeriod, data, series);
    /**
     * To destroy the Stocastic Indicator.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * Interface for a class TechnicalIndicator
 */
export interface TechnicalIndicatorModel extends SeriesBaseModel{
    /**
     * Defines the type of the technical indicator
     * @default 'Sma'
     */
    type?: TechnicalIndicators;
    /**
     * Defines the period, the price changes over which will be considered to predict the trend
     * @default 14
     */
    period?: number;
    /**
     * Defines the look back period, the price changes over which will define the %K value in stochastic indicators
     * @default 14
     */
    kPeriod?: number;
    /**
     * Defines the period, the price changes over which will define the %D value in stochastic indicators
     * @default 3
     */
    dPeriod?: number;
    /**
     * Defines the over-bought(threshold) values. It is applicable for RSI and stochastic indicators
     * @default 80
     */
    overBought?: number;
    /**
     * Defines the over-sold(threshold) values. It is applicable for RSI and stochastic indicators
     * @default 20
     */
    overSold?: number;
    /**
     * Sets the standard deviation values that helps to define the upper and lower bollinger bands
     * @default 2
     */
    standardDeviation?: number;
    /**
     * Defines the field to compare the current value with previous values
     * @default 'Close'
     */
    field?: FinancialDataFields;
    /**
     * Sets the slow period to define the Macd line
     * @default 12
     */
    slowPeriod?: number;
    /**
     * Sets the fast period to define the Macd line
     * @default 26
     */
    fastPeriod?: number;
    /**
     * Enables/Disables the over-bought and over-sold regions
     * @default true
     */
    showZones?: boolean;
    /**
     * Defines the appearance of the the MacdLine of Macd indicator
     * @default { color: '#ff9933', width: 2 }
     */
    macdLine?: ConnectorModel;
    /**
     * Defines the type of the Macd indicator.
     * @default 'Both'
     */
    macdType?: MacdType;
    /**
     * Defines the color of the positive bars in Macd indicators
     */
    macdPositiveColor?: string;
    /**
     * Defines the color of the negative bars in Macd indicators
     */
    macdNegativeColor?: string;
    /**
     * Options for customizing the BollingerBand in the indicator.
     * @default 'rgba(211,211,211,0.25)'
     */
    bandColor?: string;
    /**
     * Defines the appearance of the upper line in technical indicators
     */
    upperLine?: ConnectorModel;
    /**
     * Defines the appearance of lower line in technical indicators
     */
    lowerLine?: ConnectorModel;
    /**
     * Defines the appearance of period line in technical indicators
     */
    periodLine?: ConnectorModel;
    /**
     * Defines the name of the series, the data of which has to be depicted as indicator
     * @default ''
     */
    seriesName?: string;
}

/**
 * Defines how to represent the market trend using technical indicators
 */
export  class TechnicalIndicator extends SeriesBase {
    /**
     * Defines the type of the technical indicator
     * @default 'Sma'
     */
    type: TechnicalIndicators;
    /**
     * Defines the period, the price changes over which will be considered to predict the trend
     * @default 14
     */
    period: number;
    /**
     * Defines the look back period, the price changes over which will define the %K value in stochastic indicators
     * @default 14
     */
    kPeriod: number;
    /**
     * Defines the period, the price changes over which will define the %D value in stochastic indicators
     * @default 3
     */
    dPeriod: number;
    /**
     * Defines the over-bought(threshold) values. It is applicable for RSI and stochastic indicators
     * @default 80
     */
    overBought: number;
    /**
     * Defines the over-sold(threshold) values. It is applicable for RSI and stochastic indicators
     * @default 20
     */
    overSold: number;
    /**
     * Sets the standard deviation values that helps to define the upper and lower bollinger bands
     * @default 2
     */
    standardDeviation: number;
    /**
     * Defines the field to compare the current value with previous values
     * @default 'Close'
     */
    field: FinancialDataFields;
    /**
     * Sets the slow period to define the Macd line
     * @default 12
     */
    slowPeriod: number;
    /**
     * Sets the fast period to define the Macd line
     * @default 26
     */
    fastPeriod: number;
    /**
     * Enables/Disables the over-bought and over-sold regions
     * @default true
     */
    showZones: boolean;
    /**
     * Defines the appearance of the the MacdLine of Macd indicator
     * @default { color: '#ff9933', width: 2 }
     */
    macdLine: ConnectorModel;
    /**
     * Defines the type of the Macd indicator.
     * @default 'Both'
     */
    macdType: MacdType;
    /**
     * Defines the color of the positive bars in Macd indicators
     */
    macdPositiveColor: string;
    /**
     * Defines the color of the negative bars in Macd indicators
     */
    macdNegativeColor: string;
    /**
     * Options for customizing the BollingerBand in the indicator.
     * @default 'rgba(211,211,211,0.25)'
     */
    bandColor: string;
    /**
     * Defines the appearance of the upper line in technical indicators
     */
    upperLine: ConnectorModel;
    /**
     * Defines the appearance of lower line in technical indicators
     */
    lowerLine: ConnectorModel;
    /**
     * Defines the appearance of period line in technical indicators
     */
    periodLine: ConnectorModel;
    /**
     * Defines the name of the series, the data of which has to be depicted as indicator
     * @default ''
     */
    seriesName: string;
    /** @private */
    targetSeries: Series[];
    /** @private */
    sourceSeries: Series;
    /** @private */
    indicatorElement: Element;
    /** @private */
    clipRectElement: Element;
    /** @private */
    clipRect: Rect;
    /** @private */
    setDataSource(series: Series, chart: Chart): void;
}
/**
 * `TmaIndicator` module is used to render TMA indicator.
 */
export  class TmaIndicator extends TechnicalAnalysis {
    /**
     * Defines the predictions based on TMA approach
     * @private
     */
    initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
    /**
     * To destroy the TMA indicator.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * `Trendline` module is used to render 6 types of trendlines in chart.
 */
export  class Trendlines {
    /**
     * Defines the collection of series, that are used to represent a trendline
     * @private
     */
    initSeriesCollection(trendline: Trendline, chart: Chart): void;
    /**
     * Initializes the properties of the trendline series
     */
    private setSeriesProperties(series, trendline, name, fill, width, chart);
    /**
     * Creates the elements of a trendline
     */
    private createTrendLineElements(chart, trendline, index, element, clipRectElement);
    /**
     * Defines the data point of trendline
     */
    private getDataPoint(x, y, sourcePoint, series, index);
    /**
     * Finds the slope and intercept of trendline
     */
    private findSlopeIntercept(xValues, yValues, trendline, points);
    /**
     * Defines the points to draw the trendlines
     */
    initDataSource(trendline: Trendline, chart: Chart): void;
    /**
     * Calculation of exponential points
     */
    private setExponentialRange(points, trendline, series);
    /**
     * Calculation of logarithmic points
     */
    private setLogarithmicRange(points, trendline, series);
    /**
     * Calculation of polynomial points
     */
    private setPolynomialRange(points, trendline, series);
    /**
     * Calculation of power points
     */
    private setPowerRange(points, trendline, series);
    /**
     * Calculation of linear points
     */
    private setLinearRange(points, trendline, series);
    /**
     * Calculation of moving average points
     */
    private setMovingAverageRange(points, trendline, series);
    /**
     * Calculation of logarithmic points
     */
    private getLogarithmicPoints(trendline, points, xValues, yValues, series, slopeInterceptLog);
    /**
     * Defines the points based on data point
     */
    private getPowerPoints(trendline, points, xValues, yValues, series, slopeInterceptPower);
    /**
     * Get the polynomial points based on polynomial slopes
     */
    private getPolynomialPoints(trendline, points, xValues, yValues, series);
    /**
     * Defines the moving average points
     */
    private getMovingAveragePoints(trendline, points, xValues, yValues, series);
    /**
     * Defines the linear points
     */
    private getLinearPoints(trendline, points, xValues, yValues, series, slopeInterceptLinear);
    /**
     * Defines the exponential points
     */
    private getExponentialPoints(trendline, points, xValues, yValues, series, slopeInterceptExp);
    /**
     * Defines the points based on data point
     */
    private getPoints(trendline, points, xValues, yValues, series);
    /**
     * Defines the polynomial value of y
     */
    private getPolynomialYValue(slopes, x);
    /**
     * Defines the gauss jordan elimination
     */
    private gaussJordanElimination(matrix, polynomialSlopes);
    /**
     * Defines the trendline elements
     */
    getTrendLineElements(series: Series, chart: Chart): void;
    /**
     * To destroy the trendline
     */
    destroy(chart: Chart): void;
    /**
     * Get module name
     */
    protected getModuleName(): string;
}
/** @private */
export interface SlopeIntercept {
    slope?: number;
    intercept?: number;
}
/**
 * `Crosshair` module is used to render the crosshair for chart.
 */
export  class Crosshair {
    private elementID;
    private elementSize;
    private crosshairInterval;
    private arrowLocation;
    private isTop;
    private isBottom;
    private isLeft;
    private isRight;
    private valueX;
    private valueY;
    private rx;
    private ry;
    private chart;
    /**
     * Constructor for crosshair module.
     * @private
     */
    constructor(chart: Chart);
    /**
     * @hidden
     */
    private addEventListener();
    private mouseUpHandler();
    private mouseLeaveHandler();
    private mouseMoveHandler(event);
    /**
     * Handles the long press on chart.
     * @return {boolean}
     * @private
     */
    private longPress();
    /**
     * Renders the crosshair.
     * @return {void}
     */
    crosshair(): void;
    private renderCrosshairLine(options, crossGroup);
    private renderAxisTooltip(chart, chartRect, axisGroup);
    private getAxisText(axis);
    private tooltipLocation(text, axis, bounds, axisRect);
    private stopAnimation();
    /**
     * Removes the crosshair on mouse leave.
     * @return {void}
     * @private
     */
    removeCrosshair(duration: number): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the crosshair.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * `Selection` module handles the selection for chart.
 * @private
 */
export  class Selection extends BaseSelection {
    private renderer;
    private isSeriesMode;
    private resizing;
    /** @private */
    rectPoints: Rect;
    private closeIconId;
    private closeIcon;
    private draggedRectGroup;
    private draggedRect;
    /** @private */
    selectedDataIndexes: Indexes[];
    private series;
    private dragging;
    private dragRect;
    private rectGrabbing;
    private resizeMode;
    private chart;
    /**
     * Constructor for selection module.
     * @private.
     */
    constructor(chart: Chart);
    /**
     * Binding events for selection module.
     */
    private addEventListener();
    /**
     * Chart mouse down
     */
    private mousedown(e);
    /**
     * UnBinding events for selection module.
     */
    private removeEventListener();
    /**
     * To find private variable values
     */
    private initPrivateVariables(chart);
    /**
     * Method to select the point and series.
     * @return {void}
     */
    invokeSelection(chart: Chart): void;
    private generateStyle(series);
    private selectDataIndex(chart, indexes);
    private getElementByIndex(chart, index, suffix?);
    private getClusterElements(chart, index);
    private findElements(chart, series, index, suffix?);
    /**
     * To find the selected element.
     * @return {void}
     * @private
     */
    calculateSelectedElements(event: Event): void;
    private performSelection(index, chart, element?);
    private selection(chart, index, selectedElements);
    private clusterSelection(chart, series, index);
    private removeMultiSelectEelments(chart, index, currentIndex, seriesCollection);
    private blurEffect(chartId, visibleSeries);
    private checkSelectionElements(element, className, visibility);
    private applyStyles(elements);
    private getSelectionClass(id);
    private removeStyles(elements);
    private addOrRemoveIndex(indexes, index, add?);
    private toEquals(first, second, checkSeriesOnly);
    /**
     * To redraw the selected points.
     * @return {void}
     * @private
     */
    redrawSelection(chart: Chart, oldMode: SelectionMode): void;
    /** @private */
    legendSelection(chart: Chart, series: number): void;
    private getSeriesElements(series);
    private indexFinder(id);
    /**
     * Drag selection that returns the selected data.
     * @return {void}
     * @private
     */
    calculateDragSelectedElements(chart: Chart, dragRect: Rect): void;
    private removeOffset(rect, clip);
    /**
     * Method to draw dragging rect.
     * @return {void}
     * @private
     */
    drawDraggingRect(chart: Chart, dragRect: Rect): void;
    private createCloseButton(x, y);
    /**
     * Method to remove dragged element.
     * @return {void}
     * @private
     */
    removeDraggedElements(chart: Chart, event: Event): void;
    /**
     * Method to resize the drag rect.
     * @return {void}
     * @private
     */
    resizingSelectionRect(chart: Chart, location: ChartLocation, tapped?: boolean): void;
    private findResizeMode(chartSvgObject, rect, location);
    private changeCursorStyle(isResize, rectelement, cursorStyle);
    private removeSelectedElements(chart, index, seriesCollection);
    private setAttributes(ele, object);
    /**
     * Method to move the dragged rect.
     * @return {void}
     * @private
     */
    draggedRectMoved(chart: Chart, grabbedPoint: Rect, doDrawing?: boolean): void;
    /**
     * To complete the selection.
     * @return {void}
     * @private
     */
    completeSelection(e: Event): void;
    private getDragRect(chart, seriesClipRect);
    /** @private */
    dragStart(chart: Chart, seriesClipRect: Rect, mouseDownX: number, mouseDownY: number, event: Event): void;
    /** @private */
    mouseMove(event: PointerEvent | TouchEvent): void;
    /**
     * Get module name.
     * @private
     */
    getModuleName(): string;
    /**
     * To destroy the selection.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * `Tooltip` module is used to render the tooltip for chart series.
 */
export  class Tooltip extends BaseTooltip {
    /**
     * Constructor for tooltip module.
     * @private.
     */
    constructor(chart: Chart);
    /**
     * @hidden
     */
    private addEventListener();
    private mouseUpHandler();
    private mouseLeaveHandler();
    private mouseMoveHandler();
    /**
     * Handles the long press on chart.
     * @return {boolean}
     * @private
     */
    private longPress();
    /**
     * Renders the tooltip.
     * @return {void}
     */
    tooltip(): void;
    private findHeader(data);
    private renderSeriesTooltip(chart, isFirst, tooltipDiv);
    private findData(data, previous);
    private getSymbolLocation(data);
    private getTooltipText(pointData);
    private getTemplateText(data);
    private findMouseValue(data, chart);
    private renderGroupedTooltip(chart, isFirst, tooltipDiv);
    private getBoxLocation(data);
    private drawMarker(isBottom, isRight, size);
    private findColor(data, series);
    private parseTemplate(point, series, format, xAxis, yAxis);
    private formatPointValue(point, axis, dataValue, isXPoint, isYPoint);
    private getFormat(chart, series);
    private getIndicatorTooltipFormat(series, chart, format);
    removeHighlightedMarker(data: PointData[]): void;
    /**
     * Removes the tooltip on mouse leave.
     * @return {void}
     * @private
     */
    removeTooltip(duration: number): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the tooltip.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * Zooming Toolkit created here
 * @private
 */
export  class Toolkit {
    private chart;
    private selectionColor;
    private fillColor;
    private elementOpacity;
    private elementId;
    private zoomInElements;
    private zoomOutElements;
    private zoomElements;
    private panElements;
    /** @private */
    constructor(chart: Chart);
    /**
     * To create the pan button.
     * @return {void}
     * @private
     */
    createPanButton(childElement: Element, parentElement: Element, chart: Chart): void;
    /**
     * To create the zoom button.
     * @return {void}
     * @private
     */
    createZoomButton(childElement: Element, parentElement: Element, chart: Chart): void;
    /**
     * To create the ZoomIn button.
     * @return {void}
     * @private
     */
    createZoomInButton(childElement: Element, parentElement: Element, chart: Chart): void;
    /**
     * To create the ZoomOut button.
     * @return {void}
     * @private
     */
    createZoomOutButton(childElement: Element, parentElement: Element, chart: Chart): void;
    /**
     * To create the Reset button.
     * @return {void}
     * @private
     */
    createResetButton(childElement: Element, parentElement: Element, chart: Chart, isDevice: Boolean): void;
    /**
     * To bind events.
     * @return {void}
     * @private
     */
    wireEvents(element: Element, process: Function): void;
    /**
     * To show tooltip.
     * @return {void}
     * @private
     */
    private showTooltip(event);
    /** @private */
    removeTooltip(): void;
    /** @private */
    reset(): boolean;
    private zoomIn(e);
    private zoomOut(e);
    private zoom(e);
    /** @private */
    pan(): boolean;
    private zoomInOutCalculation(scale, chart, axes, mode);
    private applySelection(elements, color);
}
/**
 * `Zooming` module handles the zooming for chart.
 */
export  class Zoom {
    private chart;
    private zooming;
    private elementId;
    /** @private */
    zoomingRect: Rect;
    /** @private */
    toolkit: Toolkit;
    /** @private */
    toolkitElements: Element;
    /** @private */
    isPanning: boolean;
    /** @private */
    isZoomed: boolean;
    /** @private */
    isPointer: Boolean;
    /** @private */
    pinchTarget: Element;
    /** @private */
    isDevice: Boolean;
    /** @private */
    browserName: string;
    /** @private */
    touchStartList: ITouches[] | TouchList;
    /** @private */
    touchMoveList: ITouches[] | TouchList;
    /** @private */
    offset: Rect;
    /** @private */
    zoomAxes: IZoomAxisRange[];
    /** @private */
    isIOS: Boolean;
    /** @private */
    performedUI: boolean;
    private zoomkitOpacity;
    private wheelEvent;
    private cancelEvent;
    /**
     * Constructor for Zooming module.
     * @private.
     */
    constructor(chart: Chart);
    /**
     * Function that handles the Rectangular zooming.
     * @return {void}
     */
    renderZooming(e: PointerEvent | TouchEvent, chart: Chart, isTouch: boolean): void;
    private drawZoomingRectangle(chart);
    private doPan(chart, axes);
    /**
     * Redraw the chart on zooming.
     * @return {void}
     * @private
     */
    performZoomRedraw(chart: Chart): void;
    private refreshAxis(layout, chart, axes);
    private doZoom(chart, axes, bounds);
    /**
     * Function that handles the Mouse wheel zooming.
     * @return {void}
     * @private
     */
    performMouseWheelZooming(e: WheelEvent, mouseX: number, mouseY: number, chart: Chart, axes: AxisModel[]): void;
    /**
     * Function that handles the Pinch zooming.
     * @return {void}
     * @private
     */
    performPinchZooming(e: TouchEvent, chart: Chart): boolean;
    private calculatePinchZoomFactor(chart, pinchRect);
    private setTransform(transX, transY, scaleX, scaleY, chart, isPinch);
    private calculateZoomAxesRange(chart, axes);
    private showZoomingToolkit(chart);
    /**
     * To the show the zooming toolkit.
     * @return {void}
     * @private
     */
    applyZoomToolkit(chart: Chart, axes: AxisModel[]): void;
    /**
     * Return boolean property to show zooming toolkit.
     * @return {void}
     * @private
     */
    isAxisZoomed(axes: AxisModel[]): boolean;
    private zoomToolkitMove(e);
    private zoomToolkitLeave(e);
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    /**
     * Handles the mouse wheel on chart.
     * @return {boolean}
     * @private
     */
    chartMouseWheel(e: WheelEvent): boolean;
    /**
     * @hidden
     */
    private mouseMoveHandler(e);
    /**
     * @hidden
     */
    private mouseDownHandler(e);
    /**
     * @hidden
     */
    private mouseUpHandler(e);
    /**
     * @hidden
     */
    private mouseCancelHandler(e);
    /**
     * Handles the touch pointer.
     * @return {boolean}
     * @private
     */
    addTouchPointer(touchList: ITouches[], e: PointerEvent, touches: TouchList): ITouches[];
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the zooming.
     * @return {void}
     * @private
     */
    destroy(chart: Chart): void;
}
/**
 * Numeric Range.
 * @private
 */
export  class DoubleRange {
    private mStart;
    private mEnd;
    /** @private */
    readonly start: number;
    /** @private */
    readonly end: number;
    /** @private */
    readonly delta: number;
    /** @private */
    readonly median: number;
    constructor(start: number, end: number);
}
/**
 * Defines Orientation of axis. They are
 * * horizontal
 * * vertical
 * @private
 */
export  type Orientation = 'Horizontal' | 'Vertical';
/**
 * Defines area type of chart. They are
 * * none
 * * cartesianAxes
 * * polarAxes
 * @private
 */
export  type ChartAreaType = 'CartesianAxes' | 'PolarAxes';
/**
 * Defines series type of chart. They are
 * * xy
 * * highLow
 * @private
 */
export  type SeriesValueType = 'XY' | 'HighLow' | 'HighLowOpenClose' | 'BoxPlot';
/**
 * Defines the range padding of axis. They are
 * * none - Padding cannot be applied to the axis.
 * * normal - Padding is applied to the axis based on the range calculation.
 * * additional - Interval of the axis is added as padding to the minimum and maximum values of the range.
 * * round - Axis range is rounded to the nearest possible value divided by the interval.
 */
export  type ChartRangePadding = 'Auto' | 'None' | 'Normal' | 'Additional' | 'Round';
/**
 * Defines the segment axis. They are,
 * * X - Segment calculation rendered based on horizontal axis
 * * Y - Segment calculation rendered based on vertical axis
 */
export  type Segment = 'X' | 'Y';
/**
 * Defines the type series in chart. They are
 * * line - Renders the line series.
 * * column - Renders the column series.
 * * area - Renders the area series.
 * * pie - Renders the pie series.
 * * polar - Renders the polar series.
 * * radar - Renders the radar series.
 * * bar - Renders the stacking column series
 * * stackingColumn - Renders the stacking column series.
 * * stackingArea - Renders the stacking area series
 * * stackingBar - Renders the stacking bar series.
 * * StackingColumn100 - Renders the stacking column series.
 * * StackingArea100 - Renders the stacking area 100 percent series
 * * StackingBar100 - Renders the stacking bar 100 percent series.
 * * stepLine -  Renders the step line series.
 * * stepArea -  Renders the step area series.
 * * scatter - Renders the scatter series.
 * * spline - Renders the spline series
 * * rangeColumn - Renders the rangeColumn series.
 * * hilo - Renders the hilo series
 * * hiloOpenClose - Renders the HiloOpenClose Series
 * * Waterfall - Renders the Waterfall Series
 * * rangeArea - Renders the rangeArea series.
 */
export  type ChartSeriesType = 'Line' | 'Column' | 'Area' | 'Bar' | 'StackingColumn' | 'StackingArea' | 'StackingBar' | 'StepLine' | 'StepArea' | 'SplineArea' | 'Scatter' | 'Spline' | 'StackingColumn100' | 'StackingBar100' | 'StackingArea100' | 'RangeColumn' | 'Hilo' | 'HiloOpenClose' | 'Waterfall' | 'RangeArea' | 'Bubble' | 'Candle' | 'Polar' | 'Radar' | 'BoxAndWhisker' | 'MultiColoredLine' | 'MultiColoredArea';
/**
 * * Type of series to be drawn in radar or polar series. They are
 * * line - Renders the line series.
 * * column - Renders the column series.
 * * area - Renders the area series.
 * * scatter - Renders the scatter series.
 * * spline - Renders the spline series.
 * * stackingColumn - Renders the stacking column series.
 * * stackingArea - Renders the stacking area series.
 * * rangeColumn - Renders the range column series.
 * * splineArea - Renders the spline area series.
 */
export  type ChartDrawType = 'Line' | 'Column' | 'StackingColumn' | 'Area' | 'Scatter' | 'RangeColumn' | 'Spline' | 'SplineArea' | 'StackingArea';
/**
 * Defines the Edge Label Placement for an axis. They are
 * * none - No action will be perform.
 * * hide - Edge label will be hidden.
 * * shift - Shift the edge labels.
 */
export  type EdgeLabelPlacement = 'None' | 'Hide' | 'Shift';
/**
 * Defines the Label Placement for category axis. They are
 * * betweenTicks - Render the label between the ticks.
 * * onTicks - Render the label on the ticks.
 */
export  type LabelPlacement = 'BetweenTicks' | 'OnTicks';
/**
 * Defines the shape of marker. They are
 * * circle - Renders a circle.
 * * rectangle - Renders a rectangle.
 * * triangle - Renders a triangle.
 * * diamond - Renders a diamond.
 * * cross - Renders a cross.
 * * horizontalLine - Renders a horizontalLine.
 * * verticalLine - Renders a verticalLine.
 * * pentagon- Renders a pentagon.
 * * invertedTriangle - Renders a invertedTriangle.
 * * image - Renders a image.
 */
export  type ChartShape = 'Circle' | 'Rectangle' | 'Triangle' | 'Diamond' | 'Cross' | 'HorizontalLine' | 'VerticalLine' | 'Pentagon' | 'InvertedTriangle' | 'Image';
/**
 * Defines the type of axis. They are
 * * double -  Renders a numeric axis.
 * * dateTime - Renders a dateTime axis.
 * * category - Renders a category axis.
 * * logarithmic - Renders a log axis.
 * * DateTimeCategory - Renders a datetime DateTimeCategory axis
 */
export  type ValueType = 'Double' | 'DateTime' | 'Category' | 'Logarithmic' | 'DateTimeCategory';
/**
 * Defines the type of error bar. They are
 * * fixed -  Renders a fixed type error bar.
 * * percentage - Renders a percentage type error bar.
 * * standardDeviation - Renders a standard deviation type error bar.
 * * standardError -Renders a standard error type error bar.
 * * custom -Renders a custom type error bar.
 */
export  type ErrorBarType = 'Fixed' | 'Percentage' | 'StandardDeviation' | 'StandardError' | 'Custom';
/**
 * Defines the direction of error bar. They are
 * * both -  Renders both direction of error bar.
 * * minus - Renders minus direction of error bar.
 * * plus - Renders plus direction error bar.
 */
export  type ErrorBarDirection = 'Both' | 'Minus' | 'Plus';
/**
 * Defines the modes of error bar. They are
 * * vertical -  Renders a vertical error bar.
 * * horizontal - Renders a horizontal error bar.
 * * both - Renders both side error bar.
 */
export  type ErrorBarMode = 'Vertical' | 'Horizontal' | 'Both';
/**
 * Defines the interval type of datetime axis. They are
 * * auto - Define the interval of the axis based on data.
 * * years - Define the interval of the axis in years.
 * * months - Define the interval of the axis in months.
 * * days - Define the interval of the axis in days.
 * * hours - Define the interval of the axis in hours.
 * * minutes - Define the interval of the axis in minutes.
 */
export  type IntervalType = 'Auto' | 'Years' | 'Months' | 'Days' | 'Hours' | 'Minutes' | 'Seconds';
/**
 * Defines the mode of line in crosshair. They are
 * * none - Hides both vertical and horizontal crosshair line.
 * * both - Shows both vertical and horizontal crosshair line.
 * * vertical - Shows the vertical line.
 * * horizontal - Shows the horizontal line.
 */
export  type LineType = 'None' | 'Both' | 'Vertical' | 'Horizontal';
export  type MacdType = 'Line' | 'Histogram' | 'Both';
/**
 * Defines the position of the legend. They are
 * * auto - Places the legend based on area type.
 * * top - Displays the legend on the top of chart.
 * * left - Displays the legend on the left of chart.
 * * bottom - Displays the legend on the bottom of chart.
 * * right - Displays the legend on the right of chart.
 * * custom - Displays the legend  based on given x and y value.
 */
export  type LegendPosition = 'Auto' | 'Top' | 'Left' | 'Bottom' | 'Right' | 'Custom';
/**
 * Defines the shape of legend. They are
 * * circle - Renders a circle.
 * * rectangle - Renders a rectangle.
 * * triangle - Renders a triangle.
 * * diamond - Renders a diamond.
 * * cross - Renders a cross.
 * * horizontalLine - Renders a horizontalLine.
 * * verticalLine - Renders a verticalLine.
 * * pentagon - Renders a pentagon.
 * * invertedTriangle - Renders a invertedTriangle.
 * * SeriesType -Render a legend shape based on series type.
 */
export  type LegendShape = 'Circle' | 'Rectangle' | 'Triangle' | 'Diamond' | 'Cross' | 'HorizontalLine' | 'VerticalLine' | 'Pentagon' | 'InvertedTriangle' | 'SeriesType';
/**
 * Defines the zooming mode, They are.
 * * x,y - Chart will be zoomed with respect to both vertical and horizontal axis.
 * * x - Chart will be zoomed with respect to horizontal axis.
 * * y - Chart will be zoomed with respect to vertical axis.
 */
export  type ZoomMode = 'XY' | 'X' | 'Y';
/**
 * Defines the ZoomingToolkit, They are.
 * * zoom - Renders the zoom button.
 * * zoomIn - Renders the zoomIn button.
 * * zoomOut - Renders the zoomOut button.
 * * pan - Renders the pan button.
 * * reset - Renders the reset button.
 */
export  type ToolbarItems = 'Zoom' | 'ZoomIn' | 'ZoomOut' | 'Pan' | 'Reset';
/**
 * Defines the SelectionMode, They are.
 * * none - Disable the selection.
 * * series - To select a series.
 * * point - To select a point.
 * * cluster - To select a cluster of point
 * * dragXY - To select points, by dragging with respect to both horizontal and vertical axis
 * * dragX - To select points, by dragging with respect to horizontal axis.
 * * dragY - To select points, by dragging with respect to vertical axis.
 */
export  type SelectionMode = 'None' | 'Series' | 'Point' | 'Cluster' | 'DragXY' | 'DragY' | 'DragX';
/**
 * Defines the LabelPosition, They are.
 * * outer - Position the label outside the point.
 * * top - Position the label on top of the point.
 * * bottom - Position the label on bottom of the point.
 * * middle - Position the label to middle of the point.
 * * auto - Position the label based on series.
 */
export  type LabelPosition = 'Outer' | 'Top' | 'Bottom' | 'Middle' | 'Auto';
/**
 * Defines the Alignment. They are
 * * none - Shows all the labels.
 * * hide - Hide the label when it intersect.
 * * rotate45 - Rotate the label to 45 degree when it intersect.
 * * rotate90 - Rotate the label to 90 degree when it intersect.
 * *
 */
export  type LabelIntersectAction = 'None' | 'Hide' | 'Trim' | 'Wrap' | 'MultipleRows' | 'Rotate45' | 'Rotate90';
/**
 * Defines the Position. They are
 * * inside - Place the ticks or labels inside to the axis line.
 * * outside - Place the ticks or labels outside to the axis line.
 * *
 */
export  type AxisPosition = 'Inside' | 'Outside';
/**
 * Defines Theme of the chart. They are
 * * Material - Render a chart with Material theme.
 * * Fabric - Render a chart with Fabric theme
 */
export  type ChartTheme = 'Material' | 'Fabric' | 'Bootstrap' | 'Highcontrast';
/**
 *  Specifies the order of the strip line. `Over` | `Behind`.
 * * Over - Places the strip line over the series elements.
 * * Behind - laces the strip line behind the series elements.
 */
export  type ZIndex = 'Over' | 'Behind';
/**
 * Defines the strip line text position.
 * * Start - Places the strip line text at the start.
 * * Middle - Places the strip line text in the middle.
 * * End - Places the strip line text at the end.
 */
export  type Anchor = 'Start' | 'Middle' | 'End';
/**
 * Defines the empty point mode of the chart.
 * * Gap - Used to display empty points as space.
 * * Zero - Used to display empty points as zero.
 * * Drop - Used to ignore the empty point while rendering.
 * * Average - Used to display empty points as previous and next point average.
 */
export  type EmptyPointMode = 'Gap' | 'Zero' | 'Drop' | 'Average';
/**
 * Defines the type of technical indicators. They are
 * * Sma - Predicts the trend using Simple Moving Average approach
 * * Ema - Predicts the trend using Exponential Moving Average approach
 * * Tma - Predicts the trend using Triangle Moving Average approach
 * * Atr - Predicts the trend using Average True Range approach
 * * AccumulationDistribution - Predicts the trend using Accumulation Distribution approach
 * * Momentum - Predicts the trend using Momentum approach
 * * Rsi - Predicts the trend using RSI approach
 * * Macd - Predicts the trend using Moving Average Convergence Divergence approach
 * * Stochastic - Predicts the trend using Stochastic approach
 * * BollingerBands - Predicts the trend using Bollinger approach
 */
export  type TechnicalIndicators = 'Sma' | 'Ema' | 'Tma' | 'Momentum' | 'Atr' | 'AccumulationDistribution' | 'BollingerBands' | 'Macd' | 'Stochastic' | 'Rsi';
/**
 * Defines the type of trendlines. They are
 * * Linear - Defines the linear trendline
 * * Exponential - Defines the exponential trendline
 * * Polynomial - Defines the polynomial trendline
 * * Power - Defines the power trendline
 * * Logarithmic - Defines the logarithmic trendline
 * * MovingAverage - Defines the moving average trendline
 */
export  type TrendlineTypes = 'Linear' | 'Exponential' | 'Polynomial' | 'Power' | 'Logarithmic' | 'MovingAverage';
/** @private */
export  type SeriesCategories = 'TrendLine' | 'Indicator' | 'Series';
/**
 * Defines the financial data fields
 * * High - Represents the highest price in the stocks over time
 * * Low - Represents the lowest price in the stocks over time
 * * Open - Represents the opening price in the stocks over time
 * * Close - Represents the closing price in the stocks over time
 */
export  type FinancialDataFields = 'High' | 'Low' | 'Open' | 'Close';
/**
 * It defines type of spline.
 * Natural - Used to render Natural spline.
 * Cardinal - Used to render cardinal spline.
 * Clamped - Used to render Clamped spline
 * Monotonic - Used to render monotonic spline
 */
export  type SplineType = 'Natural' | 'Monotonic' | 'Cardinal' | 'Clamped';
/**
 * Defines the BoxPlotMode for box and whisker chart series, They are.
 * * exclusive - Series render based on exclusive mode.
 * * inclusive - Series render based on inclusive mode.
 * * normal - Series render based on normal mode.
 */
export  type BoxPlotMode = 'Exclusive' | 'Inclusive' | 'Normal';
/**
 * Defines the skeleton type for the axis.
 * * Date - it formats date only.
 * * DateTime - it formats date and time.
 * * Time - it formats time only.
 */
export  type SkeletonType = 'Date' | 'DateTime' | 'Time';
/**
 * Defines border type for multi level labels.
 *  * Rectangle
 *  * Brace
 *  * WithoutBorder
 *  * Without top Border
 *  * Without top and bottom border
 *  * Curly brace
 */
export  type BorderType = 'Rectangle' | 'Brace' | 'WithoutBorder' | 'WithoutTopBorder' | 'WithoutTopandBottomBorder' | 'CurlyBrace';
/**
 * To get the data on mouse move.
 * @private
 */
export  class ChartData {
    /** @private */
    chart: Chart;
    lierIndex: number;
    /** @private */
    currentPoints: PointData[] | AccPointData[];
    /** @private */
    previousPoints: PointData[] | AccPointData[];
    /**
     * Constructor for the data.
     * @private
     */
    constructor(chart: Chart);
    /**
     * Method to get the Data.
     * @private
     */
    getData(): PointData;
    isSelected(chart: Chart): boolean;
    private getRectPoint(series, rect, x, y);
    /**
     * Checks whether the region contains a point
     */
    private checkRegionContainsPoint(regionRect, rect, x, y);
    private getClosest(series, value);
    getClosestX(chart: Chart, series: Series): PointData;
}
/**
 * Annotation Module handles the Annotation for chart and accumulation series.
 */
export  class AnnotationBase {
    private control;
    private annotation;
    private isChart;
    /**
     * Constructor for chart and accumulation annotation
     * @param control
     */
    constructor(control: Chart | AccumulationChart);
    /**
     * Method to render the annotation for chart and accumulation series.
     * @private
     * @param annotation
     * @param index
     */
    render(annotation: AccumulationAnnotationSettings | ChartAnnotationSettings, index: number): HTMLElement;
    /**
     * Method to calculate the location for annotation - coordinate unit as pixel.
     * @private
     * @param location
     */
    setAnnotationPixelValue(location: ChartLocation): boolean;
    /**
     * Method to calculate the location for annotation - coordinate unit as point.
     * @private
     * @param location
     */
    setAnnotationPointValue(location: ChartLocation): boolean;
    /**
     * To process the annotation for accumulation chart
     * @param annotation
     * @param index
     * @param parentElement
     */
    processAnnotation(annotation: ChartAnnotationSettings | AccumulationAnnotationSettings, index: number, parentElement: HTMLElement): void;
    /**
     * Method to calculate the location for annotation - coordinate unit as point in accumulation chart.
     * @private
     * @param location
     */
    setAccumulationPointValue(location: ChartLocation): boolean;
    /**
     * Method to set the element style for accumulation / chart annotation.
     * @private
     * @param location
     * @param element
     * @param parentElement
     */
    setElementStyle(location: ChartLocation, element: HTMLElement, parentElement: HTMLElement): void;
    /**
     * Method to calculate the alignment value for annotation.
     * @private
     * @param alignment
     * @param size
     * @param value
     */
    setAlignmentValue(alignment: Alignment | Position, size: number, value: number): number;
}


/**
 * Interface for a class Location
 */
export interface LocationModel {
    /**
     * X coordinate of the legend in pixels.
     * @default 0
     */
    x?: number;
    /**
     * Y coordinate of the legend in pixels.
     * @default 0
     */
    y?: number;
}
/**
 * Interface for a class LegendSettings
 */
export interface LegendSettingsModel {
    /**
     * If set to true, legend will be visible.
     * @default true
     */
    visible?: boolean;
    /**
     * The height of the legend in pixels.
     * @default null
     */
    height?: string;
    /**
     * The width of the legend in pixels.
     * @default null
     */
    width?: string;
    /**
     * Specifies the location of the legend, relative to the chart.
     * If x is 20, legend moves by 20 pixels to the right of the chart. It requires the `position` to be `Custom`.
     * ```html
     * <div id='base.Chart'></div>
     * ```
     * ```typescript
     * let chart: base.Chart = new base.Chart({
     * ...
     *   legendSettings: {
     *     visible: true,
     *     position: 'Custom',
     *     location: { x: 100, y: 150 },
     *   },
     * ...
     * });
     * chart.appendTo('#base.Chart');
     * ```
     */
    location?: LocationModel;
    /**
     * Position of the legend in the chart are,
     * * Auto: Places the legend based on area type.
     * * Top: Displays the legend at the top of the chart.
     * * Left: Displays the legend at the left of the chart.
     * * Bottom: Displays the legend at the bottom of the chart.
     * * Right: Displays the legend at the right of the chart.
     * * Custom: Displays the legend  based on the given x and y values.
     * @default 'Auto'
     */
    position?: LegendPosition;
    /**
     * Option to customize the padding between legend items.
     * @default 8
     */
    padding?: number;
    /**
     * base.Legend in chart can be aligned as follows:
     * * Near: Aligns the legend to the left of the chart.
     * * Center: Aligns the legend to the center of the chart.
     * * Far: Aligns the legend to the right of the chart.
     * @default 'Center'
     */
    alignment?: Alignment;
    /**
     * Options to customize the legend text.
     */
    textStyle?: FontModel;
    /**
     * Shape height of the legend in pixels.
     * @default 10
     */
    shapeHeight?: number;
    /**
     * Shape width of the legend in pixels.
     * @default 10
     */
    shapeWidth?: number;
    /**
     * Options to customize the border of the legend.
     */
    border?: BorderModel;
    /**
     * Padding between the legend shape and text.
     * @default 5
     */
    shapePadding?: number;
    /**
     * The background color of the legend that accepts value in hex and rgba as a valid CSS color string.
     * @default 'transparent'
     */
    background?: string;
    /**
     * Opacity of the legend.
     * @default 1
     */
    opacity?: number;
    /**
     * If set to true, series' visibility collapses based on the legend visibility.
     * @default true
     */
    toggleVisibility?: boolean;
    /**
     * Description for legends.
     * @default null
     */
    description?: string;
    /**
     * TabIndex value for the legend.
     * @default 3
     */
    tabIndex?: number;
}
/**
 * Interface for a class BaseLegend
 * @private
 */
export interface BaseLegendModel {
}
/**
 * Interface for a class LegendOptions
 * @private
 */
export interface LegendOptionsModel {
}
/**
 * Configures the location for the legend.
 */
export  class Location extends base.ChildProperty<Location> {
    /**
     * X coordinate of the legend in pixels.
     * @default 0
     */
    x: number;
    /**
     * Y coordinate of the legend in pixels.
     * @default 0
     */
    y: number;
}
/**
 * Configures the legends in charts.
 */
export  class LegendSettings extends base.ChildProperty<LegendSettings> {
    /**
     * If set to true, legend will be visible.
     * @default true
     */
    visible: boolean;
    /**
     * The height of the legend in pixels.
     * @default null
     */
    height: string;
    /**
     * The width of the legend in pixels.
     * @default null
     */
    width: string;
    /**
     * Specifies the location of the legend, relative to the chart.
     * If x is 20, legend moves by 20 pixels to the right of the chart. It requires the `position` to be `Custom`.
     * ```html
     * <div id='Chart'></div>
     * ```
     * ```typescript
     * let chart: Chart = new Chart({
     * ...
     *   legendSettings: {
     *     visible: true,
     *     position: 'Custom',
     *     location: { x: 100, y: 150 },
     *   },
     * ...
     * });
     * chart.appendTo('#Chart');
     * ```
     */
    location: LocationModel;
    /**
     * Position of the legend in the chart are,
     * * Auto: Places the legend based on area type.
     * * Top: Displays the legend at the top of the chart.
     * * Left: Displays the legend at the left of the chart.
     * * Bottom: Displays the legend at the bottom of the chart.
     * * Right: Displays the legend at the right of the chart.
     * * Custom: Displays the legend  based on the given x and y values.
     * @default 'Auto'
     */
    position: LegendPosition;
    /**
     * Option to customize the padding between legend items.
     * @default 8
     */
    padding: number;
    /**
     * Legend in chart can be aligned as follows:
     * * Near: Aligns the legend to the left of the chart.
     * * Center: Aligns the legend to the center of the chart.
     * * Far: Aligns the legend to the right of the chart.
     * @default 'Center'
     */
    alignment: Alignment;
    /**
     * Options to customize the legend text.
     */
    textStyle: FontModel;
    /**
     * Shape height of the legend in pixels.
     * @default 10
     */
    shapeHeight: number;
    /**
     * Shape width of the legend in pixels.
     * @default 10
     */
    shapeWidth: number;
    /**
     * Options to customize the border of the legend.
     */
    border: BorderModel;
    /**
     * Padding between the legend shape and text.
     * @default 5
     */
    shapePadding: number;
    /**
     * The background color of the legend that accepts value in hex and rgba as a valid CSS color string.
     * @default 'transparent'
     */
    background: string;
    /**
     * Opacity of the legend.
     * @default 1
     */
    opacity: number;
    /**
     * If set to true, series' visibility collapses based on the legend visibility.
     * @default true
     */
    toggleVisibility: boolean;
    /**
     * Description for legends.
     * @default null
     */
    description: string;
    /**
     * TabIndex value for the legend.
     * @default 3
     */
    tabIndex: number;
}
/**
 * Legend base class for Chart and Accumulation chart.
 * @private
 */
export  class BaseLegend {
    protected chart: Chart | AccumulationChart;
    protected legend: LegendSettingsModel;
    protected maxItemHeight: number;
    protected isPaging: boolean;
    private clipPathHeight;
    protected totalPages: number;
    protected isVertical: boolean;
    private rowCount;
    private columnCount;
    private pageButtonSize;
    protected pageXCollections: number[];
    protected maxColumns: number;
    private isTrimmed;
    maxWidth: number;
    protected legendID: string;
    private clipRect;
    private legendTranslateGroup;
    private currentPage;
    private isChartControl;
    protected library: Legend | AccumulationLegend;
    /**  @private */
    position: LegendPosition;
    /**
     * Gets the legend bounds in chart.
     * @private
     */
    legendBounds: Rect;
    /** @private */
    legendCollections: LegendOptions[];
    /** @private */
    clearTooltip: number;
    /**
     * Constructor for the dateTime module.
     * @private
     */
    constructor(chart?: Chart | AccumulationChart);
    /**
     * Calculate the bounds for the legends.
     * @return {void}
     * @private
     */
    calculateLegendBounds(rect: Rect, availableSize: Size): void;
    /**
     * To find legend position based on available size for chart and accumulation chart
     */
    private getPosition(position, availableSize);
    /**
     * To set bounds for chart and accumulation chart
     */
    protected setBounds(computedWidth: number, computedHeight: number, legend: LegendSettingsModel, legendBounds: Rect): void;
    /**
     * To find legend location based on position, alignment for chart and accumulation chart
     */
    private getLocation(position, alignment, legendBounds, rect, availableSize);
    /**
     * To find legend alignment for chart and accumulation chart
     */
    private alignLegend(start, size, legendSize, alignment);
    /**
     * Renders the legend.
     * @return {void}
     * @private
     */
    renderLegend(chart: Chart | AccumulationChart, legend: LegendSettingsModel, legendBounds: Rect): void;
    /**
     * To find first valid legend text index for chart and accumulation chart
     */
    private findFirstLegendPosition(legendCollection);
    /**
     * To create legend rendering elements for chart and accumulation chart
     */
    private createLegendElements(chart, legendBounds, legendGroup, legend, id);
    /**
     * To render legend symbols for chart and accumulation chart
     */
    private renderSymbol(legendOption, group, i);
    /**
     * To render legend text for chart and accumulation chart
     */
    private renderText(chart, legendOption, group, textOptions, i);
    /**
     * To render legend paging elements for chart and accumulation chart
     */
    private renderPagingElements(chart, bounds, textOption, legendGroup);
    /**
     * To translate legend pages for chart and accumulation chart
     */
    protected translatePage(pagingText: Element, page: number, pageNumber: number): void;
    /**
     * To change legend pages for chart and accumulation chart
     */
    protected changePage(event: Event, pageUp: boolean): void;
    /**
     * To find legend elements id based on chart or accumulation chart
     * @private
     */
    generateId(option: LegendOptions, prefix: string, count: number): string;
    /**
     * To show or hide trimmed text tooltip for legend.
     * @return {void}
     * @private
     */
    move(event: Event): void;
}
/**
 * Class for legend options
 * @private
 */
export  class LegendOptions {
    render: boolean;
    text: string;
    fill: string;
    shape: LegendShape;
    visible: boolean;
    type: ChartSeriesType | AccumulationType;
    textSize: Size;
    location: ChartLocation;
    pointIndex?: number;
    seriesIndex?: number;
    markerShape?: ChartShape;
    markerVisibility?: boolean;
    constructor(text: string, fill: string, shape: LegendShape, visible: boolean, type: ChartSeriesType | AccumulationType, markerShape?: ChartShape, markerVisibility?: boolean, pointIndex?: number, seriesIndex?: number);
}
/**
 * Interface for a class Connector
 */
export interface ConnectorModel {
    /**
     * specifies the type of the connector line. They are
     * * Smooth
     * * Line
     * @default 'Line'
     */
    type?: ConnectorType;
    /**
     * Color of the connector line.
     * @default null
     */
    color?: string;
    /**
     * Width of the connector line in pixels.
     * @default 1
     */
    width?: number;
    /**
     * Length of the connector line in pixels.
     * @default null
     */
    length?: string;
    /**
     * dashArray of the connector line.
     * @default ''
     */
    dashArray?: string;
}
/**
 * Interface for a class Font
 */
export interface FontModel {
    /**
     * Font size for the text.
     * @default '16px'
     */
    size?: string;
    /**
     * Color for the text.
     * @default ''
     */
    color?: string;
    /**
     * FontFamily for the text.
     */
    fontFamily?: string;
    /**
     * FontWeight for the text.
     * @default 'Normal'
     */
    fontWeight?: string;
    /**
     * FontStyle for the text.
     * @default 'Normal'
     */
    fontStyle?: string;
    /**
     * Opacity for the text.
     * @default 1
     */
    opacity?: number;
    /**
     * text alignment
     * @default 'Center'
     */
    textAlignment?: Alignment;
    /**
     * Specifies the chart title text overflow
     * @default 'Trim'
     */
    textOverflow?: TextOverflow;
}
/**
 * Interface for a class Border
 */
export interface BorderModel {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default ''
     */
    color?: string;
    /**
     * The width of the border in pixels.
     * @default 1
     */
    width?: number;
}
/**
 * Interface for a class ChartArea
 */
export interface ChartAreaModel {
    /**
     * Options to customize the border of the chart area.
     */
    border?: BorderModel;
    /**
     * The background of the chart area that accepts value in hex and rgba as a valid CSS color string..
     * @default transparent
     */
    background?: string;
    /**
     * The opacity for background.
     * @default 1
     */
    opacity?: number;
}
/**
 * Interface for a class Margin
 */
export interface MarginModel {
    /**
     * Left margin in pixels.
     * @default 10
     */
    left?: number;
    /**
     * Right margin in pixels.
     * @default 10
     */
    right?: number;
    /**
     * Top margin in pixels.
     * @default 10
     */
    top?: number;
    /**
     * Bottom margin in pixels.
     * @default 10
     */
    bottom?: number;
}
/**
 * Interface for a class Animation
 */
export interface AnimationModel {
    /**
     * If set to true, series gets animated on initial loading.
     * @default true
     */
    enable?: boolean;
    /**
     * The duration of animation in milliseconds.
     * @default 1000
     */
    duration?: number;
    /**
     * The option to delay animation of the series.
     * @default 0
     */
    delay?: number;
}
/**
 * Interface for a class Indexes
 * @private
 */
export interface IndexesModel {
    /**
     * Specifies the series index
     * @default 0
     */
    series?: number;
    /**
     * Specifies the point index
     * @default 0
     */
    point?: number;
}
/**
 * Interface for a class CornerRadius
 */
export interface CornerRadiusModel {
    /**
     * Specifies the top left corner radius value
     * @default 0
     */
    topLeft?: number;
    /**
     * Specifies the top right corner radius value
     * @default 0
     */
    topRight?: number;
    /**
     * Specifies the bottom left corner radius value
     * @default 0
     */
    bottomLeft?: number;
    /**
     * Specifies the bottom right corner radius value
     * @default 0
     */
    bottomRight?: number;
}
/**
 * Interface for a class Index
 * @private
 */
export interface IndexModel {
}
/**
 * Interface for a class EmptyPointSettings
 */
export interface EmptyPointSettingsModel {
    /**
     * To customize the fill color of empty points.
     * @default null
     */
    fill?: string;
    /**
     * Options to customize the border of empty points.
     * @default "{color: 'transparent', width: 0}"
     */
    border?: BorderModel;
    /**
     * To customize the mode of empty points.
     * @default Gap
     */
    mode?: EmptyPointMode | AccEmptyPointMode;
}
/**
 * Interface for a class TooltipSettings
 */
export interface TooltipSettingsModel {
    /**
     * Enables / Disables the visibility of the tooltip.
     * @default false.
     */
    enable?: boolean;
    /**
     * If set to true, a single ToolTip will be displayed for every index.
     * @default false.
     */
    shared?: boolean;
    /**
     * The fill color of the tooltip that accepts value in hex and rgba as a valid CSS color string. 
     */
    fill?: string;
    /**
     * Header for tooltip. 
     */
    header?: string;
    /**
     * The fill color of the tooltip that accepts value in hex and rgba as a valid CSS color string. 
     */
    opacity?: number;
    /**
     * Options to customize the ToolTip text.
     */
    textStyle?: FontModel;
    /**
     * Format the ToolTip content.
     * @default null.
     */
    format?: string;
    /**
     * Custom template to format the ToolTip content. Use ${x} and ${y} as the placeholder text to display the corresponding data point.
     * @default null.
     */
    template?: string;
    /**
     * If set to true, ToolTip will animate while moving from one point to another.
     * @default true.
     */
    enableAnimation?: boolean;
    /**
     * Options to customize tooltip borders.
     */
    border?: BorderModel;
}
/**
 * Defines the appearance of the connectors
 */
export  class Connector extends base.ChildProperty<Connector> {
    /**
     * specifies the type of the connector line. They are
     * * Smooth
     * * Line
     * @default 'Line'
     */
    type: ConnectorType;
    /**
     * Color of the connector line.
     * @default null
     */
    color: string;
    /**
     * Width of the connector line in pixels.
     * @default 1
     */
    width: number;
    /**
     * Length of the connector line in pixels.
     * @default null
     */
    length: string;
    /**
     * dashArray of the connector line.
     * @default ''
     */
    dashArray: string;
}
/**
 * Configures the fonts in charts.
 */
export  class Font extends base.ChildProperty<Font> {
    /**
     * Font size for the text.
     * @default '16px'
     */
    size: string;
    /**
     * Color for the text.
     * @default ''
     */
    color: string;
    /**
     * FontFamily for the text.
     */
    fontFamily: string;
    /**
     * FontWeight for the text.
     * @default 'Normal'
     */
    fontWeight: string;
    /**
     * FontStyle for the text.
     * @default 'Normal'
     */
    fontStyle: string;
    /**
     * Opacity for the text.
     * @default 1
     */
    opacity: number;
    /**
     * text alignment
     * @default 'Center'
     */
    textAlignment: Alignment;
    /**
     * Specifies the chart title text overflow
     * @default 'Trim'
     */
    textOverflow: TextOverflow;
}
/**
 * Configures the borders in the chart.
 */
export  class Border extends base.ChildProperty<Border> {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default ''
     */
    color: string;
    /**
     * The width of the border in pixels.
     * @default 1
     */
    width: number;
}
/**
 * Configures the chart area.
 */
export  class ChartArea extends base.ChildProperty<ChartArea> {
    /**
     * Options to customize the border of the chart area.
     */
    border: BorderModel;
    /**
     * The background of the chart area that accepts value in hex and rgba as a valid CSS color string..
     * @default transparent
     */
    background: string;
    /**
     * The opacity for background.
     * @default 1
     */
    opacity: number;
}
/**
 * Configures the chart margins.
 */
export  class Margin extends base.ChildProperty<Margin> {
    /**
     * Left margin in pixels.
     * @default 10
     */
    left: number;
    /**
     * Right margin in pixels.
     * @default 10
     */
    right: number;
    /**
     * Top margin in pixels.
     * @default 10
     */
    top: number;
    /**
     * Bottom margin in pixels.
     * @default 10
     */
    bottom: number;
}
/**
 * Configures the animation behavior for chart series.
 */
export  class Animation extends base.ChildProperty<Animation> {
    /**
     * If set to true, series gets animated on initial loading.
     * @default true
     */
    enable: boolean;
    /**
     * The duration of animation in milliseconds.
     * @default 1000
     */
    duration: number;
    /**
     * The option to delay animation of the series.
     * @default 0
     */
    delay: number;
}
/** @private */
export  class Indexes extends base.ChildProperty<Indexes> {
    /**
     * Specifies the series index
     * @default 0
     */
    series: number;
    /**
     * Specifies the point index
     * @default 0
     */
    point: number;
}
/**
 * Column series rounded corner options
 */
export  class CornerRadius extends base.ChildProperty<CornerRadius> {
    /**
     * Specifies the top left corner radius value
     * @default 0
     */
    topLeft: number;
    /**
     * Specifies the top right corner radius value
     * @default 0
     */
    topRight: number;
    /**
     * Specifies the bottom left corner radius value
     * @default 0
     */
    bottomLeft: number;
    /**
     * Specifies the bottom right corner radius value
     * @default 0
     */
    bottomRight: number;
}
/**
 * @private
 */
export  class Index {
    series: number;
    point: number;
    constructor(seriesIndex: number, pointIndex?: number);
}
/**
 * Configures the Empty Points of series
 */
export  class EmptyPointSettings extends base.ChildProperty<EmptyPointSettings> {
    /**
     * To customize the fill color of empty points.
     * @default null
     */
    fill: string;
    /**
     * Options to customize the border of empty points.
     * @default "{color: 'transparent', width: 0}"
     */
    border: BorderModel;
    /**
     * To customize the mode of empty points.
     * @default Gap
     */
    mode: EmptyPointMode | AccEmptyPointMode;
}
/**
 * Configures the ToolTips in the chart.
 */
export  class TooltipSettings extends base.ChildProperty<TooltipSettings> {
    /**
     * Enables / Disables the visibility of the tooltip.
     * @default false.
     */
    enable: boolean;
    /**
     * If set to true, a single ToolTip will be displayed for every index.
     * @default false.
     */
    shared: boolean;
    /**
     * The fill color of the tooltip that accepts value in hex and rgba as a valid CSS color string.
     */
    fill: string;
    /**
     * Header for tooltip.
     */
    header: string;
    /**
     * The fill color of the tooltip that accepts value in hex and rgba as a valid CSS color string.
     */
    opacity: number;
    /**
     * Options to customize the ToolTip text.
     */
    textStyle: FontModel;
    /**
     * Format the ToolTip content.
     * @default null.
     */
    format: string;
    /**
     * Custom template to format the ToolTip content. Use ${x} and ${y} as the placeholder text to display the corresponding data point.
     * @default null.
     */
    template: string;
    /**
     * If set to true, ToolTip will animate while moving from one point to another.
     * @default true.
     */
    enableAnimation: boolean;
    /**
     * Options to customize tooltip borders.
     */
    border: BorderModel;
}
/**
 * Specifies the chart constant value
 */
/** @private */
export  const loaded: string;
/** @private */
export  const load: string;
/** @private */
export  const animationComplete: string;
/** @private */
export  const legendRender: string;
/** @private */
export  const textRender: string;
/** @private */
export  const pointRender: string;
/** @private */
export  const seriesRender: string;
/** @private */
export  const axisLabelRender: string;
/** @private */
export  const axisRangeCalculated: string;
/** @private */
export  const axisMultiLabelRender: string;
/** @private */
export  const tooltipRender: string;
/** @private */
export  const chartMouseMove: string;
/** @private */
export  const chartMouseClick: string;
/** @private */
export  const pointClick: string;
/** @private */
export  const pointMove: string;
/** @private */
export  const chartMouseLeave: string;
/** @private */
export  const chartMouseDown: string;
/** @private */
export  const chartMouseUp: string;
/** @private */
export  const zoomComplete: string;
/** @private */
export  const dragComplete: string;
/** @private */
export  const resized: string;
/** @private */
export  const beforePrint: string;
/** @private */
export  const annotationRender: string;
/**
 * data module is used to generate query and dataSource
 */
export  class Data {
    private dataManager;
    private query;
    /**
     * Constructor for data module
     * @private
     */
    constructor(dataSource?: Object | data.DataManager, query?: data.Query);
    /**
     * The function used to initialize dataManager and query
     * @return {void}
     * @private
     */
    initDataManager(dataSource: Object | data.DataManager, query: data.Query): void;
    /**
     * The function used to generate updated data.Query from chart model
     * @return {void}
     * @private
     */
    generateQuery(): data.Query;
    /**
     * The function used to get dataSource by executing given data.Query
     * @param  {data.Query} query - A data.Query that specifies to generate dataSource
     * @return {void}
     * @private
     */
    getData(query: data.Query): Promise<Object>;
}
export interface IChartEventArgs {
    /** Defines the name of the event */
    name: string;
    /** Defines the event cancel status */
    cancel: boolean;
}
export interface ILegendRenderEventArgs extends IChartEventArgs {
    /** Defines the current legend text */
    text: string;
    /** Defines the current legend fill color */
    fill: string;
    /** Defines the current legend shape */
    shape: LegendShape;
    /** Defines the current legend marker shape */
    markerShape?: ChartShape;
}
export interface IAccLegendRenderEventArgs extends IChartEventArgs {
    /** Defines the current legend shape */
    shape: LegendShape;
    /** Defines the current legend fill color */
    fill: string;
    /** Defines the current legend text */
    text: string;
}
export interface ITextRenderEventArgs extends IChartEventArgs {
    /** Defines the current series of the label */
    series: SeriesModel;
    /** Defines the current point of the label */
    point: Points;
    /** Defines the current text */
    text: string;
    /** Defines the current label fill color */
    color: string;
    /** Defines the current label border */
    border: BorderModel;
    /** Defines the current label template */
    template: string;
}
export interface IAnnotationRenderEventArgs extends IChartEventArgs {
    /** Defines the current annotation content */
    content: HTMLElement;
    /** Defines the current annotation location */
    location: ChartLocation;
}
export interface IZoomCompleteEventArgs extends IChartEventArgs {
    /** Defines the zoomed axis */
    axis: AxisModel;
    /** Defines the previous zoom factor */
    previousZoomFactor: number;
    /** Defines the previous zoom position */
    previousZoomPosition: number;
    /** Defines the current zoom factor */
    currentZoomFactor: number;
    /** Defines the current zoom position */
    currentZoomPosition: number;
}
export interface IPointRenderEventArgs extends IChartEventArgs {
    /** Defines the current series of the point */
    series: Series;
    /** Defines the current point */
    point: Points;
    /** Defines the current point fill color */
    fill: string;
    /** Defines the current point border */
    border: BorderModel;
    /** Defines the current point height */
    height?: number;
    /** Defines the current point width */
    width?: number;
    /** Defines the current point marker shape */
    shape?: ChartShape;
}
export interface ISeriesRenderEventArgs {
    /** Defines the current series */
    series: Series;
    /** Defines the current series data object */
    data: Object;
    /** Defines name of the event */
    name: string;
    /** Defines the current series fill */
    fill: string;
}
export interface IAxisLabelRenderEventArgs extends IChartEventArgs {
    /** Defines the current axis */
    axis: Axis;
    /** Defines axis current label text */
    text: string;
    /** Defines axis current label value */
    value: number;
    /** Defines axis current label font style */
    labelStyle: FontModel;
}
export interface IAxisRangeCalculatedEventArgs extends IChartEventArgs {
    /** Defines the current axis */
    axis: Axis;
    /** Defines axis current range */
    minimum: number;
    /** Defines axis current range */
    maximum: number;
    /** Defines axis current interval */
    interval: number;
}
export interface IAxisMultiLabelRenderEventArgs extends IChartEventArgs {
    /** Defines the current axis */
    axis: Axis;
    /** Defines axis current label text */
    text: string;
    /** Defines font style for multi labels */
    textStyle: FontModel;
    /** Defines text alignment for multi labels */
    alignment: Alignment;
}
export interface ITooltipRenderEventArgs extends IChartEventArgs {
    /** Defines tooltip text collections */
    text?: string;
    /** Defines tooltip text style */
    textStyle?: FontModel;
    /** Defines current tooltip series */
    series: Series | AccumulationSeries;
    /** Defines current tooltip point */
    point: Points | AccPoints;
}
export interface IMouseEventArgs extends IChartEventArgs {
    /** Defines current mouse event target id */
    target: string;
    /** Defines current mouse x location */
    x: number;
    /** Defines current mouse y location */
    y: number;
}
export interface IPointEventArgs extends IChartEventArgs {
    /** Defines the current series */
    series: SeriesModel;
    /** Defines the current point */
    point: Points;
    /** Defines the point index */
    pointIndex: number;
    /** Defines the series index */
    seriesIndex: number;
    /** Defines the current chart instance */
    chart: Chart;
    /** Defines current mouse x location */
    x: number;
    /** Defines current mouse y location */
    y: number;
}
/** @private */
export interface IFontMapping {
    size?: string;
    color?: string;
    fontWeight?: string;
    fontStyle?: string;
    fontFamily?: string;
}
/** @private */
export interface ITouches {
    pageX?: number;
    pageY?: number;
    pointerId?: number;
}
/** @private */
export interface IShapes {
    renderOption?: Object;
    functionName?: string;
}
/** @private */
export interface IZoomAxisRange {
    actualMin?: number;
    actualDelta?: number;
    min?: number;
    delta?: number;
}
export interface IDragCompleteEventArgs extends IChartEventArgs {
    /** Defines current selected Data X, Y values */
    selectedDataValues: {
        x: string;
        y: number;
    }[][];
}
export interface ILoadedEventArgs extends IChartEventArgs {
    /** Defines the current chart instance */
    chart: Chart;
}
export interface IAnimationCompleteEventArgs extends IChartEventArgs {
    /** Defines the current animation series */
    series: Series;
}
export interface IPrintEventArgs extends IChartEventArgs {
    htmlContent: Element;
}
export interface IResizeEventArgs {
    /** Defines the name of the Event */
    name: string;
    /** Defines the previous size of the accumulation chart */
    previousSize: Size;
    /** Defines the current size of the accumulation chart */
    currentSize: Size;
    /** Defines the accumulation chart instance */
    chart: Chart | AccumulationChart;
}
/** @private */
export interface IBoxPlotQuartile {
    minimum: number;
    maximum: number;
    outliers: number[];
    upperQuartile: number;
    lowerQuartile: number;
    average: number;
    median: number;
}
/** @private */
/**
 * Specifies the Theme style for chart and accumulation.
 */
export interface IThemeStyle {
    axisLabel: string;
    axisTitle: string;
    axisLine: string;
    majorGridLine: string;
    minorGridLine: string;
    majorTickLine: string;
    minorTickLine: string;
    chartTitle: string;
    legendLabel: string;
    background: string;
    areaBorder: string;
    errorBar: string;
    crosshairLine: string;
    crosshairFill: string;
    crosshairLabel: string;
    tooltipFill: string;
    tooltipBoldLabel: string;
    tooltipLightLabel: string;
    tooltipHeaderLine: string;
    markerShadow: string;
    selectionRectFill: string;
    selectionRectStroke: string;
    selectionCircleStroke: string;
}
/**
 * Specifies Chart Themes
 */
export  namespace Theme {
    /** @private */
    let axisLabelFont: IFontMapping;
    /** @private */
    let axisTitleFont: IFontMapping;
    /** @private */
    let chartTitleFont: IFontMapping;
    /** @private */
    let crosshairLabelFont: IFontMapping;
    /** @private */
    let tooltipLabelFont: IFontMapping;
    /** @private */
    let legendLabelFont: IFontMapping;
    /** @private */
    let stripLineLabelFont: IFontMapping;
}
/** @private */
export  function getSeriesColor(theme: ChartTheme | AccumulationTheme): string[];
/** @private */
export  function getThemeColor(theme: ChartTheme | AccumulationTheme): IThemeStyle;
/**
 * Selection Module handles the selection for chart.
 * @private
 */
export  class BaseSelection {
    protected styleId: string;
    protected unselected: string;
    protected control: Chart | AccumulationChart;
    constructor(control: Chart | AccumulationChart);
    /**
     * To create selection styles for series
     */
    protected seriesStyles(): void;
    /**
     * To concat indexes
     */
    protected concatIndexes(userIndexes: IndexesModel[], localIndexes: Indexes[]): Indexes[];
    /**
     * Selected points series visibility checking on legend click
     */
    protected checkVisibility(selectedIndexes: Indexes[]): boolean;
    /**
     * To add svg element style class
     * @private
     */
    addSvgClass(element: Element, className: string): void;
    /**
     * To remove svg element style class
     * @private
     */
    removeSvgClass(element: Element, className: string): void;
    /**
     * To get children from parent element
     */
    protected getChildren(parent: Element): Element[];
}
/**
 * Tooltip Module used to render the tooltip for series.
 */
export  class BaseTooltip extends ChartData {
    element: HTMLElement;
    elementSize: Size;
    textStyle: FontModel;
    isRemove: boolean;
    toolTipInterval: number;
    padding: number;
    arrowPadding: number;
    textElements: Element[];
    templateFn: Function;
    rx: number;
    ry: number;
    isComplete: boolean;
    inverted: boolean;
    formattedText: string[];
    header: string;
    markerPoint: number[];
    /** @private */
    valueX: number;
    /** @private */
    valueY: number;
    tipRadius: number;
    control: AccumulationChart | Chart;
    /**
     * Constructor for tooltip module.
     * @private.
     */
    constructor(chart: Chart | AccumulationChart);
    getElement(id: string): HTMLElement;
    /**
     * Renders the tooltip.
     * @return {void}
     * @private
     */
    getTooltipElement(isTooltip: HTMLElement): HTMLDivElement;
    private createElement(chart);
    pushData(data: PointData | AccPointData, isFirst: boolean, tooltipDiv: HTMLDivElement, isChart: boolean): boolean;
    renderTooltip(data: PointData | AccPointData, areaRect: Rect, location: ChartLocation, textCollection: string, isFirst: boolean, cartesain: boolean): Side;
    renderTemplate(data: PointData | AccPointData, rect: Rect, location: ChartLocation, point: Points | AccPoints, isFirst: boolean): void;
    renderTooltipElement(chart: Chart | AccumulationChart, pointData: PointData | AccPointData, areaRect: Rect, location: ChartLocation, cartesain: boolean, isFirst: boolean): Side;
    private changeText(point, isBottom, isRight, rect);
    renderText(isRender: boolean, chart: Chart | AccumulationChart): void;
    private createTemplate(point, data, areaRect, location, parent, isFirst);
    private sharedTooltipLocation(bounds, x, y);
    private seriesTooltipLocation(pointData, bounds, symbolLocation, arrowLocation, tipLocation);
    progressAnimation(element: HTMLElement, tooltipGroup: HTMLElement, series: Series | AccumulationSeries, opacity: number, rectOpacity: number, timeStamp: number, isRect: boolean, shared: boolean): void;
    endAnimation(element: HTMLElement, tooltipGroup: HTMLElement, series: Series | AccumulationSeries, shared: boolean): void;
    removeHighlight(chart: Chart | AccumulationChart): void;
    highlightPoint(series: Series | AccumulationSeries, pointIndex: number, highlight: boolean): void;
    highlightPoints(item: PointData | AccPointData): void;
    private animateTooltipDiv(tooltipDiv, rect);
    private updateDiv(tooltipDiv, x, y);
    triggerEvent(point: PointData | AccPointData, isFirst: boolean, textCollection: string, firstText?: boolean): boolean;
    removeText(): void;
    private updateTemplateFn(chart);
    stopAnimation(): void;
}
export  class Side {
    isRight: boolean;
    isBottom: boolean;
    constructor(bottom: boolean, right: boolean);
}
/**
 * Defines Coordinate units of an annotation. They are
 * * Pixel
 * * Point
 */
export  type Units = 'Pixel' | 'Point';
/**
 * Defines the Alignment. They are
 * * near - Align the element to the left.
 * * center - Align the element to the center.
 * * far - Align the element to the right.
 * *
 */
export  type Alignment = 'Near' | 'Center' | 'Far';
/**
 * Defines regions of an annotation. They are
 * * Chart
 * * Series
 */
export  type Regions = 'Chart' | 'Series';
/**
 * Defines the Position. They are
 * * top - Align the element to the top.
 * * middle - Align the element to the center.
 * * bottom - Align the element to the bottom.
 * *
 */
export  type Position = 'Top' | 'Middle' | 'Bottom';
/**
 * Defines the export file format.
 * * PNG - export the image file format as png.
 * * JPEG - export the image file format as jpeg.
 */
export  type ExportType = 'PNG' | 'JPEG' | 'SVG' | 'PDF';
/**
 * Defines the Text overflow.
 * * None - Shown the chart title with overlap if exceed.
 * * Wrap - Shown the chart title with wrap if exceed.
 * * Trim - Shown the chart title with trim if exceed.
 */
export  type TextOverflow = 'None' | 'Wrap' | 'Trim';
/**
 * Annotation Module handles the Annotation for chart and accumulation series.
 */
export  class ExportUtils {
    private control;
    private printWindow;
    /**
     * Constructor for chart and accumulation annotation
     * @param control
     */
    constructor(control: Chart | AccumulationChart);
    /**
     * To print the accumulation and chart elements
     * @param elements
     */
    print(elements?: string[] | string | Element): void;
    /**
     * To get the html string of the chart and accumulation
     * @param elements
     * @private
     */
    getHTMLContent(elements?: string[] | string | Element): Element;
    /**
     * To export the file as image/svg format
     * @param type
     * @param fileName
     */
    export(type: ExportType, fileName: string, orientation?: pdfexport.PdfPageOrientation): void;
    /**
     * To trigger the download element
     * @param fileName
     * @param type
     * @param url
     */
    triggerDownload(fileName: string, type: ExportType, url: string, isDownload: boolean): void;
}
/**
 * Methods for calculating the text size.
 */
/**
 * Function to measure the height and width of the text.
 * @param  {string} text
 * @param  {FontModel} font
 * @param  {string} id
 * @returns no
 * @private
 */
export  function measureText(text: string, font: FontModel): Size;
/**
 * Function to sort the dataSource, by default it sort the data in ascending order.
 * @param  {Object} data
 * @param  {string} fields
 * @param  {boolean} isDescending
 * @returns Object
 */
export  function sort(data: Object[], fields: string[], isDescending?: boolean): Object[];
/** @private */
export  function rotateTextSize(font: FontModel, text: string, angle: number, chart: Chart): Size;
/** @private */
export  function removeElement(id: string): void;
/** @private */
export  function logBase(value: number, base: number): number;
/** @private */
export  function showTooltip(text: string, x: number, y: number, areaWidth: number, id: string, element: Element, isTouch?: boolean): void;
/** @private */
export  function inside(value: number, range: VisibleRangeModel): boolean;
/** @private */
export  function withIn(value: number, range: VisibleRangeModel): boolean;
/** @private */
export  function withInRange(previousPoint: Points, currentPoint: Points, nextPoint: Points, series: Series): boolean;
/** @private */
export  function sum(values: number[]): number;
/** @private */
export  function subArraySum(values: Object[], first: number, last: number, index: number[], series: Series): number;
/** @private */
export  function subtractThickness(rect: Rect, thickness: Thickness): Rect;
/** @private */
export  function subtractRect(rect: Rect, thickness: Rect): Rect;
/** @private */
export  function degreeToLocation(degree: number, radius: number, center: ChartLocation): ChartLocation;
/** @private */
export  function getAngle(center: ChartLocation, point: ChartLocation): number;
/** @private */
export  function subArray(values: number[], index: number): number[];
/** @private */
export  function valueToCoefficient(value: number, axis: Axis): number;
/** @private */
export  function TransformToVisible(x: number, y: number, xAxis: Axis, yAxis: Axis, isInverted?: boolean, series?: Series): ChartLocation;
/**
 * method to find series, point index by element id
 * @private
 */
export  function indexFinder(id: string, isPoint?: boolean): Index;
/** @private */
export  function CoefficientToVector(coefficient: number, startAngle: number): ChartLocation;
/** @private */
export  function valueToPolarCoefficient(value: number, axis: Axis): number;
/** @private */
export  class Mean {
    verticalStandardMean: number;
    horizontalStandardMean: number;
    verticalSquareRoot: number;
    horizontalSquareRoot: number;
    verticalMean: number;
    horizontalMean: number;
    constructor(verticalStandardMean: number, verticalSquareRoot: number, horizontalStandardMean: number, horizontalSquareRoot: number, verticalMean: number, horizontalMean: number);
}
/** @private */
export  class PolarArc {
    startAngle: number;
    endAngle: number;
    innerRadius: number;
    radius: number;
    currentXPosition: number;
    constructor(startAngle?: number, endAngle?: number, innerRadius?: number, radius?: number, currentXPosition?: number);
}
/** @private */
export  function createTooltip(id: string, text: string, top: number, left: number, fontSize: string): void;
/** @private */
export  function createZoomingLabels(chart: Chart, axis: Axis, parent: Element, index: number, isVertical: boolean, rect: Rect): Element;
/** @private */
export  function withInBounds(x: number, y: number, bounds: Rect, width?: number, height?: number): boolean;
/** @private */
export  function getValueXByPoint(value: number, size: number, axis: Axis): number;
/** @private */
export  function getValueYByPoint(value: number, size: number, axis: Axis): number;
/** @private */
export  function findClipRect(series: Series): void;
/** @private */
export  function firstToLowerCase(str: string): string;
/** @private */
export  function getMinPointsDelta(axis: Axis, seriesCollection: Series[]): number;
/** @private */
export  function getAnimationFunction(effect: string): Function;
/**
 * Animation base.Effect Calculation Started Here
 * @param currentTime
 * @param startValue
 * @param endValue
 * @param duration
 * @private
 */
export  function linear(currentTime: number, startValue: number, endValue: number, duration: number): number;
/**
 * Animation base.Effect Calculation End
 * @private
 */
export  function markerAnimate(element: Element, delay: number, duration: number, series: Series | AccumulationSeries, pointIndex: number, point: ChartLocation, isLabel: boolean): void;
/**
 * Animation for template
 * @private
 */
export  function templateAnimate(element: Element, delay: number, duration: number, name: base.Effect, isRemove?: boolean): void;
/** @private */
export  function drawSymbol(location: ChartLocation, shape: string, size: Size, url: string, options: PathOption, label: string): Element;
/** @private */
export  function calculateShapes(location: ChartLocation, size: Size, shape: string, options: PathOption, url: string): IShapes;
/** @private */
export  function getRectLocation(startLocation: ChartLocation, endLocation: ChartLocation, outerRect: Rect): Rect;
/** @private */
export  function minMax(value: number, min: number, max: number): number;
/** @private */
export  function getElement(id: string): Element;
/** @private */
export  function getTemplateFunction(template: string): Function;
/** @private */
export  function createTemplate(childElement: HTMLElement, pointIndex: number, content: string, chart: Chart | AccumulationChart, point?: Points | AccPoints, series?: Series | AccumulationSeries): HTMLElement;
/** @private */
export  function getFontStyle(font: FontModel): string;
/** @private */
export  function measureElementRect(element: HTMLElement): ClientRect;
/** @private */
export  function findlElement(elements: NodeList, id: string): Element;
/** @private */
export  function getPoint(x: number, y: number, xAxis: Axis, yAxis: Axis, isInverted?: boolean, series?: Series): ChartLocation;
/** @private */
export  function appendElement(child: Element, parent: Element): void;
/** @private */
export  function getDraggedRectLocation(x1: number, y1: number, x2: number, y2: number, outerRect: Rect): Rect;
/** @private */
export  function checkBounds(start: number, size: number, min: number, max: number): number;
/** @private */
export  function getLabelText(currentPoint: Points, series: Series, chart: Chart): string[];
/** @private */
export  function stopTimer(timer: number): void;
/** @private */
export  function isCollide(rect: Rect, collections: Rect[], clipRect: Rect): boolean;
/** @private */
export  function isOverlap(currentRect: Rect, rect: Rect): boolean;
/** @private */
export  function containsRect(currentRect: Rect, rect: Rect): boolean;
/** @private */
export  function calculateRect(location: ChartLocation, textSize: Size, margin: MarginModel): Rect;
/** @private */
export  function convertToHexCode(value: ColorValue): string;
/** @private */
export  function componentToHex(value: number): string;
/** @private */
export  function convertHexToColor(hex: string): ColorValue;
/** @private */
export  function colorNameToHex(color: string): string;
/** @private */
export  function getSaturationColor(color: string, factor: number): string;
/** @private */
export  function getMedian(values: number[]): number;
/** @private */
export  function calculateLegendShapes(location: ChartLocation, size: Size, shape: string, options: PathOption): IShapes;
/** @private */
export  function textTrim(maxWidth: number, text: string, font: FontModel): string;
/** @private */
export  function stringToNumber(value: string, containerSize: number): number;
/** @private */
export  function findDirection(rX: number, rY: number, rect: Rect, arrowLocation: ChartLocation, arrowPadding: number, top: boolean, bottom: boolean, left: boolean, tipX: number, tipY: number, tipRadius?: number): string;
/** @private */
export  function textElement(options: TextOption, font: FontModel, color: string, parent: HTMLElement | Element, isMinus?: boolean): Element;
/**
 * Method to calculate the width and height of the chart
 */
export  function calculateSize(chart: Chart | AccumulationChart): void;
export  function createSvg(chart: Chart | AccumulationChart): void;
/**
 * To calculate chart title and height
 * @param title
 * @param style
 * @param width
 */
export  function getTitle(title: string, style: FontModel, width: number): string[];
/**
 * Method to calculate x position of title
 */
export  function titlePositionX(chartSize: Size, leftPadding: number, rightPadding: number, titleStyle: FontModel): number;
/**
 * Method to find new text and element size based on textOverflow
 */
export  function textWrap(currentLabel: string, maximumWidth: number, font: FontModel): string[];
/** @private */
export  class CustomizeOption {
    id: string;
    constructor(id?: string);
}
/** @private */
export  class StackValues {
    startValues?: number[];
    endValues?: number[];
    constructor(startValue?: number[], endValue?: number[]);
}
/** @private */
export  class TextOption extends CustomizeOption {
    anchor: string;
    text: string | string[];
    transform: string;
    x: number;
    y: number;
    baseLine: string;
    constructor(id?: string, x?: number, y?: number, anchor?: string, text?: string | string[], transform?: string, baseLine?: string);
}
/** @private */
export  class PathOption extends CustomizeOption {
    opacity: number;
    fill: string;
    stroke: string;
    ['stroke-width']: number;
    ['stroke-dasharray']: string;
    d: string;
    constructor(id: string, fill: string, width: number, color: string, opacity?: number, dashArray?: string, d?: string);
}
/** @private */
export  class RectOption extends PathOption {
    x: number;
    y: number;
    height: number;
    width: number;
    rx: number;
    ry: number;
    transform: string;
    constructor(id: string, fill: string, border: BorderModel, opacity: number, rect: Rect, rx?: number, ry?: number, transform?: string, dashArray?: string);
}
/** @private */
export  class CircleOption extends PathOption {
    cy: number;
    cx: number;
    r: number;
    constructor(id: string, fill: string, border: BorderModel, opacity: number, cx: number, cy: number, r: number);
}
/** @private */
export  class PolygonOption {
    id: string;
    points: string;
    fill: string;
    constructor(id: string, points: string, fill: string);
}
/** @private */
export  class Size {
    height: number;
    width: number;
    constructor(width: number, height: number);
}
/** @private */
export  class Rect {
    x: number;
    y: number;
    height: number;
    width: number;
    constructor(x: number, y: number, width: number, height: number);
}
/** @private */
export  class ChartLocation {
    x: number;
    y: number;
    constructor(x: number, y: number);
}
/** @private */
export  class Thickness {
    left: number;
    right: number;
    top: number;
    bottom: number;
    constructor(left: number, right: number, top: number, bottom: number);
}
/** @private */
export  class ColorValue {
    r: number;
    g: number;
    b: number;
    constructor(r?: number, g?: number, b?: number);
}
/** @private */
export  class PointData {
    point: Points;
    series: Series;
    lierIndex: number;
    constructor(point: Points, series: Series, index?: number);
}
/** @private */
export  class AccPointData {
    point: AccPoints;
    series: AccumulationSeries;
    constructor(point: AccPoints, series: AccumulationSeries, index?: number);
}
/** @private */
export  class ControlPoints {
    controlPoint1: ChartLocation;
    controlPoint2: ChartLocation;
    constructor(controlPoint1: ChartLocation, controlPoint2: ChartLocation);
}
/**
 * Chart components exported.
 */
 }
export namespace circulargauge { 

/**
 * Annotation Module handles the annotation of the axis.
 */
export  class Annotations {
    private gauge;
    private elementId;
    /**
     * Constructor for Annotation module.
     * @private.
     */
    constructor(gauge: CircularGauge);
    /**
     * Method to render the annotation for circular gauge.
     */
    renderAnnotation(axis: Axis, index: number): void;
    /**
     * Method to create annotation template for circular gauge.
     */
    createTemplate(element: HTMLElement, annotationIndex: number, axisIndex: number): void;
    /**
     * Method to update the annotation location for circular gauge.
     */
    private updateLocation(element, axis, annotation);
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the annotation.
     * @return {void}
     * @private
     */
    destroy(gauge: CircularGauge): void;
}
/**
 * Interface for a class Line
 */
export interface LineModel {
    /**
     * The width of the line in pixels.
     * @default 1
     */
    width?: number;
    /**
     * The dash array of the axis line.
     * @default ''
     */
    dashArray?: string;
    /**
     * The color of the axis line, which accepts value in hex, rgba as a valid CSS color string.
     */
    color?: string;
}
/**
 * Interface for a class Label
 */
export interface LabelModel {
    /**
     * The font of the axis labels
     */
    font?: FontModel;
    /**
     * To format the axis label, which accepts any global string format like 'C', 'n1', 'P' etc.
     * Also accepts placeholder like '{value}°C' in which value represent the axis label e.g. 20°C.
     * @default ''
     */
    format?: string;
    /**
     * Specifies the position of the labels. They are,
     * * inside -  Places the labels inside the axis.
     * * outside - Places the labels outside of the axis.
     * @default 'Inside'
     */
    position?: Position;
    /**
     * Specifies the label of an axis, which must get hide when an axis makes a complete circle. They are
     * * first -  Hides the 1st label on intersect.
     * * last - Hides the last label on intersect.
     * * none - Places both the labels.
     * @default 'None'
     */
    hiddenLabel?: HiddenLabel;
    /**
     * if set true, the labels will get rotated along the axis.
     * @default false
     */
    autoAngle?: boolean;
    /**
     * If set true, labels takes the range color.
     */
    useRangeColor?: boolean;
    /**
     * Distance of the labels from axis in pixel.
     * @default 0
     */
    offset?: number;
}
/**
 * Interface for a class Range
 */
export interface RangeModel {
    /**
     * Specifies the minimum value of the range.
     * @default null
     */
    start?: number;
    /**
     * Specifies the maximum value of the range.
     * @default null
     */
    end?: number;
    /**
     * The radius of the range in pixels or in percentage.
     * @default null
     */
    radius?: string;
    /**
     * Specifies the start width of the ranges
     */
    startWidth?: number | string;
    /**
     * Specifies the end width of the ranges
     */
    endWidth?: number | string;
    /**
     * Specifies the color of the ranges
     */
    color?: string;
}
/**
 * Interface for a class Tick
 */
export interface TickModel {
    /**
     * The width of the ticks in pixels.
     * @default null
     */
    width?: number;
    /**
     * The height of the line in pixels.
     * @default null
     */
    height?: number;
    /**
     * Specifies the interval of the tick line.
     * @default null
     */
    interval?: number;
    /**
     * Distance of the ticks from axis in pixel.
     * @default 0
     */
    offset?: number;
    /**
     * The color of the tick line, which accepts value in hex, rgba as a valid CSS color string.
     */
    color?: string;
    /**
     * Specifies the position of the ticks. They are
     * * inside -  Places the ticks inside the axis.
     * * outside - Places the ticks outside of the axis.
     * @default 'Inside'
     */
    position?: base.Position;
    /**
     * If set true, major ticks takes the range color.
     */
    useRangeColor?: boolean;
}
/**
 * Interface for a class Cap
 */
export interface CapModel {
    /**
     * The color of the cap.
     * @default 'transparent'
     */
    color?: string;
    /**
     * Options for customizing the border of the cap.
     */
    border?: BorderModel;
    /**
     * Radius of the cap in pixels.
     * @default 8
     */
    radius?: number;
}
/**
 * Interface for a class NeedleTail
 */
export interface NeedleTailModel {
    /**
     * The color of the back needle.
     */
    color?: string;
    /**
     * Options for customizing the border of the back needle.
     */
    border?: BorderModel;
    /**
     * The radius of the back needle in pixels or in percentage.
     * @default 0%
     */
    length?: string;
}
/**
 * Interface for a class Animation
 */
export interface AnimationModel {
    /**
     * If set true, pointers get animate on initial loading.
     * @default true
     */
    enable?: boolean;
    /**
     * Duration of animation in milliseconds.
     * @default 1000
     */
    duration?: number;
}
/**
 * Interface for a class Annotation
 */
export interface AnnotationModel {
    /**
     * Content of the annotation, which accepts the id of the custom element.
     * @default null
     */
    content?: string;
    /**
     * Angle for annotation with respect to axis.
     * @default 90
     */
    angle?: number;
    /**
     * Radius for annotation with respect to axis.
     * @default '50%'
     */
    radius?: string;
    /**
     * Order of an annotation in an axis.
     * @default '-1'
     */
    zIndex?: string;
    /**
     * Rotates the annotation along the axis.
     * @default false
     */
    autoAngle?: boolean;
    /**
     * Options for customizing the annotation text.
     */
    textStyle?: FontModel;
    /**
     * Information about annotation for assistive technology.
     * @default null
     */
    description?: string;
}
/**
 * Interface for a class Pointer
 */
export interface PointerModel {
    /**
     * Specifies the value of the pointer.
     * @default null
     */
    value?: number;
    /**
     * Specifies the type of pointer for an axis.
     * * needle -  Renders a needle.
     * * marker - Renders a marker.
     * * rangeBar - Renders a rangeBar.
     * @default 'Needle'
     */
    type?: PointerType;
    /**
     * The URL for the Image that is to be displayed as pointer.
     * It requires marker shape value to be Image.
     * @default null
     */
    imageUrl?: string;
    /**
     * Length of the pointer in pixels or in percentage.
     * @default null
     */
    radius?: string;
    /**
     * Width of the pointer in pixels.
     * @default 20
     */
    pointerWidth?: number;
    /**
     * Options for customizing the cap
     */
    cap?: CapModel;
    /**
     * Options for customizing the back needle.
     */
    needleTail?: NeedleTailModel;
    /**
     * The color of the pointer.
     */
    color?: string;
    /**
     * Options for customizing the border of the needle.
     */
    border?: BorderModel;
    /**
     * Configures the animation of pointers.
     */
    animation?: AnimationModel;
    /**
     * Specifies the shape of the marker. They are
     * * circle - Renders a circle.
     * * rectangle - Renders a rectangle.
     * * triangle - Renders a triangle.
     * * diamond - Renders a diamond.
     * * invertedTriangle - Renders a invertedTriangle.
     * * image - Renders a image.
     * @default 'Circle'
     */
    markerShape?: GaugeShape;
    /**
     * The height of the marker in pixels.
     * @default 5
     */
    markerHeight?: number;
    /**
     * Information about pointer for assistive technology.
     * @default null
     */
    description?: string;
    /**
     * The width of the marker in pixels.
     * @default 5
     */
    markerWidth?: number;
}
/**
 * Interface for a class Axis
 */
export interface AxisModel {
    /**
     * Specifies the minimum value of an axis.
     * @default null
     */
    minimum?: number;
    /**
     * Specifies the maximum value of an axis.
     * @default null
     */
    maximum?: number;
    /**
     * Radius of an axis in pixels or in percentage.
     * @default null
     */
    radius?: string;
    /**
     * Options for customizing the axis lines.
     */
    lineStyle?: LineModel;
    /**
     * Options for customizing the ranges of an axis
     */
    ranges?: RangeModel[];
    /**
     * Options for customizing the pointers of an axis
     */
    pointers?: PointerModel[];
    /**
     * ‘Annotation’ module is used to handle annotation action for an axis.
     */
    annotations?: AnnotationModel[];
    /**
     * Options for customizing the major tick lines.
     */
    majorTicks?: TickModel;
    /**
     * Options for customizing the minor tick lines.
     */
    minorTicks?: TickModel;
    /**
     * The start angle of an axis
     * @default 200
     */
    startAngle?: number;
    /**
     * The end angle of an axis
     * @default 160
     */
    endAngle?: number;
    /**
     * Specifies the direction of an axis. They are
     * * clockWise -  Renders the axis in clock wise direction.
     * * antiClockWise - Renders the axis in anti-clock wise direction.
     * @default 'clockWise'
     */
    direction?: GaugeDirection;
    /**
     * The background color of the axis, which accepts value in hex, rgba as a valid CSS color string.
     * @default null
     */
    background?: string;
    /**
     * Options to customize the axis label.
     */
    labelStyle?: LabelModel;
}
export  class AxisLayoutPanel {
    private gauge;
    private farSizes;
    private axisRenderer;
    pointerRenderer: PointerRenderer;
    constructor(gauge: CircularGauge);
    /**
     * Measure the calculate the axis size and radius.
     * @return {void}
     * @private
     */
    measureAxis(rect: Rect): void;
    /**
     * Measure to calculate the axis radius of the circular gauge.
     * @return {void}
     * @private
     */
    private calculateAxesRadius();
    /**
     * Measure to calculate the axis size.
     * @return {void}
     * @private
     */
    private measureAxisSize(gauge, rect);
    /**
     * Calculate the axis values of the circular gauge.
     * @return {void}
     * @private
     */
    private calculateAxisValues(rect?);
    /**
     * Calculate the visible range of an axis.
     * @return {void}
     * @private
     */
    private calculateVisibleRange(axis, rect);
    /**
     * Calculate the numeric intervals of an axis range.
     * @return {void}
     * @private
     */
    private calculateNumericInterval(axis, rect);
    /**
     * Calculate the nice interval of an axis range.
     * @return {void}
     * @private
     */
    private calculateNiceInterval(maxValue, minValue, radius, degree);
    /**
     * Calculate the visible labels of an axis.
     * @return {void}
     * @private
     */
    private calculateVisibleLabels(axis);
    /**
     * Measure the axes available size.
     * @return {void}
     * @private
     */
    private computeSize(axes, rect);
    /**
     * To render the axis element of the circular gauge.
     * @return {void}
     * @private
     */
    renderAxes(animate?: boolean): void;
    /**
     * Calculate maximum label width for the axis.
     * @return {void}
     */
    private getMaxLabelWidth(gauge, axis);
}
/**
 * Specifies the Axis rendering for circular gauge
 */
export  class AxisRenderer {
    private majorValues;
    private gauge;
    /**
     * Constructor for axis renderer.
     * @private.
     */
    constructor(gauge: CircularGauge);
    /**
     * Method to render the axis element of the circular gauge.
     * @return {void}
     * @private
     */
    drawAxisOuterLine(axis: Axis, index: number, element: Element, gauge: CircularGauge): void;
    /**
     * Method to render the axis line of the circular gauge.
     * @return {void}
     * @private
     */
    drawAxisLine(axis: Axis, index: number, element: Element, gauge: CircularGauge): void;
    /**
     * Method to render the axis labels of the circular gauge.
     * @return {void}
     * @private
     */
    drawAxisLabels(axis: Axis, index: number, element: Element, gauge: CircularGauge): void;
    /**
     * Method to find the anchor of the axis label.
     * @private
     */
    private findAnchor(location, style, angle, label);
    /**
     * Method to render the axis minor tick lines of the circular gauge.
     * @return {void}
     * @private
     */
    drawMinorTickLines(axis: Axis, index: number, element: Element, gauge: CircularGauge): void;
    /**
     * Method to render the axis major tick lines of the circular gauge.
     * @return {void}
     * @private
     */
    drawMajorTickLines(axis: Axis, index: number, element: Element, gauge: CircularGauge): void;
    /**
     * Method to calcualte the tick elements for the circular gauge.
     * @return {void}
     * @private
     */
    calculateTicks(value: number, options: Tick, axis: Axis): string;
    /**
     * Method to render the axis range of the circular gauge.
     * @return {void}
     * @private
     */
    drawAxisRange(axis: Axis, index: number, element: Element, gauge: CircularGauge): void;
    /**
     * Method to calculate the radius of the axis range.
     * @return {void}
     */
    private calculateRangeRadius(axis, range);
    /**
     * Method to get the range color of the circular gauge.
     * @return {void}
     * @private
     */
    setRangeColor(axis: Axis): void;
}
/**
 * Configures the axis line.
 */
export  class Line extends base.ChildProperty<Line> {
    /**
     * The width of the line in pixels.
     * @default 1
     */
    width: number;
    /**
     * The dash array of the axis line.
     * @default ''
     */
    dashArray: string;
    /**
     * The color of the axis line, which accepts value in hex, rgba as a valid CSS color string.
     */
    color: string;
}
/**
 * Configures the axis label.
 */
export  class Label extends base.ChildProperty<Label> {
    /**
     * The font of the axis labels
     */
    font: FontModel;
    /**
     * To format the axis label, which accepts any global string format like 'C', 'n1', 'P' etc.
     * Also accepts placeholder like '{value}°C' in which value represent the axis label e.g. 20°C.
     * @default ''
     */
    format: string;
    /**
     * Specifies the position of the labels. They are,
     * * inside -  Places the labels inside the axis.
     * * outside - Places the labels outside of the axis.
     * @default 'Inside'
     */
    position: Position;
    /**
     * Specifies the label of an axis, which must get hide when an axis makes a complete circle. They are
     * * first -  Hides the 1st label on intersect.
     * * last - Hides the last label on intersect.
     * * none - Places both the labels.
     * @default 'None'
     */
    hiddenLabel: HiddenLabel;
    /**
     * if set true, the labels will get rotated along the axis.
     * @default false
     */
    autoAngle: boolean;
    /**
     * If set true, labels takes the range color.
     */
    useRangeColor: boolean;
    /**
     * Distance of the labels from axis in pixel.
     * @default 0
     */
    offset: number;
}
/**
 * Configures the ranges of an axis.
 */
export  class Range extends base.ChildProperty<Range> {
    /**
     * Specifies the minimum value of the range.
     * @default null
     */
    start: number;
    /**
     * Specifies the maximum value of the range.
     * @default null
     */
    end: number;
    /**
     * The radius of the range in pixels or in percentage.
     * @default null
     */
    radius: string;
    /**
     * Specifies the start width of the ranges
     */
    startWidth: number | string;
    /**
     * Specifies the end width of the ranges
     */
    endWidth: number | string;
    /**
     * Specifies the color of the ranges
     */
    color: string;
    /** @private */
    currentRadius: number;
    /** @private */
    rangeColor: string;
}
/**
 * Configures the major and minor tick lines of an axis.
 */
export  class Tick extends base.ChildProperty<Tick> {
    /**
     * The width of the ticks in pixels.
     * @default null
     */
    width: number;
    /**
     * The height of the line in pixels.
     * @default null
     */
    height: number;
    /**
     * Specifies the interval of the tick line.
     * @default null
     */
    interval: number;
    /**
     * Distance of the ticks from axis in pixel.
     * @default 0
     */
    offset: number;
    /**
     * The color of the tick line, which accepts value in hex, rgba as a valid CSS color string.
     */
    color: string;
    /**
     * Specifies the position of the ticks. They are
     * * inside -  Places the ticks inside the axis.
     * * outside - Places the ticks outside of the axis.
     * @default 'Inside'
     */
    position: Position;
    /**
     * If set true, major ticks takes the range color.
     */
    useRangeColor: boolean;
}
/**
 * Configures the needle cap in pointer.
 */
export  class Cap extends base.ChildProperty<Cap> {
    /**
     * The color of the cap.
     * @default 'transparent'
     */
    color: string;
    /**
     * Options for customizing the border of the cap.
     */
    border: BorderModel;
    /**
     * Radius of the cap in pixels.
     * @default 8
     */
    radius: number;
}
/**
 * Configures the back needle in pointers.
 */
export  class NeedleTail extends base.ChildProperty<NeedleTail> {
    /**
     * The color of the back needle.
     */
    color: string;
    /**
     * Options for customizing the border of the back needle.
     */
    border: BorderModel;
    /**
     * The radius of the back needle in pixels or in percentage.
     * @default 0%
     */
    length: string;
}
/**
 * Configures the animation of pointers.
 */
export  class Animation extends base.ChildProperty<Animation> {
    /**
     * If set true, pointers get animate on initial loading.
     * @default true
     */
    enable: boolean;
    /**
     * Duration of animation in milliseconds.
     * @default 1000
     */
    duration: number;
}
/**
 * ‘Annotation’ module is used to handle annotation action for an axis.
 */
export  class Annotation extends base.ChildProperty<Annotation> {
    /**
     * Content of the annotation, which accepts the id of the custom element.
     * @default null
     */
    content: string;
    /**
     * Angle for annotation with respect to axis.
     * @default 90
     */
    angle: number;
    /**
     * Radius for annotation with respect to axis.
     * @default '50%'
     */
    radius: string;
    /**
     * Order of an annotation in an axis.
     * @default '-1'
     */
    zIndex: string;
    /**
     * Rotates the annotation along the axis.
     * @default false
     */
    autoAngle: boolean;
    /**
     * Options for customizing the annotation text.
     */
    textStyle: FontModel;
    /**
     * Information about annotation for assistive technology.
     * @default null
     */
    description: string;
}
/**
 * Configures the pointers of an axis.
 */
export  class Pointer extends base.ChildProperty<Pointer> {
    /**
     * Specifies the value of the pointer.
     * @default null
     */
    value: number;
    /**
     * Specifies the type of pointer for an axis.
     * * needle -  Renders a needle.
     * * marker - Renders a marker.
     * * rangeBar - Renders a rangeBar.
     * @default 'Needle'
     */
    type: PointerType;
    /**
     * The URL for the Image that is to be displayed as pointer.
     * It requires marker shape value to be Image.
     * @default null
     */
    imageUrl: string;
    /**
     * Length of the pointer in pixels or in percentage.
     * @default null
     */
    radius: string;
    /**
     * Width of the pointer in pixels.
     * @default 20
     */
    pointerWidth: number;
    /**
     * Options for customizing the cap
     */
    cap: CapModel;
    /**
     * Options for customizing the back needle.
     */
    needleTail: NeedleTailModel;
    /**
     * The color of the pointer.
     */
    color: string;
    /**
     * Options for customizing the border of the needle.
     */
    border: BorderModel;
    /**
     * Configures the animation of pointers.
     */
    animation: AnimationModel;
    /**
     * Specifies the shape of the marker. They are
     * * circle - Renders a circle.
     * * rectangle - Renders a rectangle.
     * * triangle - Renders a triangle.
     * * diamond - Renders a diamond.
     * * invertedTriangle - Renders a invertedTriangle.
     * * image - Renders a image.
     * @default 'Circle'
     */
    markerShape: GaugeShape;
    /**
     * The height of the marker in pixels.
     * @default 5
     */
    markerHeight: number;
    /**
     * Information about pointer for assistive technology.
     * @default null
     */
    description: string;
    /**
     * The width of the marker in pixels.
     * @default 5
     */
    markerWidth: number;
    /** @private */
    currentValue: number;
    /** @private */
    pathElement: Element[];
    /** @private */
    currentRadius: number;
}
/**
 * Configures an axis in a gauge.
 */
export  class Axis extends base.ChildProperty<Axis> {
    /**
     * Specifies the minimum value of an axis.
     * @default null
     */
    minimum: number;
    /**
     * Specifies the maximum value of an axis.
     * @default null
     */
    maximum: number;
    /**
     * Radius of an axis in pixels or in percentage.
     * @default null
     */
    radius: string;
    /**
     * Options for customizing the axis lines.
     */
    lineStyle: LineModel;
    /**
     * Options for customizing the ranges of an axis
     */
    ranges: RangeModel[];
    /**
     * Options for customizing the pointers of an axis
     */
    pointers: PointerModel[];
    /**
     * ‘Annotation’ module is used to handle annotation action for an axis.
     */
    annotations: AnnotationModel[];
    /**
     * Options for customizing the major tick lines.
     */
    majorTicks: TickModel;
    /**
     * Options for customizing the minor tick lines.
     */
    minorTicks: TickModel;
    /**
     * The start angle of an axis
     * @default 200
     */
    startAngle: number;
    /**
     * The end angle of an axis
     * @default 160
     */
    endAngle: number;
    /**
     * Specifies the direction of an axis. They are
     * * clockWise -  Renders the axis in clock wise direction.
     * * antiClockWise - Renders the axis in anti-clock wise direction.
     * @default 'clockWise'
     */
    direction: GaugeDirection;
    /**
     * The background color of the axis, which accepts value in hex, rgba as a valid CSS color string.
     * @default null
     */
    background: string;
    /**
     * Options to customize the axis label.
     */
    labelStyle: LabelModel;
    /** @private */
    currentRadius: number;
    /** @private */
    visibleRange: VisibleRangeModel;
    /** @private */
    visibleLabels: VisibleLabels[];
    /** @private */
    maxLabelSize: Size;
    /** @private */
    rect: Rect;
    /** @private */
    nearSize: number;
    /** @private */
    farSize: number;
}
/** @private */
export interface VisibleRangeModel {
    min?: number;
    max?: number;
    interval?: number;
}
/**
 * Specifies the Axis rendering for circular gauge
 */
export  class PointerRenderer {
    private gauge;
    /**
     * Constructor for pointer renderer.
     * @private.
     */
    constructor(gauge: CircularGauge);
    /**
     * Method to render the axis pointers of the circular gauge.
     * @return {void}
     * @private
     */
    drawPointers(axis: Axis, axisIndex: number, element: Element, gauge: CircularGauge, animate?: boolean): void;
    /**
     * Measure the pointer length of the circular gauge.
     * @return {void}
     */
    private calculatePointerRadius(axis, pointer);
    /**
     * Method to render the needle pointer of the ciruclar gauge.
     * @return {void}
     */
    private drawNeedlePointer(axis, axisIndex, index, parentElement, gauge);
    /**
     * Method to set the pointer value of the circular gauge.
     * @return {void}
     * @private
     */
    setPointerValue(axis: Axis, pointer: Pointer, value: number): void;
    /**
     * Method to render the marker pointer of the ciruclar gauge.
     * @return {void}
     */
    private drawMarkerPointer(axis, axisIndex, index, parentElement, gauge);
    /**
     * Method to render the range bar pointer of the ciruclar gauge.
     * @return {void}
     */
    private drawRangeBarPointer(axis, axisIndex, index, parentElement, gauge);
    /**
     * Method to perform the animation of the pointer in circular gauge.
     * @return {void}
     */
    private doPointerAnimation(pointer, axis);
    /**
     * Perform the needle and marker pointer animation for circular gauge.
     * @return {void}
     * @private
     */
    performNeedleAnimation(element: HTMLElement, start: number, end: number, axis: Axis, pointer: Pointer, radius?: number, innerRadius?: number): void;
    /**
     * Perform the range bar pointer animation for circular gauge.
     * @return {void}
     * @private
     */
    performRangeBarAnimation(element: HTMLElement, start: number, end: number, axis: Axis, pointer: Pointer, radius: number, innerRadius?: number): void;
}
/**
 * Interface for a class CircularGauge
 */
export interface CircularGaugeModel extends base.ComponentModel{
    /**
     * The width of the circular gauge as a string in order to provide input as both like '100px' or '100%'.
     * If specified as '100%, gauge will render to the full width of its parent element.
     * @default null
     */
    width?: string;
    /**
     * The height of the circular gauge as a string in order to provide input as both like '100px' or '100%'.
     * If specified as '100%, gauge will render to the full height of its parent element.
     * @default null
     */
    height?: string;
    /**
     * Options for customizing the color and width of the gauge border.
     */
    border?: BorderModel;
    /**
     * The background color of the gauge, which accepts value in hex, rgba as a valid CSS color string.
     * @default 'transparent'
     */
    background?: string;
    /**
     * Title for gauge
     * @default ''
     */
    title?: string;
    /**
     * Options for customizing the title of Gauge.
     */
    titleStyle?: FontModel;
    /**
     *  Options to customize the left, right, top and bottom margins of the gauge.
     */
    margin?: MarginModel;
    /**
     * Options for customizing the axes of gauge
     */
    axes?: AxisModel[];
    /**
     * Options for customizing the tooltip of gauge.
     */
    tooltip?: TooltipSettingsModel;
    /**
     * If set true, pointers can able to drag on interaction.
     * @default true
     */
    enablePointerDrag?: boolean;
    /**
     * X coordinate of the circular gauge center point, which takes values either in pixels or in percentage.
     * @default null
     */
    centerX?: string;
    /**
     * Y coordinate of the circular gauge center point, which takes values either in pixels or in percentage.
     * @default null
     */
    centerY?: string;
    /**
     * Specifies the theme for circular gauge.
     * * Material - Gauge render with material theme.
     * * Fabric - Gauge render with fabric theme.
     * @default Material
     */
    theme?: GaugeTheme;
    /**
     * Specifies whether a grouping separator should be used for a number.
     * @default false
     */
    useGroupingSeparator?: boolean;
    /**
     * Information about gauge for assistive technology.
     * @default null
     */
    description?: string;
    /**
     * TabIndex value for the gauge.
     * @default 1
     */
    tabIndex?: number;
    /**
     * Triggers after gauge base.loaded.
     * @event
     */
    loaded?: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers before gauge base.load.
     * @event
     */
    load?: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers after animation gets completed for pointers.
     * @event
     */
    animationComplete?: base.EmitType<IAnimationCompleteEventArgs>;
    /**
     * Triggers before each axis label gets rendered.
     * @event
     */
    axisLabelRender?: base.EmitType<IAxisLabelRenderEventArgs>;
    /**
     * Triggers before each annotation gets rendered.
     * @event
     */
    annotationRender?: base.EmitType<IAnnotationRenderEventArgs>;
    /**
     * Triggers before the tooltip for pointer gets rendered.
     * @event
     */
    tooltipRender?: base.EmitType<ITooltipRenderEventArgs>;
    /**
     * Triggers before the pointer is dragged.
     * @event
     */
    dragStart?: base.EmitType<IPointerDragEventArgs>;
    /**
     * Triggers while dragging the pointers.
     * @event
     */
    dragMove?: base.EmitType<IPointerDragEventArgs>;
    /**
     * Triggers after the pointer is dragged.
     * @event
     */
    dragEnd?: base.EmitType<IPointerDragEventArgs>;
    /**
     * Triggers on hovering the circular gauge.
     * @event
     */
    gaugeMouseMove?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers while cursor leaves the circular gauge.
     * @event
     */
    gaugeMouseLeave?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on mouse down.
     * @event
     */
    gaugeMouseDown?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on mouse up.
     * @event
     */
    gaugeMouseUp?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers after window resize.
     * @event
     */
    resized?: base.EmitType<IResizeEventArgs>;
}
/**
 * Circular Gauge
 */
/**
 * Represents the Circular gauge control.
 * ```html
 * <div id="gauge"/>
 * <script>
 *   var gaugeObj = new CircularGauge();
 *   gaugeObj.appendTo("#gauge");
 * </script>
 * ```
 */
export  class CircularGauge extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /**
     * annotationModule is used to add annotation in gauge.
     */
    annotationsModule: Annotations;
    /**
     * `tooltipModule` is used to show the tooltip to the circular gauge..
     */
    tooltipModule: GaugeTooltip;
    /**
     * The width of the circular gauge as a string in order to provide input as both like '100px' or '100%'.
     * If specified as '100%, gauge will render to the full width of its parent element.
     * @default null
     */
    width: string;
    /**
     * The height of the circular gauge as a string in order to provide input as both like '100px' or '100%'.
     * If specified as '100%, gauge will render to the full height of its parent element.
     * @default null
     */
    height: string;
    /**
     * Options for customizing the color and width of the gauge border.
     */
    border: BorderModel;
    /**
     * The background color of the gauge, which accepts value in hex, rgba as a valid CSS color string.
     * @default 'transparent'
     */
    background: string;
    /**
     * Title for gauge
     * @default ''
     */
    title: string;
    /**
     * Options for customizing the title of Gauge.
     */
    titleStyle: FontModel;
    /**
     *  Options to customize the left, right, top and bottom margins of the gauge.
     */
    margin: MarginModel;
    /**
     * Options for customizing the axes of gauge
     */
    axes: AxisModel[];
    /**
     * Options for customizing the tooltip of gauge.
     */
    tooltip: TooltipSettingsModel;
    /**
     * If set true, pointers can able to drag on interaction.
     * @default true
     */
    enablePointerDrag: boolean;
    /**
     * X coordinate of the circular gauge center point, which takes values either in pixels or in percentage.
     * @default null
     */
    centerX: string;
    /**
     * Y coordinate of the circular gauge center point, which takes values either in pixels or in percentage.
     * @default null
     */
    centerY: string;
    /**
     * Specifies the theme for circular gauge.
     * * Material - Gauge render with material theme.
     * * Fabric - Gauge render with fabric theme.
     * @default Material
     */
    theme: GaugeTheme;
    /**
     * Specifies whether a grouping separator should be used for a number.
     * @default false
     */
    useGroupingSeparator: boolean;
    /**
     * Information about gauge for assistive technology.
     * @default null
     */
    description: string;
    /**
     * TabIndex value for the gauge.
     * @default 1
     */
    tabIndex: number;
    /**
     * Triggers after gauge loaded.
     * @event
     */
    loaded: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers before gauge load.
     * @event
     */
    load: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers after animation gets completed for pointers.
     * @event
     */
    animationComplete: base.EmitType<IAnimationCompleteEventArgs>;
    /**
     * Triggers before each axis label gets rendered.
     * @event
     */
    axisLabelRender: base.EmitType<IAxisLabelRenderEventArgs>;
    /**
     * Triggers before each annotation gets rendered.
     * @event
     */
    annotationRender: base.EmitType<IAnnotationRenderEventArgs>;
    /**
     * Triggers before the tooltip for pointer gets rendered.
     * @event
     */
    tooltipRender: base.EmitType<ITooltipRenderEventArgs>;
    /**
     * Triggers before the pointer is dragged.
     * @event
     */
    dragStart: base.EmitType<IPointerDragEventArgs>;
    /**
     * Triggers while dragging the pointers.
     * @event
     */
    dragMove: base.EmitType<IPointerDragEventArgs>;
    /**
     * Triggers after the pointer is dragged.
     * @event
     */
    dragEnd: base.EmitType<IPointerDragEventArgs>;
    /**
     * Triggers on hovering the circular gauge.
     * @event
     */
    gaugeMouseMove: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers while cursor leaves the circular gauge.
     * @event
     */
    gaugeMouseLeave: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on mouse down.
     * @event
     */
    gaugeMouseDown: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on mouse up.
     * @event
     */
    gaugeMouseUp: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers after window resize.
     * @event
     */
    resized: base.EmitType<IResizeEventArgs>;
    /** @private */
    renderer: base.SvgRenderer;
    /** @private */
    svgObject: Element;
    /** @private */
    availableSize: Size;
    /** @private */
    intl: base.Internationalization;
    /** @private */
    private resizeTo;
    /** @private */
    midPoint: GaugeLocation;
    /** @private */
    activePointer: Pointer;
    /** @private */
    activeAxis: Axis;
    /** @private */
    animatePointer: boolean;
    /** @private */
    /**
     * Render axis panel for gauge.
     * @hidden
     */
    gaugeAxisLayoutPanel: AxisLayoutPanel;
    /**
     * Constructor for creating the widget
     * @hidden
     */
    constructor(options?: CircularGaugeModel, element?: string | HTMLElement);
    /**
     *  To create svg object, renderer and binding events for the container.
     */
    protected preRender(): void;
    private themeEffect();
    private setThemeColors(labelcolor, others);
    /**
     * To render the circular gauge elements
     */
    protected render(): void;
    /**
     * Method to unbind events for circular gauge
     */
    private unWireEvents();
    /**
     * Method to bind events for circular gauge
     */
    private wireEvents();
    /**
     * Handles the mouse move.
     * @return {boolean}
     * @private
     */
    mouseMove(e: PointerEvent): boolean;
    /**
     * Handles the mouse leave.
     * @return {boolean}
     * @private
     */
    mouseLeave(e: PointerEvent): boolean;
    /**
     * Handles the mouse right click.
     * @return {boolean}
     * @private
     */
    gaugeRightClick(event: MouseEvent | PointerEvent): boolean;
    /**
     * Handles the pointer draf while mouse move on gauge.
     * @private
     */
    pointerDrag(location: GaugeLocation): void;
    /**
     * Handles the mouse down on gauge.
     * @return {boolean}
     * @private
     */
    gaugeOnMouseDown(e: PointerEvent): boolean;
    /**
     * Handles the mouse end.
     * @return {boolean}
     * @private
     */
    mouseEnd(e: PointerEvent): boolean;
    /**
     * Handles the mouse event arguments.
     * @return {IMouseEventArgs}
     * @private
     */
    private getMouseArgs(e, type, name);
    /**
     * Handles the gauge resize.
     * @return {boolean}
     * @private
     */
    gaugeResize(e: Event): boolean;
    /**
     * Applying styles for circular gauge elements
     */
    private setGaugeStyle(element);
    /**
     * Method to set culture for gauge
     */
    private setCulture();
    /**
     * Methods to create svg element for circular gauge.
     */
    private createSvg();
    /**
     * To Remove the SVG from circular gauge.
     * @return {boolean}
     * @private
     */
    removeSvg(): void;
    /**
     * To initialize the circular gauge private variable.
     * @private
     */
    private initPrivateVariable();
    /**
     * To calculate the size of the circular gauge element.
     */
    private calculateSvgSize();
    /**
     * Method to calculate the availble size for circular gauge.
     */
    private calculateBounds();
    /**
     * To render elements for circular gauge
     */
    private renderElements(animate?);
    /**
     * Method to render the title for circular gauge.
     */
    private renderTitle();
    /**
     * Method to render the border for circular gauge.
     */
    private renderBorder();
    /**
     * Method to set the pointer value dynamically for circular gauge.
     */
    setPointerValue(axisIndex: number, pointerIndex: number, value: number): void;
    /**
     * Method to set the annotation content dynamically for circular gauge.
     */
    setAnnotationValue(axisIndex: number, annotationIndex: number, content: string): void;
    /**
     * Method to set the range values dynamically for circular gauge.
     */
    setRangeValue(axisIndex: number, rangeIndex: number, start: number, end: number): void;
    /**
     * To destroy the widget
     * @method destroy
     * @return {void}
     * @member of Circular-Gauge
     */
    destroy(): void;
    /**
     * To provide the array of modules needed for control rendering
     * @return {base.ModuleDeclaration[]}
     * @private
     */
    requiredModules(): base.ModuleDeclaration[];
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    getPersistData(): string;
    /**
     * Called internally if any of the property value changed.
     * @private
     */
    onPropertyChanged(newProp: CircularGaugeModel, oldProp: CircularGaugeModel): void;
    /**
     * Get component name for circular gauge
     * @private
     */
    getModuleName(): string;
}
/**
 * Circular Gauge component exported items
 */
/**
 * Interface for a class Border
 */
export interface BorderModel {
    /**
     * The color of the border, which accepts value in hex, rgba as a valid CSS color string.
     */
    color?: string;
    /**
     * The width of the border in pixels.
     */
    width?: number;
}
/**
 * Interface for a class Font
 */
export interface FontModel {
    /**
     * Font size for text.
     */
    size?: string;
    /**
     * Color for text.
     */
    color?: string;
    /**
     * FontFamily for text.
     */
    fontFamily?: string;
    /**
     * FontWeight for text.
     */
    fontWeight?: string;
    /**
     * FontStyle for text.
     */
    fontStyle?: string;
    /**
     * Opacity for text.
     */
    opacity?: number;
}
/**
 * Interface for a class Margin
 */
export interface MarginModel {
    /**
     * Left margin in pixels.
     * @default 10
     */
    left?: number;
    /**
     * Right margin in pixels.
     * @default 10
     */
    right?: number;
    /**
     * Top margin in pixels.
     * @default 10
     */
    top?: number;
    /**
     * Bottom margin in pixels.
     * @default 10
     */
    bottom?: number;
}
/**
 * Interface for a class TooltipSettings
 */
export interface TooltipSettingsModel {
    /**
     * Enable / Disable the visibility of tooltip.
     * @default false
     */
    enable?: boolean;
    /**
     * The fill color of the tooltip, which accepts value in hex, rgba as a valid CSS color string. 
     */
    fill?: string;
    /**
     * Options to customize the tooltip text.
     */
    textStyle?: FontModel;
    /**
     * Format of the tooltip content.
     * @default null
     */
    format?: string;
    /**
     * Custom template to format the tooltip content. Use ${x} and ${y} as a placeholder text to display the corresponding data point.
     * @default null
     */
    template?: string;
    /**
     * If set true, tooltip will animate, while moving from one point to another.
     * @default true
     */
    enableAnimation?: boolean;
    /**
     * Options to customize the border for tooltip.
     */
    border?: BorderModel;
}
/**
 * Configures the borders in circular gauge.
 */
export  class Border extends base.ChildProperty<Border> {
    /**
     * The color of the border, which accepts value in hex, rgba as a valid CSS color string.
     */
    color: string;
    /**
     * The width of the border in pixels.
     */
    width: number;
}
/**
 * Configures the fonts in circular gauge.
 */
export  class Font extends base.ChildProperty<Font> {
    /**
     * Font size for text.
     */
    size: string;
    /**
     * Color for text.
     */
    color: string;
    /**
     * FontFamily for text.
     */
    fontFamily: string;
    /**
     * FontWeight for text.
     */
    fontWeight: string;
    /**
     * FontStyle for text.
     */
    fontStyle: string;
    /**
     * Opacity for text.
     */
    opacity: number;
}
/**
 * Configures the margin of circular gauge.
 */
export  class Margin extends base.ChildProperty<Margin> {
    /**
     * Left margin in pixels.
     * @default 10
     */
    left: number;
    /**
     * Right margin in pixels.
     * @default 10
     */
    right: number;
    /**
     * Top margin in pixels.
     * @default 10
     */
    top: number;
    /**
     * Bottom margin in pixels.
     * @default 10
     */
    bottom: number;
}
/**
 * Configures the tooltip in circular gauge.
 */
export  class TooltipSettings extends base.ChildProperty<TooltipSettings> {
    /**
     * Enable / Disable the visibility of tooltip.
     * @default false
     */
    enable: boolean;
    /**
     * The fill color of the tooltip, which accepts value in hex, rgba as a valid CSS color string.
     */
    fill: string;
    /**
     * Options to customize the tooltip text.
     */
    textStyle: FontModel;
    /**
     * Format of the tooltip content.
     * @default null
     */
    format: string;
    /**
     * Custom template to format the tooltip content. Use ${x} and ${y} as a placeholder text to display the corresponding data point.
     * @default null
     */
    template: string;
    /**
     * If set true, tooltip will animate, while moving from one point to another.
     * @default true
     */
    enableAnimation: boolean;
    /**
     * Options to customize the border for tooltip.
     */
    border: BorderModel;
}
/**
 * Specifies the gauge constant value
 */
/** @private */
export  const loaded: string;
/** @private */
export  const load: string;
/** @private */
export  const animationComplete: string;
/** @private */
export  const axisLabelRender: string;
/** @private */
export  const tooltipRender: string;
/** @private */
export  const annotationRender: string;
/** @private */
export  const gaugeMouseMove: string;
/** @private */
export  const gaugeMouseLeave: string;
/** @private */
export  const gaugeMouseDown: string;
/** @private */
export  const gaugeMouseUp: string;
/** @private */
export  const dragStart: string;
/** @private */
export  const dragMove: string;
/** @private */
export  const dragEnd: string;
/** @private */
export  const resized: string;
/**
 * interface doc
 */
/**
 * Specifies Circular-Gauge Events
 */
export interface ICircularGaugeEventArgs {
    /**
     * name of the event
     */
    name: string;
    /**
     * to cancel the event
     */
    cancel: boolean;
}
/**
 * Specifies Loaded event arguments for circular gauge.
 */
export interface ILoadedEventArgs extends ICircularGaugeEventArgs {
    /**
     * gauge event argument
     */
    gauge: CircularGauge;
}
/**
 * Specifies AnimationComplete event arguments for circular gauge.
 */
export interface IAnimationCompleteEventArgs extends ICircularGaugeEventArgs {
    /**
     * axis event argument
     */
    axis: Axis;
    /**
     * pointer event argument
     */
    pointer: Pointer;
}
/**
 * Specifies AxisLabelRender event arguments for circular gauge.
 */
export interface IAxisLabelRenderEventArgs extends ICircularGaugeEventArgs {
    /**
     * axis event argument
     */
    axis: Axis;
    /**
     * text event argument
     */
    text: string;
    /**
     * value event argument
     */
    value: number;
}
/**
 * Specifies TooltipRender event arguments for circular gauge.
 */
export interface ITooltipRenderEventArgs extends ICircularGaugeEventArgs {
    /**
     * content event argument
     */
    content?: string | HTMLElement;
    /**
     * textStyle event argument
     */
    textStyle?: FontModel;
    /**
     * border event argument
     */
    border?: BorderModel;
    /**
     * axis event argument
     */
    axis: Axis;
    /**
     * pointer event argument
     */
    pointer: Pointer;
}
/**
 * Specifies AnnotationRender event arguments for circular gauge.
 */
export interface IAnnotationRenderEventArgs extends ICircularGaugeEventArgs {
    /**
     * content event argument
     */
    content?: string;
    /**
     * textStyle event argument
     */
    textStyle?: FontModel;
    /**
     * axis event argument
     */
    axis: Axis;
    /**
     * annotation event argument
     */
    annotation: Annotation;
}
/**
 * Specifies DragStart, DragMove and DragEnd events arguments for circular gauge.
 */
export interface IPointerDragEventArgs {
    /**
     * name event argument
     */
    name: string;
    /**
     * axis event argument
     */
    axis: Axis;
    /**
     * pointer event argument
     */
    pointer: Pointer;
    /**
     * currentValue event argument
     */
    currentValue: number;
    /**
     * previousValue event argument
     */
    previousValue?: number;
}
/**
 * Specifies Resize event arguments for circular gauge.
 */
export interface IResizeEventArgs {
    /**
     * name event argument
     */
    name: string;
    /**
     * previousSize event argument
     */
    previousSize: Size;
    /**
     * currentSize event argument
     */
    currentSize: Size;
    /**
     * gauge event argument
     */
    gauge: CircularGauge;
}
/**
 * Specifies Mouse events arguments for circular gauge.
 */
export interface IMouseEventArgs extends ICircularGaugeEventArgs {
    /**
     * target event argument
     */
    target: Element;
    /**
     * x event argument
     */
    x: number;
    /**
     * y event argument
     */
    y: number;
}
/**
 * Specifies visible point
 */
export interface IVisiblePointer {
    /**
     * axisIndex event argument
     */
    axisIndex?: number;
    /**
     * pointerIndex event argument
     */
    pointerIndex?: number;
}
/**
 * Specifies font mapping
 */
export interface IFontMapping {
    /**
     * size event argument
     */
    size?: string;
    /**
     * color event argument
     */
    color?: string;
    /**
     * fontWeight event argument
     */
    fontWeight?: string;
    /**
     * fontStyle event argument
     */
    fontStyle?: string;
    /**
     * fontFamily event argument
     */
    fontFamily?: string;
}
/**
 * Specifies gauge Themes
 */
export  namespace Theme {
    /** @private */
    let axisLabelFont: IFontMapping;
    /** @private */
    let axisLineColor: string;
    /** @private */
    let tickLineColor: string;
    /** @private */
    let pointerColor: string;
}
/** @private */
export  function getRangePalette(theme: string): string[];
/**
 * popups.Tooltip Module handles the tooltip of the circular gauge
 */
export  class GaugeTooltip {
    private gauge;
    private element;
    private currentAxis;
    private tooltip;
    private currentPointer;
    private borderStyle;
    private textStyle;
    ejTooltip: popups.Tooltip;
    /**
     * Constructor for popups.Tooltip module.
     * @private.
     */
    constructor(gauge: CircularGauge);
    /**
     * Method to render the tooltip for circular gauge.
     */
    renderTooltip(target: Element): void;
    /**
     * Method to append the target element for tooltip
     */
    private appendTargetElement(angle);
    /**
     * Method to find the position of the tooltip anchor for circular gauge.
     */
    private findPosition(angle);
    /**
     * Method to perform the tooltip for circular gauge.
     */
    private onBeforeRender(args);
    /**
     * Method to customize the tooltip elements for circular gauge.
     */
    private tooltipCustomization(args);
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the tooltip.
     * @return {void}
     * @private
     */
    destroy(gauge: CircularGauge): void;
}
/**
 * Defines position of the axis ticks / labels. They are
 * * inside
 * * outside
 * @private
 */
export  type Position = 'Inside' | 'Outside';
/**
 * Defines Pointer type of the axis. They are
 * * needle
 * * marker
 * * rangeBar
 * @private
 */
export  type PointerType = 'Needle' | 'Marker' | 'RangeBar';
/**
 * Defines Direction of the gauge. They are
 * * ClockWise
 * * AntiClockWise
 * @private
 */
export  type GaugeDirection = 'ClockWise' | 'AntiClockWise';
/**
 * Defines Theme of the gauge. They are
 * * Material
 * * Fabric
 * @private
 */
export  type GaugeTheme = 'Material' | 'Bootstrap' | 'Highcontrast' | 'Fabric';
/**
 * Defines Hidden label of the axis. They are
 * * First
 * * Last
 * @private
 */
export  type HiddenLabel = 'First' | 'Last' | 'None';
/**
 * Defines the shape of marker. They are
 * * circle - Renders a circle.
 * * rectangle - Renders a rectangle.
 * * triangle - Renders a triangle.
 * * diamond - Renders a diamond.
 * * cross - Renders a cross.
 * * horizontalLine - Renders a horizontalLine.
 * * verticalLine - Renders a verticalLine.
 * * pentagon- Renders a pentagon.
 * * invertedTriangle - Renders a invertedTriangle.
 * * image - Renders a image.
 */
export  type GaugeShape = 'Circle' | 'Rectangle' | 'Triangle' | 'Diamond' | 'InvertedTriangle' | 'Image';
/**
 * Function to measure the height and width of the text.
 * @param  {string} text
 * @param  {FontModel} font
 * @param  {string} id
 * @returns Size
 * @private
 */
export  function measureText(text: string, font: FontModel): Size;
/**
 * Function to find number from string
 * * @returns number
 * @private
 */
export  function toPixel(value: string, maxDimension: number): number;
/**
 * Function to get the style from FontModel.
 * @returns string
 * @private
 */
export  function getFontStyle(font: FontModel): string;
/**
 * Function to set style to the element.
 * @private
 */
export  function setStyles(element: HTMLElement, fill: string, border: BorderModel): void;
/**
 * Function to measure the element rect.
 * @returns ClientRect
 * @private
 */
export  function measureElementRect(element: HTMLElement): ClientRect;
/**
 * Function to convert the number from string.
 * @returns number
 * @private
 */
export  function stringToNumber(value: string, containerSize: number): number;
/**
 * Function to create the text element.
 * @returns Element
 * @private
 */
export  function textElement(options: TextOption, font: FontModel, color: string, parent: HTMLElement | Element, styles?: string): Element;
/**
 * Function to append the path to the element.
 * @returns Element
 * @private
 */
export  function appendPath(options: PathOption, element: Element, gauge: CircularGauge, functionName?: string): Element;
/**
 * Function to calculate the sum of array values.
 * @returns number
 * @private
 */
export  function calculateSum(from: number, to: number, values: number[]): number;
/**
 * Function to calculate the value for linear animation effect
 * @param currentTime
 * @param startValue
 * @param endValue
 * @param duration
 * @private
 */
export  function linear(currentTime: number, startValue: number, endValue: number, duration: number): number;
/**
 * Function to get the angle from value for circular gauge.
 * @returns number
 * @private
 */
export  function getAngleFromValue(value: number, maximumValue: number, minimumValue: number, startAngle: number, endAngle: number, isClockWise: boolean): number;
/**
 * Function to get the degree for circular gauge.
 * @returns number
 * @private
 */
export  function getDegree(startAngle: number, endAngle: number): number;
/**
 * Function to get the value from angle for circular gauge.
 * @returns number
 * @private
 */
export  function getValueFromAngle(angle: number, maximumValue: number, minimumValue: number, startAngle: number, endAngle: number, isClockWise: boolean): number;
/**
 * Function to check whether it's a complete circle for circular gauge.
 * @returns boolean
 * @private
 */
export  function isCompleteAngle(startAngle: number, endAngle: number): boolean;
/**
 * Function to get angle from location for circular gauge.
 * @returns number
 * @private
 */
export  function getAngleFromLocation(center: GaugeLocation, point: GaugeLocation): number;
/**
 * Function to get the location from angle for circular gauge.
 * @returns GaugeLocation
 * @private
 */
export  function getLocationFromAngle(degree: number, radius: number, center: GaugeLocation): GaugeLocation;
/**
 * Function to get the path direction of the circular gauge.
 * @returns string
 * @private
 */
export  function getPathArc(center: GaugeLocation, start: number, end: number, radius: number, startWidth?: number, endWidth?: number): string;
/**
 * Function to get the range path direction of the circular gauge.
 * @returns string
 * @private
 */
export  function getRangePath(start: GaugeLocation, end: GaugeLocation, innerStart: GaugeLocation, innerEnd: GaugeLocation, radius: number, startRadius: number, endRadius: number, clockWise: number): string;
/**
 * Function to calculate the complete path arc of the circular gauge.
 * @returns string
 * @private
 */
export  function getCompleteArc(center: GaugeLocation, start: number, end: number, radius: number, innerRadius: number): string;
/**
 * Function to get the circular path direction of the circular gauge.
 * @returns string
 * @private
 */
export  function getCirclePath(start: GaugeLocation, end: GaugeLocation, radius: number, clockWise: number): string;
/**
 * Function to get the complete path direction of the circular gauge.
 * @returns string
 * @private
 */
export  function getCompletePath(center: GaugeLocation, start: GaugeLocation, end: GaugeLocation, radius: number, innerStart: GaugeLocation, innerEnd: GaugeLocation, innerRadius: number, clockWise: number): string;
/**
 * Function to get element from id.
 * @returns Element
 * @private
 */
export  function getElement(id: string): Element;
/**
 * Function to compile the template function for circular gauge.
 * @returns Function
 * @private
 */
export  function getTemplateFunction(template: string): Function;
/**
 * Function to remove the element from id.
 * @private
 */
export  function removeElement(id: string): void;
/**
 * Function to get current point for circular gauge using element id.
 * @returns IVisiblePointer
 * @private
 */
export  function getPointer(targetId: string, gauge: CircularGauge): IVisiblePointer;
/**
 * Function to convert the label using formar for cirular gauge.
 * @returns string
 * @private
 */
export  function getLabelFormat(format: string): string;
/**
 * Function to calculate the marker shape for circular gauge.
 * @returns PathOption
 * @private
 */
export  function calculateShapes(location: GaugeLocation, shape: string, size: Size, url: string, options: PathOption): PathOption;
/**
 * Function to get range color from value for circular gauge.
 * @returns string
 * @private
 */
export  function getRangeColor(value: number, ranges: Range[], color: string): string;
/** @private */
export  class CustomizeOption {
    id: string;
    constructor(id?: string);
}
/** @private */
export  class PathOption extends CustomizeOption {
    opacity: number;
    fill: string;
    stroke: string;
    ['stroke-width']: number;
    ['stroke-dasharray']: string;
    d: string;
    transform: string;
    style: string;
    constructor(id: string, fill: string, width: number, color: string, opacity?: number, dashArray?: string, d?: string, transform?: string, style?: string);
}
/** @private */
export  class RectOption extends CustomizeOption {
    x: number;
    y: number;
    height: number;
    width: number;
    opacity: number;
    fill: string;
    stroke: string;
    ['stroke-width']: number;
    constructor(id: string, fill: string, border: BorderModel, opacity: number, rect: Rect);
}
/**
 * Internal class size
 */
export  class Size {
    /**
     * Specifies the height.
     */
    height: number;
    /**
     * Specifies the width.
     */
    width: number;
    constructor(width: number, height: number);
}
/** @private */
export  class GaugeLocation {
    x: number;
    y: number;
    constructor(x: number, y: number);
}
/** @private */
export  class Rect {
    x: number;
    y: number;
    height: number;
    width: number;
    constructor(x: number, y: number, width: number, height: number);
}
/** @private */
export  class TextOption extends CustomizeOption {
    anchor: string;
    text: string;
    transform: string;
    x: number;
    y: number;
    baseLine: string;
    constructor(id?: string, x?: number, y?: number, anchor?: string, text?: string, transform?: string, baseLine?: string);
}
/** @private */
export  class VisibleLabels {
    text: string;
    value: number;
    size: Size;
    constructor(text: string, value: number, size?: Size);
}
/**
 * Circular Gauge component exported.
 */
 }
export namespace compression { 

/**
 * represent compression stream writer
 * ```typescript
 * let compressedWriter = new CompressedStreamWriter();
 * let text: string = 'Hello world!!!';
 * compressedWriter.write(text, 0, text.length);
 * compressedWriter.close();
 * ```
 */
export  class CompressedStreamWriter {
    private stream;
    private pendingBuffer;
    private pendingBufLength;
    private pendingBufCache;
    private pendingBufBitsInCache;
    private treeLiteral;
    private treeDistances;
    private treeCodeLengths;
    private bufferPosition;
    private arrLiterals;
    private arrDistances;
    private extraBits;
    private currentHash;
    private hashHead;
    private hashPrevious;
    private matchStart;
    private matchLength;
    private matchPrevAvail;
    private blockStart;
    private stringStart;
    private lookAhead;
    private dataWindow;
    private inputBuffer;
    private totalBytesIn;
    private inputOffset;
    private inputEnd;
    private windowSize;
    private windowMask;
    private hashSize;
    private hashMask;
    private hashShift;
    private maxDist;
    private checkSum;
    private noWrap;
    /**
     * get compressed data
     */
    readonly compressedData: Uint8Array[];
    readonly getCompressedString: string;
    /**
     * Initializes compressor and writes ZLib header if needed.
     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.
     */
    constructor(noWrap?: boolean);
    /**
     * Compresses data and writes it to the stream.
     * @param {Uint8Array} data - data to compress
     * @param {number} offset - offset in data
     * @param {number} length - length of the data
     * @returns {void}
     */
    write(data: Uint8Array | string, offset: number, length: number): void;
    /**
     * write ZLib header to the compressed data
     * @return {void}
     */
    writeZLibHeader(): void;
    /**
     *  Write Most Significant Bytes in to stream
     * @param {number} s - check sum value
     */
    pendingBufferWriteShortBytes(s: number): void;
    private compressData(finish);
    private compressSlow(flush, finish);
    private discardMatch();
    private matchPreviousAvailable();
    private matchPreviousBest(prevMatch, prevLen);
    private lookAheadCompleted(finish);
    private huffmanIsFull(finish);
    private fillWindow();
    private slideWindow();
    private insertString();
    private findLongestMatch(curMatch);
    private updateHash();
    private huffmanTallyLit(literal);
    private huffmanTallyDist(dist, len);
    private huffmanFlushBlock(stored, storedOffset, storedLength, lastBlock);
    private huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);
    private huffmanLengthCode(len);
    private huffmanDistanceCode(distance);
    private huffmanSendAllTrees(blTreeCodes);
    private huffmanReset();
    private huffmanCompressBlock();
    /**
     * write bits in to internal buffer
     * @param {number} b - source of bits
     * @param {number} count - count of bits to write
     */
    pendingBufferWriteBits(b: number, count: number): void;
    private pendingBufferFlush(isClose?);
    private pendingBufferFlushBits();
    private pendingBufferWriteByteBlock(data, offset, length);
    private pendingBufferWriteShort(s);
    private pendingBufferAlignToByte();
    /**
     * close the stream and write all pending buffer in to stream
     * @returns {void}
     */
    close(): void;
    /**
     * release allocated un-managed resource
     * @returns {void}
     */
    destroy(): void;
}
/**
 * represent the Huffman Tree
 */
export  class CompressorHuffmanTree {
    private codeFrequency;
    private codes;
    private codeLength;
    private lengthCount;
    private codeMinCount;
    private codeCount;
    private maxLength;
    private writer;
    private static reverseBits;
    static huffCodeLengthOrders: number[];
    readonly treeLength: number;
    readonly codeLengths: Uint8Array;
    readonly codeFrequencies: Uint16Array;
    /**
     * Create new Huffman Tree
     * @param {CompressedStreamWriter} writer instance
     * @param {number} elementCount - element count
     * @param {number} minCodes - minimum count
     * @param {number} maxLength - maximum count
     */
    constructor(writer: CompressedStreamWriter, elementCount: number, minCodes: number, maxLength: number);
    setStaticCodes(codes: Int16Array, lengths: Uint8Array): void;
    /**
     * reset all code data in tree
     * @returns {void}
     */
    reset(): void;
    /**
     * write code to the compressor output stream
     * @param {number} code - code to be written
     * @returns {void}
     */
    writeCodeToStream(code: number): void;
    /**
     * calculate code from their frequencies
     * @returns {void}
     */
    buildCodes(): void;
    static bitReverse(value: number): number;
    /**
     * calculate length of compressed data
     * @returns {number}
     */
    getEncodedLength(): number;
    /**
     * calculate code frequencies
     * @param {CompressorHuffmanTree} blTree
     * @returns {void}
     */
    calculateBLFreq(blTree: CompressorHuffmanTree): void;
    /**
     * @param {CompressorHuffmanTree} blTree - write tree to output stream
     * @returns {void}
     */
    writeTree(blTree: CompressorHuffmanTree): void;
    /**
     * Build huffman tree
     * @returns {void}
     */
    buildTree(): void;
    private constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);
    private buildLength(child);
    private recreateTree(child, overflow, numLeafs);
    private calculateOptimalCodeLength(child, overflow, numNodes);
}
/**
 * Checksum calculator, based on Adler32 algorithm.
 */
export  class ChecksumCalculator {
    private static checkSumBitOffset;
    private static checksumBase;
    private static checksumIterationCount;
    /**
     * Updates checksum by calculating checksum of the
     * given buffer and adding it to current value.
     * @param {number} checksum - current checksum.
     * @param {Uint8Array} buffer - data byte array.
     * @param {number} offset - offset in the buffer.
     * @param {number} length - length of data to be used from the stream.
     * @returns {number}
     */
    static checksumUpdate(checksum: number, buffer: Uint8Array, offset: number, length: number): number;
}
/**
 * export ZipArchive class
 */
/**
 * class provide compression library
 * ```typescript
 * let archive = new ZipArchive();
 * archive.compressionLevel = 'Normal';
 * let archiveItem = new ZipArchiveItem(archive, 'directoryName\fileName.txt');
 * archive.addItem(archiveItem);
 * archive.save(fileName.zip);
 * ```
 */
export  class ZipArchive {
    private files;
    private level;
    /**
     * gets compression level
     */
    /**
     * sets compression level
     */
    compressionLevel: CompressionLevel;
    /**
     * gets items count
     */
    readonly length: number;
    /**
     * constructor for creating ZipArchive instance
     */
    constructor();
    /**
     * add new item to archive
     * @param {ZipArchiveItem} item - item to be added
     * @returns {void}
     */
    addItem(item: ZipArchiveItem): void;
    /**
     * add new directory to archive
     * @param directoryName directoryName to be created
     * @returns {void}
     */
    addDirectory(directoryName: string): void;
    /**
     * gets item at specified index
     * @param {number} index - item index
     * @returns {ZipArchiveItem}
     */
    getItem(index: number): ZipArchiveItem;
    /**
     * determines whether an element is in the collection
     * @param {string | ZipArchiveItem} item - item to search
     * @returns {boolean}
     */
    contains(item: string | ZipArchiveItem): boolean;
    /**
     * save archive with specified file name
     * @param {string} fileName save archive with specified file name
     * @returns {Promise<ZipArchive>}
     */
    save(fileName: string): Promise<ZipArchive>;
    /**
     * Save archive as blob
     * @return {Promise<Blob>}
     */
    saveAsBlob(): Promise<Blob>;
    private saveInternal(fileName, skipFileSave);
    /**
     * release allocated un-managed resource
     * @returns {void}
     */
    destroy(): void;
    private getCompressedData(item);
    private compressData(input, data, crc32Table);
    private constructZippedObject(zipParts, data, dirLength, isDirectory);
    private writeHeader(data, date);
    private writeZippedContent(fileName, zipData, localDirLen, skipFileSave);
    private writeCentralDirectory(data, localHeader, offset, externalFileAttribute);
    private writeFooter(zipData, centralLength, localLength);
    private getArrayBuffer(input);
    private getBytes(value, offset);
    private getModifiedTime(date);
    private getModifiedDate(date);
    private calculateCrc32Value(crc32Value, input, crc32Table);
}
/**
 * Class represent unique ZipArchive item
 * ```typescript
 * let archiveItem = new ZipArchiveItem(archive, 'directoryName\fileName.txt');
 * ```
 */
export  class ZipArchiveItem {
    data: Blob | ArrayBuffer;
    private fileName;
    /**
     * Get the name of archive item
     * @returns string
     */
    /**
     * Set the name of archive item
     * @param  {string} value
     */
    name: string;
    /**
     * constructor for creating {ZipArchiveItem} instance
     * @param {Blob|ArrayBuffer} data file data
     * @param {itemName} itemName absolute file path
     */
    constructor(data: Blob | ArrayBuffer, itemName: string);
    /**
     * release allocated un-managed resource
     * @returns {void}
     */
    destroy(): void;
}
export interface CompressedData {
    fileName: string;
    compressedData: Uint8Array[] | string;
    uncompressedDataSize: number;
    compressedSize: number;
    crc32Value: number;
    compressionType: string;
    isDirectory: boolean;
}
export interface ZippedObject {
    localHeader: string;
    centralDir: string;
    compressedData: CompressedData;
}
/**
 * Compression level.
 */
export  type CompressionLevel = 'NoCompression' | 'Normal';
 }
export namespace data { 

/**
 * Adaptors are specific data source type aware interfaces that are used by DataManager to communicate with DataSource.
 * This is the base adaptor class that other adaptors can extend.
 * @hidden
 */
export  class Adaptor {
    /**
     * Specifies the datasource option.
     * @default null
     */
    dataSource: DataOptions;
    /**
     * It contains the datamanager operations list like group, searches, etc.,
     * @default null
     * @hidden
     */
    pvt: PvtOptions;
    /**
     * Constructor for Adaptor class
     * @param  {DataOptions} ds?
     * @hidden
     * @returns aggregates
     */
    constructor(ds?: DataOptions);
    protected options: RemoteOptions;
    /**
     * Returns the data from the query processing.
     * @param  {Object} data
     * @param  {DataOptions} ds?
     * @param  {Query} query?
     * @param  {XMLHttpRequest} xhr?
     * @returns Object
     */
    processResponse(data: Object, ds?: DataOptions, query?: Query, xhr?: XMLHttpRequest): Object;
    /**
     * Specifies the type of adaptor.
     * @default Adaptor
     */
    type: Object;
}
/**
 * JsonAdaptor is used to process JSON data. It contains methods to process the given JSON data based on the queries.
 * @hidden
 */
export  class JsonAdaptor extends Adaptor {
    /**
     * Process the JSON data based on the provided queries.
     * @param  {DataManager} dataManager
     * @param  {Query} query
     * @returns Object
     */
    processQuery(dataManager: DataManager, query: Query): Object;
    /**
     * Performs batch update in the JSON array which add, remove and update records.
     * @param  {DataManager} dm
     * @param  {CrudOptions} changes
     * @param  {RemoteArgs} e
     */
    batchRequest(dm: DataManager, changes: CrudOptions, e: RemoteArgs): CrudOptions;
    /**
     * Performs filter operation with the given data and where query.
     * @param  {Object[]} ds
     * @param  {{validate:Function}} e
     */
    onWhere(ds: Object[], e: {
        validate: Function;
    }): Object[];
    /**
     * Returns aggregate function based on the aggregate type.
     * @param  {Object[]} ds
     * @param  {{field:string} e
     * @param  {string}} type
     */
    onAggregates(ds: Object[], e: {
        field: string;
        type: string;
    }): Function;
    /**
     * Performs search operation based on the given query.
     * @param  {Object[]} ds
     * @param  {QueryOptions} e
     */
    onSearch(ds: Object[], e: QueryOptions): Object[];
    /**
     * Sort the data with given direction and field.
     * @param  {Object[]} ds
     * @param  {{comparer:(a:Object} e
     * @param  {Object} b
     */
    onSortBy(ds: Object[], e: {
        comparer: (a: Object, b: Object) => number;
        fieldName: string;
    }, query: Query): Object[];
    /**
     * Group the data based on the given query.
     * @param  {Object[]} ds
     * @param  {QueryOptions} e
     * @param  {Query} query
     */
    onGroup(ds: Object[], e: QueryOptions, query: Query): Object[];
    /**
     * Retrieves records based on the given page index and size.
     * @param  {Object[]} ds
     * @param  {{pageSize:number} e
     * @param  {number}} pageIndex
     * @param  {Query} query
     */
    onPage(ds: Object[], e: {
        pageSize: number;
        pageIndex: number;
    }, query: Query): Object[];
    /**
     * Retrieves records based on the given start and end index from query.
     * @param  {Object[]} ds
     * @param  {{start:number} e
     * @param  {number}} end
     */
    onRange(ds: Object[], e: {
        start: number;
        end: number;
    }): Object[];
    /**
     * Picks the given count of records from the top of the datasource.
     * @param  {Object[]} ds
     * @param  {{nos:number}} e
     */
    onTake(ds: Object[], e: {
        nos: number;
    }): Object[];
    /**
     * Skips the given count of records from the data source.
     * @param  {Object[]} ds
     * @param  {{nos:number}} e
     */
    onSkip(ds: Object[], e: {
        nos: number;
    }): Object[];
    /**
     * Selects specified columns from the data source.
     * @param  {Object[]} ds
     * @param  {{fieldNames:string}} e
     */
    onSelect(ds: Object[], e: {
        fieldNames: string[] | Function;
    }): Object[];
    /**
     * Inserts new record in the table.
     * @param  {DataManager} dm
     * @param  {Object} data
     * @param  {number} position
     */
    insert(dm: DataManager, data: Object, tableName?: string, query?: Query, position?: number): Object;
    /**
     * Remove the data from the dataSource based on the key field value.
     * @param  {DataManager} dm
     * @param  {string} keyField
     * @param  {Object} value
     * @param  {string} tableName?
     * @returns null
     */
    remove(dm: DataManager, keyField: string, value: Object, tableName?: string): Object[];
    /**
     * Updates existing record and saves the changes to the table.
     * @param  {DataManager} dm
     * @param  {string} keyField
     * @param  {Object} value
     * @param  {string} tableName?
     * @returns null
     */
    update(dm: DataManager, keyField: string, value: Object, tableName?: string): void;
}
/**
 * URL Adaptor of DataManager can be used when you are required to use remote service to retrieve data.
 * It interacts with server-side for all DataManager Queries and CRUD operations.
 * @hidden
 */
export  class UrlAdaptor extends Adaptor {
    /**
     * Process the query to generate request body.
     * @param  {DataManager} dm
     * @param  {Query} query
     * @param  {Object[]} hierarchyFilters?
     * @returns p
     */
    processQuery(dm: DataManager, query: Query, hierarchyFilters?: Object[]): Object;
    private getRequestQuery(options, query, singles, request, request1);
    /**
     * Convert the object from processQuery to string which can be added query string.
     * @param  {Object} req
     * @param  {Query} query
     * @param  {DataManager} dm
     */
    convertToQueryString(request: Object, query: Query, dm: DataManager): string;
    /**
     * Return the data from the data manager processing.
     * @param  {DataResult} data
     * @param  {DataOptions} ds?
     * @param  {Query} query?
     * @param  {XMLHttpRequest} xhr?
     * @param  {Object} request?
     * @param  {CrudOptions} changes?
     */
    processResponse(data: DataResult, ds?: DataOptions, query?: Query, xhr?: XMLHttpRequest, request?: Object, changes?: CrudOptions): DataResult;
    /**
     * Add the group query to the adaptor`s option.
     * @param  {Object[]} e
     * @returns void
     */
    onGroup(e: QueryOptions[]): QueryOptions[];
    /**
     * Add the aggregate query to the adaptor`s option.
     * @param  {Aggregates[]} e
     * @returns void
     */
    onAggregates(e: Aggregates[]): void;
    /**
     * Prepare the request body based on the newly added, removed and updated records.
     * The result is used by the batch request.
     * @param  {DataManager} dm
     * @param  {CrudOptions} changes
     * @param  {Object} e
     */
    batchRequest(dm: DataManager, changes: CrudOptions, e: Object): Object;
    /**
     * Method will trigger before send the request to server side.
     * Used to set the custom header or modify the request options.
     * @param  {DataManager} dm
     * @param  {XMLHttpRequest} request
     * @returns void
     */
    beforeSend(dm: DataManager, request: XMLHttpRequest): void;
    /**
     * Prepare and returns request body which is used to insert a new record in the table.
     * @param  {DataManager} dm
     * @param  {Object} data
     * @param  {string} tableName
     */
    insert(dm: DataManager, data: Object, tableName: string): Object;
    /**
     * Prepare and return request body which is used to remove record from the table.
     * @param  {DataManager} dm
     * @param  {string} keyField
     * @param  {number|string} value
     * @param  {string} tableName
     */
    remove(dm: DataManager, keyField: string, value: number | string, tableName: string): Object;
    /**
     * Prepare and return request body which is used to update record.
     * @param  {DataManager} dm
     * @param  {string} keyField
     * @param  {Object} value
     * @param  {string} tableName
     */
    update(dm: DataManager, keyField: string, value: Object, tableName: string): Object;
    /**
     * To generate the predicate based on the filtered query.
     * @param  {Object[]|string[]|number[]} data
     * @param  {Query} query
     * @hidden
     */
    getFiltersFrom(data: Object[] | string[] | number[], query: Query): Predicate;
    protected getAggregateResult(pvt: PvtOptions, data: DataResult, args: DataResult, groupDs?: Object[]): DataResult;
    protected getQueryRequest(query: Query): Requests;
    private addParams(options);
}
/**
 * OData Adaptor that is extended from URL Adaptor, is used for consuming data through OData Service.
 * @hidden
 */
export  class ODataAdaptor extends UrlAdaptor {
    private getModuleName;
    protected options: RemoteOptions;
    constructor();
    /**
     * Generate request string based on the filter criteria from query.
     * @param  {Predicate} pred
     * @param  {boolean} requiresCast?
     */
    onPredicate(predicate: Predicate, query: Query | boolean, requiresCast?: boolean): string;
    /**
     * Generate request string based on the multiple filter criteria from query.
     * @param  {Predicate} pred
     * @param  {boolean} requiresCast?
     */
    onComplexPredicate(predicate: Predicate, query: Query, requiresCast?: boolean): string;
    /**
     * Generate query string based on the multiple filter criteria from query.
     * @param  {Predicate} filter
     * @param  {boolean} requiresCast?
     */
    onEachWhere(filter: Predicate, query: Query, requiresCast?: boolean): string;
    /**
     * Generate query string based on the multiple filter criteria from query.
     * @param  {string[]} filters
     */
    onWhere(filters: string[]): string;
    /**
     * Generate query string based on the multiple search criteria from query.
     * @param  {{fields:string[]} e
     * @param  {string} operator
     * @param  {string} key
     * @param  {boolean}} ignoreCase
     */
    onEachSearch(e: {
        fields: string[];
        operator: string;
        key: string;
        ignoreCase: boolean;
    }): void;
    /**
     * Generate query string based on the search criteria from query.
     * @param  {Object} e
     */
    onSearch(e: Object): string;
    /**
     * Generate query string based on multiple sort criteria from query.
     * @param  {QueryOptions} e
     */
    onEachSort(e: QueryOptions): string;
    /**
     * Returns sort query string.
     * @param  {string[]} e
     */
    onSortBy(e: string[]): string;
    /**
     * Adds the group query to the adaptor option.
     * @param  {Object[]} e
     * @returns string
     */
    onGroup(e: QueryOptions[]): QueryOptions[];
    /**
     * Returns the select query string.
     * @param  {string[]} e
     */
    onSelect(e: string[]): string;
    /**
     * Add the aggregate query to the adaptor option.
     * @param  {Object[]} e
     * @returns string
     */
    onAggregates(e: Object[]): string;
    /**
     * Returns the query string which requests total count from the data source.
     * @param  {boolean} e
     * @returns string
     */
    onCount(e: boolean): string;
    /**
     * Method will trigger before send the request to server side.
     * Used to set the custom header or modify the request options.
     * @param  {DataManager} dm
     * @param  {XMLHttpRequest} request
     * @param  {base.Ajax} settings?
     */
    beforeSend(dm: DataManager, request: XMLHttpRequest, settings?: base.Ajax): void;
    /**
     * Returns the data from the query processing.
     * @param  {DataResult} data
     * @param  {DataOptions} ds?
     * @param  {Query} query?
     * @param  {XMLHttpRequest} xhr?
     * @param  {base.Ajax} request?
     * @param  {CrudOptions} changes?
     * @returns aggregateResult
     */
    processResponse(data: DataResult, ds?: DataOptions, query?: Query, xhr?: XMLHttpRequest, request?: base.Ajax, changes?: CrudOptions): Object;
    /**
     * Converts the request object to query string.
     * @param  {Object} req
     * @param  {Query} query
     * @param  {DataManager} dm
     * @returns tableName
     */
    convertToQueryString(request: Object, query: Query, dm: DataManager): string;
    /**
     * Prepare and returns request body which is used to insert a new record in the table.
     * @param  {DataManager} dm
     * @param  {Object} data
     * @param  {string} tableName?
     */
    insert(dm: DataManager, data: Object, tableName?: string): Object;
    /**
     * Prepare and return request body which is used to remove record from the table.
     * @param  {DataManager} dm
     * @param  {string} keyField
     * @param  {number} value
     * @param  {string} tableName?
     */
    remove(dm: DataManager, keyField: string, value: number, tableName?: string): Object;
    /**
     * Updates existing record and saves the changes to the table.
     * @param  {DataManager} dm
     * @param  {string} keyField
     * @param  {Object} value
     * @param  {string} tableName?
     * @returns this
     */
    update(dm: DataManager, keyField: string, value: Object, tableName?: string): Object;
    /**
     * Prepare the request body based on the newly added, removed and updated records.
     * The result is used by the batch request.
     * @param  {DataManager} dm
     * @param  {CrudOptions} changes
     * @param  {RemoteArgs} e
     * @returns {Object}
     */
    batchRequest(dm: DataManager, changes: CrudOptions, e: RemoteArgs): Object;
    /**
     * Generate the string content from the removed records.
     * The result will be send during batch update.
     * @param  {Object[]} arr
     * @param  {RemoteArgs} e
     * @returns this
     */
    generateDeleteRequest(arr: Object[], e: RemoteArgs): string;
    /**
     * Generate the string content from the inserted records.
     * The result will be send during batch update.
     * @param  {Object[]} arr
     * @param  {RemoteArgs} e
     */
    generateInsertRequest(arr: Object[], e: RemoteArgs): string;
    /**
     * Generate the string content from the updated records.
     * The result will be send during batch update.
     * @param  {Object[]} arr
     * @param  {RemoteArgs} e
     */
    generateUpdateRequest(arr: Object[], e: RemoteArgs): string;
    private static getField(prop);
    private generateBodyContent(arr, e, stat);
    protected processBatchResponse(data: DataResult, query?: Query, xhr?: XMLHttpRequest, request?: base.Ajax, changes?: CrudOptions): CrudOptions | DataResult;
}
/**
 * The OData v4 is an improved version of OData protocols.
 * The DataManager uses the ODataV4Adaptor to consume OData v4 services.
 * @hidden
 */
export  class ODataV4Adaptor extends ODataAdaptor {
    isOdatav4: boolean;
    /**
     * @hidden
     */
    protected getModulename(): string;
    protected options: RemoteOptions;
    /**
     * Returns the query string which requests total count from the data source.
     * @param  {boolean} e
     * @returns string
     */
    onCount(e: boolean): string;
    /**
     * Generate request string based on the filter criteria from query.
     * @param  {Predicate} pred
     * @param  {boolean} requiresCast?
     */
    onPredicate(predicate: Predicate, query: Query | boolean, requiresCast?: boolean): string;
    /**
     *  Generate query string based on the multiple search criteria from query.
     * @param  {{fields:string[]} e
     * @param  {string} operator
     * @param  {string} key
     * @param  {boolean}} ignoreCase
     */
    onEachSearch(e: {
        fields: string[];
        operator: string;
        key: string;
        ignoreCase: boolean;
    }): void;
    /**
     *  Generate query string based on the search criteria from query.
     * @param  {Object} e
     */
    onSearch(e: Object): string;
    /**
     * Method will trigger before send the request to server side.
     * Used to set the custom header or modify the request options.
     * @param  {DataManager} dm
     * @param  {XMLHttpRequest} request
     * @param  {base.Ajax} settings
     * @returns void
     */
    beforeSend(dm: DataManager, request: XMLHttpRequest, settings: base.Ajax): void;
    /**
     * Returns the data from the query processing.
     * @param  {DataResult} data
     * @param  {DataOptions} ds?
     * @param  {Query} query?
     * @param  {XMLHttpRequest} xhr?
     * @param  {base.Ajax} request?
     * @param  {CrudOptions} changes?
     * @returns aggregateResult
     */
    processResponse(data: DataResult, ds?: DataOptions, query?: Query, xhr?: XMLHttpRequest, request?: base.Ajax, changes?: CrudOptions): Object;
}
/**
 * The Web API is a programmatic interface to define the request and response messages system that is mostly exposed in JSON or XML.
 * The DataManager uses the WebApiAdaptor to consume Web API.
 * Since this adaptor is targeted to interact with Web API created using OData endpoint, it is extended from ODataAdaptor
 * @hidden
 */
export  class WebApiAdaptor extends ODataAdaptor {
    /**
     * Prepare and returns request body which is used to insert a new record in the table.
     * @param  {DataManager} dm
     * @param  {Object} data
     * @param  {string} tableName?
     */
    insert(dm: DataManager, data: Object, tableName?: string): Object;
    /**
     * Prepare and return request body which is used to remove record from the table.
     * @param  {DataManager} dm
     * @param  {string} keyField
     * @param  {number} value
     * @param  {string} tableName?
     */
    remove(dm: DataManager, keyField: string, value: number, tableName?: string): Object;
    /**
     * Prepare and return request body which is used to update record.
     * @param  {DataManager} dm
     * @param  {string} keyField
     * @param  {Object} value
     * @param  {string} tableName?
     */
    update(dm: DataManager, keyField: string, value: Object, tableName?: string): Object;
    /**
     * Method will trigger before send the request to server side.
     * Used to set the custom header or modify the request options.
     * @param  {DataManager} dm
     * @param  {XMLHttpRequest} request
     * @param  {base.Ajax} settings
     * @returns void
     */
    beforeSend(dm: DataManager, request: XMLHttpRequest, settings: base.Ajax): void;
    /**
     * Returns the data from the query processing.
     * @param  {DataResult} data
     * @param  {DataOptions} ds?
     * @param  {Query} query?
     * @param  {XMLHttpRequest} xhr?
     * @param  {base.Ajax} request?
     * @param  {CrudOptions} changes?
     * @returns aggregateResult
     */
    processResponse(data: DataResult, ds?: DataOptions, query?: Query, xhr?: XMLHttpRequest, request?: base.Ajax, changes?: CrudOptions): Object;
}
/**
 * WebMethodAdaptor can be used by DataManager to interact with web method.
 * @hidden
 */
export  class WebMethodAdaptor extends UrlAdaptor {
    /**
     * Prepare the request body based on the query.
     * The query information can be accessed at the WebMethod using variable named `value`.
     * @param  {DataManager} dm
     * @param  {Query} query
     * @param  {Object[]} hierarchyFilters?
     * @returns application
     */
    processQuery(dm: DataManager, query: Query, hierarchyFilters?: Object[]): Object;
}
/**
 * RemoteSaveAdaptor, extended from JsonAdaptor and it is used for binding local data and performs all DataManager queries in client-side.
 * It interacts with server-side only for CRUD operations.
 * @hidden
 */
export  class RemoteSaveAdaptor extends JsonAdaptor {
    /**
     * @hidden
     */
    constructor();
    /**
     * Prepare the request body based on the newly added, removed and updated records.
     * Also perform the changes in the locally cached data to sync with the remote data.
     * The result is used by the batch request.
     * @param  {DataManager} dm
     * @param  {CrudOptions} changes
     * @param  {RemoteArgs} e
     */
    batchRequest(dm: DataManager, changes: CrudOptions, e: RemoteArgs): Object;
}
/**
 * Cache Adaptor is used to cache the data of the visited pages. It prevents new requests for the previously visited pages.
 * You can configure cache page size and duration of caching by using cachingPageSize and timeTillExpiration properties of the DataManager
 * @hidden
 */
export  class CacheAdaptor extends UrlAdaptor {
    private cacheAdaptor;
    private pageSize;
    private guidId;
    private isCrudAction;
    private isInsertAction;
    /**
     * Constructor for CacheAdaptor class.
     * @param  {CacheAdaptor} adaptor?
     * @param  {number} timeStamp?
     * @param  {number} pageSize?
     * @hidden
     */
    constructor(adaptor?: CacheAdaptor, timeStamp?: number, pageSize?: number);
    /**
     * It will generate the key based on the URL when we send a request to server.
     * @param  {string} url
     * @param  {Query} query?
     * @hidden
     */
    generateKey(url: string, query: Query): string;
    /**
     * Process the query to generate request body.
     * If the data is already cached, it will return the cached data.
     * @param  {DataManager} dm
     * @param  {Query} query?
     * @param  {Object[]} hierarchyFilters?
     */
    processQuery(dm: DataManager, query?: Query, hierarchyFilters?: Object[]): Object;
    /**
     * Returns the data from the query processing.
     * It will also cache the data for later usage.
     * @param  {DataResult} data
     * @param  {DataManager} ds?
     * @param  {Query} query?
     * @param  {XMLHttpRequest} xhr?
     * @param  {base.Ajax} request?
     * @param  {CrudOptions} changes?
     */
    processResponse(data: DataResult, ds?: DataManager, query?: Query, xhr?: XMLHttpRequest, request?: base.Ajax, changes?: CrudOptions): DataResult;
    /**
     * Method will trigger before send the request to server side. Used to set the custom header or modify the request options.
     * @param  {DataManager} dm
     * @param  {XMLHttpRequest} request
     * @param  {base.Ajax} settings?
     */
    beforeSend(dm: DataManager, request: XMLHttpRequest, settings?: base.Ajax): void;
    /**
     * Updates existing record and saves the changes to the table.
     * @param  {DataManager} dm
     * @param  {string} keyField
     * @param  {Object} value
     * @param  {string} tableName
     */
    update(dm: DataManager, keyField: string, value: Object, tableName: string): Object;
    /**
     * Prepare and returns request body which is used to insert a new record in the table.
     * @param  {DataManager} dm
     * @param  {Object} data
     * @param  {string} tableName?
     */
    insert(dm: DataManager, data: Object, tableName?: string): Object;
    /**
     * Prepare and return request body which is used to remove record from the table.
     * @param  {DataManager} dm
     * @param  {string} keyField
     * @param  {Object} value
     * @param  {string} tableName?
     */
    remove(dm: DataManager, keyField: string, value: Object, tableName?: string): Object[];
    /**
     * Prepare the request body based on the newly added, removed and updated records.
     * The result is used by the batch request.
     * @param  {DataManager} dm
     * @param  {CrudOptions} changes
     * @param  {RemoteArgs} e
     */
    batchRequest(dm: DataManager, changes: CrudOptions, e: RemoteArgs): CrudOptions;
}
/**
 * @hidden
 */
export interface CrudOptions {
    changedRecords?: Object[];
    addedRecords?: Object[];
    deletedRecords?: Object[];
    action?: string;
    table?: string;
    key?: string;
}
/**
 * @hidden
 */
export interface PvtOptions {
    groups?: QueryOptions[];
    aggregates?: Aggregates[];
    search?: Object | Predicate;
    changeSet?: number;
    searches?: Object[];
}
/**
 * @hidden
 */
export interface DataResult {
    nodeType?: number;
    addedRecords?: Object[];
    d?: DataResult | Object[];
    Count?: number;
    count?: number;
    result?: Object;
    results?: Object[] | DataResult;
    aggregate?: DataResult;
    aggregates?: Aggregates;
    value?: Object;
    Items?: Object[] | DataResult;
    keys?: string[];
    groupDs?: Object[];
}
/**
 * @hidden
 */
export interface Requests {
    sorts: QueryOptions[];
    groups: QueryOptions[];
    filters: QueryOptions[];
    searches: QueryOptions[];
    aggregates: QueryOptions[];
}
/**
 * @hidden
 */
export interface RemoteArgs {
    guid?: string;
    url?: string;
    key?: string;
    cid?: number;
    cSet?: string;
}
/**
 * @hidden
 */
export interface RemoteOptions {
    from?: string;
    requestType?: string;
    sortBy?: string;
    select?: string;
    skip?: string;
    group?: string;
    take?: string;
    search?: string;
    count?: string;
    where?: string;
    aggregates?: string;
    expand?: string;
    accept?: string;
    multipartAccept?: string;
    batch?: string;
    changeSet?: string;
    batchPre?: string;
    contentId?: string;
    batchContent?: string;
    changeSetContent?: string;
    batchChangeSetContentType?: string;
}
/**
 * Data modules
 */
/**
 * DataManager is used to manage and manipulate relational data.
 */
export  class DataManager {
    /** @hidden */
    adaptor: AdaptorOptions;
    /** @hidden */
    defaultQuery: Query;
    /** @hidden */
    dataSource: DataOptions;
    /** @hidden */
    dateParse: boolean;
    /** @hidden */
    ready: Promise<base.Ajax>;
    private isDataAvailable;
    private requests;
    /**
     * Constructor for DataManager class
     * @param  {DataOptions|JSON[]} dataSource?
     * @param  {Query} query?
     * @param  {AdaptorOptions|string} adaptor?
     * @hidden
     */
    constructor(dataSource?: DataOptions | JSON[] | Object[], query?: Query, adaptor?: AdaptorOptions | string);
    /**
     * Overrides DataManager's default query with given query.
     * @param  {Query} query - Defines the new default query.
     */
    setDefaultQuery(query: Query): DataManager;
    /**
     * Executes the given query with local data source.
     * @param  {Query} query - Defines the query to retrieve data.
     */
    executeLocal(query?: Query): Object[];
    /**
     * Executes the given query with either local or remote data source.
     * It will be executed as asynchronously and returns Promise object which will be resolved or rejected after action completed.
     * @param  {Query|Function} query - Defines the query to retrieve data.
     * @param  {Function} done - Defines the callback function and triggers when the Promise is resolved.
     * @param  {Function} fail - Defines the callback function and triggers when the Promise is rejected.
     * @param  {Function} always - Defines the callback function and triggers when the Promise is resolved or rejected.
     */
    executeQuery(query: Query | Function, done?: Function, fail?: Function, always?: Function): Promise<base.Ajax>;
    private static getDeferedArgs(query, result, args?);
    private static nextTick(fn);
    private extendRequest(url, fnSuccess, fnFail);
    private makeRequest(url, deffered, args?, query?);
    private beforeSend(request, settings?);
    /**
     * Save bulk changes to the given table name.
     * User can add a new record, edit an existing record, and delete a record at the same time.
     * If the datasource from remote, then updated in a single post.
     * @param  {Object} changes - Defines the CrudOptions.
     * @param  {string} key - Defines the column field.
     * @param  {string|Query} tableName - Defines the table name.
     * @param  {Query} query - Sets default query for the DataManager.
     */
    saveChanges(changes: Object, key?: string, tableName?: string | Query, query?: Query): Promise<Object> | Object;
    /**
     * Inserts new record in the given table.
     * @param  {Object} data - Defines the data to insert.
     * @param  {string|Query} tableName - Defines the table name.
     * @param  {Query} query - Sets default query for the DataManager.
     */
    insert(data: Object, tableName?: string | Query, query?: Query, position?: number): Object | Promise<Object>;
    /**
     * Removes data from the table with the given key.
     * @param  {string} keyField - Defines the column field.
     * @param  {Object} value - Defines the value to find the data in the specified column.
     * @param  {string|Query} tableName - Defines the table name
     * @param  {Query} query - Sets default query for the DataManager.
     */
    remove(keyField: string, value: Object, tableName?: string | Query, query?: Query): Object | Promise<Object>;
    /**
     * Updates existing record in the given table.
     * @param  {string} keyField - Defines the column field.
     * @param  {Object} value - Defines the value to find the data in the specified column.
     * @param  {string|Query} tableName - Defines the table name
     * @param  {Query} query - Sets default query for the DataManager.
     */
    update(keyField: string, value: Object, tableName?: string | Query, query?: Query): Object | Promise<Object>;
    private doAjaxRequest(res);
}
/**
 * Deferred is used to handle asynchronous operation.
 */
export  class Deferred {
    /**
     * Resolve a Deferred object and call doneCallbacks with the given args.
     */
    resolve: Function;
    /**
     * Reject a Deferred object and call failCallbacks with the given args.
     */
    reject: Function;
    /**
     * Promise is an object that represents a value that may not be available yet, but will be resolved at some point in the future.
     */
    promise: Promise<Object>;
    /**
     * Defines the callback function triggers when the Deferred object is resolved.
     */
    then: Function;
    /**
     * Defines the callback function triggers when the Deferred object is rejected.
     */
    catch: Function;
}
/**
 * @hidden
 */
export interface DataOptions {
    url?: string;
    adaptor?: AdaptorOptions;
    insertUrl?: string;
    removeUrl?: string;
    updateUrl?: string;
    crudUrl?: string;
    batchUrl?: string;
    json?: Object[];
    headers?: Object[];
    accept?: boolean;
    data?: JSON;
    timeTillExpiration?: number;
    cachingPageSize?: number;
    enableCaching?: boolean;
    requestType?: string;
    key?: string;
    crossDomain?: boolean;
    jsonp?: string;
    dataType?: string;
    offline?: boolean;
    requiresFormat?: boolean;
}
/**
 * @hidden
 */
export interface ReturnOption {
    result?: ReturnOption;
    count?: number;
    url?: string;
    aggregates?: Aggregates;
}
/**
 * @hidden
 */
export interface RequestOptions {
    xhr?: XMLHttpRequest;
    count?: number;
    result?: ReturnOption;
    request?: base.Ajax;
    aggregates?: Aggregates;
    actual?: Object;
    virtualSelectRecords?: Object;
    error?: string;
}
/**
 * @hidden
 */
export interface AdaptorOptions {
    processQuery?: Function;
    processResponse?: Function;
    beforeSend?: Function;
    batchRequest?: Function;
    insert?: Function;
    remove?: Function;
    update?: Function;
}
/**
 * Query class is used to build query which is used by the DataManager to communicate with datasource.
 */
export  class Query {
    /** @hidden */
    queries: QueryOptions[];
    /** @hidden */
    key: string;
    /** @hidden */
    fKey: string;
    /** @hidden */
    fromTable: string;
    /** @hidden */
    lookups: string[];
    /** @hidden */
    expands: Object[];
    /** @hidden */
    sortedColumns: Object[];
    /** @hidden */
    groupedColumns: Object[];
    /** @hidden */
    subQuerySelector: Function;
    /** @hidden */
    subQuery: Query;
    /** @hidden */
    isChild: boolean;
    /** @hidden */
    params: ParamOption[];
    /** @hidden */
    isCountRequired: boolean;
    /** @hidden */
    dataManager: DataManager;
    /**
     * Constructor for Query class.
     * @param  {string|string[]} from?
     * @hidden
     */
    constructor(from?: string | string[]);
    /**
     * Sets the primary key.
     * @param  {string} field - Defines the column field.
     */
    setKey(field: string): Query;
    /**
     * Sets default DataManager to execute query.
     * @param  {DataManager} dataManager - Defines the DataManager.
     */
    using(dataManager: DataManager): Query;
    /**
     * Executes query with the given DataManager.
     * @param  {DataManager} dataManager - Defines the DataManager.
     * @param  {Function} done - Defines the success callback.
     * @param  {Function} fail - Defines the failure callback.
     * @param  {Function} always - Defines the callback which will be invoked on either success or failure.
     *
     * <pre>
     * let dataManager: DataManager = new DataManager([{ ID: '10' }, { ID: '2' }, { ID: '1' }, { ID: '20' }]);
     * let query: Query = new Query();
     * query.sortBy('ID', (x: string, y: string): number => { return parseInt(x, 10) - parseInt(y, 10) });
     * let promise: Promise< Object > = query.execute(dataManager);
     * promise.then((e: { result: Object }) => { });
     * </pre>
     */
    execute(dataManager?: DataManager, done?: Function, fail?: Function, always?: Function): Promise<Object>;
    /**
     * Executes query with the local datasource.
     * @param  {DataManager} dataManager - Defines the DataManager.
     */
    executeLocal(dataManager?: DataManager): Object[];
    /**
     * Creates deep copy of the Query object.
     */
    clone(): Query;
    /**
     * Specifies the name of table to retrieve data in query execution.
     * @param  {string} tableName - Defines the table name.
     */
    from(tableName: string): Query;
    /**
     * Adds additional parameter which will be sent along with the request which will be generated while DataManager execute.
     * @param  {string} key - Defines the key of additional parameter.
     * @param  {Function|string} value - Defines the value for the key.
     */
    addParams(key: string, value: Function | string): Query;
    /**
     * Expands the related table.
     * @param  {string|Object[]} tables
     */
    expand(tables: string | Object[]): Query;
    /**
     * Filter data with given filter criteria.
     * @param  {string|Predicate} fieldName - Defines the column field or Predicate.
     * @param  {string} operator - Defines the operator how to filter data.
     * @param  {string|number|boolean} value - Defines the values to match with data.
     * @param  {boolean} ignoreCase - If ignore case set to false, then filter data with exact match or else
     * filter data with case insensitive.
     */
    where(fieldName: string | Predicate | Predicate[], operator?: string, value?: string | Date | number | boolean, ignoreCase?: boolean, ignoreAccent?: boolean): Query;
    /**
     * Search data with given search criteria.
     * @param  {string|number|boolean} searchKey - Defines the search key.
     * @param  {string|string[]} fieldNames - Defines the collection of column fields.
     * @param  {string} operator - Defines the operator how to search data.
     * @param  {boolean} ignoreCase - If ignore case set to false, then filter data with exact match or else
     * filter data with case insensitive.
     */
    search(searchKey: string | number | boolean, fieldNames?: string | string[], operator?: string, ignoreCase?: boolean, ignoreAccent?: boolean): Query;
    /**
     * Sort the data with given sort criteria.
     * By default, sort direction is ascending.
     * @param  {string|string[]} fieldName - Defines the single or collection of column fields.
     * @param  {string|Function} comparer - Defines the sort direction or custom sort comparer function.
     */
    sortBy(fieldName: string | string[], comparer?: string | Function, isFromGroup?: boolean): Query;
    /**
     * Sorts data in descending order.
     * @param  {string} fieldName - Defines the column field.
     */
    sortByDesc(fieldName: string): Query;
    /**
     * Groups data with the given field name.
     * @param  {string} fieldName - Defines the column field.
     */
    group(fieldName: string, fn?: Function, format?: string | base.NumberFormatOptions | base.DateFormatOptions): Query;
    /**
     * Gets data based on the given page index and size.
     * @param  {number} pageIndex - Defines the current page index.
     * @param  {number} pageSize - Defines the no of records per page.
     */
    page(pageIndex: number, pageSize: number): Query;
    /**
     * Gets data based on the given start and end index.
     * @param  {number} start - Defines the start index of the datasource.
     * @param  {number} end - Defines the end index of the datasource.
     */
    range(start: number, end: number): Query;
    /**
     * Gets data from the top of the data source based on given number of records count.
     * @param  {number} nos - Defines the no of records to retrieve from datasource.
     */
    take(nos: number): Query;
    /**
     * Skips data with given number of records count from the top of the data source.
     * @param  {number} nos - Defines the no of records skip in the datasource.
     */
    skip(nos: number): Query;
    /**
     * Selects specified columns from the data source.
     * @param  {string|string[]} fieldNames - Defines the collection of column fields.
     */
    select(fieldNames: string | string[]): Query;
    /**
     * Gets the records in hierarchical relationship from two tables. It requires the foreign key to relate two tables.
     * @param  {Query} query - Defines the query to relate two tables.
     * @param  {Function} selectorFn - Defines the custom function to select records.
     */
    hierarchy(query: Query, selectorFn: Function): Query;
    /**
     * Sets the foreign key which is used to get data from the related table.
     * @param  {string} key - Defines the foreign key.
     */
    foreignKey(key: string): Query;
    /**
     * It is used to get total number of records in the DataManager execution result.
     */
    requiresCount(): Query;
    /**
     * Aggregate the data with given type and field name.
     * @param  {string} type - Defines the aggregate type.
     * @param  {string} field - Defines the column field to aggregate.
     */
    aggregate(type: string, field: string): Query;
    /**
     * Pass array of filterColumn query for performing filter operation.
     * @param  {QueryOptions[]} queries
     * @param  {string} name
     * @hidden
     */
    static filterQueries(queries: QueryOptions[], name: string): QueryOptions[];
    /**
     * To get the list of queries which is already filtered in current data source.
     * @param  {Object[]} queries
     * @param  {string[]} singles
     * @hidden
     */
    static filterQueryLists(queries: Object[], singles: string[]): Object;
}
/**
 * Predicate class is used to generate complex filter criteria.
 * This will be used by DataManager to perform multiple filtering operation.
 */
export  class Predicate {
    /** @hidden */
    field: string;
    /** @hidden */
    operator: string;
    /** @hidden */
    value: string | number | Date | boolean | Predicate | Predicate[];
    /** @hidden */
    condition: string;
    /** @hidden */
    ignoreCase: boolean;
    /** @hidden */
    ignoreAccent: boolean;
    /** @hidden */
    isComplex: boolean;
    /** @hidden */
    predicates: Predicate[];
    /** @hidden */
    comparer: Function;
    [x: string]: string | number | Date | boolean | Predicate | Predicate[] | Function;
    /**
     * Constructor for Predicate class.
     * @param  {string|Predicate} field
     * @param  {string} operator
     * @param  {string|number|boolean|Predicate|Predicate[]} value
     * @param  {boolean=false} ignoreCase
     * @hidden
     */
    constructor(field: string | Predicate, operator: string, value: string | number | Date | boolean | Predicate | Predicate[], ignoreCase?: boolean, ignoreAccent?: boolean);
    /**
     * Adds n-number of new predicates on existing predicate with “and” condition.
     * @param  {Object[]} args - Defines the collection of predicates.
     */
    static and(...args: Object[]): Predicate;
    /**
     * Adds new predicate on existing predicate with “and” condition.
     * @param  {string} field - Defines the column field.
     * @param  {string} operator - Defines the operator how to filter data.
     * @param  {string} value - Defines the values to match with data.
     * @param  {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else
     * filter data with case insensitive.
     */
    and(field: string | Predicate, operator?: string, value?: string | number, ignoreCase?: boolean, ignoreAccent?: boolean): Predicate;
    /**
     * Adds n-number of new predicates on existing predicate with “or” condition.
     * @param  {Object[]} args - Defines the collection of predicates.
     */
    static or(...args: Object[]): Predicate;
    /**
     * Adds new predicate on existing predicate with “or” condition.
     * @param  {string} field - Defines the column field.
     * @param  {string} operator - Defines the operator how to filter data.
     * @param  {string} value - Defines the values to match with data.
     * @param  {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else
     * filter data with case insensitive.
     */
    or(field: string | Predicate, operator?: string, value?: string | number, ignoreCase?: boolean, ignoreAccent?: boolean): Predicate;
    /**
     * Converts plain JavaScript object to Predicate object.
     * @param  {Predicate[]|Predicate} json - Defines single or collection of Predicate.
     */
    static fromJson(json: Predicate[] | Predicate): Predicate[];
    /**
     * Validate the record based on the predicates.
     * @param  {Object} record - Defines the datasource record.
     */
    validate(record: Object): boolean;
    /**
     * Converts predicates to plain JavaScript.
     * This method is uses Json stringify when serializing Predicate object.
     */
    toJson(): Object;
    private static combinePredicates(predicates, operator);
    private static combine(pred, field, operator, value, condition, ignoreCase?, ignoreAccent?);
    private static fromJSONData(json);
}
/**
 * @hidden
 */
export interface QueryOptions {
    fn?: string;
    e?: QueryOptions;
    fieldNames?: string | string[];
    operator?: string;
    searchKey?: string | number | boolean;
    ignoreCase?: boolean;
    ignoreAccent?: boolean;
    comparer?: string | Function;
    format?: string | base.NumberFormatOptions | base.DateFormatOptions;
    direction?: string;
    pageIndex?: number;
    pageSize?: number;
    start?: number;
    end?: number;
    nos?: number;
    field?: string;
    fieldName?: string;
    type?: Object;
    name?: string | string[];
    filter?: Object;
    key?: string;
    value?: string | number | Date | boolean | Predicate | Predicate[];
    isComplex?: boolean;
    predicates?: Predicate[];
    condition?: string;
}
/**
 * @hidden
 */
export interface QueryList {
    onSelect?: QueryOptions;
    onPage?: QueryOptions;
    onSkip?: QueryOptions;
    onTake?: QueryOptions;
    onRange?: QueryOptions;
}
/**
 * @hidden
 */
export interface ParamOption {
    key: string;
    value?: string;
    fn?: Function;
}
/**
 * Data manager common utility methods.
 * @hidden
 */
export  class DataUtil {
    /**
     * Specifies the value which will be used to adjust the date value to server timezone.
     * @default null
     */
    static serverTimezoneOffset: number;
    /**
     * Returns the value by invoking the provided parameter function.
     * If the paramater is not of type function then it will be returned as it is.
     * @param  {Function|string|string[]|number} value
     * @param  {Object} inst?
     * @hidden
     */
    static getValue<T>(value: T | Function, inst?: Object): T;
    /**
     * Returns true if the input string ends with given string.
     * @param  {string} input
     * @param  {string} substr
     */
    static endsWith(input: string, substr: string): boolean;
    /**
     * Returns true if the input string starts with given string.
     * @param  {string} str
     * @param  {string} startstr
     */
    static startsWith(input: string, start: string): boolean;
    /**
     * To return the sorting function based on the string.
     * @param  {string} order
     * @hidden
     */
    static fnSort(order: string): Function;
    /**
     * Comparer function which is used to sort the data in ascending order.
     * @param  {string|number} x
     * @param  {string|number} y
     * @returns number
     */
    static fnAscending(x: string | number, y: string | number): number;
    /**
     * Comparer function which is used to sort the data in descending order.
     * @param  {string|number} x
     * @param  {string|number} y
     * @returns number
     */
    static fnDescending(x: string | number, y: string | number): number;
    private static extractFields(obj, fields);
    /**
     * Select objects by given fields from jsonArray.
     * @param  {Object[]} jsonArray
     * @param  {string[]} fields
     */
    static select(jsonArray: Object[], fields: string[]): Object[];
    /**
     * Group the input data based on the field name.
     * It also performs aggregation of the grouped records based on the aggregates paramater.
     * @param  {Object[]} jsonArray
     * @param  {string} field?
     * @param  {Object[]} agg?
     * @param  {number} level?
     * @param  {Object[]} groupDs?
     */
    static group(jsonArray: Object[], field?: string, aggregates?: Object[], level?: number, groupDs?: Object[], format?: Function): Object[];
    /**
     * It is used to categorize the multiple items based on a specific field in jsonArray.
     * The hierarchical queries are commonly required when you use foreign key binding.
     * @param  {string} fKey
     * @param  {string} from
     * @param  {Object[]} source
     * @param  {Group} lookup?
     * @param  {string} pKey?
     * @hidden
     */
    static buildHierarchy(fKey: string, from: string, source: Group, lookup?: Group, pKey?: string): void;
    /**
     * Throw error with the given string as message.
     * @param  {string} er
     */
    static throwError: Function;
    static aggregates: Aggregates;
    /**
     * The method used to get the field names which started with specified characters.
     * @param  {Object} obj
     * @param  {string[]} fields?
     * @param  {string} prefix?
     * @hidden
     */
    static getFieldList(obj: Object, fields?: string[], prefix?: string): string[];
    /**
     * Gets the value of the property in the given object.
     * The complex object can be accessed by providing the field names concatenated with dot(.).
     * @param  {string} nameSpace - The name of the property to be accessed.
     * @param  {Object} from - Defines the source object.
     */
    static getObject(nameSpace: string, from: Object): Object;
    /**
     * To set value for the nameSpace in desired object.
     * @param {string} nameSpace - String value to the get the inner object.
     * @param {Object} value - Value that you need to set.
     * @param {Object} obj - Object to get the inner object value.
     * @return { [key: string]: Object; } | Object
     * @hidden
     */
    static setValue(nameSpace: string, value: Object, obj: Object): {
        [key: string]: Object;
    } | Object;
    /**
     * Sort the given data based on the field and comparer.
     * @param  {Object[]} ds - Defines the input data.
     * @param  {string} field - Defines the field to be sorted.
     * @param  {Function} comparer - Defines the comparer function used to sort the records.
     */
    static sort(ds: Object[], field: string, comparer: Function): Object[];
    static ignoreDiacritics(value: string | number | boolean): string | Object;
    private static merge(left, right, fieldName, comparer);
    private static getVal(array, index, field?);
    private static toLowerCase(val);
    /**
     * Specifies the Object with filter operators.
     */
    static operatorSymbols: {
        [key: string]: string;
    };
    /**
     * Specifies the Object with filter operators which will be used for OData filter query generation.
     * * It will be used for date/number type filter query.
     */
    static odBiOperator: {
        [key: string]: string;
    };
    /**
     * Specifies the Object with filter operators which will be used for OData filter query generation.
     * It will be used for string type filter query.
     */
    static odUniOperator: {
        [key: string]: string;
    };
    /**
     * Specifies the Object with filter operators which will be used for ODataV4 filter query generation.
     * It will be used for string type filter query.
     */
    static odv4UniOperator: {
        [key: string]: string;
    };
    static diacritics: {
        [key: string]: string;
    };
    static fnOperators: Operators;
    /**
     * To perform the filter operation with specified adaptor and returns the result.
     * @param  {Object} adaptor
     * @param  {string} fnName
     * @param  {Object} param1?
     * @param  {Object} param2?
     * @hidden
     */
    static callAdaptorFunction(adaptor: Object, fnName: string, param1?: Object, param2?: Object): Object;
    /**
     * To perform the parse operation on JSON data, like convert to string from JSON or convert to JSON from string.
     */
    static parse: ParseOption;
    /**
     * Checks wheather the given input is a plain object or not.
     * @param  {Object|Object[]} obj
     */
    static isPlainObject(obj: Object | Object[]): boolean;
    /**
     * Returns true when the browser cross origin request.
     */
    static isCors(): boolean;
    /**
     * Generate random GUID value which will be prefixed with the given value.
     * @param  {string} prefix
     */
    static getGuid(prefix: string): string;
    /**
     * Checks wheather the given value is null or not.
     * @param  {string|Object} val
     * @returns boolean
     */
    static isNull(val: string | Object): boolean;
    /**
     * To get the required items from collection of objects.
     * @param  {Object[]} array
     * @param  {string} field
     * @param  {Function} comparer
     * @returns Object
     * @hidden
     */
    static getItemFromComparer(array: Object[], field: string, comparer: Function): Object;
    /**
     * To get distinct values of Array or Array of Objects.
     * @param  {Object[]} json
     * @param  {string} field
     * @param  {boolean} requiresCompleteRecord
     * @returns Object[]
     * * distinct array of objects is return when requiresCompleteRecord set as true.
     * @hidden
     */
    static distinct(json: Object[], fieldName: string, requiresCompleteRecord?: boolean): Object[];
    /**
     * @hidden
     */
    static dateParse: DateParseOption;
}
/**
 * @hidden
 */
export interface Aggregates {
    sum?: Function;
    average?: Function;
    min?: Function;
    max?: Function;
    truecount?: Function;
    falsecount?: Function;
    count?: Function;
    type?: string;
    field?: string;
}
/**
 * @hidden
 */
export interface Operators {
    equal?: Function;
    notequal?: Function;
    lessthan?: Function;
    greaterthan?: Function;
    lessthanorequal?: Function;
    greaterthanorequal?: Function;
    contains?: Function;
    notnull?: Function;
    isnull?: Function;
    startswith?: Function;
    endswith?: Function;
    processSymbols?: Function;
    processOperator?: Function;
}
/**
 * @hidden
 */
export interface Group {
    GroupGuid?: string;
    level?: number;
    childLevels?: number;
    records?: Object[];
    key?: string;
    count?: number;
    items?: Object[];
    aggregates?: Object;
    field?: string;
    result?: Object;
}
/**
 * @hidden
 */
export interface ParseOption {
    parseJson?: Function;
    iterateAndReviveArray?: Function;
    iterateAndReviveJson?: Function;
    jsonReviver?: (key: string, value: Object) => Object;
    isJson?: Function;
    isGuid?: Function;
    replacer?: Function;
    jsonReplacer?: Function;
    arrayReplacer?: Function;
}
/**
 * @hidden
 */
export interface DateParseOption {
    addSelfOffset?: (input: Date) => Date;
    toUTC?: (input: Date) => Date;
    toTimeZone?: (input: Date, offset?: number, utc?: boolean) => Date;
}
 }
export namespace diagrams { 

/**
 * Interface for a class Thickness
 */
export interface ThicknessModel {
}
/**
 * Interface for a class Margin
 */
export interface MarginModel {
    /**
     * Sets the space to be left from the left side of the immediate parent of an element
     * @default 0
     */
    left?: number;
    /**
     * Sets the space to be left from the right side of the immediate parent of an element
     * @default ''
     */
    right?: number;
    /**
     * Sets the space to be left from the top side of the immediate parent of an element
     * @default ''
     */
    top?: number;
    /**
     * Sets the space to be left from the bottom side of the immediate parent of an element
     * @default ''
     */
    bottom?: number;
}
/**
 * Interface for a class Shadow
 */
export interface ShadowModel {
    /**
     * Defines the angle of Shadow
     * @default 45
     */
    angle?: number;
    /**
     * Defines the distance of Shadow
     * @default 5
     */
    distance?: number;
    /**
     * Defines the opacity of Shadow
     * @default 0.7
     */
    opacity?: number;
    /**
     * Defines the color of Shadow
     */
    color?: string;
}
/**
 * Interface for a class Stop
 */
export interface StopModel {
    /**
     * Defines the color of stop 
     * @default ''
     */
    color?: string;
    /**
     * Defines the offset of stop
     * @default 0
     */
    offset?: number;
    /**
     * Defines the opacity of stop
     * @default 1
     */
    opacity?: number;
}
/**
 * Interface for a class Gradient
 */
export interface GradientModel {
    /**
     * Defines the stop collection of gradient
     * @default undefined
     */
    stops?: StopModel[];
    /**
     * Defines the type of gradient
     * @default GradientType.Linear
     */
    type?: GradientType;
    /**
     * Defines the id of gradient
     * @default ''
     */
    id?: string;
}
/**
 * Interface for a class LinearGradient
 */
export interface LinearGradientModel extends GradientModel{
    /**
     * Defines the x1 value of linear gradient
     * @default 0
     */
    x1?: number;
    /**
     * Defines the x2 value of linear gradient
     * @default 0
     */
    x2?: number;
    /**
     * Defines the y1 value of linear gradient
     * @default 0
     */
    y1?: number;
    /**
     * Defines the y2 value of linear gradient
     * @default 0
     */
    y2?: number;
}
/**
 * Interface for a class RadialGradient
 */
export interface RadialGradientModel extends GradientModel{
    /**
     * Defines the cx value of radial gradient
     * @default cx
     */
    cx?: number;
    /**
     * Defines the cy value of radial gradient
     * @default cy
     */
    cy?: number;
    /**
     * Defines the fx value of radial gradient
     * @default fx
     */
    fx?: number;
    /**
     * Defines the fy value of radial gradient
     * @default fy
     */
    fy?: number;
    /**
     * Defines the r value of radial gradient
     * @default r
     */
    r?: number;
}
/**
 * Interface for a class ShapeStyle
 */
export interface ShapeStyleModel {
    /**
     * Sets the fill color of a shape/path
     * @default ''
     */
    fill?: string;
    /**
     * Sets the stroke color of a shape/path
     * @default ''
     */
    strokeColor?: string;
    /**
     * Defines the pattern of dashes and spaces to stroke the path/shape
     * @default ''
     */
    strokeDashArray?: string;
    /**
     * Defines the stroke width of the path/shape
     * @default ''
     */
    strokeWidth?: number;
    /**
     * Sets the opacity of a shape/path
     * @default ''
     */
    opacity?: number;
    /**
     * Defines the gradient of a shape/path
     * @default null
     */
    gradient?: GradientModel | LinearGradientModel | RadialGradientModel;
}
/**
 * Interface for a class StrokeStyle
 */
export interface StrokeStyleModel extends ShapeStyleModel{
    /**
     * Sets the fill color of a shape/path
     * @default ''
     */
    fill?: string;
}
/**
 * Interface for a class TextStyle
 */
export interface TextStyleModel extends ShapeStyleModel{
    /**
     * Sets the font color of a text
     * @default 'black'
     */
    color?: string;
    /**
     * Sets the font type of a text
     * @default 'Arial'
     */
    fontFamily?: string;
    /**
     * Defines the font size of a text
     * @default 12
     */
    fontSize?: number;
    /**
     * Enables/disables the italic style of text
     * @default false
     */
    italic?: boolean;
    /**
     * Enables/disables the bold style of text
     * @default false
     */
    bold?: boolean;
    /**
     * Defines how the white space and new line characters have to be handled
     * @default WhiteSpace.PreLine
     */
    whiteSpace?: WhiteSpace;
    /**
     * Defines how the text should be wrapped, when the text size exceeds some specific bounds
     * @default  WordBreak.KeepAll
     */
    textWrapping?: TextWrap;
    /**
     * Defines how the text should be aligned within its bounds
     * @default TextAlign.Center
     */
    textAlign?: TextAlign;
    /**
     * Defines how the text should be decorated. For example, with underline/over line
     * @default TextDecoration.None
     */
    textDecoration?: TextDecoration;
    /**
     * Defines how to handle the text when it exceeds the given size.
     * @default TextOverflow.Wrap
     */
    textOverflow?: TextOverflow;
}
/**
 * Layout Model module defines the styles and types to arrange objects in containers
 */
export  class Thickness {
    left: number;
    right: number;
    top: number;
    bottom: number;
    constructor(left: number, right: number, top: number, bottom: number);
}
/**
 * Defines the space to be left between an object and its immediate parent
 */
export  class Margin extends base.ChildProperty<Margin> {
    /**
     * Sets the space to be left from the left side of the immediate parent of an element
     * @default 0
     */
    left: number;
    /**
     * Sets the space to be left from the right side of the immediate parent of an element
     * @default ''
     */
    right: number;
    /**
     * Sets the space to be left from the top side of the immediate parent of an element
     * @default ''
     */
    top: number;
    /**
     * Sets the space to be left from the bottom side of the immediate parent of an element
     * @default ''
     */
    bottom: number;
}
/**
 * Defines the Shadow appearance of the objects
 */
export  class Shadow extends base.ChildProperty<Shadow> {
    /**
     * Defines the angle of Shadow
     * @default 45
     */
    angle: number;
    /**
     * Defines the distance of Shadow
     * @default 5
     */
    distance: number;
    /**
     * Defines the opacity of Shadow
     * @default 0.7
     */
    opacity: number;
    /**
     * Defines the color of Shadow
     */
    color: string;
}
/**
 * Defines the stop of gradient
 */
export  class Stop extends base.ChildProperty<Stop> {
    /**
     * Defines the color of stop
     * @default ''
     */
    color: string;
    /**
     * Defines the offset of stop
     * @default 0
     */
    offset: number;
    /**
     * Defines the opacity of stop
     * @default 1
     */
    opacity: number;
}
/**
 * Defines the gradient of styles
 */
export  class Gradient extends base.ChildProperty<Gradient> {
    /**
     * Defines the stop collection of gradient
     * @default undefined
     */
    stops: StopModel[];
    /**
     * Defines the type of gradient
     * @default GradientType.Linear
     */
    type: GradientType;
    /**
     * Defines the id of gradient
     * @default ''
     */
    id: string;
}
/**
 * Defines the linear gradient of styles
 */
export  class LinearGradient extends Gradient {
    /**
     * Defines the x1 value of linear gradient
     * @default 0
     */
    x1: number;
    /**
     * Defines the x2 value of linear gradient
     * @default 0
     */
    x2: number;
    /**
     * Defines the y1 value of linear gradient
     * @default 0
     */
    y1: number;
    /**
     * Defines the y2 value of linear gradient
     * @default 0
     */
    y2: number;
}
/**
 * Defines the radial gradient of styles
 */
export  class RadialGradient extends Gradient {
    /**
     * Defines the cx value of radial gradient
     * @default cx
     */
    cx: number;
    /**
     * Defines the cy value of radial gradient
     * @default cy
     */
    cy: number;
    /**
     * Defines the fx value of radial gradient
     * @default fx
     */
    fx: number;
    /**
     * Defines the fy value of radial gradient
     * @default fy
     */
    fy: number;
    /**
     * Defines the r value of radial gradient
     * @default r
     */
    r: number;
}
/**
 * Defines the style of shape/path
 */
export  class ShapeStyle extends base.ChildProperty<ShapeStyle> {
    /**
     * Sets the fill color of a shape/path
     * @default ''
     */
    fill: string;
    /**
     * Sets the stroke color of a shape/path
     * @default ''
     */
    strokeColor: string;
    /**
     * Defines the pattern of dashes and spaces to stroke the path/shape
     * @default ''
     */
    strokeDashArray: string;
    /**
     * Defines the stroke width of the path/shape
     * @default ''
     */
    strokeWidth: number;
    /**
     * Sets the opacity of a shape/path
     * @default ''
     */
    opacity: number;
    /**
     * Defines the gradient of a shape/path
     * @default null
     */
    gradient: GradientModel | LinearGradientModel | RadialGradientModel;
}
/**
 * Defines the stroke style of a path
 */
export  class StrokeStyle extends ShapeStyle {
    /**
     * Sets the fill color of a shape/path
     * @default ''
     */
    fill: string;
}
/**
 * Defines the appearance of text
 */
export  class TextStyle extends ShapeStyle {
    /**
     * Sets the font color of a text
     * @default 'black'
     */
    color: string;
    /**
     * Sets the font type of a text
     * @default 'Arial'
     */
    fontFamily: string;
    /**
     * Defines the font size of a text
     * @default 12
     */
    fontSize: number;
    /**
     * Enables/disables the italic style of text
     * @default false
     */
    italic: boolean;
    /**
     * Enables/disables the bold style of text
     * @default false
     */
    bold: boolean;
    /**
     * Defines how the white space and new line characters have to be handled
     * @default WhiteSpace.PreLine
     */
    whiteSpace: WhiteSpace;
    /**
     * Defines how the text should be wrapped, when the text size exceeds some specific bounds
     * @default  WordBreak.KeepAll
     */
    textWrapping: TextWrap;
    /**
     * Defines how the text should be aligned within its bounds
     * @default TextAlign.Center
     */
    textAlign: TextAlign;
    /**
     * Defines how the text should be decorated. For example, with underline/over line
     * @default TextDecoration.None
     */
    textDecoration: TextDecoration;
    /**
     * Defines how to handle the text when it exceeds the given size.
     * @default TextOverflow.Wrap
     */
    textOverflow: TextOverflow;
}
/**
 * Canvas module is used to define a plane(canvas) and to arrange the children based on margin
 */
export  class Canvas extends Container {
    /**
     * Measures the minimum space that the canvas requires
     * @param availableSize
     */
    measure(availableSize: Size): Size;
    /**
     * Arranges the child elements of the canvas
     */
    arrange(desiredSize: Size): Size;
    /**
     * Aligns the child element based on its parent
     * @param child
     * @param childSize
     * @param parentSize
     * @param x
     * @param y
     */
    private alignChildBasedOnParent(child, childSize, parentSize, x, y);
    /**
     * Aligns the child elements based on a point
     * @param child
     * @param x
     * @param y
     */
    private alignChildBasedOnaPoint(child, x, y);
}
/**
 * Container module is used to group related objects
 */
export  class Container extends DiagramElement {
    /**
     * Gets/Sets the space between the container and its immediate children
     */
    padding: Thickness;
    /**
     * Gets/Sets the collection of child elements
     */
    children: DiagramElement[];
    private desiredBounds;
    affectChildren: boolean;
    /**
     * returns whether the container has child elements or not
     */
    hasChildren(): boolean;
    prevRotateAngle: number;
    /**
     * Measures the minimum space that the container requires
     *
     * @param availableSize
     */
    measure(availableSize: Size): Size;
    /**
     * Arranges the container and its children
     * @param desiredSize
     */
    arrange(desiredSize: Size): Size;
    /**
     * Stretches the child elements based on the size of the container
     * @param size
     */
    protected stretchChildren(size: Size): void;
    /**
     * Considers the padding of the element when measuring its desired size
     * @param size
     */
    protected applyPadding(size: Size): void;
    /**
     * Finds the offset of the child element with respect to the container
     * @param child
     * @param center
     */
    protected findChildOffsetFromCenter(child: DiagramElement, center: PointModel): void;
    private GetChildrenBounds(child);
}
/**
 * StackPanel module is used to arrange its children in a line
 */
export  class StackPanel extends Container {
    /**
     * Gets/Sets the orientation of the stack panel
     */
    orientation: Orientation;
    /**
     * Measures the minimum space that the panel needs
     * @param availableSize
     */
    measure(availableSize: Size): Size;
    /**
     * Arranges the child elements of the stack panel
     * @param desiredSize
     */
    arrange(desiredSize: Size): Size;
    /**
     * Measures the minimum space that the panel needs
     * @param availableSize
     */
    private measureStackPanel(availableSize, updateSize);
    private arrangeStackPanel(desiredSize, updatePosition);
    private updateHorizontalStack(child, parent);
    private updateVerticalStack(child, parent);
    private arrangeHorizontalStack(x, y, child, parent, parenBounds, childBounds);
    private arrangeVerticalStack(x, y, child, parent, parentSize, childSize);
    protected stretchChildren(size: Size): void;
    private applyChildMargin(child, size);
}
/**
 * DiagramElement module defines the basic unit of diagram
 */
export  class DiagramElement {
    /**
     * Sets the unique id of the element
     */
    id: string;
    /**
     * Sets/Gets the reference point of the element
     */
    pivot: PointModel;
    /**
     * Sets or gets whether the content of the element needs to be measured
     */
    protected isDirt: boolean;
    /**
     * Sets or gets whether the content of the element to be visible
     */
    visible: boolean;
    /**
     * Sets/Gets the x-coordinate of the element
     */
    offsetX: number;
    /**
     * Sets/Gets the y-coordinate of the element
     */
    offsetY: number;
    /**
     * Set the corner of the element
     */
    cornerRadius: number;
    /**
     * Sets/Gets the minimum height of the element
     */
    minHeight: number;
    /**
     * Sets/Gets the minimum width of the element
     */
    minWidth: number;
    /**
     * Sets/Gets the maximum width of the element
     */
    maxWidth: number;
    /**
     * Sets/Gets the maximum height of the element
     */
    maxHeight: number;
    /**
     * Sets/Gets the width of the element
     */
    width: number;
    /**
     * Sets/Gets the height of the element
     */
    height: number;
    /**
     * Sets/Gets the rotate angle of the element
     */
    rotateAngle: number;
    /**
     * Sets/Gets the margin of the element
     */
    margin: MarginModel;
    /**
     * Sets/Gets how the element has to be horizontally arranged with respect to its immediate parent
     */
    horizontalAlignment: HorizontalAlignment;
    /**
     * Sets/Gets how the element has to be vertically arranged with respect to its immediate parent
     */
    verticalAlignment: VerticalAlignment;
    /**
     * Sets whether the element has to be aligned with respect to a point/with respect to its immediate parent
     */
    relativeMode: RelativeMode;
    /**
     * Sets whether the element has to be transformed based on its parent or not
     */
    transform: Transform;
    /**
     * Sets the style of the element
     */
    style: ShapeStyleModel;
    parentId: string;
    /**
     * Gets the minimum size that is required by the element
     */
    desiredSize: Size;
    /**
     * Gets the size that the element will be rendered
     */
    actualSize: Size;
    /**
     * Gets the rotate angle that is set to the immediate parent of the element
     */
    parentTransform: number;
    isSvgRender: boolean;
    /**
     * Gets/Sets the boundary of the element
     */
    bounds: Rect;
    /**
     * Gets/Sets the corners of the rectangular bounds
     */
    corners: Rect;
    /**
     * Defines the appearance of the shadow of the element
     */
    shadow: ShadowModel;
    /**
     * Sets the offset of the element with respect to its parent
     * @param x
     * @param y
     * @param mode
     */
    setOffsetWithRespectToBounds(x: number, y: number, mode: UnitMode): void;
    /**
     * Gets the position of the element with respect to its parent
     * @param size
     */
    getAbsolutePosition(size: Size): PointModel;
    private position;
    private unitMode;
    float: boolean;
    outerBounds: Rect;
    private floatingBounds;
    /**
     * Measures the minimum space that the element requires
     * @param availableSize
     */
    measure(availableSize: Size): Size;
    /**
     * Arranges the element
     * @param desiredSize
     */
    arrange(desiredSize: Size): Size;
    /**
     * Updates the bounds of the element
     */
    updateBounds(): void;
    /**
     * Validates the size of the element with respect to its minimum and maximum size
     * @param desiredSize
     * @param availableSize
     */
    protected validateDesiredSize(desiredSize: Size, availableSize: Size): Size;
}
/**
 * ImageElement defines a basic image elements
 */
export  class ImageElement extends DiagramElement {
    /**
     * sets or gets the image source
     */
    private imageSource;
    source: string;
    /**
     * sets scaling factor of the image
     */
    imageScale: Scale;
    /**
     * sets the alignment of the image
     */
    imageAlign: ImageAlignment;
    /**
     * Sets how to stretch the image
     */
    stretch: Stretch;
    /**
     * Saves the actual size of the image
     */
    contentSize: Size;
    /**
     * Measures minimum space that is required to render the image
     * @param availableSize
     */
    measure(availableSize: Size): Size;
    /**
     * Arranges the image
     * @param desiredSize
     */
    arrange(desiredSize: Size): Size;
}
/**
 * NativeElement defines the basic native elements
 */
export  class NativeElement extends DiagramElement {
    private data;
    /**
     * Gets or sets the geometry of the native element
     */
    content: string;
    /**
     * defines geometry of the native element
     * @private
     */
    template: SVGElement;
    private getNativeContent();
    /**
     * sets scaling factor of the Native Element
     */
    scale: Stretch;
    /**
     * Saves the actual size of the Native Element
     * @private
     */
    contentSize: Size;
    /**
     * Saves the top left point of the Native Element
     * @private
     */
    templatePosition: PointModel;
    /**
     * Measures minimum space that is required to render the Native Element
     * @param availableSize
     */
    measure(availableSize: Size): Size;
    /**
     * Arranges the Native Element
     * @param desiredSize
     */
    arrange(desiredSize: Size): Size;
}
/**
 * PathElement takes care of how to align the path based on offsetX and offsetY
 */
export  class PathElement extends DiagramElement {
    /**
     * Gets or sets the geometry of the path element
     */
    private pathData;
    data: string;
    /**
     * Gets/Sets whether the path has to be transformed to fit the given x,y, width, height
     */
    transformPath: boolean;
    /**
     * Gets/Sets the equivalent path, that will have the origin as 0,0
     */
    absolutePath: string;
    absoluteBounds: Rect;
    /**
     * Measures the minimum space that is required to render the element
     * @param availableSize
     */
    measure(availableSize: Size): Size;
    /**
     * Arranges the path element
     * @param desiredSize
     */
    arrange(desiredSize: Size): Size;
    /**
     * Translates the path to 0,0 and scales the path based on the actual size
     * @param pathData
     * @param bounds
     * @param actualSize
     */
    updatePath(pathData: string, bounds: Rect, actualSize: Size): string;
}
/**
 * TextElement is used to display text/annotations
 */
export  class TextElement extends DiagramElement {
    /**
     * sets or gets the image source
     */
    private textContent;
    hyperLink: HyperLinkModel;
    content: string;
    /**
     * Defines the appearance of the text element
     */
    style: TextStyleModel;
    /**
     * Measures the minimum size that is required for the text element
     * @param availableSize
     */
    measure(availableSize: Size): Size;
    /**
     * Arranges the text element
     * @param desiredSize
     */
    arrange(desiredSize: Size): Size;
}
/**
 * data source defines the basic unit of diagram
 */
export  class DataSourceSettings {
    /**
     * Constructor for the data binding module.
     * @private
     */
    constructor();
    /**
     * To destroy the data binding module
     * @return {void}
     * @private
     */
    destroy(): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    dataTable: object;
    /**
     * Initialize nodes and connectors when we have a data as JSON
     * @param data
     * @param diagram
     * @private
     */
    initData(data: DataSourceModel, diagram: Diagram): void;
    /**
     * Initialize nodes and connector when we have a data as remote url
     * @param data
     * @param diagram
     * @private
     */
    initSource(data: DataSourceModel, diagram: Diagram): void;
    private applyDataSource(mapper, data, diagram);
    /**
     * updateMultipleRootNodes method is used  to update the multiple Root Nodes
     * @param object
     * @param rootnodes
     * @param mapper
     * @param data
     */
    private updateMultipleRootNodes(obj, rootNodes, mapper, data);
    /**
     * Get the node values
     * @param mapper
     * @param item
     * @param diagram
     */
    private applyNodeTemplate(mapper, item, diagram);
    private renderChildNodes(mapper, parent, value, rtNodes, diagram);
    private containsConnector(diagram, sourceNode, targetNode);
    /**
     *  collectionContains method is used to  check wthear the node is already present in collection or not
     * @param node
     * @param diagram
     * @param id
     * @param parentId
     */
    private collectionContains(node, diagram, id, parentId);
    /**
     * Get the Connector values
     * @param sourceNode
     * @param targetNode
     * @param diagram
     */
    private applyConnectorTemplate(sNode, tNode, diagram);
}
/**
 * Interface for a class Diagram
 */
export interface DiagramModel extends base.ComponentModel{
    /**
     * Defines the width of the diagram model.
     * @default undefined
     */
    width?: string | number;
    /**
     * Defines the diagram rendering mode.
     * @default base.Canvas
     */
    mode?: RenderingMode;
    /**
     * Defines the height of the diagram model.
     * @default undefined
     */
    height?: string | number;
    /**
     * Enable auto scroll for diagram
     * @default false
     */
    canAutoScroll?: boolean;
    /**
     * Defines the context menu
     */
    showContextMenu?: boolean;
    /**
     * Show only custom context menu
     */
    showCustomContextMenuOnly?: boolean;
    /**
     * Define the context menu items
     */
    customContextMenuItems?: ContextMenuItemModel[];
    /**
     * Defines the diagram constraints
     */
    constraints?: DiagramConstraints;
    /**
     * Defines the precedence of the interactive tools
     */
    tool?: DiagramTools;
    /**
     * Defines the bridge direction of diagram connectors
     * @default top
     */
    bridgeDirection?: BridgeDirection;
    /**
     * Defines the background color of the diagram
     * @default transparent
     */
    backgroundColor?: String;
    /**
     * Defines the snap settings of diagram
     */
    snapSettings?: SnapSettingsModel;
    /**
     * Defines the ruler settings of diagram
     */
    rulerSettings?: RulerSettingsModel;
    /**
     * Defines the page settings of the diagram
     */
    pageSettings?: PageSettingsModel;
    /**
     * Defines the collection of nodes - change diagram element as node
     * @default undefined
     */
    nodes?: NodeModel[] | GroupModel[];
    /**
     * Define the draw type of diagram
     */
    drawingObject?: NodeModel | ConnectorModel;
    /**
     * Defines the collection of connectors
     * @default ''
     */
    connectors?: ConnectorModel[];
    /**
     * basic elements
     */
    basicElements?: DiagramElement[];
    /**
     * defines the base.Tooltip for the diagram
     * @default new base.DiagramTooltip()
     */
    tooltip?: DiagramTooltipModel;
    /**
     * Configure data source for diagram
     */
    dataSourceSettings?: DataSourceModel;
    /**
     * Allows the user to save custom information/data about diagram
     */
    addInfo?: object;
    /**
     * Binds the custom JSON fields with node
     */
    getNodeDefaults?: Function;
    /**
     * Helps to returns the last segment direction of connectors
     */
    getConnectorDefaults?: Function;
    /**
     * Allows to set the node template
     */
    setNodeTemplate?: Function;
    /**
     * Allows to get the custom properties that have to be serialized
     */
    getCustomProperty?: Function;
    /**
     * Defines the collection of selected items and size and position of the selector
     */
    selectedItems?: SelectorModel;
    /**
     * Defines how the diagram has to arrange the nodes
     */
    layout?: LayoutModel;
    /**
     * Defines a set of custom commands and binds them with a set of desired key gestures
     */
    commandManager?: CommandManagerModel;
    /**
     * Triggers after diagram is populated.
     * @event
     */
    dataLoaded?: base.EmitType<IDataLoadedEventArgs>;
    /**
     * Triggers once the property changed.
     * @event
     */
    selectionChange?: base.EmitType<ISelectionChangeEventArgs>;
    /**
     * Triggers once the resize property changed.
     * @event
     */
    sizeChange?: base.EmitType<ISizeChangeEventArgs>;
    /**
     * Triggers once the connection changed.
     * @event
     */
    connectionChange?: base.EmitType<IConnectionChangeEventArgs>;
    /**
     * Triggers once the resize property changed.
     * @event
     */
    sourcePointChange?: base.EmitType<IEndChangeEventArgs>;
    /**
     * Triggers once the resize property changed.
     * @event
     */
    targetPointChange?: base.EmitType<IEndChangeEventArgs>;
    /**
     * Triggers once the node or connector  property changed.
     * @event
     */
    propertyChange?: base.EmitType<IPropertyChangeEventArgs>;
    /**
     * Triggers once the dragging is happening.
     * @event
     */
    positionChange?: base.EmitType<IDraggingEventArgs>;
    /**
     * Triggers once the animation has done
     * @event
     */
    animationComplete?: base.EmitType<Object>;
    /**
     * Triggers once the rotate property changed.
     * @event
     */
    rotateChange?: base.EmitType<IRotationEventArgs>;
    /**
     * Triggers once the diagram object is added or removed property changed.
     * @event
     */
    collectionChange?: base.EmitType<ICollectionChangeEventArgs>;
    /**
     * Triggers after render the diagram elements
     * @event
     */
    created?: base.EmitType<Object>;
    /**
     * Triggers before context menu opens.
     * @event
     */
    contextMenuOpen?: base.EmitType<any>;
    /**
     * Triggers when click on context menu.
     * @event
     */
    contextMenuClick?: base.EmitType<any>;
    /**
     * Defines layers of the diagram
     * @default ''
     */
    layers?: LayerModel[];
    /**
     * Triggers when dropped.
     * @event
     */
    drop?: base.EmitType<IDropEventArgs>;
}
/**
 * Diagram control
 * ```
 * <div id='diagram'/>
 * <script>
 *   var diagramObj = new Diagram({ width:'1000px', height:'500px' });
 *   diagramObj.appendTo('#diagram');
 * </script>
 * ```
 */
export  class Diagram extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /**
     * `organizationalchartModule` is used to arrange the nodes in a organizational chart like struture
     * @private
     */
    organizationalChartModule: HierarchicalTree;
    /**
     * `hierarchicalTreeModule` is used to arrange the nodes in a organizational chart like struture
     * @private
     */
    hierarchicalTreeModule: object;
    /**
     * `databindingModule` is used to arrange the nodes in a organizational chart like struture
     * @private
     */
    dataBindingModule: DataSourceSettings;
    /**
     * `snappingModule` is used to Snap the objects
     * @private
     */
    snappingModule: SnappingController;
    /**
     * `printandexportModule` is used to print or export the objects
     * @private
     */
    printandExportModule: PrintAndExport;
    /**
     * `bpmnModule` is used to add built-in BPMN Shapes to diagrams
     * @private
     */
    bpmnModule: BpmnDiagrams;
    /**
     * 'SymmetricalLayout' is usd to render layout in symmetrical method
     * @private
     */
    symmetricalLayoutModule: SymmetricLayoutManager;
    /**
     * `bridgingModule` is used to add bridges to connectors
     * @private
     */
    bridgingModule: ConnectorBridging;
    /**
     * `undoRedoModule` is used to revert and restore the changes
     * @private
     */
    undoRedoModule: UndoRedo;
    /**
     * `layoutAnimateModule` is used to revert and restore the changes
     * @private
     */
    layoutAnimateModule: LayoutAnimation;
    /**
     * 'context menu module' is used to manipulate context menu
     * @private
     */
    contextMenuModule: DiagramContextMenu;
    /**
     * Defines the width of the diagram model.
     * @default undefined
     */
    width: string | number;
    /**
     * Defines the diagram rendering mode.
     * @default Canvas
     */
    mode: RenderingMode;
    /**
     * Defines the height of the diagram model.
     * @default undefined
     */
    height: string | number;
    /**
     * Enable auto scroll for diagram
     * @default false
     */
    canAutoScroll: boolean;
    /**
     * Defines the context menu
     */
    showContextMenu: boolean;
    /**
     * Show only custom context menu
     */
    showCustomContextMenuOnly: boolean;
    /**
     * Define the context menu items
     */
    customContextMenuItems: ContextMenuItemModel[];
    /**
     * Defines the diagram constraints
     */
    constraints: DiagramConstraints;
    /**
     * Defines the precedence of the interactive tools
     */
    tool: DiagramTools;
    /**
     * Defines the bridge direction of diagram connectors
     * @default top
     */
    bridgeDirection: BridgeDirection;
    /**
     * Defines the background color of the diagram
     * @default transparent
     */
    backgroundColor: String;
    /**
     * Defines the snap settings of diagram
     */
    snapSettings: SnapSettingsModel;
    /**
     * Defines the ruler settings of diagram
     */
    rulerSettings: RulerSettingsModel;
    /**
     * Defines the page settings of the diagram
     */
    pageSettings: PageSettingsModel;
    /**
     * Defines the collection of nodes - change diagram element as node
     * @default undefined
     */
    nodes: NodeModel[] | GroupModel[];
    /**
     * Define the draw type of diagram
     */
    drawingObject: NodeModel | ConnectorModel;
    /**
     * Defines the collection of connectors
     * @default ''
     */
    connectors: ConnectorModel[];
    /**
     * basic elements
     */
    basicElements: DiagramElement[];
    /**
     * defines the popups.Tooltip for the diagram
     * @default new DiagramTooltip()
     */
    tooltip: DiagramTooltipModel;
    /**
     * Configure data source for diagram
     */
    dataSourceSettings: DataSourceModel;
    /**
     * Allows the user to save custom information/data about diagram
     */
    addInfo: object;
    /**
     * Binds the custom JSON fields with node
     */
    getNodeDefaults: Function;
    /**
     * Helps to returns the last segment direction of connectors
     */
    getConnectorDefaults: Function;
    /**
     * Allows to set the node template
     */
    setNodeTemplate: Function;
    /**
     * Allows to get the custom properties that have to be serialized
     */
    getCustomProperty: Function;
    /**
     * Defines the collection of selected items and size and position of the selector
     */
    selectedItems: SelectorModel;
    /**
     * Defines how the diagram has to arrange the nodes
     */
    layout: LayoutModel;
    /**
     * Defines a set of custom commands and binds them with a set of desired key gestures
     */
    commandManager: CommandManagerModel;
    /**
     * Triggers after diagram is populated.
     * @event
     */
    dataLoaded: base.EmitType<IDataLoadedEventArgs>;
    /**
     * Triggers once the property changed.
     * @event
     */
    selectionChange: base.EmitType<ISelectionChangeEventArgs>;
    /**
     * Triggers once the resize property changed.
     * @event
     */
    sizeChange: base.EmitType<ISizeChangeEventArgs>;
    /**
     * Triggers once the connection changed.
     * @event
     */
    connectionChange: base.EmitType<IConnectionChangeEventArgs>;
    /**
     * Triggers once the resize property changed.
     * @event
     */
    sourcePointChange: base.EmitType<IEndChangeEventArgs>;
    /**
     * Triggers once the resize property changed.
     * @event
     */
    targetPointChange: base.EmitType<IEndChangeEventArgs>;
    /**
     * Triggers once the node or connector  property changed.
     * @event
     */
    propertyChange: base.EmitType<IPropertyChangeEventArgs>;
    /**
     * Triggers once the dragging is happening.
     * @event
     */
    positionChange: base.EmitType<IDraggingEventArgs>;
    /**
     * Triggers once the animation has done
     * @event
     */
    animationComplete: base.EmitType<Object>;
    /**
     * Triggers once the rotate property changed.
     * @event
     */
    rotateChange: base.EmitType<IRotationEventArgs>;
    /**
     * Triggers once the diagram object is added or removed property changed.
     * @event
     */
    collectionChange: base.EmitType<ICollectionChangeEventArgs>;
    /**
     * Triggers after render the diagram elements
     * @event
     */
    created: base.EmitType<Object>;
    /**
     * Triggers before context menu opens.
     * @event
     */
    contextMenuOpen: base.EmitType<navigations.BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers when click on context menu.
     * @event
     */
    contextMenuClick: base.EmitType<navigations.MenuEventArgs>;
    /**
     * Defines layers of the diagram
     * @default ''
     */
    layers: LayerModel[];
    /**
     * Triggers when dropped.
     * @event
     */
    drop: base.EmitType<IDropEventArgs>;
    /** @private */
    preventUpdate: boolean;
    /** @hidden */
    /** @private */
    localeObj: base.L10n;
    private defaultLocale;
    /** @private */
    currentDrawingObject: Node | Connector;
    /** @private */
    currentSymbol: Node | Connector;
    diagramRenderer: DiagramRenderer;
    private gridlineSvgLayer;
    private renderer;
    /** @private */
    tooltipObject: popups.Tooltip;
    private diagramCanvas;
    /** @private */
    diagramLayer: HTMLCanvasElement | SVGGElement;
    private diagramLayerDiv;
    private adornerLayer;
    private eventHandler;
    /** @private */
    scroller: DiagramScroller;
    /** @private */
    spatialSearch: SpatialSearch;
    /** @private */
    commandHandler: CommandHandler;
    /** @private */
    layerZIndex: number;
    /** @private */
    layerZIndexTable: {};
    /** @private */
    currentZoom: number;
    /** @private */
    nameTable: {};
    /** @private */
    private htmlLayer;
    /** @private */
    historyList: History;
    /** @private */
    diagramActions: DiagramAction;
    /** @private */
    commands: {};
    /** @private */
    activeLabel: string;
    /** @private */
    activeLayer: LayerModel;
    /** @private */
    serviceLocator: ServiceLocator;
    /** @private */
    views: string[];
    /**
     * Constructor for creating the widget
     */
    constructor(options?: DiagramModel, element?: HTMLElement | string);
    /**
     * Triggers when the diagram control is created
     */
    diagramCreated(): void;
    /**
     * Updates the diagram control when the objects are changed
     * @param newProp Lists the new values of the changed properties
     * @param oldProp Lists the old values of the changed properties
     */
    onPropertyChanged(newProp: DiagramModel, oldProp: DiagramModel): void;
    /**
     * Get the properties to be maintained in the persisted state.
     * @return {string}
     */
    getPersistData(): string;
    /**
     * Initialize nodes, connectors and renderer
     */
    protected preRender(): void;
    private initializeServices();
    /**
     * Renders the diagram control with nodes and connectors
     */
    render(): void;
    /**
     * Returns the module name of the diagram
     */
    getModuleName(): string;
    /**
     * To provide the array of modules needed for control rendering
     * @return {base.ModuleDeclaration[]}
     * @private
     */
    requiredModules(): base.ModuleDeclaration[];
    /**
     * Destroys the diagram control
     */
    destroy(): void;
    /**
     * Wires the mouse events with diagram control
     */
    private wireEvents();
    /**
     * Unwires the mouse events from diagram control
     */
    private unWireEvents();
    /**
     * Selects the given collection of objects
     * @param objects Defines the collection of nodes and connectors to be selected
     * @param multipleSelection Defines whether the existing selection has to be cleared or not
     */
    select(objects: (NodeModel | ConnectorModel)[], multipleSelection?: boolean): void;
    /**
     * Selects the all the objects.
     */
    selectAll(): void;
    /**
     * Removes the given object from selection list
     * @param obj Defines the object to be unselected
     */
    unSelect(obj: NodeModel | ConnectorModel): void;
    /**
     * Removes all elements from the selection list
     */
    clearSelection(): void;
    /**
     * Removes the selected nodes and connectors from diagram and moves them to diagram clipboard
     */
    cut(): void;
    /**
     * Adds the given object/ the object in the diagram clipboard to diagram control
     * @param obj Defines the object to be added to diagram
     */
    paste(obj?: NodeModel | ConnectorModel): void;
    /**
     * fit the diagram to the page with respect to mode and region
     */
    fitToPage(options?: IFitOptions): void;
    /**
     * bring the specified bounds into the viewport
     */
    bringIntoView(bound: Rect): void;
    /**
     * bring the specified bounds to the center of the viewport
     */
    bringToCenter(bound: Rect): void;
    /**
     * Copies the selected nodes and connectors to diagram clipboard
     */
    copy(): object;
    /**
     * send the selected nodes or connectors back
     */
    sendToBack(): void;
    /**
     * set the active layer
     *  @param layerName defines the name of the layer which is to be active layer
     */
    setActiveLayer(layerName: string): void;
    /**
     * add the layer into diagram
     * @param layer defines the layer model which is to be added
     * @param layerObject defines the object of the layer
     */
    addLayer(layer: LayerModel, layerObject?: object[]): void;
    /**
     * remove the layer from diagram
     * @param layerId define the id of the layer
     */
    removeLayer(layerId: string): void;
    /**
     * move objects from the layer to another layer from diagram
     * @param objects define the objects id of string array
     */
    moveObjects(objects: string[], targetLayer?: string): void;
    /**
     * move the layer backward
     * @param layerName define the name of the layer
     */
    sendLayerBackward(layerName: string): void;
    /**
     * move the layer forward
     * @param layerName define the name of the layer
     */
    bringLayerForward(layerName: string): void;
    /**
     * clone a layer with its object
     * @param layerName define the name of the layer
     */
    cloneLayer(layerName: string): void;
    /**
     * bring the selected nodes or connectors to front
     */
    bringToFront(): void;
    /**
     * send the selected nodes or connectors forward
     */
    moveForward(): void;
    /**
     * send the selected nodes or connectors back
     */
    sendBackward(): void;
    /**
     * Moves the selected objects towards the given direction
     * @param direction Defines the direction by which the objects have to be moved
     * @param x Defines the distance by which the selected objects have to be horizontally moved
     * @param y Defines the distance by which the selected objects have to be vertically moved
     */
    nudge(direction: NudgeDirection, x?: number, y?: number): void;
    /**
     * Drags the given object by the specified pixels
     * @param obj Defines the nodes/connectors to be dragged
     * @param tx Defines the distance by which the given objects have to be horizontally moved
     * @param ty Defines the distance by which the given objects have to be vertically moved
     */
    drag(obj: NodeModel | ConnectorModel | SelectorModel, tx: number, ty: number): void;
    /**
     * Scales the given objects by the given ratio
     * @param obj Defines the objects to be resized
     * @param sx Defines the ratio by which the objects have to be horizontally scaled
     * @param sy Defines the ratio by which the objects have to be vertically scaled
     * @param pivot Defines the reference point with respect to which the objects will be resized
     */
    scale(obj: NodeModel | ConnectorModel | SelectorModel, sx: number, sy: number, pivot: PointModel): boolean;
    /**
     * Rotates the given nodes/connectors by the given angle
     * @param obj Defines the objects to be rotated
     * @param angle Defines the angle by which the objects have to be rotated
     * @param pivot Defines the reference point with reference to which the objects have to be rotated
     */
    rotate(obj: NodeModel | ConnectorModel | SelectorModel, angle: number, pivot?: PointModel): boolean;
    /**
     * Moves the source point of the given connector
     * @param obj Defines the connector, the end points of which has to be moved
     * @param tx Defines the distance by which the end point has to be horizontally moved
     * @param ty Defines the distance by which the end point has to be vertically moved
     */
    dragSourceEnd(obj: ConnectorModel, tx: number, ty: number): void;
    /**
     * Moves the target point of the given connector
     * @param obj Defines the connector, the end points of which has to be moved
     * @param tx Defines the distance by which the end point has to be horizontally moved
     * @param ty Defines the distance by which the end point has to be vertically moved
     */
    dragTargetEnd(obj: ConnectorModel, tx: number, ty: number): void;
    /**
     * Finds all the objects that is under the given mouse position
     * @param position Defines the position, the objects under which has to be found
     * @param source Defines the object, the objects under which has to be found
     */
    findObjectsUnderMouse(position: PointModel, source?: IElement): IElement[];
    /**
     * Finds the object that is under the given mouse position
     * @param objects Defines the collection of objects, from which the object has to be found.
     * @param action Defines the action, using which the relevant object has to be found.
     * @param inAction Defines the active state of the action.
     */
    findObjectUnderMouse(objects: (NodeModel | ConnectorModel)[], action: Actions, inAction: boolean): IElement;
    /**
     * Finds the object that is under the given active object (Source)
     * @param objects Defines the collection of objects, from which the object has to be found.
     * @param action Defines the action, using which the relevant object has to be found.
     * @param inAction Defines the active state of the action.
     */
    findTargetObjectUnderMouse(objects: (NodeModel | ConnectorModel)[], action: Actions, inAction: boolean): IElement;
    /**
     * Finds the child element of the given object at the given position
     * @param obj Defines the object, the child element of which has to be found
     * @param position Defines the position, the child element under which has to be found
     */
    findElementUnderMouse(obj: IElement, position: PointModel): DiagramElement;
    /**
     * Defines the action to be done, when the mouse hovers the given element of the given object
     * @param obj Defines the object under mouse
     * @param wrapper Defines the target element of the object under mouse
     * @param position Defines the current mouse position
     */
    findActionToBeDone(obj: NodeModel | ConnectorModel, wrapper: DiagramElement, position: PointModel): Actions;
    /**
     * Returns the tool that handles the given action
     * @param action Defines the action that is going to be performed
     */
    getTool(action: string): ToolBase;
    /**
     * Defines the cursor that corresponds to the given action
     * @param action Defines the action that is going to be performed
     */
    getCursor(action: string): string;
    /**
     * Initializes the undo redo actions
     * @private
     */
    initHistory(): void;
    /**
     * Adds the given change in the diagram control to the track
     * @param entry Defines the entry/information about a change in diagram
     */
    addHistoryEntry(entry: HistoryEntryModel): void;
    /**
     * Starts grouping the actions that will be undone/restored as a whole
     */
    startGroupAction(): void;
    /**
     * Closes grouping the actions that will be undone/restored as a whole
     */
    endGroupAction(): void;
    /**
     * Restores the last action that is performed
     */
    undo(): void;
    /**
     * Restores the last undone action
     */
    redo(): void;
    /**
     * Aligns the group of objects to with reference to the first object in the group
     * @param objects Defines the objects that have to be aligned
     * @param option Defines the factor, by which the objects have to be aligned
     */
    align(option: AlignmentOptions, objects?: (NodeModel | ConnectorModel)[]): void;
    /**
     * Arranges the group of objects with equal intervals, but within the group of objects
     * @param objects Defines the objects that have to be equally spaced
     * @param option Defines the factor to distribute the shapes
     */
    distribute(option: DistributeOptions, objects?: (NodeModel | ConnectorModel)[]): void;
    /**
     * Scales the given objects to the size of the first object in the group
     * @param objects Defines the collection of objects that have to be scaled
     * @param option Defines whether the node has to be horizontally scaled, vertically scaled or both
     */
    sameSize(option: SizingOptions, objects?: (NodeModel | ConnectorModel)[]): void;
    /**
     * Scales the diagram control by the given factor
     * @param factor Defines the factor by which the diagram is zoomed
     * @param focusedPoint Defines the point with respect to which the diagram has to be zoomed
     */
    zoom(factor: number, focusedPoint?: PointModel): void;
    /**
     * Scales the diagram control by the given factor
     * @param options used to define the zoom factor, focus point and zoom type.
     *
     */
    zoomTo(options: ZoomOptions): void;
    /**
     * Pans the diagram control to the given horizontal and vertical offsets
     * @param horizontalOffset Defines the horizontal distance to which the diagram has to be scrolled
     * @param verticalOffset Defines the vertical distance to which the diagram has to be scrolled
     */
    pan(horizontalOffset: number, verticalOffset: number, focusedPoint?: PointModel): void;
    /** @private */
    triggerEvent(eventName: DiagramEvent, args: object): void;
    /**
     * Adds the given object to diagram control
     * @param obj Defines the object that has to be added to diagram
     */
    add(obj: NodeModel | ConnectorModel): Node | Connector;
    /**
     * Splice the InEdge and OutEdge of the for the node with respect to corresponding connectors that is deleting
     */
    private spliceConnectorEdges(connector, isSource);
    /**
     * Remove the dependent connectors if the node is deleted
     */
    private removeDependentConnector(node);
    /**
     * checking whether the selected object has connector edges
     */
    private hasEdges(selectedItems);
    private removeObjectsFromLayer(obj);
    /**
     * Removes the given object from diagram
     * @param obj Defines the object that has to be removed from diagram
     */
    remove(obj?: NodeModel | ConnectorModel): void;
    /**
     * Clears all nodes and objects in the diagram
     */
    clear(): void;
    private getLabel(node, id);
    /**
     * Specified annotation to edit mode
     * @param node Defines node/connector that contains the annotation to be edited
     * @param id Defines annotation id to be edited in the node
     */
    startTextEdit(node?: NodeModel | ConnectorModel, id?: string): void;
    /**
     * Automatically updates the diagram objects based on the type of the layout
     */
    doLayout(): ILayout;
    /**
     * Serializes the diagram control as a string
     */
    save(): string;
    /**
     * Converts the given string as a Diagram Control
     * @param data Defines the behavior of the diagram to be loaded
     */
    load(data: string): object;
    /**
     * To export Diagram
     * @param options defines the how the image to be exported.
     */
    exportDiagram(options: IExportOptions): string | SVGElement;
    /**
     * To print Diagram
     * @param optons defines how the image to be printed.
     */
    print(options: IPrintOptions): void;
    /**
     * Add ports at the run time
     */
    addPorts(obj: Node, ports: PointPortModel[]): void;
    /**
     * Add Labels at the run time
     */
    addLabels(obj: Node, labels: ShapeAnnotationModel[] | PathAnnotation[] | PathAnnotationModel[]): void;
    /**
     * Remove Labels at the run time
     */
    removeLabels(obj: Node, labels: ShapeAnnotationModel[] | PathAnnotationModel[]): void;
    /**
     * Remove Ports at the run time
     */
    removePorts(obj: Node, ports: PointPortModel[]): void;
    private getSizeValue(real);
    private renderRuler();
    private intOffPageBackground();
    private initDiagram();
    private renderBackgroundLayer(bounds, commonStyle);
    private renderGridLayer(bounds, commonStyle);
    private renderDiagramLayer(bounds, commonStyle);
    private initLayers();
    private renderAdornerLayer(bounds, commonStyle);
    private renderPortsExpandLayer(bounds, commonStyle);
    private renderHTMLLayer(bounds, commonStyle);
    private renderNativeLayer(bounds, commonStyle);
    createSvg(id: string, width: string | Number, height: string | Number): SVGElement;
    private initObjects();
    initLayerObjects(): void;
    private addToLayer(obj, hasLayers);
    private updateLayer(newProp);
    private initData();
    private initNodes(obj, layer);
    private initGroup(obj, layer);
    private initConnectors(obj, layer);
    private setZIndex(layer, obj);
    private initializeDiagramLayers();
    /** @private */
    initObject(obj: IElement, layer?: LayerModel): void;
    private initNode(obj);
    private canExecute();
    private initViews();
    private initCommands();
    private initCommandManager(newCommands, commands);
    /** @private */
    updateNodeEdges(node: Node): void;
    /** @private */
    updateEdges(obj: Connector): void;
    /** @private */
    refreshDiagram(): void;
    /** @private */
    updateDiagramObject(obj: (NodeModel | ConnectorModel)): void;
    /** @private  */
    getObjectsOfLayer(objectArray: string[]): (NodeModel | ConnectorModel)[];
    /** @private */
    refreshDiagramLayer(): void;
    /** @private */
    refreshCanvasLayers(): void;
    /** @private */
    refreshCanvasDiagramLayer(view: View): void;
    /** @private */
    updatePortVisibility(node: Node, portVisibility: PortVisibility, inverse?: Boolean): void;
    /** @private */
    refreshSvgDiagramLayer(view: View): void;
    /** @private */
    renderDiagramElements(canvas: HTMLCanvasElement | SVGElement, renderer: DiagramRenderer): void;
    /** @private */
    updateBridging(): void;
    /** @private */
    setCursor(cursor: string): void;
    /** @private */
    clearCanvas(view: View): void;
    /** @private */
    updateScrollOffset(): void;
    /** @private */
    setOffset(offsetX: number, offsetY: number): void;
    /** @private */
    setSize(width: number, height: number): void;
    /**
     * Defines how to remove the Page breaks
     * @private
     */
    removePageBreaks(): void;
    /**
     * Defines how the page breaks has been rendered
     * @private
     */
    renderPageBreaks(bounds?: Rect): void;
    private validatePageSize();
    private viewport;
    private view;
    /**
     * @private
     */
    setOverview(overview: View, id?: string): void;
    private renderNodes(overview);
    private updateThumbConstraints(node, selectorModel);
    /** @private */
    renderSelector(multipleSelection: boolean): void;
    /** @private */
    updateSelector(): void;
    /** @private */
    highlightSelectedRegion(x: number, y: number, width: number, height: number): void;
    /**
     * @private
     */
    renderHighlighter(element: DiagramElement): void;
    /**
     * @private
     */
    clearHighlighter(): void;
    /** @private */
    getNodesConnectors(selectedItems: (NodeModel | ConnectorModel)[]): (NodeModel | ConnectorModel)[];
    /** @private */
    clearSelectorLayer(): void;
    /** @private */
    getWrapper(nodes: Container, id: string): DiagramElement;
    private getEndNodeWrapper(node);
    private containsMargin(node);
    /**
     * @private
     */
    endEdit(): void;
    private canLogChange();
    private modelChanged(newProp, oldProp);
    private resetDiagramActions();
    /** @private */
    updateObject(actualObject: Node | Connector, oldObject: Node | Connector, object: Node | Connector): void;
    /** @private */
    nodePropertyChange(actualObject: Node, oldObject: Node, node: Node): void;
    /** @private */
    connectorPropertyChange(actualObject: Connector, oldProp: Connector, newProp: Connector): void;
    /**
     * update the  opacity  and visibility for the node  once the layout animation starts
     */
    /** @private */
    updateNodeProperty(element: Container, visible?: boolean, opacity?: number): void;
    /**
     * Updates the visibility of the node/connector
     * @private
     */
    private updateElementVisibility(element, obj, visible);
    private updateAnnotations(newProp, actualObject);
    /** @private */
    updateAnnotation(changedObject: AnnotationModel, actualAnnotation: ShapeAnnotationModel, nodes: Container, actualObject?: object): void;
    /** @private */
    updatePort(changedObject: PointPortModel, actualPort: PointPortModel, nodes: Container): void;
    private updateIcon(actualObject);
    private updateTooltip(actualObject, node);
    private updateQuad(obj);
    private removeFromAQuad(obj);
    private updatePage();
    /** @private */
    protectPropertyChange(enable: boolean): void;
    private initDroppables();
}
/**
 * Interface for a class DataSource
 */
export interface DataSourceModel {
    /**
     * Sets the unique id of the data source items
     * @default ''
     */
    id?: string;
    /**
     * Sets the data source either as a collection of objects or as an URL of DataManager
     * @default null
     */
    dataManager?: any;
    /**
     * Sets the unique id of the root data source item
     * @default ''
     */
    root?: string;
    /**
     * Sets the parent id of the data source item
     * @default ''
     */
    parentId?: string;
    /**
     * Sets the SourceTypes DataSource Item
     * @default SourceTypes.HierarchicalData
     */
    type?: SourceTypes;
    /**
     * Binds the custom data with node model
     */
    doBinding?: Function;
}
/**
 * data source defines the basic unit of diagram
 */
export  class DataSource extends base.ChildProperty<DataSource> {
    /**
     * Sets the unique id of the data source items
     * @default ''
     */
    id: string;
    /**
     * Sets the data source either as a collection of objects or as an URL of data.DataManager
     * @default null
     */
    dataManager: data.DataManager;
    /**
     * Sets the unique id of the root data source item
     * @default ''
     */
    root: string;
    /**
     * Sets the parent id of the data source item
     * @default ''
     */
    parentId: string;
    /**
     * Sets the SourceTypes DataSource Item
     * @default SourceTypes.HierarchicalData
     */
    type: SourceTypes;
    /**
     * Binds the custom data with node model
     */
    doBinding: Function;
}
/**
 * Interface for a class Gridlines
 */
export interface GridlinesModel {
    /**
     * Sets the line color of gridlines
     */
    lineColor?: string;
    /**
     * Defines the lineDashArray of gridlines
     * @default ''
     */
    lineDashArray?: string;
    /**
     * Sets the lineIntervals of horizontalGridlines
     * @default [1.25, 18.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75]
     */
    lineIntervals?: number[];
    /**
     * Defines the snap interval for object
     * @default [20]
     */
    snapInterval?: number[];
}
/**
 * Interface for a class SnapSettings
 */
export interface SnapSettingsModel {
    /**
     * Horizontal gridlines for SnapSettings
     * @default new Gridlines()
     */
    horizontalGridlines?: GridlinesModel;
    /**
     * Vertical gridlines for SnapSettings
     * @default new Gridlines()
     */
    verticalGridlines?: GridlinesModel;
    /**
     * Constraints for gridlines and snapping
     * @default SnapConstraints.ShowLines
     */
    constraints?: SnapConstraints;
    /**
     * Snap Angle for object
     * @default 5
     */
    snapAngle?: number;
    /**
     * Sets the Snap object distance
     * @default 5
     */
    snapObjectDistance?: number;
}
/**
 * Defines gridlines
 */
export  class Gridlines extends base.ChildProperty<Gridlines> {
    /**
     * Sets the line color of gridlines
     */
    lineColor: string;
    /**
     * Defines the lineDashArray of gridlines
     * @default ''
     */
    lineDashArray: string;
    /**
     * Sets the lineIntervals of horizontalGridlines
     * @default [1.25, 18.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75]
     */
    lineIntervals: number[];
    /**
     * Defines the snap interval for object
     * @default [20]
     */
    snapInterval: number[];
    /** @private */
    scaledIntervals: number[];
}
/**
 * Defines the public properties of diagram
 */
export  class SnapSettings extends base.ChildProperty<SnapSettings> {
    /**
     * Horizontal gridlines for SnapSettings
     * @default new Gridlines()
     */
    horizontalGridlines: GridlinesModel;
    /**
     * Vertical gridlines for SnapSettings
     * @default new Gridlines()
     */
    verticalGridlines: GridlinesModel;
    /**
     * Constraints for gridlines and snapping
     * @default SnapConstraints.ShowLines
     */
    constraints: SnapConstraints;
    /**
     * Snap Angle for object
     * @default 5
     */
    snapAngle: number;
    /**
     * Sets the Snap object distance
     * @default 5
     */
    snapObjectDistance: number;
}
/**
 * Interface for a class HistoryEntry
 */
export interface HistoryEntryModel {
    /**
     * Sets the type of the entry to be stored
     */
    type?: EntryType;
    /**
     * Sets the changed values to be stored
     */
    redoObject?: NodeModel | ConnectorModel | SelectorModel | DiagramModel;
    /**
     * Sets the changed values to be stored
     */
    undoObject?: NodeModel | ConnectorModel | SelectorModel | DiagramModel;
    /**
     * Sets the category for the entry
     */
    category?: EntryCategory;
    /**
     * Sets the next the current object
     */
    next?: HistoryEntryModel;
    /**
     * Sets the previous of the current object
     */
    previous?: HistoryEntryModel;
    /**
     * Sets the type of the object is added or remove
     */
    changeType?: EntryChangeType;
    /**
     * Set the value for undo action is activated
     */
    isUndo?: boolean;
    /**
     * Used to stored the entry or not
     */
    cancel?: boolean;
}
export interface History {
    /**
     * set the history entry can be undo
     */
    canUndo?: boolean;
    /**
     * Set the history entry can be redo
     */
    canRedo?: boolean;
    /**
     *  Set the current entry object
     */
    currentEntry?: HistoryEntryModel;
    /**
     * Stores a history entry to history list
     */
    push?: Function;
    /**
     * Used for custom undo option
     */
    undo?: Function;
    /**
     * Used for custom redo option
     */
    redo?: Function;
    /**
     * Used to intimate the group action is start
     */
    startGroupAction?: Function;
    /**
     * Used to intimate the group action is end
     */
    endGroupAction?: Function;
    /**
     * Used to decide to stored the changes to history
     */
    canLog?: Function;
}
/**
 * Interface for a class KeyGesture
 */
export interface KeyGestureModel {
    /**
     * Sets the key value, on recognition of which the command will be executed.
     */
    key?: Keys;
    /**
     * Sets a combination of key modifiers, on recognition of which the command will be executed.
     */
    keyModifiers?: KeyModifiers;
}
/**
 * Interface for a class Command
 */
export interface CommandModel {
    /**
     * Defines the name of the command
     */
    name?: string;
    /**
     * Check the command is executable at the moment or not
     */
    canExecute?: Function;
    /**
     * Defines what to be executed when the key combination is recognized
     */
    execute?: Function;
    /**
     * Defines a combination of keys and key modifiers.
     */
    gesture?: KeyGestureModel;
}
/**
 * Interface for a class CommandManager
 */
export interface CommandManagerModel {
    /**
     * Stores the multiple command names with the corresponding command objects
     * @default ''
     */
    commands?: CommandModel[];
}
/**
 * Defines keyboard commands
 */
export  class KeyGesture extends base.ChildProperty<KeyGesture> {
    /**
     * Sets the key value, on recognition of which the command will be executed.
     */
    key: Keys;
    /**
     * Sets a combination of key modifiers, on recognition of which the command will be executed.
     */
    keyModifiers: KeyModifiers;
}
export  class Command extends base.ChildProperty<Command> {
    /**
     * Defines the name of the command
     */
    name: string;
    /**
     * Check the command is executable at the moment or not
     */
    canExecute: Function;
    /**
     * Defines what to be executed when the key combination is recognized
     */
    execute: Function;
    /**
     * Defines a combination of keys and key modifiers.
     */
    gesture: KeyGestureModel;
}
export  class CommandManager extends base.ChildProperty<CommandManager> {
    /**
     * Stores the multiple command names with the corresponding command objects
     * @default ''
     */
    commands: CommandModel[];
}
/**
 * Interface for a class Layer
 */
export interface LayerModel {
    /**
     * Defines the name of the layer 
     * @default ''
     */
    id?: string;
    /**
     * Defines visibility of the layer
     * @default true
     */
    visible?: boolean;
    /**
     * Defines lock property of the layer 
     * @default false
     */
    lock?: boolean;
    /**
     * Defines the object in the layer
     * @default ''
     */
    objects?: string[];
    /**
     * Defines the description of the layer
     * @default ''
     */
    addInfo?: object;
    /**
     * Defines the zOrder of the layer
     * @default ''
     */
    zIndex?: number;
}
/**
 * Defines the BackgroundImage of diagram
 */
export  class Layer extends base.ChildProperty<Layer> {
    /**
     * Defines the name of the layer
     * @default ''
     */
    id: string;
    /**
     * Defines visibility of the layer
     * @default true
     */
    visible: boolean;
    /**
     * Defines lock property of the layer
     * @default false
     */
    lock: boolean;
    /**
     * Defines the object in the layer
     * @default ''
     */
    objects: string[];
    /**
     * Defines the description of the layer
     * @default ''
     */
    addInfo: object;
    /**
     * Defines the zOrder of the layer
     * @default ''
     */
    zIndex: number;
    /**  @private   */
    objectZIndex: number;
    /**   @private  */
    zIndexTable: {};
    constructor(parent: any, propName: string, defaultValue: Object, isArray?: boolean);
}
/**
 * Interface for a class Background
 */
export interface BackgroundModel {
    /**
     * Defines the source of BackgroundImage 
     * @default ''
     */
    source?: string;
    /**
     * Defines the background color
     * @default 'transparent'
     */
    color?: string;
    /**
     * Defines the scale of the BackgroundImage 
     * @default ''
     */
    scale?: Scale;
    /**
     * Defines the alignment of the BackgroundImage 
     * @default ''
     */
    align?: ImageAlignment;
}
/**
 * Interface for a class PageSettings
 */
export interface PageSettingsModel {
    /**
     * Sets the width for the Page
     * @default null
     */
    width?: number;
    /**
     * Sets the height of the Page
     * @default null
     */
    height?: number;
    /**
     * Sets the space to be left between an annotation and its parent node/connector
     * @default new base.Margin(0,0,0,0)
     */
    margin?: MarginModel;
    /**
     * AutoScrollBorder
     */
    autoScrollBorder?: MarginModel;
    /**
     * Sets the PageOrientation for the diagram to page
     * @default ('Landscape')
     */
    orientation?: PageOrientation;
    /**
     * Sets the BoundaryConstraints to page
     * @default ('Infinity')
     */
    boundaryConstraints?: BoundaryConstraints;
    /**
     * Defines the background color and image  of diagram
     * @default 'transparent' 
     */
    background?: BackgroundModel;
    /**
     * Sets the Multiple page for diagram
     * @default false
     */
    multiplePage?: boolean;
    /**
     * Sets the Page Break for diagram
     * @default false
     */
    showPageBreaks?: boolean;
}
/**
 * Defines the BackgroundImage of diagram
 */
export  class Background extends base.ChildProperty<Background> {
    /**
     * Defines the source of BackgroundImage
     * @default ''
     */
    source: string;
    /**
     * Defines the background color
     * @default 'transparent'
     */
    color: string;
    /**
     * Defines the scale of the BackgroundImage
     * @default ''
     */
    scale: Scale;
    /**
     * Defines the alignment of the BackgroundImage
     * @default ''
     */
    align: ImageAlignment;
}
/**
 * Defines PageSettings
 */
export  class PageSettings extends base.ChildProperty<PageSettings> {
    /**
     * Sets the width for the Page
     * @default null
     */
    width: number;
    /**
     * Sets the height of the Page
     * @default null
     */
    height: number;
    /**
     * Sets the space to be left between an annotation and its parent node/connector
     * @default new Margin(0,0,0,0)
     */
    margin: MarginModel;
    /**
     * AutoScrollBorder
     */
    autoScrollBorder: MarginModel;
    /**
     * Sets the PageOrientation for the diagram to page
     * @default ('Landscape')
     */
    orientation: PageOrientation;
    /**
     * Sets the BoundaryConstraints to page
     * @default ('Infinity')
     */
    boundaryConstraints: BoundaryConstraints;
    /**
     * Defines the background color and image  of diagram
     * @default 'transparent'
     */
    background: BackgroundModel;
    /**
     * Sets the Multiple page for diagram
     * @default false
     */
    multiplePage: boolean;
    /**
     * Sets the Page Break for diagram
     * @default false
     */
    showPageBreaks: boolean;
}
/**
 * Interface for a class RulerSettings
 */
export interface RulerSettingsModel {
    /**
     * Sets the visibility of the ruler
     * @default 'false'
     */
    enableRuler?: boolean;
}
/**
 * Defines rulers
 */
export  class RulerSettings extends base.ChildProperty<RulerSettings> {
    /**
     * Sets the visibility of the ruler
     * @default 'false'
     */
    enableRuler: boolean;
}
/**
 * enum module defines the public enumerations
 */
/**
 * Defines how the diagram elements have to be aligned with respect to its immediate parent
 * * Stretch - Stretches the diagram element throughout its immediate parent
 * * Left - Aligns the diagram element at the left of its immediate parent
 * * Right - Aligns the diagram element at the right of its immediate parent
 * * Center - Aligns the diagram element at the center of its immediate parent
 * * Auto - Aligns the diagram element based on the characteristics of its immediate parent
 */
export  type HorizontalAlignment = 'Stretch' | 'Left' | 'Right' | 'Center' | 'Auto';
/**
 * Defines how the diagram elements have to be aligned with respect to its immediate parent
 * * Stretch - Stretches the diagram element throughout its immediate parent
 * * Top - Aligns the diagram element at the top of its immediate parent
 * * Bottom - Aligns the diagram element at the bottom of its immediate parent
 * * Center - Aligns the diagram element at the center of its immediate parent
 * * Auto - Aligns the diagram element based on the characteristics of its immediate parent
 */
export  type VerticalAlignment = 'Stretch' | 'Top' | 'Bottom' | 'Center' | 'Auto';
export  const contextMenuClick: string;
export  const contextMenuOpen: string;
/**
 * Defines the orientation of the Page
 * Landscape - Display with page Width is more than the page Height.
 * Portrait - Display with page Height is more than the page width.
 */
export  type PageOrientation = 'Landscape' | 'Portrait';
/**
 * Defines the orientation of the layout
 * * TopToBottom - Renders the layout from top to bottom
 * * BottomToTop - Renders the layout from bottom to top
 * * LeftToRight - Renders the layout from left to right
 * * RightToLeft - Renders the layout from right to left
 */
export  type LayoutOrientation = 'TopToBottom' | 'BottomToTop' | 'LeftToRight' | 'RightToLeft';
/**
 * Defines the types of the automatic layout
 * * HierarchicalTree - Defines the type of the layout as Hierarchical Tree
 * * OrganizationalChart - Defines the type of the layout as Organizational Chart
 */
export  type LayoutType = 'HierarchicalTree' | 'OrganizationalChart' | 'SymmetricalLayout';
/**
 * Defines how the first segments have to be defined in a layout
 * Auto - Defines the first segment direction based on the type of the layout
 * Orientation - Defines the first segment direction based on the orientation of the layout
 * Custom - Defines the first segment direction dynamically by the user
 */
export  type ConnectionDirection = 'Auto' | 'Orientation' | 'Custom';
/**
 * Defines where the user handles have to be aligned
 * Top - Aligns the user handles at the top of an object
 * Bottom - Aligns the user handles at the bottom of an object
 * Left - Aligns the user handles at the left of an object
 * Right - Aligns the user handles at the right of an object
 */
export  type Side = 'Top' | 'Bottom' | 'Left' | 'Right';
/**
 * Defines how the connectors have to be routed in a layout
 * Default - Routes the connectors like a default diagram
 * Layout - Routes the connectors based on the type of the layout
 */
export  type ConnectorSegments = 'Default' | 'Layout';
/**
 * Defines how the annotations have to be aligned with respect to its immediate parent
 * Center - Aligns the annotation at the center of a connector segment
 * Before - Aligns the annotation before a connector segment
 * After - Aligns the annotation after a connector segment
 */
export  type AnnotationAlignment = 'Center' | 'Before' | 'After';
/**
 * Defines the type of the port
 * Point - Sets the type of the port as Point
 * Path - Sets the type of the port as Path
 * Dynamic - Sets the type of the port as Dynamic
 */
export  type PortTypes = 'Point' | 'Path' | 'Dynamic';
/**
 * Defines the type of the annotation
 * Shape - Sets the annotation type as Shape
 * Path - Sets the annotation type as Path
 */
export  type AnnotationTypes = 'Shape' | 'Path';
/**
 * File Format type for export.
 * JPG - Save the file in JPG Format
 * PNG - Saves the file in PNG Format
 * BMP - Save the file in BMP Format
 * SVG - save the file in SVG format
 * @private
 */
export  type FileFormats = 'JPG' | 'PNG' | 'BMP' | 'SVG';
/**
 * Defines whether the diagram has to be exported as an image or it has to be converted as image url
 * Download
 * Data
 * @private
 */
export  type ExportModes = 'Download' | 'Data';
/**
 * Defines the region that has to be drawn as an image
 * PageSettings -  With the given page settings image has to be exported.
 * Content - The diagram content is export
 * CustomBounds - Exported with given bounds.
 * @private
 */
export  type DiagramRegions = 'PageSettings' | 'Content' | 'CustomBounds';
/**
 * Constraints to define when a port has to be visible
 * Visible - Always shows the port
 * Hidden - Always hides the port
 * Hover - Shows the port when the mouse hovers over a node
 * Connect - Shows the port when a connection end point is dragged over a node
 * Default - By default the ports will be visible when a node is hovered and being tried to connect
 */
export  enum PortVisibility {
    /** Always shows the port */
    Visible = 1,
    /** Always hides the port */
    Hidden = 2,
    /** Shows the port when the mouse hovers over a node */
    Hover = 4,
    /** Shows the port when a connection end point is dragged over a node */
    Connect = 8,
    /** the ports will be visible when a node is hovered and being tried to connect with */
    Default = 12,
}
/**
 * Defines the constraints to Enables / Disables some features of Snapping.
 * None - Snapping does not happen
 * ShowHorizontalLines - Displays only the horizontal gridlines in diagram.
 * ShowVerticalLines - Displays only the Vertical gridlines in diagram.
 * ShowLines - Display both Horizontal and Vertical gridlines.
 * SnapToHorizontalLines - Enables the object to snap only with horizontal gridlines.
 * SnapToVerticalLines - Enables the object to snap only with horizontal gridlines.
 * SnapToLines - Enables the object to snap with both horizontal and Vertical gridlines.
 * snapToObject - Enables the object to snap with the other objects in the diagram.
 */
/** @private */
export  enum SnapConstraints {
    /** None - Snapping does not happen */
    None = 0,
    /** ShowHorizontalLines - Displays only the horizontal gridlines in diagram. */
    ShowHorizontalLines = 1,
    /** ShowVerticalLines - Displays only the Vertical gridlines in diagram  */
    ShowVerticalLines = 2,
    /** ShowLines - Display both Horizontal and Vertical gridlines */
    ShowLines = 3,
    /** SnapToHorizontalLines - Enables the object to snap only with horizontal gridlines */
    SnapToHorizontalLines = 4,
    /** SnapToVerticalLines - Enables the object to snap only with horizontal gridlines */
    SnapToVerticalLines = 8,
    /** SnapToLines - Enables the object to snap with both horizontal and Vertical gridlines */
    SnapToLines = 12,
    /** SnapToObject - Enables the object to snap with the other objects in the diagram. */
    SnapToObject = 16,
    /** Shows gridlines and enables snapping */
    All = 31,
}
/**
 * Defines the visibility of the selector handles
 * None - Hides all the selector elements
 * ConnectorSourceThumb - Shows/hides the source thumb of the connector
 * ConnectorTargetThumb - Shows/hides the target thumb of the connector
 * ResizeSouthEast - Shows/hides the bottom right resize handle of the selector
 * ResizeSouthWest - Shows/hides the bottom left resize handle of the selector
 * ResizeNorthEast - Shows/hides the top right resize handle of the selector
 * ResizeNorthWest - Shows/hides the top left resize handle of the selector
 * ResizeEast - Shows/hides the middle right resize handle of the selector
 * ResizeWest - Shows/hides the middle left resize handle of the selector
 * ResizeSouth - Shows/hides the bottom center resize handle of the selector
 * ResizeNorth - Shows/hides the top center resize handle of the selector
 * Rotate - Shows/hides the rotate handle of the selector
 * UserHandles - Shows/hides the user handles of the selector
 * Resize - Shows/hides all resize handles of the selector
 * @private
 */
export  enum SelectorConstraints {
    /** Hides all the selector elements */
    None = 1,
    /** Shows/hides the source thumb of the connector */
    ConnectorSourceThumb = 2,
    /** Shows/hides the target thumb of the connector */
    ConnectorTargetThumb = 4,
    /** Shows/hides the bottom right resize handle of the selector */
    ResizeSouthEast = 8,
    /** Shows/hides the bottom left resize handle of the selector */
    ResizeSouthWest = 16,
    /** Shows/hides the top right resize handle of the selector */
    ResizeNorthEast = 32,
    /** Shows/hides the top left resize handle of the selector */
    ResizeNorthWest = 64,
    /** Shows/hides the middle right resize handle of the selector  */
    ResizeEast = 128,
    /** Shows/hides the middle left resize handle of the selector */
    ResizeWest = 256,
    /** Shows/hides the bottom center resize handle of the selector */
    ResizeSouth = 512,
    /** Shows/hides the top center resize handle of the selector */
    ResizeNorth = 1024,
    /**  Shows/hides the rotate handle of the selector */
    Rotate = 2048,
    /** Shows/hides the user handles of the selector */
    UserHandle = 4096,
    /** Shows/hides the default tooltip of nodes and connectors */
    ToolTip = 8192,
    /** Shows/hides all resize handles of the selector */
    ResizeAll = 2046,
    /** Shows all handles of the selector  */
    All = 16382,
}
/**
 * Defines the type of the panel
 * None - Defines that the panel will not rearrange its children. Instead, it will be positioned based on its children.
 * Canvas - Defines the type of the panel as Canvas
 * Stack - Defines the type of the panel as Stack
 * Grid - Defines the type of the panel as Grid
 * WrapPanel - Defines the type of the panel as WrapPanel
 */
export  type Panels = 'None' | 'Canvas' | 'Stack' | 'Grid' | 'WrapPanel';
/**
 * Defines the orientation
 * Horizontal - Sets the orientation as Horizontal
 * Vertical - Sets the orientation as Vertical
 */
export  type Orientation = 'Horizontal' | 'Vertical';
/**
 * Defines the reference with respect to which the diagram elements have to be aligned
 * Point - Diagram elements will be aligned with respect to a point
 * Object - Diagram elements will be aligned with respect to its immediate parent
 */
export  type RelativeMode = 'Point' | 'Object';
/**
 * Defines how to wrap the text when it exceeds the element bounds
 * WrapWithOverflow - Wraps the text so that no word is broken
 * Wrap - Wraps the text and breaks the word, if necessary
 * NoWrap - Text will no be wrapped
 */
export  type TextWrap = 'WrapWithOverflow' | 'Wrap' | 'NoWrap';
/**
 * Defines how to handle the text when it exceeds the element bounds
 * Wrap - Wraps the text to next line, when it exceeds its bounds
 * Ellipsis - It truncates the overflown text and represents the clipping with an ellipsis
 * Clip - It clips the overflow text
 */
export  type TextOverflow = 'Wrap' | 'Ellipsis' | 'Clip';
/**
 * Defines the alignment options
 * Left - Aligns the objects at the left of the selector bounds
 * Right - Aligns the objects at the right of the selector bounds
 * Center - Aligns the objects at the horizontal center of the selector bounds
 * Top - Aligns the objects at the top of the selector bounds
 * Bottom - Aligns the objects at the bottom of the selector bounds
 * Middle - Aligns the objects at the vertical center of the selector bounds
 */
export  type AlignmentOptions = 'Left' | 'Right' | 'Center' | 'Top' | 'Bottom' | 'Middle';
/**
 * Defines the distribution options
 * RightToLeft - Distributes the objects based on the distance between the right and left sides of the adjacent objects
 * Left - Distributes the objects based on the distance between the left sides of the adjacent objects
 * Right - Distributes the objects based on the distance between the right sides of the adjacent objects
 * Center - Distributes the objects based on the distance between the center of the adjacent objects
 * BottomToTop - Distributes the objects based on the distance between the bottom and top sides of the adjacent objects
 * Top - Distributes the objects based on the distance between the top sides of the adjacent objects
 * Bottom - Distributes the objects based on the distance between the bottom sides of the adjacent objects
 * Middle - Distributes the objects based on the distance between the vertical center of the adjacent objects
 */
export  type DistributeOptions = 'RightToLeft' | 'Left' | 'Right' | 'Center' | 'BottomToTop' | 'Top' | 'Bottom' | 'Middle';
/**
 * Defines the sizing options
 * Width - Scales the width of the selected objects
 * Height - Scales the height of the selected objects
 * Size - Scales the selected objects both vertically and horizontally
 */
export  type SizingOptions = 'Width' | 'Height' | 'Size';
/**
 * Defines how to handle the empty space and empty lines of a text
 * PreserveAll - Preserves all empty spaces and empty lines
 * CollapseSpace - Collapses the consequent spaces into one
 * CollapseAll - Collapses all consequent empty spaces and empty lines
 */
export  type WhiteSpace = 'PreserveAll' | 'CollapseSpace' | 'CollapseAll';
/**
 * Defines how to handle the rubber band selection
 * CompleteIntersect - Selects the objects that are contained within the selected region
 * PartialIntersect - Selects the objects that are partially intersected with the selected region
 */
export  type RubberBandSelectionMode = 'CompleteIntersect' | 'PartialIntersect';
/**
 * Defines the rendering mode of the diagram
 * SVG - Renders the diagram objects as SVG elements
 * Canvas - Renders the diagram in a canvas
 */
export  type RenderingMode = 'SVG' | 'Canvas';
/**
 * Defines how to decorate the text
 * Overline - Decorates the text with a line above the text
 * Underline - Decorates the text with an underline
 * LineThrough - Decorates the text by striking it with a line
 * None - Text will not have any specific decoration
 */
export  type TextDecoration = 'Overline' | 'Underline' | 'LineThrough' | 'None';
/**
 * Defines how the text has to be aligned
 * Left - Aligns the text at the left of the text bounds
 * Right - Aligns the text at the right of the text bounds
 * Center - Aligns the text at the center of the text bounds
 * Justify - Aligns the text in a justified manner
 */
export  type TextAlign = 'Left' | 'Right' | 'Center' | 'Justify';
/**
 * Defines the constraints to enable/disable certain features of connector.
 * * None - Interaction of the connectors cannot be done.
 * * Select - Selects the connector.
 * * Delete - Delete the connector.
 * * Drag - Drag the connector.
 * * DragSourceEnd - Drag the source end of the connector.
 * * DragTargetEnd - Drag the target end of the connector.
 * * DragSegmentThump - Drag the segment thump of the connector.
 * * AllowDrop - Allow to drop a node.
 * * Bridging - Creates bridge  on intersection of two connectors.
 * * BridgeObstacle -
 * * InheritBridging - Creates bridge  on intersection of two connectors.
 * * PointerEvents - Sets the pointer events.
 * * Tooltip - Dispalys a tooltip for the connectors.
 * * InheritToolTip - Dispalys a tooltip for the connectors.
 * * Interaction - Features of the connector used for interaction.
 * * Default - Default features of the connector.
 * @private
 */
export  enum ConnectorConstraints {
    /** Disable all connector Constraints. */
    None = 1,
    /** Enables connector to be selected. */
    Select = 2,
    /** Enables connector to be Deleted. */
    Delete = 4,
    /** Enables connector to be Dragged. */
    Drag = 8,
    /** Enables connectors source end to be selected. */
    DragSourceEnd = 16,
    /** Enables connectors target end to be selected. */
    DragTargetEnd = 32,
    /** Enables control point and end point of every segment in a connector for editing. */
    DragSegmentThumb = 64,
    /** Enables AllowDrop constraints to the  connector. */
    AllowDrop = 128,
    /** Enables bridging to the connector. */
    Bridging = 256,
    /** Enables or Disables Bridge Obstacles with overlapping of connectors. */
    BridgeObstacle = 512,
    /** Enables bridging to the connector. */
    InheritBridging = 1024,
    /** Used to set the pointer events. */
    PointerEvents = 2048,
    /** Enables or disables tool tip for the connectors */
    Tooltip = 4096,
    /** Enables or disables tool tip for the connectors */
    InheritTooltip = 8192,
    /** Enables Interaction. */
    Interaction = 4218,
    /** Enables all constraints. */
    Default = 11838,
}
/**
 * Enables/Disables certain features of node
 * @private
 */
export  enum NodeConstraints {
    /** Disable all node Constraints. */
    None = 0,
    /** Enables node to be selected. */
    Select = 2,
    /** Enables node to be Dragged. */
    Drag = 4,
    /** Enables node to be Rotate. */
    Rotate = 8,
    /** Enables node to display shadow. */
    Shadow = 16,
    /** Enables node to provide pointer  option */
    PointerEvents = 32,
    /** Enables node to delete */
    Delete = 64,
    /** Enables node to provide in connect option */
    InConnect = 128,
    /** Enables node to provide out connect option */
    OutConnect = 256,
    /** Enables node to provide individual resize option */
    Individual = 512,
    /** Enables node to provide Expandable option */
    Expandable = 1024,
    /** Enables node to provide allow to drop option */
    AllowDrop = 2048,
    /** Enables node to inherit the interaction option */
    Inherit = 78,
    /** Enable ResizeNorthEast of the node  */
    ResizeNorthEast = 4096,
    /** Enable ResizeEast of the node  */
    ResizeEast = 8192,
    /** Enable ResizeSouthEast of the node  */
    ResizeSouthEast = 16384,
    /** Enable ResizeSouth of the node  */
    ResizeSouth = 32768,
    /** Enable ResizeSouthWest of the node  */
    ResizeSouthWest = 65536,
    /** Enable ResizeWest of the node  */
    ResizeWest = 131072,
    /** Enable ResizeNorthWest of the node  */
    ResizeNorthWest = 262144,
    /** Enable ResizeNorth of the node  */
    ResizeNorth = 524288,
    /** Enable Resize of the node  */
    Resize = 1044480,
    /** Enables the Aspect ratio fo the node */
    AspectRatio = 1048576,
    /** Enables or disables tool tip for the Nodes */
    Tooltip = 2097152,
    /** Enables or disables tool tip for the Nodes */
    InheritTooltip = 4194304,
    /** Enables all constraints */
    Default = 5240814,
}
/** Enables/Disables the handles of the selector
 * @private
 */
export  enum ThumbsConstraints {
    /** Enable Rotate Thumb  */
    Rotate = 2,
    /** Enable Connector source point  */
    ConnectorSource = 4,
    /** Enable Connector target point  */
    ConnectorTarget = 8,
    /** Enable ResizeNorthEast Resize  */
    ResizeNorthEast = 16,
    /** Enable ResizeEast Resize  */
    ResizeEast = 32,
    /** Enable ResizeSouthEast Resize */
    ResizeSouthEast = 64,
    /** Enable ResizeSouth Resize */
    ResizeSouth = 128,
    /** Enable ResizeSouthWest Resize */
    ResizeSouthWest = 256,
    /** Enable ResizeWest Resize */
    ResizeWest = 512,
    /** Enable ResizeNorthWest Resize */
    ResizeNorthWest = 1024,
    /** Enable ResizeNorth Resize */
    ResizeNorth = 2048,
    /** Enables all constraints */
    Default = 4094,
}
/**
 * Enables/Disables certain features of diagram
 * @private
 */
export  enum DiagramConstraints {
    None = 1,
    Bridging = 2,
    CrispEdges = 4,
    UndoRedo = 8,
    Tooltip = 16,
    Default = 12,
}
/**
 * Activates the diagram tools
 * @private
 */
export  enum DiagramTools {
    None = 0,
    SingleSelect = 1,
    MultipleSelect = 2,
    ZoomPan = 4,
    DrawOnce = 8,
    continuousDraw = 16,
    Default = 3,
}
/**
 * Defines the bridge direction
 * Top - Defines the direction of the bridge as Top
 * Bottom - Defines the direction of the bridge as Bottom
 * Left - Sets the bridge direction as left
 * Right - Sets the bridge direction as right
 */
export  type BridgeDirection = 'top' | 'bottom' | 'left' | 'right';
/**
 * Defines the type of the gradient
 * Linear - Sets the type of the gradient as Linear
 * Radial - Sets the type of the gradient as Radial
 */
export  type GradientType = 'Linear' | 'Radial';
/**
 * Defines the shape of a node
 * Path - Sets the type of the node as Path
 * Text - Sets the type of the node as Text
 * Image - Sets the type of the node as Image
 * Basic - Sets the type of the node as Basic
 * Flow - Sets the type of the node as Flow
 * Bpmn - Sets the type of the node as Bpmn
 * Native - Sets the type of the node as Native
 */
export  type Shapes = 'Path' | 'Text' | 'Image' | 'Basic' | 'Flow' | 'Bpmn' | 'Native' | 'Polygon';
export  type Scale = 'None' | 'Meet' | 'Slice';
export  type ImageAlignment = 'None' | 'XMinYMin' | 'XMidYMin' | 'XMaxYMin' | 'XMinYMid' | 'XMidYMid' | 'XMaxYMid' | 'XMinYMax' | 'XMidYMax' | 'XMaxYMax';
/**
 * Defines the type of the flow shape
 * Process - Sets the type of the flow shape as Process
 * Decision - Sets the type of the flow shape as Decision
 * Document - Sets the type of the flow shape as Document
 * PreDefinedProcess - Sets the type of the flow shape as PreDefinedProcess
 * Terminator - Sets the type of the flow shape as Terminator
 * PaperTap - Sets the type of the flow shape as PaperTap
 * DirectData - Sets the type of the flow shape as DirectData
 * SequentialData - Sets the type of the flow shape as SequentialData
 * MultiData - Sets the type of the flow shape as MultiData
 * Collate - Sets the type of the flow shape as Collate
 * SummingJunction - Sets the type of the flow shape as SummingJunction
 * Or - Sets the type of the flow shape as Or
 * InternalStorage - Sets the type of the flow shape as InternalStorage
 * Extract - Sets the type of the flow shape as Extract
 * ManualOperation - Sets the type of the flow shape as ManualOperation
 * Merge - Sets the type of the flow shape as Merge
 * OffPageReference - Sets the type of the flow shape as OffPageReference
 * SequentialAccessStorage - Sets the type of the flow shape as SequentialAccessStorage
 * Annotation - Sets the type of the flow shape as Annotation
 * Annotation2 - Sets the type of the flow shape as Annotation2
 * Data - Sets the type of the flow shape as Data
 * Card - Sets the type of the flow shape as Card
 * Delay - Sets the type of the flow shape as Delay
 * Preparation - Sets the type of the flow shape as Preparation
 * Display - Sets the type of the flow shape as Display
 * ManualInput - Sets the type of the flow shape as ManualInput
 * LoopLimit - Sets the type of the flow shape as LoopLimit
 * StoredData - Sets the type of the flow shape as StoredData
 */
export  type FlowShapes = 'Process' | 'Decision' | 'Document' | 'PreDefinedProcess' | 'Terminator' | 'PaperTap' | 'DirectData' | 'SequentialData' | 'Sort' | 'MultiDocument' | 'Collate' | 'SummingJunction' | 'Or' | 'InternalStorage' | 'Extract' | 'ManualOperation' | 'Merge' | 'OffPageReference' | 'SequentialAccessStorage' | 'Annotation' | 'Annotation2' | 'Data' | 'Card' | 'Delay' | 'Preparation' | 'Display' | 'ManualInput' | 'LoopLimit' | 'StoredData';
/**
 * Defines the basic shapes
 * Rectangle - Sets the type of the basic shape as Rectangle
 * Ellipse - Sets the type of the basic shape as Ellipse
 * Hexagon - Sets the type of the basic shape as Hexagon
 * Parallelogram - Sets the type of the basic shape as Parallelogram
 * Triangle - Sets the type of the basic shape as Triangle
 * Plus - Sets the type of the basic shape as Plus
 * Star - Sets the type of the basic shape as Star
 * Pentagon - Sets the type of the basic shape as Pentagon
 * Heptagon - Sets the type of the basic shape as Heptagon
 * Octagon - Sets the type of the basic shape as Octagon
 * Trapezoid - Sets the type of the basic shape as Trapezoid
 * Decagon - Sets the type of the basic shape as Decagon
 * RightTriangle - Sets the type of the basic shape as RightTriangle
 * Cylinder - Sets the type of the basic shape as Cylinder
 * Diamond - Sets the type of the basic shape as Diamond
 */
export  type BasicShapes = 'Rectangle' | 'Ellipse' | 'Hexagon' | 'Parallelogram' | 'Triangle' | 'Plus' | 'Star' | 'Pentagon' | 'Heptagon' | 'Octagon' | 'Trapezoid' | 'Decagon' | 'RightTriangle' | 'Cylinder' | 'Diamond';
/**
 * Defines the type of the Bpmn Shape
 * Event - Sets the type of the Bpmn Shape as Event
 * Gateway - Sets the type of the Bpmn Shape as Gateway
 * Message - Sets the type of the Bpmn Shape as Message
 * DataObject - Sets the type of the Bpmn Shape as DataObject
 * DataSource - Sets the type of the Bpmn Shape as DataSource
 * Activity - Sets the type of the Bpmn Shape as Activity
 * Group - Sets the type of the Bpmn Shape as Group
 */
export  type BpmnShapes = 'Event' | 'Gateway' | 'Message' | 'DataObject' | 'DataSource' | 'Activity' | 'Group';
/**
 * Defines the type of the Bpmn Events
 * Start - Sets the type of the Bpmn Event as Start
 * Start - Sets the type of the Bpmn Event as Intermediate
 * Start - Sets the type of the Bpmn Event as End
 * Start - Sets the type of the Bpmn Event as NonInterruptingStart
 * Start - Sets the type of the Bpmn Event as NonInterruptingIntermediate
 * Start - Sets the type of the Bpmn Event as ThrowingIntermediate
 */
export  type BpmnEvents = 'Start' | 'Intermediate' | 'End' | 'NonInterruptingStart' | 'NonInterruptingIntermediate' | 'ThrowingIntermediate';
/**
 * Defines the type of the Bpmn Triggers
 * None - Sets the type of the trigger as None
 * Message - Sets the type of the trigger as Message
 * Timer - Sets the type of the trigger as Timer
 * Escalation - Sets the type of the trigger as Escalation
 * Link - Sets the type of the trigger as Link
 * Error - Sets the type of the trigger as Error
 * Compensation - Sets the type of the trigger as Compensation
 * Signal - Sets the type of the trigger as Signal
 * Multiple - Sets the type of the trigger as Multiple
 * Parallel - Sets the type of the trigger as Parallel
 * Cancel - Sets the type of the trigger as Cancel
 * Conditional - Sets the type of the trigger as Conditional
 * Terminate - Sets the type of the trigger as Terminate
 */
export  type BpmnTriggers = 'None' | 'Message' | 'Timer' | 'Escalation' | 'Link' | 'Error' | 'Compensation' | 'Signal' | 'Multiple' | 'Parallel' | 'Cancel' | 'Conditional' | 'Terminate';
/**
 * Defines the type of the Bpmn gateways
 * None - Sets the type of the gateway as None
 * Exclusive - Sets the type of the gateway as Exclusive
 * Inclusive - Sets the type of the gateway as Inclusive
 * Parallel - Sets the type of the gateway as Parallel
 * Complex - Sets the type of the gateway as Complex
 * EventBased - Sets the type of the gateway as EventBased
 * ExclusiveEventBased - Sets the type of the gateway as ExclusiveEventBased
 * ParallelEventBased - Sets the type of the gateway as ParallelEventBased
 */
export  type BpmnGateways = 'None' | 'Exclusive' | 'Inclusive' | 'Parallel' | 'Complex' | 'EventBased' | 'ExclusiveEventBased' | 'ParallelEventBased';
/**
 * Defines the type of the Bpmn Data Objects
 * None - Sets the type of the data object as None
 * Input - Sets the type of the data object as Input
 * Output - Sets the type of the data object as Output
 */
export  type BpmnDataObjects = 'None' | 'Input' | 'Output';
/**
 * Defines the type of the Bpmn Activity
 * None - Sets the type of the Bpmn Activity as None
 * Task - Sets the type of the Bpmn Activity as Task
 * SubProcess - Sets the type of the Bpmn Activity as SubProcess
 */
export  type BpmnActivities = 'None' | 'Task' | 'SubProcess';
/**
 * Defines the type of the Bpmn Loops
 * None - Sets the type of the Bpmn loop as None
 * Standard - Sets the type of the Bpmn loop as Standard
 * ParallelMultiInstance - Sets the type of the Bpmn loop as ParallelMultiInstance
 * SequenceMultiInstance - Sets the type of the Bpmn loop as SequenceMultiInstance
 */
export  type BpmnLoops = 'None' | 'Standard' | 'ParallelMultiInstance' | 'SequenceMultiInstance';
/**
 * Defines the type of the Bpmn Tasks
 * None - Sets the type of the Bpmn Tasks as None
 * Service - Sets the type of the Bpmn Tasks as Service
 * Receive - Sets the type of the Bpmn Tasks as Receive
 * Send - Sets the type of the Bpmn Tasks as Send
 * InstantiatingReceive - Sets the type of the Bpmn Tasks as InstantiatingReceive
 * Manual - Sets the type of the Bpmn Tasks as Manual
 * BusinessRule - Sets the type of the Bpmn Tasks as BusinessRule
 * User - Sets the type of the Bpmn Tasks as User
 * Script - Sets the type of the Bpmn Tasks as Script
 */
export  type BpmnTasks = 'None' | 'Service' | 'Receive' | 'Send' | 'InstantiatingReceive' | 'Manual' | 'BusinessRule' | 'User' | 'Script';
/**
 * Defines the type of the Bpmn Subprocess
 * None - Sets the type of the Sub process as None
 * Transaction - Sets the type of the Sub process as Transaction
 * Event - Sets the type of the Sub process as Event
 */
export  type BpmnSubProcessTypes = 'None' | 'Transaction' | 'Event';
/**
 * Defines the type of the Bpmn boundary
 * Default - Sets the type of the boundary as Default
 * Call - Sets the type of the boundary as Call
 * Event - Sets the type of the boundary as Event
 */
export  type BpmnBoundary = 'Default' | 'Call' | 'Event';
/** @private */
export  type TransactionSubProcesses = 'processes' | 'success' | 'error' | 'cancel';
/**
 * Defines the connection shapes
 * Bpmn - Sets the type of the connection shape as Bpmn
 */
export  type ConnectionShapes = 'None' | 'Bpmn';
/**
 * Defines the type of the Bpmn flows
 * Sequence - Sets the type of the Bpmn Flow as Sequence
 * Association - Sets the type of the Bpmn Flow as Association
 * Message - Sets the type of the Bpmn Flow as Message
 */
export  type BpmnFlows = 'Sequence' | 'Association' | 'Message';
/**
 * Defines the type of the Bpmn Association Flows
 * Default - Sets the type of Association flow as Default
 * Directional - Sets the type of Association flow as Directional
 * BiDirectional - Sets the type of Association flow as BiDirectional
 */
export  type BpmnAssociationFlows = 'Default' | 'Directional' | 'BiDirectional';
/**
 * Defines the type of the Bpmn Message Flows
 * Default - Sets the type of the Message flow as Default
 * InitiatingMessage - Sets the type of the Message flow as InitiatingMessage
 * NonInitiatingMessage - Sets the type of the Message flow as NonInitiatingMessage
 */
export  type BpmnMessageFlows = 'Default' | 'InitiatingMessage' | 'NonInitiatingMessage';
/**
 * Defines the type of the Bpmn Sequence flows
 * Default - Sets the type of the sequence flow as Default
 * Normal - Sets the type of the sequence flow as Normal
 * Conditional - Sets the type of the sequence flow as Conditional
 */
export  type BpmnSequenceFlows = 'Default' | 'Normal' | 'Conditional';
/**
 * Defines the segment type of the connector
 * Straight - Sets the segment type as Straight
 * Orthogonal - Sets the segment type as Orthogonal
 * Arc - Sets the segment type as Arc
 * QuadraticBezier - Sets the segment type as QuadraticBezier
 * CubicBezier - Sets the segment type as CubicBezier
 */
export  type Segments = 'Straight' | 'Orthogonal' | 'Arc' | 'QuadraticBezier' | 'CubicBezier';
/**
 * Defines the decorator shape of the connector
 * None - Sets the decorator shape as None
 * Arrow - Sets the decorator shape as Arrow
 * Diamond - Sets the decorator shape as Diamond
 * Path - Sets the decorator shape as Path
 * OpenArrow - Sets the decorator shape as OpenArrow
 * Circle - Sets the decorator shape as Circle
 * Square - Sets the decorator shape as Square
 * Fletch - Sets the decorator shape as Fletch
 * OpenFetch - Sets the decorator shape as OpenFetch
 * IndentedArrow - Sets the decorator shape as Indented Arrow
 * OutdentedArrow - Sets the decorator shape as Outdented Arrow
 * DoubleArrow - Sets the decorator shape as DoubleArrow
 */
export  type DecoratorShapes = 'None' | 'Arrow' | 'Diamond' | 'Path' | 'OpenArrow' | 'Circle' | 'Square' | 'Fletch' | 'OpenFetch' | 'IndentedArrow' | 'OutdentedArrow' | 'DoubleArrow';
/**
 * Defines the shape of the ports
 * X - Sets the decorator shape as X
 * Circle - Sets the decorator shape as Circle
 * Square - Sets the decorator shape as Square
 * Custom - Sets the decorator shape as Custom
 */
export  type PortShapes = 'X' | 'Circle' | 'Square' | 'Custom';
export  type UnitMode = 'Absolute' | 'Fraction';
export  type EntryType = 'PositionChanged' | 'Align' | 'Distribute' | 'SizeChanged' | 'Sizing' | 'RotationChanged' | 'ConnectionChanged' | 'PropertyChanged' | 'CollectionChanged' | 'StartGroup' | 'EndGroup';
export  type EntryCategory = 'Internal' | 'External';
export  type EntryChangeType = 'Insert' | 'Remove';
export  enum Transform {
    Self = 1,
    Parent = 2,
}
export  type NudgeDirection = 'Left' | 'Right' | 'Up' | 'Down';
export  type Stretch = 'None' | 'Stretch' | 'Meet' | 'Slice';
export  type BoundaryConstraints = 'Infinity' | 'Diagram' | 'Page';
export  enum RenderMode {
    Canvas = 0,
    Svg = 1,
}
/**
 * Sets a combination of key modifiers, on recognition of which the command will be executed.They are
 * * None - no modifires are pressed
 * * Control - ctrl key
 * * Meta - meta key im mac
 * * Alt - alt key
 * * Shift - shift key
 * @private
 */
export  enum KeyModifiers {
    /** No modifiers are pressed */
    None = 0,
    /** The CTRL key */
    Control = 1,
    /** The Meta key pressed in Mac */
    Meta = 1,
    /** The ALT key */
    Alt = 2,
    /** The Shift key */
    Shift = 4,
}
/**
 * Sets the key value, on recognition of which the command will be executed. They are
 * * none - no key
 * * Number0 = The 0 key
 * * Number1 = The 1 key
 * * Number2 = The 2 key
 * * Number3 = The 3 key
 * * Number4 = The 4 key
 * * Number5 = The 5 key
 * * Number6 = The 6 key
 * * Number7 = The 7 key
 * * Number8 = The 8 key
 * * Number9 = The 9 key
 * * Number0 = The 0 key
 * * F2 = The f2 key
 * * A = The a key
 * * B = The b key
 * * C = The c key
 * * D = The d key
 * * E = The e key
 * * F = The f key
 * * G = The g key
 * * H = The h key
 * * I = The i key
 * * J = The j key
 * * K = The k key
 * * L = The l key
 * * M = The m key
 * * N = The n key
 * * O = The o key
 * * P = The p key
 * * Q = The q key
 * * R = The r key
 * * S = The s key
 * * T = The t key
 * * U = The u key
 * * V = The v key
 * * W = The w key
 * * X = The x key
 * * Y = The y key
 * * Z = The z key
 * * Left = The left key
 * * Right = The right key
 * * Top = The top key
 * * Bottom = The bottom key
 * * Escape = The Escape key
 * * Tab = The tab key
 * * Delete = The delete key
 * * Enter = The enter key
 * @private
 */
export  enum Keys {
    /** No key pressed */
    None,
    /** The 0 key */
    Number0 = 0,
    /** The 1 key */
    Number1 = 1,
    /** The 2 key */
    Number2 = 2,
    /** The 3 key */
    Number3 = 3,
    /** The 4 key */
    Number4 = 4,
    /** The 5 key */
    Number5 = 5,
    /** The 6 key */
    Number6 = 6,
    /** The 7 key */
    Number7 = 7,
    /** The 8 key */
    Number8 = 8,
    /** The 9 key */
    Number9 = 9,
    /** The F2 key */
    F2 = 113,
    /** The A key */
    A = 65,
    /** The B key */
    B = 66,
    /** The C key */
    C = 67,
    /** The D key */
    D = 68,
    /** The E key */
    E = 69,
    /** The F key */
    F = 70,
    /** The G key */
    G = 71,
    /** The H key */
    H = 72,
    /** The I key */
    I = 73,
    /** The J key */
    J = 74,
    /** The K key */
    K = 75,
    /** The L key */
    L = 76,
    /** The M key */
    M = 77,
    /** The N key */
    N = 78,
    /** The O key */
    O = 79,
    /** The P key */
    P = 80,
    /** The Q key */
    Q = 81,
    /** The R key */
    R = 82,
    /** The S key */
    S = 83,
    /** The T key */
    T = 84,
    /** The U key */
    U = 85,
    /** The V key */
    V = 86,
    /** The W key */
    W = 87,
    /** The X key */
    X = 88,
    /** The Y key */
    Y = 89,
    /** The Z key */
    Z = 90,
    /** The left arrow key */
    Left = 37,
    /** The up arrow key */
    Up = 38,
    /** The right arrow key */
    Right = 39,
    /** The down arrow key */
    Down = 40,
    /** The Escape key */
    Escape = 27,
    /** The delete key */
    Delete = 46,
    /** The tab key */
    Tab = 9,
    /** The enter key */
    Enter = 13,
}
/**
 * Enables/Disables certain actions of diagram
 * @private
 */
export  enum DiagramAction {
    Render = 2,
    PublicMethod = 4,
    ToolAction = 8,
    UndoRedo = 16,
    TextEdit = 32,
}
/** @private */
export  enum NoOfSegments {
    Zero = 0,
    One = 1,
    Two = 2,
    Three = 3,
    Four = 4,
    Five = 5,
}
/** @private */
export  type SourceTypes = 'HierarchicalData' | 'MindMap';
/**
 * Defines the relative mode of the tooltip
 * Object - sets the tooltip position relative to the node
 * Mouse - sets the tooltip position relative to the mouse
 */
export  type TooltipRelativeMode = 'Object' | 'Mouse';
/**
 * Collections of icon content shapes.
 * None
 * Minus - sets the icon shape as minus
 * Plus - sets the icon shape as Plus
 * ArrowUp - sets the icon shape as ArrowUp
 * ArrowDown - sets the icon shape as ArrowDown
 * Template - sets the icon shape based on  the given  custom template
 * Path - sets the icon shape based on the given  custom Path
 */
export  type IconShapes = 'None' | 'Minus' | 'Plus' | 'ArrowUp' | 'ArrowDown' | 'Template' | 'Path';
/**
 * Defines the collection of sub tree orientations in an organizational chart
 * Vertical - Aligns the child nodes in vertical manner
 * Horizontal - Aligns the child nodes in horizontal manner
 */
export  type SubTreeOrientation = 'Vertical' | 'Horizontal';
/**
 * Defines the collection of sub tree alignments in an organizational chart
 * Left - Aligns the child nodes at the left of the parent in a horizontal/vertical sub tree
 * Right - Aligns the child nodes at the right of the parent in a horizontal/vertical sub tree
 * Center - Aligns the child nodes at the center of the parent in a horizontal sub tree
 * Alternate - Aligns the child nodes at both left and right sides of the parent in a vertical sub tree
 * Balanced - Aligns the child nodes in multiple rows to balance the width and height of the horizontal sub tree
 */
export  type SubTreeAlignments = 'Left' | 'Right' | 'Center' | 'Alternate' | 'Balanced';
/**
 * events of diagram
 * @private
 */
export  enum DiagramEvent {
    'collectionChange' = 0,
    'rotateChange' = 1,
    'positionChange' = 2,
    'propertyChange' = 3,
    'selectionChange' = 4,
    'sizeChange' = 5,
    'sourcePointChange' = 6,
    'targetPointChange' = 7,
    'connectionChange' = 8,
    'animationComplete' = 9,
    'drop' = 10,
}
/**
 * Defines the zoom type
 * ZoomIn - Zooms in the diagram control
 * ZoomOut - Zooms out the diagram control
 */
export  type ZoomTypes = 'ZoomIn' | 'ZoomOut';
/**
 * Defines how the diagram has to fit into view
 * Page - Fits the diagram content within the viewport
 * Width - Fits the width of the diagram content within the viewport
 * Height - Fits the height of the diagram content within the viewport
 */
export  type FitModes = 'Page' | 'Width' | 'Height';
/** @private */
export  type SelectionChangeCause = 'Interaction' | 'Commands' | 'Keyboard' | 'Unknown';
/** @private */
export  type EventState = 'Changing' | 'Changed' | 'Cancelled';
/** @private */
export  type State = 'Start' | 'Progress' | 'Completed';
/** @private */
export  type ChangeType = 'Addition' | 'Removal';
/**
 * Diagram component exported items
 */
/**
 * Finds the action to be taken for the object under mouse
 *
 */
/** @private */
export  function findToolToActivate(obj: object, wrapper: DiagramElement, position: PointModel, diagram: Diagram, touchStart?: ITouches[] | TouchList, touchMove?: ITouches[] | TouchList): Actions;
/** @private */
export  function contains(mousePosition: PointModel, corner: PointModel, padding: number): boolean;
/** @private */
export  function hasSelection(diagram: Diagram): boolean;
/** @private */
export  function hasSingleConnection(diagram: Diagram): boolean;
/** @private */
export  function isSelected(diagram: Diagram, element: object): boolean;
/** @private */
export  type Actions = 'None' | 'Select' | 'Drag' | 'ResizeWest' | 'ConnectorSourceEnd' | 'ConnectorTargetEnd' | 'ResizeEast' | 'ResizeSouth' | 'ResizeNorth' | 'ResizeSouthEast' | 'ResizeSouthWest' | 'ResizeNorthEast' | 'ResizeNorthWest' | 'Rotate' | 'ConnectorEnd' | 'Custom' | 'Draw' | 'Pan' | 'BezierSourceThumb' | 'BezierTargetThumb' | 'LayoutAnimation' | 'PinchZoom' | 'HyperLink';
/** @private */
export  function getCursor(cursor: Actions, angle: number): string;
/**
 * Defines the behavior of commands
 */
export  class CommandHandler {
    clipboardData: ClipBoardObject;
    private state;
    private diagram;
    readonly snappingModule: SnappingController;
    readonly layoutAnimateModule: LayoutAnimation;
    constructor(diagram: Diagram);
    /** @private */
    startTransaction(): void;
    /** @private */
    endTransaction(): void;
    /**
     * @private
     */
    showTooltip(node: IElement, position: PointModel, content: string, toolName: string, isTooltipVisible: boolean): void;
    /**
     * @private
     */
    closeTooltip(): void;
    /**
     * @private
     */
    canEnableDefaultTooltip(): boolean;
    /**
     * @private
     */
    updateSelector(): void;
    /**
     * @private
     */
    triggerEvent(event: DiagramEvent, args: object): void;
    /**
     * @private
     */
    disConnect(obj: IElement, endPoint?: string): void;
    private connectionEventChange(connector, oldChanges, newChanges, endPoint);
    /**
     * @private
     */
    findTarget(element: DiagramElement, argsTarget: IElement): NodeModel | PointPortModel;
    /**
     * @private
     */
    connect(endPoint: string, args: MouseEventArgs): void;
    /** @private */
    cut(): void;
    /** @private */
    addLayer(layer: LayerModel, objects?: object[]): void;
    /** @private */
    getObjectLayer(objectName: string): LayerModel;
    /** @private */
    getLayer(layerName: string): LayerModel;
    /** @private */
    removeLayer(layerId: string): void;
    /** @private */
    moveObjects(objects: string[], targetLayer?: string): void;
    /** @private */
    cloneLayer(layerName: string): void;
    /** @private */
    updateEdges(node: Node): void;
    /** @private */
    copy(): object;
    /** @private */
    cloneElement(): Object[];
    /** @private */
    paste(obj: NodeModel | ConnectorModel): void;
    /** @private */
    pasteObject(obj: Node | Connector, multiSelect: boolean, pasteObject: object): void;
    /**
     * @private
     */
    private updateNodeEdges(object, pasteObject, isInEdge);
    /**
     * @private
     */
    private updateConnectorTarget(obj, pasteObject, isInEdge);
    /**
     * @private
     */
    cloneObject(obj: Node | Connector): Node | Connector;
    /**
     * @private
     */
    addObject(obj: Node | Connector): void;
    /** @private */
    updateConnector(node: Connector): void;
    /** @private */
    selectObjects(obj: (NodeModel | ConnectorModel)[], multipleSelection?: boolean, oldValue?: (NodeModel | ConnectorModel)[]): void;
    /** @private */
    select(obj: NodeModel | ConnectorModel, multipleSelection?: boolean): void;
    /** @private */
    unSelect(obj: NodeModel | ConnectorModel): void;
    /** @private */
    getChildElements(child: DiagramElement[]): string[];
    private moveSvgNode(nodeId, targetID);
    /** @private */
    sendLayerBackward(layerName: string): void;
    /** @private */
    bringLayerForward(layerName: string): void;
    /** @private */
    sendToBack(): void;
    /** @private */
    bringToFront(): void;
    /** @private */
    sortByZIndex(nodeArray: object[], sortID?: string): object[];
    /** @private */
    sendForward(): void;
    /** @private */
    sendBackward(): void;
    initSelectorWrapper(): void;
    /** @private */
    doRubberBandSelection(region: Rect): void;
    /** @private */
    dragConnectorEnds(endPoint: string, obj: IElement, point: PointModel): boolean;
    getSelectedObject(): (NodeModel | ConnectorModel)[];
    /** @private */
    clearSelection(triggerAction?: boolean): void;
    /** @private */
    drag(obj: NodeModel | ConnectorModel, tx: number, ty: number): void;
    /** @private */
    updateEndPoint(connector: Connector): void;
    /** @private */
    dragSourceEnd(obj: ConnectorModel, tx: number, ty: number, preventUpdate?: boolean, point?: PointModel, endPoint?: string, update?: boolean): boolean;
    /**
     * Translate the bezier points during the interaction
     */
    private translateBezierPoints(connector, value, tx, ty, point?, update?);
    /** @private */
    dragTargetEnd(obj: ConnectorModel, tx: number, ty: number, preventUpdate?: boolean, point?: PointModel, endPoint?: string, update?: boolean): boolean;
    /** @private */
    rotate(obj: NodeModel | ConnectorModel, angle: number, pivot: PointModel): void;
    /** @private */
    snapConnectorEnd(currentPosition: PointModel): PointModel;
    snapAngle(angle: number): number;
    rotatePoints(conn: ConnectorModel, angle: number, pivot: PointModel): void;
    /** @private */
    scale(obj: NodeModel | ConnectorModel, sw: number, sh: number, pivot: PointModel, refObject?: IElement): boolean;
    scaleObject(sw: number, sh: number, pivot: PointModel, obj: IElement, element: DiagramElement, refObject: IElement): void;
    checkBoundaryConstraints(tx: number, ty: number, nodeBounds?: Rect): boolean;
    /** @private */
    dragSelectedObjects(tx: number, ty: number): boolean;
    /** @private */
    scaleSelectedItems(sx: number, sy: number, pivot: PointModel): boolean;
    /** @private */
    rotateSelectedItems(angle: number): boolean;
    /** @private */
    hasSelection(): boolean;
    /** @private */
    isSelected(element: IElement): boolean;
    /**
     * initExpand is used for layout expand and collapse interaction
     */
    initExpand(args: MouseEventArgs): void;
    /**
     * @private
     */
    updateNodeDimension(obj: Node | Connector, rect?: Rect): void;
    /** @private */
    highlightSelectedRegion(x: number, y: number, width: number, height: number): void;
    /**
     * @private
     */
    renderHighlighter(args: MouseEventArgs, connectHighlighter?: boolean): void;
    /** @private */
    mouseOver(source: IElement, target: IElement, position: PointModel): boolean;
    /**
     * @private
     */
    snapPoint(startPoint: PointModel, endPoint: PointModel, tx: number, ty: number): PointModel;
    /**
     * @private
     */
    removeSnap(): void;
    /** @private */
    drop(source: IElement, target: IElement, position: PointModel): void;
    /** @private */
    resetDragState(): void;
    /** @private */
    resetScaleState(): void;
    /** @private */
    resetRotation(): void;
    /** @private */
    addHistoryEntry(entry: HistoryEntryModel): void;
    /** @private */
    align(objects: (NodeModel | ConnectorModel)[], option: AlignmentOptions): void;
    /** @private */
    distribute(objects: (NodeModel | ConnectorModel)[], option: DistributeOptions): void;
    /** @private */
    sameSize(objects: (NodeModel | ConnectorModel)[], option: SizingOptions): void;
    private storeObject(selectorObject, object);
    /** @private */
    scroll(scrollX: number, scrollY: number, focusPoint?: PointModel): void;
    /**
     * @private
     */
    drawHighlighter(element: IElement): void;
    /**
     * @private
     */
    removeHighlighter(): void;
    /** @private */
    zoom(scale: number, scrollX: number, scrollY: number, focusPoint?: PointModel): void;
}
/** @private */
export interface TransactionState {
    element: SelectorModel;
    backup: ObjectState;
}
/** @private */
export interface ClipBoardObject {
    pasteIndex?: number;
    clipObject?: object;
}
/** @private */
export interface ObjectState {
    offsetX?: number;
    offsetY?: number;
    width?: number;
    height?: number;
    pivot?: PointModel;
    angle?: number;
}
/**
 * This module handles the mouse and touch events
 */
export  class DiagramEventHandler {
    private currentAction;
    private action;
    private isBlocked;
    private blocked;
    private commandHandler;
    private isMouseDown;
    private inAction;
    private currentPosition;
    private timeOutValue;
    private doingAutoScroll;
    private prevPosition;
    private diagram;
    private objectFinder;
    private tool;
    private eventArgs;
    private hoverElement;
    private initialEventArgs;
    /** @private */
    touchStartList: ITouches[] | TouchList;
    /** @private */
    touchMoveList: ITouches[] | TouchList;
    /** @private */
    constructor(diagram: Diagram, commandHandler: CommandHandler);
    /** @private */
    getMousePosition(e: MouseEvent | PointerEvent | TouchEvent): PointModel;
    /** @private */
    private updateCursor();
    mouseDown(evt: PointerEvent): void;
    /** @private */
    mouseMove(e: PointerEvent | TouchEvent, touches: TouchList): void;
    private checkAutoScroll(e);
    /** @private */
    mouseUp(evt: PointerEvent): void;
    /** @private */
    mouseLeave(evt: PointerEvent): void;
    /** @private */
    mouseWheel(evt: WheelEvent): void;
    /** @private */
    keyDown(evt: KeyboardEvent): void;
    private startAutoScroll(e);
    private doAutoScroll(option, e, delay?, autoScroll?);
    private elementEnter(mousePosition, elementOver);
    private elementLeave();
    private altKeyPressed(keyModifier);
    private ctrlKeyPressed(keyModifier);
    private shiftKeyPressed(keyModifier);
    /** @private */
    scrolled(evt: PointerEvent): void;
    doubleClick(evt: PointerEvent): void;
    /**
     * @private
     */
    inputChange(evt: inputs.InputArgs): void;
    private checkEditBoxAsTarget(evt);
    private getMouseEventArgs(position, args, source?);
    /** @private */
    getTool(action: Actions): ToolBase;
    /** @private */
    getCursor(action: Actions): string;
    /** @private */
    findElementUnderMouse(obj: IElement, position: PointModel): DiagramElement;
    /** @private */
    findObjectsUnderMouse(position: PointModel, source?: IElement): IElement[];
    /** @private */
    findObjectUnderMouse(objects: (NodeModel | ConnectorModel)[], action: Actions, inAction: boolean): IElement;
    /** @private */
    findTargetUnderMouse(objects: (NodeModel | ConnectorModel)[], action: Actions, inAction: boolean): IElement;
    /** @private */
    findActionToBeDone(obj: NodeModel | ConnectorModel, wrapper: DiagramElement, position: PointModel): Actions;
}
/** @private */
export interface Info {
    ctrlKey?: boolean;
}
/** @private */
export interface MouseEventArgs {
    position?: PointModel;
    source?: IElement;
    sourceWrapper?: DiagramElement;
    target?: IElement;
    targetWrapper?: DiagramElement;
    info?: Info;
    startTouches?: TouchList | ITouches[];
    moveTouches?: TouchList | ITouches[];
}
/**
 * Diagram scroller module handles the size of diagrams
 */
export  class DiagramScroller {
    /** @private */
    transform: TransformFactor;
    private diagram;
    private objects;
    /** @private */
    horizontalOffset: number;
    /** @private */
    verticalOffset: number;
    /** @private */
    viewPortWidth: number;
    /** @private */
    viewPortHeight: number;
    private diagramWidth;
    private diagramHeight;
    /** @private */
    scrollerWidth: number;
    private hScrollSize;
    private vScrollSize;
    constructor(diagram: Diagram);
    /** @private */
    updateScrollOffsets(hOffset?: number, vOffset?: number): void;
    /** @private */
    setScrollOffset(hOffset: number, vOffset: number): void;
    /** @private */
    setSize(): void;
    /** @private */
    setViewPortSize(width: number, height: number): void;
    /**
     * To get page pageBounds
     * @private
     */
    getPageBounds(boundingRect?: boolean, region?: DiagramRegions): Rect;
    /**
     * To get page break when PageBreak is set as true
     * @private
     */
    getPageBreak(pageBounds: Rect): Segment[];
    /** @private */
    zoom(factor: number, deltaX?: number, deltaY?: number, focusPoint?: PointModel): void;
    /** @private */
    fitToPage(options?: IFitOptions): void;
    /** @private */
    bringIntoView(rect: Rect): void;
    /** @private */
    bringToCenter(bounds: Rect): void;
}
/** @private */
export interface TransformFactor {
    tx: number;
    ty: number;
    scale: number;
}
export interface Segment {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
}
/**
 * Interface for a class UserHandle
 */
export interface UserHandleModel {
    /**
     * Defines the name of user Handle
     * @default ''
     */
    name?: string;
    /**
     * Defines the path data of user Handle 
     * @default ''
     */
    pathData?: string;
    /**
     * Defines the background color of user Handle 
     * @default ''
     */
    backgroundColor?: string;
    /**
     * Defines the side of user Handle 
     * @default ''
     */
    side?: Side;
    /**
     * Defines the borderColor of user Handle 
     * @default ''
     */
    borderColor?: string;
    /**
     * Defines the borderWidth of user Handle 
     * @default ''
     */
    borderWidth?: number;
    /**
     * Defines the size of user Handle 
     * @default ''
     */
    size?: number;
    /**
     * Defines the path color of user Handle 
     * @default ''
     */
    pathColor?: string;
    /**
     * Defines the tool of user Handle 
     * @default 10
     */
    disPlacement?: number;
    /**
     * Defines the visible of user Handle 
     * @default true
     */
    visible?: boolean;
    /**
     * Defines the offset of user Handle 
     * @default 0
     */
    offset?: number;
    /**
     * Defines the margin of the user handle
     * @default { left: 0, right: 0, top: 0, bottom:0 }
     */
    margin?: MarginModel;
    /**
     * Defines the horizontalAlignment of user Handle 
     * @default 'Center'
     */
    horizontalAlignment?: HorizontalAlignment;
    /**
     * Defines the verticalAlignment of user Handle 
     * @default 'Center'
     */
    verticalAlignment?: VerticalAlignment;
}
/**
 * Interface for a class Selector
 */
export interface SelectorModel {
    /**
     * Defines the size and position of the container
     */
    wrapper?: Container;
    /**
     * Defines the collection of selected nodes
     */
    nodes?: NodeModel[];
    /**
     * Defines the collection of selected connectors
     */
    connectors?: ConnectorModel[];
    /**
     * Sets/Gets the width of the container
     */
    width?: number;
    /**
     * Sets/Gets the height of the container
     */
    height?: number;
    /**
     * set the constraint of the container
     */
    thumbsConstraints?: ThumbsConstraints;
    /**
     * Sets the rotate angle of the container
     */
    rotateAngle?: number;
    /**
     * Sets the position of the container
     */
    offsetX?: number;
    /**
     * Sets the position of the container
     */
    offsetY?: number;
    /**
     * Sets the pivot of the selector
     */
    pivot?: PointModel;
    /**
     * Defines how to pick the objects to be selected using rubber band selection
     */
    rubberBandSelectionMode?: RubberBandSelectionMode;
    /**
     * Defines the collection of user handle connectors
     */
    userHandles?: UserHandleModel[];
    /**
     * Defines how to pick the objects to be selected 
     */
    constraints?: SelectorConstraints;
}
/**
 * Defines the behavior of selector
 */
export  class UserHandle extends base.ChildProperty<UserHandle> {
    /**
     * Defines the name of user Handle
     * @default ''
     */
    name: string;
    /**
     * Defines the path data of user Handle
     * @default ''
     */
    pathData: string;
    /**
     * Defines the background color of user Handle
     * @default ''
     */
    backgroundColor: string;
    /**
     * Defines the side of user Handle
     * @default ''
     */
    side: Side;
    /**
     * Defines the borderColor of user Handle
     * @default ''
     */
    borderColor: string;
    /**
     * Defines the borderWidth of user Handle
     * @default ''
     */
    borderWidth: number;
    /**
     * Defines the size of user Handle
     * @default ''
     */
    size: number;
    /**
     * Defines the path color of user Handle
     * @default ''
     */
    pathColor: string;
    /**
     * Defines the tool of user Handle
     * @default 10
     */
    disPlacement: number;
    /**
     * Defines the visible of user Handle
     * @default true
     */
    visible: boolean;
    /**
     * Defines the offset of user Handle
     * @default 0
     */
    offset: number;
    /**
     * Defines the margin of the user handle
     * @default { left: 0, right: 0, top: 0, bottom:0 }
     */
    margin: MarginModel;
    /**
     * Defines the horizontalAlignment of user Handle
     * @default 'Center'
     */
    horizontalAlignment: HorizontalAlignment;
    /**
     * Defines the verticalAlignment of user Handle
     * @default 'Center'
     */
    verticalAlignment: VerticalAlignment;
}
/**
 * Defines the behavior of the selected objects
 */
export  class Selector extends base.ChildProperty<Selector> implements IElement {
    /**
     * Defines the size and position of the container
     */
    wrapper: Container;
    /**
     * Defines the collection of selected nodes
     */
    nodes: NodeModel[];
    /**
     * Defines the collection of selected connectors
     */
    connectors: ConnectorModel[];
    /**
     * Sets/Gets the width of the container
     */
    width: number;
    /**
     * Sets/Gets the height of the container
     */
    height: number;
    /**
     * set the constraint of the container
     */
    thumbsConstraints: ThumbsConstraints;
    /**
     * Sets the rotate angle of the container
     */
    rotateAngle: number;
    /**
     * Sets the position of the container
     */
    offsetX: number;
    /**
     * Sets the position of the container
     */
    offsetY: number;
    /**
     * Sets the pivot of the selector
     */
    pivot: PointModel;
    /**
     * Defines how to pick the objects to be selected using rubber band selection
     */
    rubberBandSelectionMode: RubberBandSelectionMode;
    /**
     * Defines the collection of user handle connectors
     */
    userHandles: UserHandleModel[];
    /**
     * Defines how to pick the objects to be selected
     */
    constraints: SelectorConstraints;
    /**
     * Initializes the UI of the container
     */
    init(diagram: Diagram): Container;
}
/**
 * Quad helps to maintain a set of objects that are contained within the particular region
 */
/** @private */
export  class Quad {
    /** @private */
    objects: IGroupable[];
    /** @private */
    left: number;
    /** @private */
    top: number;
    /** @private */
    width: number;
    /** @private */
    height: number;
    /** @private */
    first: Quad;
    /** @private */
    second: Quad;
    /** @private */
    third: Quad;
    /** @private */
    fourth: Quad;
    /** @private */
    parent: Quad;
    private spatialSearch;
    /** @private */
    constructor(left: number, top: number, width: number, height: number, spatialSearching: SpatialSearch);
    /** @private */
    findQuads(currentViewPort: Rect, quads: Quad[]): void;
    private isIntersect(t);
    /** @private */
    selectQuad(): Quad;
    private getQuad(target);
    /** @private */
    isContained(): boolean;
    /** @private */
    addIntoAQuad(node: IGroupable): Quad;
    private add(quad);
}
/** @private */
export interface QuadSet {
    target?: Quad;
    source?: Quad;
}
/** @private */
export interface QuadAddition {
    quad?: Quad;
    isAdded?: boolean;
}
/**
 * Spatial search module helps to effectively find the objects over diagram
 */
export  class SpatialSearch {
    private topElement;
    private bottomElement;
    private rightElement;
    private leftElement;
    private quadSize;
    private quadTable;
    private objectTable;
    /** @private */
    parentQuad: Quad;
    private pageLeft;
    private pageRight;
    private pageTop;
    private pageBottom;
    /** @private */
    childLeft: number;
    /** @private */
    childTop: number;
    /** @private */
    childRight: number;
    /** @private */
    childBottom: number;
    /** @private */
    childNode: IGroupable;
    /** @private */
    constructor(objectTable: object);
    /** @private */
    removeFromAQuad(node: IGroupable): void;
    private update(quad);
    private addIntoAQuad(node);
    updateQuad(node: IGroupable): boolean;
    private isWithinPageBounds(node);
    /** @private */
    findQuads(region: Rect): Quad[];
    /** @private */
    findObjects(region: Rect): IGroupable[];
    /** @private */
    updateBounds(node: IGroupable): boolean;
    private findBottom(quad);
    private findRight(quad);
    private findLeft(quad);
    private findTop(quad);
    /** @private */
    setCurrentNode(node: IGroupable): void;
    /** @private */
    getPageBounds(originX?: number, originY?: number): Rect;
    /** @private */
    getQuad(node: IGroupable): Quad;
}
/** @private */
export interface IGroupable {
    id: string;
    outerBounds: Rect;
}
/**
 * Defines the interactive tools
 */
export  class ToolBase {
    /**
     * Initializes the tool
     * @param command Command that is corresponding to the current action
     */
    constructor(command: CommandHandler);
    /**
     * Command that is corresponding to the current action
     */
    protected commandHandler: CommandHandler;
    /**
     * Sets/Gets whether the interaction is being done
     */
    protected inAction: boolean;
    /**
     * Sets/Gets the current mouse position
     */
    protected currentPosition: PointModel;
    /**
     * Sets/Gets the previous mouse position
     */
    prevPosition: PointModel;
    /**
     * Sets/Gets the initial mouse position
     */
    protected startPosition: PointModel;
    /**
     * Sets/Gets the current element that is under mouse
     */
    protected currentElement: IElement;
    blocked: boolean;
    protected isTooltipVisible: boolean;
    /**
     * Sets/Gets the previous object when mouse down
     */
    protected undoElement: SelectorModel;
    protected startAction(currentElement: IElement): void;
    mouseDown(args: MouseEventArgs): void;
    mouseMove(args: MouseEventArgs): boolean;
    mouseUp(args: MouseEventArgs): void;
    protected endAction(): void;
    abort(): void;
}
/**
 * Helps to select the objects
 */
export  class SelectTool extends ToolBase {
    mouseDown(args: MouseEventArgs): void;
    mouseMove(args: MouseEventArgs): boolean;
    mouseUp(args: MouseEventArgs): void;
}
/**
 * Helps to edit the selected connectors
 */
export  class ConnectTool extends ToolBase {
    protected endPoint: string;
    constructor(commandHandler: CommandHandler, endPoint: string);
    mouseDown(args: MouseEventArgs): void;
    mouseUp(args: MouseEventArgs): void;
    mouseMove(args: MouseEventArgs): boolean;
    private getTooltipContent(node);
    abort(): void;
    endAction(): void;
}
/**
 * Drags the selected objects
 */
export  class MoveTool extends ToolBase {
    /**
     * Sets/Gets the previous mouse position
     */
    prevPosition: PointModel;
    private initialOffset;
    currentTarget: IElement;
    constructor(commandHandler: CommandHandler);
    mouseDown(args: MouseEventArgs): void;
    mouseUp(args: MouseEventArgs): void;
    mouseMove(args: MouseEventArgs): boolean;
    private getTooltipContent(node);
    abort(): void;
    endAction(): void;
}
/**
 * Rotates the selected objects
 */
export  class RotateTool extends ToolBase {
    constructor(commandHandler: CommandHandler);
    mouseDown(args: MouseEventArgs): void;
    mouseUp(args: MouseEventArgs): void;
    mouseMove(args: MouseEventArgs): boolean;
    private getTooltipContent(node);
    abort(): void;
    endAction(): void;
}
/**
 * Scales the selected objects
 */
export  class ResizeTool extends ToolBase {
    /**
     * Sets/Gets the previous mouse position
     */
    prevPosition: PointModel;
    private corner;
    initialOffset: PointModel;
    initialBounds: Rect;
    constructor(commandHandler: CommandHandler, corner: string);
    mouseDown(args: MouseEventArgs): void;
    mouseUp(args: MouseEventArgs): boolean;
    mouseMove(args: MouseEventArgs): boolean;
    private getTooltipContent(node);
    private getPivot();
    private getChanges(change);
    /**
     * Updates the size with delta width and delta height using scaling.
     */
    private updateSize(shape, startPoint, endPoint, corner);
    /**
     * Aspect ratio used to resize the width or height based on resizing the height or width
     */
    private scaleObjects(matrix, deltaWidth, deltaHeight, corner, startPoint, endPoint, source?);
    abort(): void;
}
/**
 * Draws a node that is defined by the user
 */
export  class NodeDrawingTool extends ToolBase {
    /** @private */
    drawingObject: Node | Connector;
    /** @private */
    sourceObject: Node | Connector;
    constructor(commandHandler: CommandHandler, sourceObject: Node | Connector);
    mouseDown(args: MouseEventArgs): void;
    mouseMove(args: MouseEventArgs): boolean;
    mouseUp(args: MouseEventArgs): void;
    endAction(): void;
}
/**
 * Draws a connector that is defined by the user
 */
export  class ConnectorDrawingTool extends ConnectTool {
    /** @private */
    drawingObject: Node | Connector;
    /** @private */
    sourceObject: Node | Connector;
    constructor(commandHandler: CommandHandler, endPoint: string, sourceObject: Node | Connector);
    mouseDown(args: MouseEventArgs): void;
    mouseMove(args: MouseEventArgs): boolean;
    mouseUp(args: MouseEventArgs): void;
    endAction(): void;
}
/**
 * Pans the diagram control on drag
 */
export  class ZoomPanTool extends ToolBase {
    private zooming;
    constructor(commandHandler: CommandHandler, zoom: boolean);
    mouseDown(args: MouseEventArgs): void;
    mouseMove(args: MouseEventArgs): boolean;
    mouseUp(args: MouseEventArgs): void;
    endAction(): void;
    private getDistance(touch1, touch2);
    private updateTouch(startTouch, moveTouch);
}
/**
 * Animate the layout during expand and collapse
 */
export  class ExpandTool extends ToolBase {
    constructor(commandHandler: CommandHandler);
    mouseUp(args: MouseEventArgs): void;
}
/**
 * Opens the annotation hypeLink at mouse up
 */
export  class LabelTool extends ToolBase {
    constructor(commandHandler: CommandHandler);
    mouseUp(args: MouseEventArgs): void;
}
/**
 * Interface for a class Layout
 */
export interface LayoutModel {
    /**
     * Sets the name of the node with respect to which all other nodes will be translated
     * @default ''
     */
    fixedNode?: string;
    /**
     * Sets the space that has to be horizontally left between the nodes
     * @default 30
     */
    horizontalSpacing?: number;
    /**
     * Sets the space that has to be Vertically left between the nodes
     * @default 30
     */
    verticalSpacing?: number;
    /**
     * MaxIteration 
     * @default 30
     */
    maxIteration?: number;
    /**
     * springFactor
     * @default 40
     */
    springFactor?: number;
    /**
     * springLength
     * @default 50
     */
    springLength?: number;
    /**
     * * Defines the space between the viewport and the layout
     * @default 0
     */
    margin?: MarginModel;
    /**
     * Defines how the layout has to be horizontally aligned
     * @default 'Auto'
     */
    horizontalAlignment?: HorizontalAlignment;
    /**
     * Defines how the layout has to be Vertically aligned
     * @default 'Auto'
     */
    verticalAlignment?: VerticalAlignment;
    /**
     * Defines the orientation of layout
     * @default LayoutOrientation.TopToBottom
     */
    layoutOrientation?: LayoutOrientation;
    /**
     * Sets how to define the connection direction (first segment direction & last segment direction).
     * @default 'Auto'
     */
    connectionDirection?: ConnectionDirection;
    /**
     * Sets whether the segments have to be customized based on the layout or not
     * @default ConnectorSegments.Default
     */
    connectorSegments?: ConnectorSegments;
    /**
     * Defines the Type of Layout
     * @default LayoutType.Organizational
     */
    type?: LayoutType;
    /**
     * getLayout Info
     */
    getLayoutInfo?: Function;
    /**
     * Aligns the layout within the given bounds
     */
    bounds?: Rect;
    /**
     * Animation feature for layout
     */
    enableAnimation?: boolean;
    /**
     * Root node name  of the layout 
     */
    root?: string;
}
/**
 * Defines the behavior of the automatic layouts
 */
export  class Layout extends base.ChildProperty<Layout> {
    /**
     * Sets the name of the node with respect to which all other nodes will be translated
     * @default ''
     */
    fixedNode: string;
    /**
     * Sets the space that has to be horizontally left between the nodes
     * @default 30
     */
    horizontalSpacing: number;
    /**
     * Sets the space that has to be Vertically left between the nodes
     * @default 30
     */
    verticalSpacing: number;
    /**
     * MaxIteration
     * @default 30
     */
    maxIteration: number;
    /**
     * springFactor
     * @default 40
     */
    springFactor: number;
    /**
     * springLength
     * @default 50
     */
    springLength: number;
    /**
     * * Defines the space between the viewport and the layout
     * @default 0
     */
    margin: MarginModel;
    /**
     * Defines how the layout has to be horizontally aligned
     * @default 'Auto'
     */
    horizontalAlignment: HorizontalAlignment;
    /**
     * Defines how the layout has to be Vertically aligned
     * @default 'Auto'
     */
    verticalAlignment: VerticalAlignment;
    /**
     * Defines the orientation of layout
     * @default LayoutOrientation.TopToBottom
     */
    layoutOrientation: LayoutOrientation;
    /**
     * Sets how to define the connection direction (first segment direction & last segment direction).
     * @default 'Auto'
     */
    connectionDirection: ConnectionDirection;
    /**
     * Sets whether the segments have to be customized based on the layout or not
     * @default ConnectorSegments.Default
     */
    connectorSegments: ConnectorSegments;
    /**
     * Defines the Type of Layout
     * @default LayoutType.Organizational
     */
    type: LayoutType;
    /**
     * getLayout Info
     */
    getLayoutInfo: Function;
    /**
     * Aligns the layout within the given bounds
     */
    bounds: Rect;
    /**
     * Animation feature for layout
     */
    enableAnimation: boolean;
    /**
     * Root node name  of the layout
     */
    root: string;
}
/**
 * Defines the properties of the node
 */
export interface INode {
    id: string;
    offsetX: number;
    offsetY: number;
    actualSize: {
        width: number;
        height: number;
    };
    inEdges: string[];
    outEdges: string[];
    pivot: PointModel;
    excludeFromLayout: boolean;
    isExpanded: boolean;
    data: object;
    treeBounds?: Bounds;
    differenceX?: number;
    differenceY?: number;
}
/**
 * Defines the properties of the connector
 */
export interface IConnector {
    id: string;
    sourceID: string;
    targetID: string;
    visited?: boolean;
    visible?: boolean;
    points?: PointModel[];
}
export interface Bounds {
    x: number;
    y: number;
    right: number;
    bottom: number;
    canMoveBy?: number;
}
export interface TreeInfo {
    orientation?: SubTreeOrientation;
    type?: SubTreeAlignments;
    offset?: number;
    enableRouting?: boolean;
    children?: string[];
    assistants?: string[];
    level?: number;
    hasSubTree?: boolean;
    rows?: number;
}
/**
 * Hierarchical Tree and Organizational Chart
 */
export  class HierarchicalTree {
    /**
     * Constructor for the organizational chart module.
     * @private
     */
    constructor();
    /**
     * To destroy the organizational chart
     * @return {void}
     * @private
     */
    destroy(): void;
    /**
     * Defines the layout animation
     *
     */
    isAnimation: boolean;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    updateLayout(nodes: INode[], nameTable: object, layoutProp: Layout, viewport: PointModel, uniqueId: string): ILayout;
    private doLayout(layout, nodes, viewport, uniqueId);
    private getBounds(node);
    private updateTree(layout, x, y, shape, level?, prev?, dontupdate?);
    private updateLeafNode(layout, shape, prev, dimensions, level, dontupdate);
    private setUpLayoutInfo(layout, item);
    private translateSubTree(translateInfo, asstDif, translate, dontupdate);
    private updateRearBounds(layout, shape, levelBounds, level, intersect?);
    private shiftSubordinates(layout, intersect, diff);
    private setDepthSpaceForAssitants(layout, shape, bottom, height, lev, vSpace);
    private setBreadthSpaceForAssistants(layout, shape, dim, space, bottom, level);
    private getDimensions(layout, shape, x, y, level);
    private hasChild(layout, shape);
    private updateHorizontalTree(layout, shape, prev, x, y, level);
    private updateHorizontalTreeWithMultipleRows(layout, shape, prev, x, y, level);
    private updateLeftTree(layout, treeInfo, shape, x, bottom, lev);
    private alignRowsToCenter(layout, i, shape, treeInfo, rightX);
    private updateRearBoundsOfTree(layout, rightTree, diff, dimensions);
    private splitRows(rows, leftTree, rightTree);
    private updateVerticalTree(layout, shape, x, y, level, dontUpdate);
    private splitChildrenInRows(layout, shape);
    private extend(temp);
    private findOffset(layout, shape, info, type);
    private uniteRects(rect1, rect2);
    private spaceLeftFromPrevSubTree(layout, shape, bounds);
    private findIntersectingLevels(layout, bounds, level, actualLevel?);
    private findLevel(layout, bounds, level);
    private getParentNode(layout, node);
    private updateEdges(layout, node, depth);
    private updateAnchor(layout, bounds, viewPort);
    private updateConnectors(layout, node, level);
    private updateSegments(layout, conn, node, target, i);
    private updateSegmentsForBalancedTree(layout, connector, node, target, i);
    private get3Points(layout, node, target);
    private get5Points(layout, node, target);
    private getPointsForMultipleRows(layout, node, target);
    private updatePointsForHorizontalOrientation(layout, node, target);
    private updateNodes(layout, node, mod, update?, dx?, dy?);
}
/** @private */
export interface ILayout {
    anchorX?: number;
    anchorY?: number;
    maxLevel?: number;
    nameTable?: object;
    firstLevelNodes?: INode[];
    centerNode?: null;
    type?: string;
    orientation?: string;
    graphNodes?: {};
    rootNode?: INode;
    updateView?: boolean;
    verticalSpacing?: number;
    horizontalSpacing?: number;
    levels?: LevelBounds[];
    horizontalAlignment?: HorizontalAlignment;
    verticalAlignment?: VerticalAlignment;
    fixedNode?: string;
    bounds?: Rect;
    getLayoutInfo?: Function;
    getConnectorSegments?: Function;
    level?: number;
    margin?: MarginModel;
    objects?: INode[];
    root?: string;
}
export interface LevelBounds {
    rBounds: Bounds;
}
export  class GraphForceNode {
    /**
     * @private
     */
    velocityX: number;
    /**
     * @private
     */
    velocityY: number;
    /**
     * @private
     */
    location: PointModel;
    /**
     * @private
     */
    nodes: IGraphObject[];
    /**
     * @private
     */
    graphNode: IGraphObject;
    constructor(gnNode: IGraphObject);
    /**
     * @private
     */
    applyChanges(): void;
}
/**
 * SymmetricalLayout
 */
export  class SymmetricLayoutManager {
    private cdCOEF;
    private cfMAXVELOCITY;
    private cnMAXITERACTION;
    private cnSPRINGLENGTH;
    private mszMaxForceVelocity;
    /**
     * @private
     */
    springLength: number;
    /**
     * @private
     */
    springFactor: number;
    /**
     * @private
     */
    maxIteration: number;
    private selectedNode;
    constructor();
    /**
     * @private
     */
    destroy(): void;
    protected getModuleName(): string;
    private doGraphLayout(graphLayoutManager);
    private preLayoutNodes(lstNodes, rcBounds);
    /**
     * @private
     */
    doLayout(graphLayoutManager: GraphLayoutManager): void;
    private makeSymmetricLayout(lstNodes);
    private appendForces(lstNodes);
    private resetGraphPosition(lstNodes, graph);
    private convertGraphNodes(lstNodes);
    /**
     * @private
     */
    getForceNode(gnNode: IGraphObject): GraphForceNode;
    private updateNeigbour(vtSource, vtTarget);
    private lineAngle(pt1, pt2);
    private pointDistance(pt1, pt2);
    private calcRelatesForce(vtSource, vtTarget, normalDistance);
    /**
     * @private
     */
    updateLayout(nodeCollection: IGraphObject[], connectors: IGraphObject[], symmetricLayout: SymmetricLayoutManager, nameTable: object, layout: Layout, viewPort: PointModel): void;
    private calcNodesForce(vtSource, vtTarget);
    private calcForce(distance, minDist, angle, vtTarget);
}
export  class GraphLayoutManager {
    private mhelperSelectedNode;
    private visitedStack;
    private cycleEdgesCollection;
    private nameTable;
    /**
     * @private
     */
    nodes: IGraphObject[];
    private graphObjects;
    private connectors;
    private passedNodes;
    /**
     * @private
     */
    selectedNode: IGraphObject;
    /**
     * @private
     */
    updateLayout(nodeCollection: IGraphObject[], connectors: IGraphObject[], symmetricLayout: SymmetricLayoutManager, nameTable: object, layout: Layout, viewPort: PointModel): boolean;
    /**
     * @private
     */
    getModelBounds(lNodes: IGraphObject[]): Rect;
    private updateLayout1(nodesToLayout, symmetricLayout);
    private getNodesToPosition(nodes);
    private selectNodes(node);
    private selectConnectedNodes(nodeGraph);
    private exploreRelatives(nodeGraph);
    private exploreRelatives1(nodeGraph, relativesToExplore);
    private getConnectedRelatives(graphNode);
    private dictionaryContains(obj, keyObj);
    private dictionaryLength(obj);
    private getConnectedChildren(graphNode);
    private getConnectedParents(graphNode);
    private setNode(list, node);
    private findNode(list, fullName);
    private addGraphNode(node);
    private isConnectedToAnotherNode(gnNode);
    private searchEdgeCollection(edgesToSearchThrough, connectionDirection);
    private exploreGraphEdge(node);
    private addNode(nodeToAdd, collectionToAdd);
    private detectCyclesInGraph(nodes);
    private getUnVisitedChildNodes(top);
}
export interface ITreeInfo extends INode, IConnector {
    type?: graphType;
    parents?: IGraphObject[];
    children?: IGraphObject[];
    tag?: GraphForceNode;
    center?: PointModel;
    Added?: boolean;
    isCycleEdge: boolean;
    visible?: boolean;
    GraphNodes?: {};
    LeftMargin?: number;
    TopMargin?: number;
    location?: PointModel;
    Bounds?: Rect;
}
export interface IGraphObject extends INode, IConnector {
    treeInfo?: ITreeInfo;
}
export  type graphType = 'Node' | 'Connector';
/**
 * Interface for a class HyperLink
 */
export interface HyperLinkModel {
    /**
     * Sets the fill color of the link
     * @default 'blue'
     */
    color?: string;
    /**
     * Defines the content for hyperLink
     * @default ''
     */
    content?: string;
    /**
     * Defines the link for hyperLink
     * @default ''
     */
    link?: string;
    /**
     * Defines how the link should be decorated. For example, with underline/over line
     * @default 'None'
     */
    textDecoration?: TextDecoration;
}
/**
 * Interface for a class Annotation
 */
export interface AnnotationModel {
    /**
     * Sets the textual description of the node/connector
     * @default ''
     */
    content?: string;
    /**
     * Sets the hyperLink for the label 
     * @default undefined
     */
    hyperLink?: HyperLinkModel;
    /**
     * Defines the unique id of the annotation
     * @default ''
     */
    id?: string;
    /**
     * Sets the width of the text
     * @default undefined
     */
    width?: number;
    /**
     * Sets the height of the text
     * @default undefined
     */
    height?: number;
    /**
     * Defines the appearance of the text
     * @default new TextStyle()
     */
    style?: TextStyleModel;
    /**
     * Sets the horizontal alignment of the text with respect to the parent node/connector
     * @default HorizontalAlignment.Center
     */
    horizontalAlignment?: HorizontalAlignment;
    /**
     * Sets the vertical alignment of the text with respect to the parent node/connector
     * @default VerticalAlignment.Center
     */
    verticalAlignment?: VerticalAlignment;
    /**
     * Sets the space to be left between an annotation and its parent node/connector
     * @default new Margin(0,0,0,0)
     */
    margin?: MarginModel;
    /**
     * Sets the type of the annotation
     */
    type?: AnnotationTypes;
    /**
     * Allows the user to save custom information/data about an annotation
     */
    addInfo?: object;
}
/**
 * Interface for a class ShapeAnnotation
 */
export interface ShapeAnnotationModel extends AnnotationModel{
    /**
     * Sets the position of the annotation with respect to its parent bounds
     * @default undefined
     */
    offset?: PointModel;
}
/**
 * Interface for a class PathAnnotation
 */
export interface PathAnnotationModel extends AnnotationModel{
    /**
     * Sets the segment offset of annotation
     * @default 0.5
     */
    offset?: number;
    /**
     * Sets the segment alignment of annotation
     * @default Center
     */
    alignment?: AnnotationAlignment;
}
/**
 * Defines the hyperLink for the annotation
 */
export  class HyperLink extends base.ChildProperty<HyperLink> {
    /**
     * Sets the fill color of the link
     * @default 'blue'
     */
    color: string;
    /**
     * Defines the content for hyperLink
     * @default ''
     */
    content: string;
    /**
     * Defines the link for hyperLink
     * @default ''
     */
    link: string;
    /**
     * Defines how the link should be decorated. For example, with underline/over line
     * @default 'None'
     */
    textDecoration: TextDecoration;
}
/**
 * Defines the textual description of nodes/connectors
 */
export  class Annotation extends base.ChildProperty<Annotation> {
    /**
     * Sets the textual description of the node/connector
     * @default ''
     */
    content: string;
    /**
     * Sets the hyperLink for the label
     * @default undefined
     */
    hyperLink: HyperLinkModel;
    /**
     * Defines the unique id of the annotation
     * @default ''
     */
    id: string;
    /**
     * Sets the width of the text
     * @default undefined
     */
    width: number;
    /**
     * Sets the height of the text
     * @default undefined
     */
    height: number;
    /**
     * Defines the appearance of the text
     * @default new TextStyle()
     */
    style: TextStyleModel;
    /**
     * Sets the horizontal alignment of the text with respect to the parent node/connector
     * @default HorizontalAlignment.Center
     */
    horizontalAlignment: HorizontalAlignment;
    /**
     * Sets the vertical alignment of the text with respect to the parent node/connector
     * @default VerticalAlignment.Center
     */
    verticalAlignment: VerticalAlignment;
    /**
     * Sets the space to be left between an annotation and its parent node/connector
     * @default new Margin(0,0,0,0)
     */
    margin: MarginModel;
    /**
     * Sets the type of the annotation
     */
    type: AnnotationTypes;
    /**
     * Allows the user to save custom information/data about an annotation
     */
    addInfo: object;
}
/**
 * Defines the textual description of nodes/connectors with respect to bounds
 */
export  class ShapeAnnotation extends Annotation {
    /**
     * Sets the position of the annotation with respect to its parent bounds
     * @default undefined
     */
    offset: PointModel;
    constructor(parent: any, propName: string, defaultValue: Object, isArray?: boolean);
}
/**
 * Defines the connector annotation
 */
export  class PathAnnotation extends Annotation {
    /**
     * Sets the segment offset of annotation
     * @default 0.5
     */
    offset: number;
    /**
     * Sets the segment alignment of annotation
     * @default Center
     */
    alignment: AnnotationAlignment;
}
/**
 * BPMN Diagrams contains the BPMN functionalities
 */
export  class BpmnDiagrams {
    /** @private */
    initBPMNContent(content: DiagramElement, node: Node): DiagramElement;
    /** @private */
    getBPMNShapes(node: Node): PathElement;
    /** @private */
    getBPMNGroup(node: Node): Canvas;
    /** @private */
    getBPMNGatewayShape(node: Node): Canvas;
    /** @private */
    getBPMNDataObjectShape(node: Node): Canvas;
    /** @private */
    getBPMNTaskShape(node: Node): Canvas;
    /** @private */
    getBPMNEventShape(node: Node, subEvent: BpmnSubEventsModel): Canvas;
    /** @private */
    getBPMNSubProcessShape(node: Node): Canvas;
    /** @private */
    getBPMNSubProcessLoopShape(node: Node): PathElement;
    /** @private */
    getBPMNCompensationShape(node: Node, compensationNode: PathElement): PathElement;
    /** @private */
    getBPMNActivityShape(node: Node): Canvas;
    /** @private */
    getBPMNSubprocessEvent(node: Node, subProcessEventsShapes: Canvas, events: BpmnSubEventsModel): void;
    /** @private */
    getBPMNAdhocShape(node: Node, adhocNode: PathElement, subProcess: BpmnSubProcessModel): PathElement;
    /** @private */
    private getSubprocessChildCount(node);
    /** @private */
    private getTaskChildCount(node);
    /** @private */
    private setStyle(child, node);
    /** @private */
    updateBPMN(changedProp: Node, oldObject: Node, actualObject: Node, diagram: Diagram): void;
    /** @private */
    updateBPMNGateway(node: Node, changedProp: Node): void;
    /** @private */
    updateBPMNDataObject(node: Node, newObject: Node, oldObject: Node): void;
    /** @private */
    getEvent(node: Node, oldObject: Node, event: string, child0: DiagramElement, child1: DiagramElement, child2: DiagramElement): void;
    /** @private */
    private updateEventVisibility(oldObject, child1);
    /** @private */
    updateBPMNEvent(node: Node, newObject: Node, oldObject: Node): void;
    /** @private */
    updateBPMNEventTrigger(node: Node, newObject: Node): void;
    /** @private */
    updateBPMNActivity(node: Node, newObject: Node, oldObject: Node, diagram: Diagram): void;
    /** @private */
    updateBPMNActivityTask(node: Node, newObject: Node): void;
    /** @private */
    updateBPMNActivityTaskLoop(node: Node, newObject: Node, x: number, subChildCount: number, area: number, start: number): void;
    /** @private */
    private updateChildMargin(elementWrapper, subChildCount, area, x, start);
    /** @private */
    updateBPMNActivitySubProcess(node: Node, newObject: Node, oldObject: Node, diagram: Diagram): void;
    /** @private */
    updateBPMNSubProcessEvent(node: Node, newObject: Node, oldObject: Node, diagram: Diagram): void;
    /** @private */
    getEventSize(events: BpmnSubEventsModel, wrapperChild: Canvas): void;
    /** @private */
    updateBPMNSubProcessAdhoc(node: Node, oldObject: Node, subProcess: BpmnSubProcessModel, x: number, subChildCount: number, area: number): void;
    /** @private */
    updateBPMNSubProcessBoundary(node: Node, subProcess: BpmnSubProcessModel): void;
    /** @private */
    updateBPMNSubProcessCollapsed(node: Node, oldObject: Node, subProcess: BpmnSubProcessModel, x: number, subChildCount: number, area: number): void;
    /** @private */
    updateBPMNSubProcessCompensation(node: Node, oldObject: Node, subProcess: BpmnSubProcessModel, x: number, subChildCount: number, area: number): void;
    /** @private */
    updateBPMNSubProcessLoop(node: Node, oldObject: Node, subProcess: BpmnSubProcessModel, x: number, subChildCount: number, area: number): void;
    /** @private */
    updateBPMNConnector(actualObject: Connector, oldObject: Connector, connection: Connector, diagram: Diagram): Connector;
    /** @private */
    getSequence(actualObject: Connector, oldObject: Connector, connection: Connector, diagram: Diagram): Connector;
    /** @private */
    getAssociation(actualObject: Connector, oldObject: Connector, connection: Connector, diagram: Diagram): Connector;
    /** @private */
    getMessage(actualObject: Connector, oldObject: Connector, connection: Connector, diagram: Diagram): Connector;
    private setSizeForBPMNEvents(event, wrapper, width, height);
    private setSizeForBPMNGateway(event, wrapper, width, height);
    private setSizeForBPMNDataObjects(event, wrapper, width, height);
    private setSizeForBPMNActivity(activity, wrapper, width, height);
    /**
     * Constructor for the BpmnDiagrams module
     * @private
     */
    constructor();
    /**
     * To destroy the BpmnDiagrams module
     * @return {void}
     * @private
     */
    destroy(): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
export  function getBpmnShapePathData(shape: string): string;
export  function getBpmnTriggerShapePathData(shape: string): string;
export  function getBpmnGatewayShapePathData(shape: string): string;
export  function getBpmnTaskShapePathData(shape: string): string;
export  function getBpmnLoopShapePathData(shape: string): string;
/**
 * ConnectorBridging defines the bridging behavior
 */
/** @private */
export  class ConnectorBridging {
    /** @private */
    updateBridging(conn: Connector, diagram: Diagram): void;
    /** @private */
    firstBridge(bridgeList: BridgeSegment[], connector: Connector, bridgeSpacing: number): void;
    /** @private */
    createSegment(st: PointModel, end: PointModel, angle: number, direction: BridgeDirection, index: number, conn: Connector, diagram: Diagram): ArcSegment;
    /** @private */
    createBridgeSegment(startPt: PointModel, endPt: PointModel, angle: number, bridgeSpace: number, sweep: number): string;
    /** @private */
    sweepDirection(angle: number, bridgeDirection: BridgeDirection, connector: Connector, diagram: Diagram): number;
    /** @private */
    getPointAtLength(length: number, pts: PointModel[]): PointModel;
    /** @private */
    protected getPoints(connector: Connector): PointModel[];
    private intersectsRect(rect1, rect2);
    /** @private */
    intersect(points1: PointModel[], points2: PointModel[], self: boolean, bridgeDirection: BridgeDirection, zOrder: boolean): PointModel[];
    /** @private */
    inter1(startPt: PointModel, endPt: PointModel, pts: PointModel[], zOrder: boolean, bridgeDirection: BridgeDirection): PointModel[];
    private checkForHorizontalLine(angle);
    private intersect2(start1, end1, start2, end2);
    /** @private */
    getLineSegment(x1: number, y1: number, x2: number, y2: number): Segment;
    private isEmptyPoint(point);
    private getLengthAtFractionPoint(connector, pointAt);
    private getSlope(startPt, endPt, point, connector);
    /** @private */
    angleCalculation(startPt: PointModel, endPt: PointModel): number;
    private lengthCalculation(startPt, endPt);
    /**
     * Constructor for the bridging module
     * @private
     */
    constructor();
    /**
     * To destroy the bridging module
     * @return {void}
     * @private
     */
    destroy(): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * Interface for a class Decorator
 */
export interface DecoratorModel {
    /**
     * Sets the width of the decorator
     * @default ''
     */
    width?: number;
    /**
     * Sets the height of the decorator
     * @default ''
     */
    height?: number;
    /**
     * Sets the shape of the decorator
     * @default 'Arrow'
     */
    shape?: DecoratorShapes;
    /**
     * Sets the decorator padding value
     * @default 10
     */
    hitPadding?: number;
    /**
     * Defines the appearance of the decorator
     * @default new base.ShapeStyle()
     */
    style?: ShapeStyleModel;
    /**
     * Defines the position of the decorator with respect to the source/target point of the connector
     * @default ''
     */
    pivot?: PointModel;
    /**
     * Defines the geometry of the decorator shape
     * @default ''
     */
    pathData?: string;
}
/**
 * Interface for a class Vector
 */
export interface VectorModel {
    /**
     * Defines the angle for the bezier curve
     * @default 0
     */
    angle?: number;
    /**
     * Defines the distance for the bezier curve
     * @default 0
     */
    distance?: number;
}
/**
 * Interface for a class ConnectorShape
 */
export interface ConnectorShapeModel {
    /**
     * Defines the type of node shape
     * @default 'Bpmn'
     */
    type?: ConnectionShapes;
}
/**
 * Interface for a class BpmnFlow
 */
export interface BpmnFlowModel extends ConnectorShapeModel{
    /**
     * Sets the type of the Bpmn flows
     * @default 'Sequence'
     */
    flow?: BpmnFlows;
    /**
     * Sets the type of the Bpmn Sequence flows
     * @default 'Normal'
     */
    sequence?: BpmnSequenceFlows;
    /**
     * Sets the type of the Bpmn message flows
     * @default ''
     */
    message?: BpmnMessageFlows;
    /**
     * Sets the type of the Bpmn association flows
     * @default ''
     */
    association?: BpmnAssociationFlows;
}
/**
 * Interface for a class Connector
 */
export interface ConnectorModel extends NodeBaseModel{
    /**
     * Defines the shape of the connector
     * @default 'Bpmn'
     */
    shape?: ConnectorShapeModel | BpmnFlowModel;
    /**
     * Defines the constraints of connector
     * @default base.ConnectorConstraints.None
     */
    constraints?: ConnectorConstraints;
    /**
     * Defines the bridgeSpace of connector
     * @default 10
     */
    bridgeSpace?: number;
    /**
     * Defines the collection of textual annotations of connectors
     * @default undefined
     */
    annotations?: PathAnnotationModel[];
    /**
     * Sets the beginning point of the connector
     * @default new Point(0,0)
     */
    sourcePoint?: PointModel;
    /**
     * Sets the end point of the connector
     * @default new Point(0,0)
     */
    targetPoint?: PointModel;
    /**
     * Sets the  point1 of the bezier connector
     * @default new Point(0,0)
     */
    point1?: PointModel;
    /**
     * Sets the  point2 of the bezier connector
     * @default new Point(0,0)
     */
    point2?: PointModel;
    /**
     * Sets the source node/connector object of the connector
     * @default null
     */
    sourceID?: string;
    /**
     * Sets the target node/connector object of the connector
     * @default null
     */
    targetID?: string;
    /**
     * Sets the connector padding value
     * @default 10
     */
    hitPadding?: number;
    /**
     * Defines the type of the connector
     * @default 'Straight'
     */
    type?: Segments;
    /**
     * Sets the set of points that defines the path of the connector
     * @default []
     */
    intermediatePoints?: PointModel[];
    /**
     * Sets the corner radius of the connector
     * @default 0
     */
    cornerRadius?: number;
    /**
     * Defines the source decorator of the connector
     * @default new Decorator()
     */
    sourceDecorator?: DecoratorModel;
    /**
     * Defines the target decorator of the connector
     * @default new Decorator()
     */
    targetDecorator?: DecoratorModel;
    /**
     * defines the tooltip for the connector
     * @default new DiagramToolTip();
     */
    tooltip?: DiagramTooltipModel;
    /**
     * Defines the vector1 of the bezier connector
     * @default new Vector()
     */
    vector1?: VectorModel;
    /**
     * Defines the vector1 of the bezier connector
     * @default new Vector()
     */
    vector2?: VectorModel;
    /**
     * Sets the unique id of the source port of the connector
     * @default ''
     */
    sourcePortId?: string;
    /**
     * Sets the unique id of the target port of the connector
     * @default ''
     */
    targetPortId?: string;
    /**
     * Defines the appearance of the connection path
     * @default ''
     */
    style?: StrokeStyleModel;
    /**
     * Defines the UI of the connector
     * @default null
     */
    wrapper?: Container;
}

/**
 * Decorators are used to decorate the end points of the connector with some predefined path geometry
 */
export  class Decorator extends base.ChildProperty<Decorator> {
    /**
     * Sets the width of the decorator
     * @default ''
     */
    width: number;
    /**
     * Sets the height of the decorator
     * @default ''
     */
    height: number;
    /**
     * Sets the shape of the decorator
     * @default 'Arrow'
     */
    shape: DecoratorShapes;
    /**
     * Sets the decorator padding value
     * @default 10
     */
    hitPadding: number;
    /**
     * Defines the appearance of the decorator
     * @default new ShapeStyle()
     */
    style: ShapeStyleModel;
    /**
     * Defines the position of the decorator with respect to the source/target point of the connector
     * @default ''
     */
    pivot: PointModel;
    /**
     * Defines the geometry of the decorator shape
     * @default ''
     */
    pathData: string;
}
export  class Vector extends base.ChildProperty<Vector> {
    /**
     * Defines the angle for the bezier curve
     * @default 0
     */
    angle: number;
    /**
     * Defines the distance for the bezier curve
     * @default 0
     */
    distance: number;
}
/**
 * Sets the type of the connector
 */
export  class ConnectorShape extends base.ChildProperty<ConnectorShape> {
    /**
     * Defines the type of node shape
     * @default 'Bpmn'
     */
    type: ConnectionShapes;
}
/**
 * Sets the type of the Bpmn flows
 */
export  class BpmnFlow extends ConnectorShape {
    /**
     * Sets the type of the Bpmn flows
     * @default 'Sequence'
     */
    flow: BpmnFlows;
    /**
     * Sets the type of the Bpmn Sequence flows
     * @default 'Normal'
     */
    sequence: BpmnSequenceFlows;
    /**
     * Sets the type of the Bpmn message flows
     * @default ''
     */
    message: BpmnMessageFlows;
    /**
     * Sets the type of the Bpmn association flows
     * @default ''
     */
    association: BpmnAssociationFlows;
}
/**
 * Get the direction of the control points while the bezier is connected to the node
 */
export  function getDirection(bounds: Rect, points: PointModel, excludeBounds: boolean): string;
export  function isEmptyVector(element: VectorModel): boolean;
/**
 * Get the bezier points if control points are not given.
 */
export  function getBezierPoints(sourcePoint: PointModel, targetPoint: PointModel, direction?: string): PointModel;
/**
 * Update the endpoints during the data bind bind action.
 */
export  function updateEndPoints(actualObject: Connector, oldProp: Connector, newProp: Connector): void;
/**
 * Get the bezier curve bounds.
 */
export  function getBezierBounds(startPoint: PointModel, controlPoint1: PointModel, controlPoint2: PointModel, endPoint: PointModel, connector: Connector): Rect;
/**
 * Get the intermediate bezier curve for point over connector
 */
export  function bezierPoints(connector: ConnectorModel, startPoint: PointModel, point1: PointModel, point2: PointModel, endPoint: PointModel, i: number, max: number): PointModel;
/**
 * Connectors are used to create links between nodes
 */
export  class Connector extends NodeBase implements IElement {
    /**
     * Defines the shape of the connector
     * @default 'Bpmn'
     */
    shape: ConnectorShapeModel | BpmnFlowModel;
    /**
     * Defines the constraints of connector
     * @default ConnectorConstraints.None
     */
    constraints: ConnectorConstraints;
    /**
     * Defines the bridgeSpace of connector
     * @default 10
     */
    bridgeSpace: number;
    /**
     * Defines the collection of textual annotations of connectors
     * @default undefined
     */
    annotations: PathAnnotationModel[];
    /**
     * Sets the beginning point of the connector
     * @default new Point(0,0)
     */
    sourcePoint: PointModel;
    /**
     * Sets the end point of the connector
     * @default new Point(0,0)
     */
    targetPoint: PointModel;
    /**
     * Sets the  point1 of the bezier connector
     * @default new Point(0,0)
     */
    point1: PointModel;
    /**
     * Sets the  point2 of the bezier connector
     * @default new Point(0,0)
     */
    point2: PointModel;
    /**
     * Sets the source node/connector object of the connector
     * @default null
     */
    sourceID: string;
    /**
     * Sets the target node/connector object of the connector
     * @default null
     */
    targetID: string;
    /**
     * Sets the connector padding value
     * @default 10
     */
    hitPadding: number;
    /**
     * Defines the type of the connector
     * @default 'Straight'
     */
    type: Segments;
    /**
     * Sets the set of points that defines the path of the connector
     * @default []
     */
    intermediatePoints: PointModel[];
    /**
     * Sets the corner radius of the connector
     * @default 0
     */
    cornerRadius: number;
    /**
     * Defines the source decorator of the connector
     * @default new Decorator()
     */
    sourceDecorator: DecoratorModel;
    /**
     * Defines the target decorator of the connector
     * @default new Decorator()
     */
    targetDecorator: DecoratorModel;
    /**
     * defines the tooltip for the connector
     * @default new DiagramToolTip();
     */
    tooltip: DiagramTooltipModel;
    /**
     * Defines the vector1 of the bezier connector
     * @default new Vector()
     */
    vector1: VectorModel;
    /**
     * Defines the vector1 of the bezier connector
     * @default new Vector()
     */
    vector2: VectorModel;
    /**
     * Sets the unique id of the source port of the connector
     * @default ''
     */
    sourcePortId: string;
    /**
     * Sets the unique id of the target port of the connector
     * @default ''
     */
    targetPortId: string;
    /**
     * Defines the appearance of the connection path
     * @default ''
     */
    style: StrokeStyleModel;
    /**
     * Defines the UI of the connector
     * @default null
     */
    wrapper: Container;
    /** @private */
    bridges: Bridge[];
    /** @private */
    parentId: string;
    /** @private */
    sourceWrapper: DiagramElement;
    /** @private */
    targetWrapper: DiagramElement;
    /** @private */
    sourcePortWrapper: DiagramElement;
    /** @private */
    targetPortWrapper: DiagramElement;
    /**
     * Sets the  point1 of the bezier connector
     */
    /** @private */
    bezierPoint1: PointModel;
    /**
     * Sets the  point2 of the bezier connector
     */
    /** @private */
    bezierPoint2: PointModel;
    constructor(parent: any, propName: string, defaultValue: Object, isArray?: boolean);
    /** @private */
    init(diagram: any): Canvas;
    private getBpmnSequenceFlow();
    private getBpmnAssociationFlow();
    private getBpmnMessageFlow();
    /** @private */
    distance(pt1: PointModel, pt2: PointModel): number;
    findPath(sourcePt: PointModel, targetPt: PointModel): Object;
    /** @private */
    getAnnotationElement(annotation: PathAnnotation, points: PointModel[], bounds: Rect): TextElement;
    /** @private */
    updateAnnotation(annotation: PathAnnotation, points: PointModel[], bounds: Rect, textElement: TextElement): void;
    /** @private */
    getConnectorPoints(type: Segments, points?: PointModel[]): PointModel[];
    /** @private */
    updateSegmentElement(connector: Connector, points: PointModel[], element: PathElement): PathElement;
    /** @private */
    getSegmentElement(connector: Connector, segmentElement: PathElement): PathElement;
    /** @private */
    getDecoratorElement(offsetPoint: PointModel, adjacentPoint: PointModel, decorator: DecoratorModel): PathElement;
    private bridgePath(connector, path, pointIndex);
    /** @private */
    updateDecoratorElement(element: DiagramElement, pt: PointModel, adjacentPoint: PointModel, decorator: DecoratorModel): void;
    /** @private */
    getSegmentPath(connector: Connector, pts: PointModel[]): string;
    /** @private */
    updateShapeElement(connector: Connector): void;
    /** @private */
    updateShapePosition(connector: Connector, element: DiagramElement): void;
    /** @hidden */
    scale(sw: number, sh: number, refObject?: DiagramElement): void;
}
/**
 * @private
 */
export  const menuClass: ContextMenuClassList;
/**
 * @private
 */
export interface ContextMenuClassList {
    copy: string;
    paste: string;
    content: string;
    undo: string;
    redo: string;
    cut: string;
    selectAll: string;
    bringToFront: string;
    sendToBack: string;
    moveForward: string;
    sendBackward: string;
    order: string;
}
/**
 * 'ContextMenu module used to handle context menu actions.'
 * @private
 */
export  class DiagramContextMenu {
    private element;
    contextMenu: navigations.ContextMenu;
    private defaultItems;
    /**
     * @private
     */
    disableItems: string[];
    /**
     * @private
     */
    hiddenItems: string[];
    private parent;
    private l10n;
    private serviceLocator;
    private localeText;
    private eventArgs;
    /**
     * @private
     */
    isOpen: boolean;
    constructor(parent?: Diagram, service?: ServiceLocator);
    /**
     * @hidden
     * @private
     */
    addEventListener(): void;
    /**
     * @hidden
     * @private
     */
    removeEventListener(): void;
    private render();
    private getMenuItems();
    private contextMenuOpen();
    private contextMenuItemClick(args);
    private contextMenuOnClose(args);
    private getLocaleText(item);
    private updateItemStatus();
    private ensureItems(item, event?);
    private contextMenuBeforeOpen(args);
    private ensureTarget(item);
    /**
     * To destroy the Context menu.
     * @method destroy
     * @return {void}
     * @private
     */
    destroy(): void;
    private getModuleName();
    private generateID(item);
    private getKeyFromId(id);
    private buildDefaultItems(item);
    private getDefaultItems();
    private setLocaleKey();
}
/**
 * BasicShapeDictionary defines the shape of the built-in basic shapes
 */
/** @private */
export  function getBasicShape(shape: string): string;
/**
 * ShapeDictionary defines the shape of the default nodes and ports
 */
/** @private */
export  function getPortShape(shape: PortShapes): string;
/** @private */
export  function getDecoratorShape(shape: DecoratorShapes, decorator: DecoratorModel): string;
/**
 * @private
 * @param icon
 * sets the path data for different icon shapes
 */
export  function getIconShape(icon: IconShapeModel): string;
/**
 * FlowShapeDictionary defines the shape of the built-in flow shapes
 */
/** @private */
export  function getFlowShape(shape: string): string;
/**
 * Interface for a class Panel
 */
export interface PanelModel {
    /**
     * Defines the type of Panel
     * @default 'None'
     */
    type?: Panels;
}
/**
 * Interface for a class StackPanels
 */
export interface StackPanelsModel extends PanelModel{
    /**
     * Defines the type of panel as Stack
     * @default 'Stack'
     */
    type?: Panels;
    /**
     * Defines the the type of orientation for stack panel
     * @default ''Horizontal''
     */
    orientation?: Orientation;
}
/**
 * Interface for a class CanvasPanels
 */
export interface CanvasPanelsModel extends PanelModel{
    /**
     * Defines the type of Panel
     * @default 'Canvas'
     */
    type?: Panels;
}
/**
 * Interface for a class Group
 */
export interface GroupModel {
    /**
     * Represents the unique id of Group
     * @default ''
     */
    id?: string;
    /**
     * Defines the children of group element
     * @default Node
     */
    children?: (NodeModel | GroupModel | ConnectorModel)[];
    /**
     * Defines the Panel for group
     * @default None
     */
    panel?: PanelModel;
    /**
     * Defines the visual order of the node/connector in DOM
     * @default -1
     */
    zIndex?: number;
    /**
     * Defines the width of group
     * @default -1
     */
    width?: number;
    /**
     * Defines the height of group
     * @default -1
     */
    height?: number;
    /**
     * Defines the offsetX value for group
     * @default 0
     */
    offsetX?: number;
    /**
     * Defines the offsetY for group
     * @default 0
     */
    offsetY?: number;
    /**
     * Sets the reference point, that will act as the offset values(offsetX, offsetY) of a node
     * @default new Point(0.5,0.5)
     */
    pivot?: PointModel;
    /**
     * Sets the shape style of the group
     * @default new base.ShapeStyle()
     */
    style?: ShapeStyleModel;
    /**
     * Defines the rotateAngle for group
     * @default 0
     */
    rotateAngle?: number;
    /**
     * Defines the margin for group
     * @default 0
     */
    margin?: MarginModel;
}
/**
 * Get the object as Node | Group | Connector
 * @param object
 */
export  let getChildType: Function;
export  let getPanelType: Function;
export  class Panel extends base.ChildProperty<Panel> {
    /**
     * Defines the type of Panel
     * @default 'None'
     */
    type: Panels;
}
export  class StackPanels extends Panel {
    /**
     * Defines the type of panel as Stack
     * @default 'Stack'
     */
    type: Panels;
    /**
     * Defines the the type of orientation for stack panel
     * @default ''Horizontal''
     */
    orientation: Orientation;
}
export  class CanvasPanels extends Panel {
    /**
     * Defines the type of Panel
     * @default 'Canvas'
     */
    type: Panels;
}
/**
 * Groups are used to group related objects
 */
export  class Group extends base.ChildProperty<Group> implements IElement {
    /**
     * Represents the unique id of Group
     * @default ''
     */
    id: string;
    /**
     * Defines the children of group element
     * @default Node
     */
    children: (NodeModel | GroupModel | ConnectorModel)[];
    /**
     * Defines the Panel for group
     * @default None
     */
    panel: PanelModel;
    /**
     * Defines the visual order of the node/connector in DOM
     * @default -1
     */
    zIndex: number;
    /**
     * Defines the width of group
     * @default -1
     */
    width: number;
    /**
     * Defines the height of group
     * @default -1
     */
    height: number;
    /**
     * Defines the offsetX value for group
     * @default 0
     */
    offsetX: number;
    /**
     * Defines the offsetY for group
     * @default 0
     */
    offsetY: number;
    /**
     * Sets the reference point, that will act as the offset values(offsetX, offsetY) of a node
     * @default new Point(0.5,0.5)
     */
    pivot: PointModel;
    /**
     * Sets the shape style of the group
     * @default new ShapeStyle()
     */
    style: ShapeStyleModel;
    /**
     * Defines the rotateAngle for group
     * @default 0
     */
    rotateAngle: number;
    /**
     * Defines the margin for group
     * @default 0
     */
    margin: MarginModel;
    padding: Thickness;
    /**
     * Sets or gets the UI of a group
     * @default null
     */
    wrapper: Container;
    /**
     * Allows to initialize the UI of a group
     */
    init(diagram: any): DiagramElement;
    /**
     * update the group properties
     * @param element,group
     */
    private updateProperty(element, group);
}
/**
 * Interface for a class IconShape
 */
export interface IconShapeModel {
    /**
     * Defines the shape of the icon.
     * @default Iconshape.None;
     */
    shape?: IconShapes;
    /**
     * Sets the fill color of a icon.
     * @default ''
     */
    fill?: string;
    /**
     * Defines how the Icon has to be horizontally aligned.
     * @default 'Center'
     */
    horizontalAlignment?: HorizontalAlignment;
    /**
     * Defines how the Icon has to be Vertically aligned.
     * @default 'Center'
     */
    verticalAlignment?: VerticalAlignment;
    /**
     * Defines the width of the icon.
     * @default 20
     */
    width?: number;
    /**
     * Defines the height of the icon.
     * @default 20
     */
    height?: number;
    /**
     * Defines the offset of the icon.
     * @default new Point(0.5,1)
     */
    offset?: PointModel;
    /**
     * Sets the border color of a icon.
     * @default ''
     */
    borderColor?: string;
    /**
     * Defines the border width of the icon.
     * @default 1
     */
    borderWidth?: number;
    /**
     * Defines the space that the icon has to be moved from its actual position
     * @default new Margin(0,0,0,0)
     */
    margin?: MarginModel;
    /**
     * Defines the geometry of a path
     * @default ''
     */
    pathData?: string;
    /**
     * Defines the template
     * @default ''
     */
    content?: string;
}
/**
 * Defines the behavior of default IconShape
 */
export  class IconShape extends base.ChildProperty<IconShape> {
    /**
     * Defines the shape of the icon.
     * @default Iconshape.None;
     */
    shape: IconShapes;
    /**
     * Sets the fill color of a icon.
     * @default ''
     */
    fill: string;
    /**
     * Defines how the Icon has to be horizontally aligned.
     * @default 'Center'
     */
    horizontalAlignment: HorizontalAlignment;
    /**
     * Defines how the Icon has to be Vertically aligned.
     * @default 'Center'
     */
    verticalAlignment: VerticalAlignment;
    /**
     * Defines the width of the icon.
     * @default 20
     */
    width: number;
    /**
     * Defines the height of the icon.
     * @default 20
     */
    height: number;
    /**
     * Defines the offset of the icon.
     * @default new Point(0.5,1)
     */
    offset: PointModel;
    /**
     * Sets the border color of a icon.
     * @default ''
     */
    borderColor: string;
    /**
     * Defines the border width of the icon.
     * @default 1
     */
    borderWidth: number;
    /**
     * Defines the space that the icon has to be moved from its actual position
     * @default new Margin(0,0,0,0)
     */
    margin: MarginModel;
    /**
     * Defines the geometry of a path
     * @default ''
     */
    pathData: string;
    /**
     * Defines the template
     * @default ''
     */
    content: string;
}
/**
 * IElement interface defines the base of the diagram objects (node/connector)
 */
export interface IElement {
    wrapper: Container;
    init(diagram: Diagram): DiagramElement;
}
/**
 * IDataLoadedEventArgs defines the event arguments after data is loaded
 */
export interface IDataLoadedEventArgs {
    diagram: Diagram;
}
/**
 * CollectionChangeEvents notifies the node/connector are added or removed
 *
 */
export interface ISelectionChangeEventArgs {
    oldValue: (NodeModel | ConnectorModel)[];
    newValue: (NodeModel | ConnectorModel)[];
    state: EventState;
    cause: DiagramAction;
    type: ChangeType;
    cancel: boolean;
}
export interface ISizeChangeEventArgs {
    source: SelectorModel;
    state: State;
    oldValue: SelectorModel;
    newValue: SelectorModel;
    cancel: boolean;
}
export interface IRotationEventArgs {
    source: SelectorModel;
    state: State;
    oldValue: SelectorModel;
    newValue: SelectorModel;
    cancel: boolean;
}
export interface ICollectionChangeEventArgs {
    element: NodeModel | ConnectorModel;
    cause: DiagramAction;
    state: EventState;
    type: ChangeType;
    cancel: boolean;
}
export interface IPropertyChangeEventArgs {
    element: (NodeModel | ConnectorModel)[];
    cause: DiagramAction;
    oldValue: DiagramModel;
    newValue: DiagramModel;
}
export interface IDraggingEventArgs {
    source: SelectorModel;
    state: State;
    oldValue: SelectorModel;
    newValue: SelectorModel;
    target: NodeModel | ConnectorModel;
    targetPosition: PointModel;
    allowDrop: boolean;
    cancel: boolean;
}
export interface IDropEventArgs {
    source: NodeModel | ConnectorModel | SelectorModel;
    target: NodeModel | ConnectorModel;
    position: PointModel;
}
export interface IConnectionChangeEventArgs {
    connector: ConnectorModel;
    oldValue: Connector | {
        nodeId: string;
        portId: string;
    };
    newValue: Connector | {
        nodeId: string;
        portId: string;
    };
    connectorEnd: string;
    state: EventState;
    cancel: boolean;
}
export interface IEndChangeEventArgs {
    connector: ConnectorModel;
    oldValue: PointModel;
    newValue: PointModel;
    targetNode: string;
    targetPort: string;
    state: State;
    cancel: boolean;
}
export interface Animation {
    state: State;
}
/**
 * Defines the context menu item model.
 */
export interface ContextMenuItemModel extends navigations.MenuItemModel {
    /**
     * Define the target to show the menu item.
     */
    target?: string;
}
export interface ZoomOptions {
    zoomFactor?: number;
    focusPoint?: PointModel;
    type?: ZoomTypes;
}
/**
 * Defines the options to export diagrams
 */
export interface IPrintOptions {
    /**
     * Sets the width for the Page
     * @default null
     */
    pageWidth?: number;
    /**
     * Sets the height of the Page
     * @default null
     */
    pageHeight?: number;
    /**
     * Sets the space to be left between an annotation and its parent node/connector
     * @default new Margin(0,0,0,0)
     */
    margin?: MarginModel;
    /**
     * Sets the PageOrientation for the diagram to page
     * @default 'Landscape'
     */
    pageOrientation?: PageOrientation;
    /**
     * Sets the Multiple page for diagram
     * @default false
     */
    multiplePage?: boolean;
    /**
     * Sets the region for the print settings
     * @default 'PageSettings'
     */
    region?: DiagramRegions;
    /**
     * Sets the stretch
     * @default('Stretch')
     */
    stretch?: Stretch;
}
/**
 * Defines the options to export diagrams
 */
export interface IExportOptions extends IPrintOptions {
    /**
     * Sets the file name for the File
     * @default('')
     */
    fileName?: string;
    /**
     * Sets the file format to save the file
     * @default('')
     */
    format?: FileFormats;
    /**
     * Sets the Mode for the file to be downloaded
     * @default('')
     */
    mode?: ExportModes;
    /**
     * Sets the bounds for the export diagram
     * @default (0)
     */
    bounds?: Rect;
}
export interface IFitOptions {
    mode?: FitModes;
    region?: DiagramRegions;
    margin?: MarginModel;
    canZoomIn?: boolean;
    customBounds?: Rect;
}
/** @private */
export interface ITouches {
    pageX?: number;
    pageY?: number;
    pointerId?: number;
}
/** @private */
export interface View {
    mode: RenderingMode;
    removeDocument: Function;
    updateView: Function;
    renderDocument: Function;
    element: HTMLElement;
    contentWidth?: number;
    contentHeight?: number;
    diagramLayer: HTMLCanvasElement | SVGGElement;
    id: string;
}
/**
 * Layout Animation function to enable or disable layout animation
 */
export  class LayoutAnimation {
    /**
     * Layout expand function for animation of expand and collapse
     */
    expand(node: Node, diagram?: Diagram): void;
    /**
     * Setinterval and Clear interval for layout animation
     */
    /** @private */
    layoutAnimation(objValue: ILayout, layoutTimer: Object, stop: boolean, diagram: Diagram): void;
    /**
     * Setinterval and Clear interval for layout animation
     */
    /** @private */
    expandCollapse(source: Node, visibility: boolean, diagram: Diagram): void;
    /**
     * update the node opacity for the node and connector once the layout animation starts
     */
    updateOpacity(source: Node, value: number, diagram: Diagram): void;
    /**
     * To destroy the  LayoutAnimate module
     * @return {void}
     * @private
     */
    destroy(): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * Interface for a class NodeBase
 */
export interface NodeBaseModel {
    /**
     * Represents the unique id of nodes/connectors
     * @default ''
     */
    id?: string;
    /**
     * Defines the visual order of the node/connector in DOM
     * @default -1
     */
    zIndex?: number;
    /**
     * Defines the space to be let between the node and its immediate parent
     * @default 0
     */
    margin?: MarginModel;
    /**
     * Sets how to horizontally align a node with respect to its immediate parent
     * @default HorizontalAlignment.Center
     */
    horizontalAlignment?: HorizontalAlignment;
    /**
     * Sets how to vertically align a node with respect to its immediate parent
     * @default VerticalAlignment.Center
     */
    verticalAlignment?: VerticalAlignment;
    /**
     * Sets the visibility of the node/connector
     * @default true
     */
    visible?: boolean;
    /**
     * Defines the collection of connection points of nodes/connectors
     * @default undefined
     */
    ports?: PointPortModel[];
    /**
     * Defines if the node is expanded or not
     * @default true
     */
    isExpanded?: boolean;
    /**
     * defines the tooltip for the node
     * @default new DiagramToolTip()
     */
    tooltip?: DiagramTooltipModel;
    /**
     * Defines the properties of the Expand Icon
     * @default
     */
    expandIcon?: IconShapeModel;
    /**
     * Defines the properties of the collapse Icon
     * @default
     */
    collapseIcon?: IconShapeModel;
    /**
     * Defines whether the node should be automatically positioned or not
     * @default false
     */
    excludeFromLayout?: boolean;
    /**
     * Allows the user to save custom information/data about a node/connector
     */
    addInfo?: object;
}
/**
 * Defines the common behavior of nodes, connectors and groups
 */
export  abstract class NodeBase extends base.ChildProperty<NodeBase> {
    /**
     * Represents the unique id of nodes/connectors
     * @default ''
     */
    id: string;
    /**
     * Defines the visual order of the node/connector in DOM
     * @default -1
     */
    zIndex: number;
    /**
     * Defines the space to be let between the node and its immediate parent
     * @default 0
     */
    margin: MarginModel;
    /**
     * Sets how to horizontally align a node with respect to its immediate parent
     * @default HorizontalAlignment.Center
     */
    horizontalAlignment: HorizontalAlignment;
    /**
     * Sets how to vertically align a node with respect to its immediate parent
     * @default VerticalAlignment.Center
     */
    verticalAlignment: VerticalAlignment;
    /**
     * Sets the visibility of the node/connector
     * @default true
     */
    visible: boolean;
    /**
     * Defines the collection of connection points of nodes/connectors
     * @default undefined
     */
    ports: PointPortModel[];
    /**
     * Defines if the node is expanded or not
     * @default true
     */
    isExpanded: boolean;
    /**
     * defines the tooltip for the node
     * @default new DiagramToolTip()
     */
    tooltip: DiagramTooltipModel;
    /**
     * Defines the properties of the Expand Icon
     * @default
     */
    expandIcon: IconShapeModel;
    /**
     * Defines the properties of the collapse Icon
     * @default
     */
    collapseIcon: IconShapeModel;
    /**
     * Defines whether the node should be automatically positioned or not
     * @default false
     */
    excludeFromLayout: boolean;
    /**
     * Allows the user to save custom information/data about a node/connector
     */
    addInfo: object;
}
/**
 * Interface for a class Shape
 */
export interface ShapeModel {
    /**
     * Defines the type of node shape
     * @default 'Basic'
     */
    type?: Shapes;
    /**
     * Defines the space to be let between the node and its immediate parent
     * @default 0
     */
    margin?: MarginModel;
    
}
/**
 * Interface for a class Path
 */
export interface PathModel extends ShapeModel {
    /**
     * Defines the type of node shape
     * @default 'Basic'
     */
    type?: Shapes;
    /**
     * Defines the geometry of a path
     * @default ''
     */
    data?: string;
}
/**
 * Interface for a class Native
 */
export interface NativeModel extends ShapeModel{
    /**
     * Defines the type of node shape.
     * @default 'Basic'
     */
    type?: Shapes;
    /**
     * Defines the geometry of a native element.
     * @default ''
     */
    content?: string;
    /**
     * Defines the scale of the native element.
     * @default 'Stretch'
     */
    scale?: Stretch;
}
/**
 * Interface for a class Polygon
 */
export interface PolygonModel extends ShapeModel{
    /**
     * Defines the type of node shape
     * @default 'Basic'
     */
    type?: Shapes;
    /**
     * Defines the points for the node
     * @default undefined
     */
    points?: PointModel[];
}
/**
 * Interface for a class Image
 */
export interface ImageModel extends ShapeModel{
    /**
     * Defines the type of node shape
     * @default 'Basic'
     */
    type?: Shapes;
    /**
     * Defines the source of the image
     * @default ''
     */
    source?: string;
    /**
     * Defines the scale of the image
     * @default ''
     */
    scale?: Scale;
    /**
     * Defines the alignment of the image
     * @default ''
     */
    align?: ImageAlignment;
}
/**
 * Interface for a class Text
 */
export interface TextModel extends ShapeModel{
    /**
     * Defines the type of node shape
     * @default 'Basic'
     */
    type?: Shapes;
    /**
     * Defines the content of a text
     * @default ''
     */
    content?: string;
}
/**
 * Interface for a class BasicShape
 */
export interface BasicShapeModel extends ShapeModel{
    /**
     * Defines the type of node shape
     * @default 'Basic'
     */
    type?: Shapes;
    /**
     * Defines the type of the basic shape
     * @default ''
     */
    shape?: BasicShapes;
    /**
     * Sets the corner of the node
     * @default 0
     */
    cornerRadius?: number;
}
/**
 * Interface for a class FlowShape
 */
export interface FlowShapeModel extends ShapeModel{
    /**
     * Defines the type of node shape
     * @default 'Basic'
     */
    type?: Shapes;
    /**
     * Defines the type of the flow shape
     * @default ''
     */
    shape?: FlowShapes;
}
/**
 * Interface for a class BpmnGateway
 */
export interface BpmnGatewayModel {
    /**
     * Defines the type of the BPMN Gateway
     * @default 'None'
     */
    type?: BpmnGateways;
}
/**
 * Interface for a class BpmnDataObject
 */
export interface BpmnDataObjectModel {
    /**
     * Defines the type of the BPMN data object
     * @default 'None'
     */
    type?: BpmnDataObjects;
    /**
     * Sets whether the data object is a collection or not
     * @default false
     */
    collection?: boolean;
}
/**
 * Interface for a class BpmnTask
 */
export interface BpmnTaskModel {
    /**
     * Defines the type of the task
     * @default 'None'
     */
    type?: BpmnTasks;
    /**
     * Defines the type of the BPMN loops
     * @default 'None'
     */
    loop?: BpmnLoops;
    /**
     * Sets whether the task is global or not
     * @default false
     */
    call?: boolean;
    /**
     * Sets whether the task is triggered as a compensation of another specific activity
     * @default false
     */
    compensation?: boolean;
}
/**
 * Interface for a class BpmnEvent
 */
export interface BpmnEventModel {
    /**
     * Sets the type of the BPMN Event
     * @default 'Start'
     */
    event?: BpmnEvents;
    /**
     * Defines the type of the trigger
     * @default 'None'
     */
    trigger?: BpmnTriggers;
}
/**
 * Interface for a class BpmnSubEvents
 */
export interface BpmnSubEventsModel {
    /**
     * Defines the type of the trigger
     * @default 'None'
     */
    trigger?: BpmnTriggers;
    /**
     * Sets the type of the BPMN Event
     * @default 'Start'
     */
    event?: BpmnEvents;
    /**
     * Sets the id of the BPMN sub event
     * @default ''
     */
    name?: string;
    /**
     * Defines the position of the sub event
     * @default new Point(0.5,0.5)
     */
    offset?: PointModel;
    /**
     * Defines the collection of textual annotations of the sub events
     * @default undefined
     */
    annotations?: ShapeAnnotationModel[];
    /**
     * Defines the collection of connection points of the sub events
     * @default undefined
     */
    ports?: PointPortModel[];
    /**
     * Sets the width of the node
     * @default undefined
     */
    width?: number;
    /**
     * Sets the height of the node
     * @default undefined
     */
    height?: number;
    /**
     * Defines the space to be let between the node and its immediate parent
     * @default 0
     */
    margin?: MarginModel;
    /**
     * Sets how to horizontally align a node with respect to its immediate parent
     * @default 'Center'
     */
    horizontalAlignment?: HorizontalAlignment;
    /**
     * Sets how to vertically align a node with respect to its immediate parent
     * @default 'Center'
     */
    verticalAlignment?: VerticalAlignment;
}
/**
 * Interface for a class BpmnSubProcess
 */
export interface BpmnSubProcessModel {
    /**
     * Defines the type of the sub process
     * @default 'None'
     */
    type?: BpmnSubProcessTypes;
    /**
     * Defines whether the sub process is without any prescribed order or not
     * @default false
     */
    adhoc?: boolean;
    /**
     * Defines the boundary type of the BPMN process
     * @default 'Default'
     */
    boundary?: BpmnBoundary;
    /**
     * Defines the whether the task is triggered as a compensation of another task
     * @default false
     */
    compensation?: boolean;
    /**
     * Defines the  type of the BPMNLoop
     * @default 'None'
     */
    loop?: BpmnLoops;
    /**
     * Defines the whether the shape is collapsed or not
     * @default true
     */
    collapsed?: boolean;
    /**
     * Defines the transaction sub process
     * @default 'undefined'
     */
    events?: BpmnSubEventsModel[];
    /**
     * Defines the transaction sub process
     * @default 'None'
     */
    transaction?: TransactionSubProcesses;
}
/**
 * Interface for a class BpmnActivity
 */
export interface BpmnActivityModel {
    /**
     * Defines the type of the activity
     * @default 'Task'
     */
    activity?: BpmnActivities;
    /**
     * Defines the BPMN task
     * @default 'new BPMNTask()'
     */
    task?: BpmnTaskModel;
    /**
     * Defines the type of the SubProcesses
     * @default 'None'
     */
    subProcess?: BpmnSubProcessModel;
}
/**
 * Interface for a class BpmnShape
 */
export interface BpmnShapeModel extends ShapeModel{
    /**
     * Defines the type of node shape
     * @default 'Bpmn'
     */
    type?: Shapes;
    /**
     * Defines the type of the BPMN shape
     * @default 'Event'
     */
    shape?: BpmnShapes;
    /**
     * Defines the type of node shape
     * @default 'None'
     */
    event?: BpmnEventModel;
    /**
     * Defines the type of node shape
     * @default 'None'
     */
    gateway?: BpmnGatewayModel;
    /**
     * Defines the type of node shape
     * @default 'None'
     */
    dataObject?: BpmnDataObjectModel;
    /**
     * Defines the type of node shape
     * @default 'None'
     */
    activity?: BpmnActivityModel;
}
/**
 * Interface for a class Node
 */
export interface NodeModel extends NodeBaseModel{
    /**
     * Defines the collection of textual annotations of nodes/connectors
     * @default undefined
     */
    annotations?: ShapeAnnotationModel[];
    /**
     * Sets the x-coordinate of the position of the node
     * @default 0
     */
    offsetX?: number;
    /**
     * Sets the y-coordinate of the position of the node
     * @default 0
     */
    offsetY?: number;
    /**
     * Sets the reference point, that will act as the offset values(offsetX, offsetY) of a node
     * @default new Point(0.5,0.5)
     */
    pivot?: PointModel;
    /**
     * Sets the width of the node
     * @default undefined
     */
    width?: number;
    /**
     * Sets the height of the node
     * @default undefined
     */
    height?: number;
    /**
     * Sets the minimum width of the node
     * @default undefined
     */
    minWidth?: number;
    /**
     * Sets the minimum height of the node
     * @default undefined
     */
    minHeight?: number;
    /**
     * Sets the maximum width of the node
     * @default undefined
     */
    maxWidth?: number;
    /**
     * Sets the maximum height of the node
     * @default undefined
     */
    maxHeight?: number;
    /**
     * Sets the rotate angle of the node
     * @default 0
     */
    rotateAngle?: number;
    /**
     * Sets the shape style of the node
     * @default new ShapeStyle()
     */
    style?: ShapeStyleModel | TextStyleModel;
    /**
     * Sets the background color of the shape
     * @default 'none'
     */
    backgroundColor?: string;
    /**
     * Sets the border color of the node
     * @default 'none'
     */
    borderColor?: string;
    /**
     * Sets the border width of the node
     * @default 0
     */
    borderWidth?: number;
    /**
     * Sets the data source of the node
     */
    data?: object;
    /**
     * Defines the shape of a node
     * @default Basic Shape
     */
    shape?: ShapeModel | FlowShapeModel | BasicShapeModel | ImageModel | PathModel | TextModel | BpmnShapeModel | NativeModel | PolygonModel;
    /**
     * Sets or gets the UI of a node
     * @default null
     */
    wrapper?: Container;
    /**
     * Enables/Disables certain features of nodes
     * @default NodeConstraints.Default
     */
    constraints?: NodeConstraints;
    /**
     * Defines the shadow of a shape/path
     * @default null
     */
    shadow?: ShadowModel;
}

/**
 * Defines the behavior of default shape
 */
export  class Shape extends base.ChildProperty<Shape> {
    /**
     * Defines the type of node shape
     * @default 'Basic'
     */
    type: Shapes;
    /**
     * Defines the space to be let between the node and its immediate parent
     * @default 0
     */
    margin: MarginModel;
}
/**
 * Defines the behavior of path shape
 */
export  class Path extends Shape {
    /**
     * Defines the type of node shape
     * @default 'Basic'
     */
    type: Shapes;
    /**
     * Defines the geometry of a path
     * @default ''
     */
    data: string;
}
/**
 * Defines the behavior of Native shape
 */
export  class Native extends Shape {
    /**
     * Defines the type of node shape.
     * @default 'Basic'
     */
    type: Shapes;
    /**
     * Defines the geometry of a native element.
     * @default ''
     */
    content: string;
    /**
     * Defines the scale of the native element.
     * @default 'Stretch'
     */
    scale: Stretch;
}
/**
 * Defines the polygon shape
 */
export  class Polygon extends Shape {
    /**
     * Defines the type of node shape
     * @default 'Basic'
     */
    type: Shapes;
    /**
     * Defines the points for the node
     * @default undefined
     */
    points: PointModel[];
}
/**
 * Defines the behavior of image shape
 */
export  class Image extends Shape {
    /**
     * Defines the type of node shape
     * @default 'Basic'
     */
    type: Shapes;
    /**
     * Defines the source of the image
     * @default ''
     */
    source: string;
    /**
     * Defines the scale of the image
     * @default ''
     */
    scale: Scale;
    /**
     * Defines the alignment of the image
     * @default ''
     */
    align: ImageAlignment;
}
/**
 * Defines the behavior of the text shape
 */
export  class Text extends Shape {
    /**
     * Defines the type of node shape
     * @default 'Basic'
     */
    type: Shapes;
    /**
     * Defines the content of a text
     * @default ''
     */
    content: string;
}
/**
 * Defines the behavior of the basic shape
 */
export  class BasicShape extends Shape {
    /**
     * Defines the type of node shape
     * @default 'Basic'
     */
    type: Shapes;
    /**
     * Defines the type of the basic shape
     * @default ''
     */
    shape: BasicShapes;
    /**
     * Sets the corner of the node
     * @default 0
     */
    cornerRadius: number;
}
/**
 * Defines the behavior of the flow shape
 */
export  class FlowShape extends Shape {
    /**
     * Defines the type of node shape
     * @default 'Basic'
     */
    type: Shapes;
    /**
     * Defines the type of the flow shape
     * @default ''
     */
    shape: FlowShapes;
}
/**
 * Defines the behavior of the bpmn gateway shape
 */
export  class BpmnGateway extends base.ChildProperty<BpmnGateway> {
    /**
     * Defines the type of the BPMN Gateway
     * @default 'None'
     */
    type: BpmnGateways;
}
/**
 * Defines the behavior of the bpmn data object
 */
export  class BpmnDataObject extends base.ChildProperty<BpmnDataObject> {
    /**
     * Defines the type of the BPMN data object
     * @default 'None'
     */
    type: BpmnDataObjects;
    /**
     * Sets whether the data object is a collection or not
     * @default false
     */
    collection: boolean;
}
/**
 * Defines the behavior of the bpmn task shape
 */
export  class BpmnTask extends base.ChildProperty<BpmnTask> {
    /**
     * Defines the type of the task
     * @default 'None'
     */
    type: BpmnTasks;
    /**
     * Defines the type of the BPMN loops
     * @default 'None'
     */
    loop: BpmnLoops;
    /**
     * Sets whether the task is global or not
     * @default false
     */
    call: boolean;
    /**
     * Sets whether the task is triggered as a compensation of another specific activity
     * @default false
     */
    compensation: boolean;
}
/**
 * Defines the behavior of the bpmn Event shape
 */
export  class BpmnEvent extends base.ChildProperty<BpmnEvent> {
    /**
     * Sets the type of the BPMN Event
     * @default 'Start'
     */
    event: BpmnEvents;
    /**
     * Defines the type of the trigger
     * @default 'None'
     */
    trigger: BpmnTriggers;
}
/**
 * Defines the behavior of the bpmn sub event
 */
export  class BpmnSubEvents extends base.ChildProperty<BpmnSubEvents> {
    /**
     * Defines the type of the trigger
     * @default 'None'
     */
    trigger: BpmnTriggers;
    /**
     * Sets the type of the BPMN Event
     * @default 'Start'
     */
    event: BpmnEvents;
    /**
     * Sets the id of the BPMN sub event
     * @default ''
     */
    name: string;
    /**
     * Defines the position of the sub event
     * @default new Point(0.5,0.5)
     */
    offset: PointModel;
    /**
     * Defines the collection of textual annotations of the sub events
     * @default undefined
     */
    annotations: ShapeAnnotationModel[];
    /**
     * Defines the collection of connection points of the sub events
     * @default undefined
     */
    ports: PointPortModel[];
    /**
     * Sets the width of the node
     * @default undefined
     */
    width: number;
    /**
     * Sets the height of the node
     * @default undefined
     */
    height: number;
    /**
     * Defines the space to be let between the node and its immediate parent
     * @default 0
     */
    margin: MarginModel;
    /**
     * Sets how to horizontally align a node with respect to its immediate parent
     * @default 'Center'
     */
    horizontalAlignment: HorizontalAlignment;
    /**
     * Sets how to vertically align a node with respect to its immediate parent
     * @default 'Center'
     */
    verticalAlignment: VerticalAlignment;
}
/**
 * Defines the behavior of the BPMNSubProcess
 */
export  class BpmnSubProcess extends base.ChildProperty<BpmnSubProcess> {
    /**
     * Defines the type of the sub process
     * @default 'None'
     */
    type: BpmnSubProcessTypes;
    /**
     * Defines whether the sub process is without any prescribed order or not
     * @default false
     */
    adhoc: boolean;
    /**
     * Defines the boundary type of the BPMN process
     * @default 'Default'
     */
    boundary: BpmnBoundary;
    /**
     * Defines the whether the task is triggered as a compensation of another task
     * @default false
     */
    compensation: boolean;
    /**
     * Defines the  type of the BPMNLoop
     * @default 'None'
     */
    loop: BpmnLoops;
    /**
     * Defines the whether the shape is collapsed or not
     * @default true
     */
    collapsed: boolean;
    /**
     * Defines the transaction sub process
     * @default 'undefined'
     */
    events: BpmnSubEventsModel[];
    /**
     * Defines the transaction sub process
     * @default 'None'
     */
    transaction: TransactionSubProcesses;
}
/**
 * Defines the behavior of the bpmn activity shape
 */
export  class BpmnActivity extends base.ChildProperty<BpmnActivity> {
    /**
     * Defines the type of the activity
     * @default 'Task'
     */
    activity: BpmnActivities;
    /**
     * Defines the BPMN task
     * @default 'new BPMNTask()'
     */
    task: BpmnTaskModel;
    /**
     * Defines the type of the SubProcesses
     * @default 'None'
     */
    subProcess: BpmnSubProcessModel;
}
/**
 * Defines the behavior of the bpmn shape
 */
export  class BpmnShape extends Shape {
    /**
     * Defines the type of node shape
     * @default 'Bpmn'
     */
    type: Shapes;
    /**
     * Defines the type of the BPMN shape
     * @default 'Event'
     */
    shape: BpmnShapes;
    /**
     * Defines the type of node shape
     * @default 'None'
     */
    event: BpmnEventModel;
    /**
     * Defines the type of node shape
     * @default 'None'
     */
    gateway: BpmnGatewayModel;
    /**
     * Defines the type of node shape
     * @default 'None'
     */
    dataObject: BpmnDataObjectModel;
    /**
     * Defines the type of node shape
     * @default 'None'
     */
    activity: BpmnActivityModel;
}
/**
 * Defines the behavior of nodes
 */
export  class Node extends NodeBase implements IElement {
    /**
     * Defines the collection of textual annotations of nodes/connectors
     * @default undefined
     */
    annotations: ShapeAnnotationModel[];
    /**
     * Sets the x-coordinate of the position of the node
     * @default 0
     */
    offsetX: number;
    /**
     * Sets the y-coordinate of the position of the node
     * @default 0
     */
    offsetY: number;
    /**
     * Sets the reference point, that will act as the offset values(offsetX, offsetY) of a node
     * @default new Point(0.5,0.5)
     */
    pivot: PointModel;
    /**
     * Sets the width of the node
     * @default undefined
     */
    width: number;
    /**
     * Sets the height of the node
     * @default undefined
     */
    height: number;
    /**
     * Sets the minimum width of the node
     * @default undefined
     */
    minWidth: number;
    /**
     * Sets the minimum height of the node
     * @default undefined
     */
    minHeight: number;
    /**
     * Sets the maximum width of the node
     * @default undefined
     */
    maxWidth: number;
    /**
     * Sets the maximum height of the node
     * @default undefined
     */
    maxHeight: number;
    /**
     * Sets the rotate angle of the node
     * @default 0
     */
    rotateAngle: number;
    /**
     * Sets the shape style of the node
     * @default new ShapeStyle()
     */
    style: ShapeStyleModel | TextStyleModel;
    /**
     * Sets the background color of the shape
     * @default 'none'
     */
    backgroundColor: string;
    /**
     * Sets the border color of the node
     * @default 'none'
     */
    borderColor: string;
    /**
     * Sets the border width of the node
     * @default 0
     */
    borderWidth: number;
    /**
     * Sets the data source of the node
     */
    data: object;
    /**
     * Defines the shape of a node
     * @default Basic Shape
     */
    shape: ShapeModel | FlowShapeModel | BasicShapeModel | ImageModel | PathModel | TextModel | BpmnShapeModel | NativeModel | PolygonModel;
    /**
     * Sets or gets the UI of a node
     * @default null
     */
    wrapper: Container;
    /**
     * Enables/Disables certain features of nodes
     * @default NodeConstraints.Default
     */
    constraints: NodeConstraints;
    /**
     * Defines the shadow of a shape/path
     * @default null
     */
    shadow: ShadowModel;
    /** @private */
    parentId: string;
    /** @private */
    outEdges: string[];
    /** @private */
    inEdges: string[];
    /** @private */
    readonly actualSize: Size;
    constructor(parent: any, propName: string, defaultValue: Object, isArray?: boolean);
    /**
     * Allows to initialize the UI of a node
     */
    /** @private */
    init(diagram: any): DiagramElement;
    /** @private */
    initContainer(): Container;
    /** @private */
    initPorts(): void;
    /** @private */
    initIcons(): void;
    /** @private */
    initAnnotations(): void;
    /** @private */
    initPortWrapper(ports: Port): DiagramElement;
    /** @private */
    initAnnotationWrapper(annotation: Annotation): DiagramElement;
    private initIconContainer(options, iconContainer);
    private initIconSymbol(options, iconContainer);
}
/** @private */
export  let getNodeType: Function;
/**
 * Interface for a class Port
 */
export interface PortModel {
    /**
     * Defines the unique id of the port
     * @default ''
     */
    id?: string;
    /**
     * Sets the horizontal alignment of the port with respect to its immediate parent(node/connector)
     * @default 'Center'
     */
    horizontalAlignment?: HorizontalAlignment;
    /**
     * Sets the vertical alignment of the port with respect to its immediate parent(node/connector)
     * @default 'Center'
     */
    verticalAlignment?: VerticalAlignment;
    /**
     * Defines the space that the port has to be moved from its actual position
     * @default new base.Margin(0,0,0,0)
     */
    margin?: MarginModel;
    /**
     * Sets the width of the port
     * @default 12
     */
    width?: number;
    /**
     * Sets the height of the port
     * @default 12
     */
    height?: number;
    /**
     * Defines the appearance of the port
     */
    style?: ShapeStyleModel;
    /**
     * Defines the type of the port shape
     * @default 'Square'
     */
    shape?: PortShapes;
    /**
     * Defines the type of the port visibility
     * @default PortVisibility.Visible
     */
    visibility?: PortVisibility;
    /**
     * Defines the geometry of the port
     * @default ''
     */
    pathData?: string;
    /**
     * Defines the type of the port
     */
    type?: PortTypes;
    /**
     * Allows the user to save custom information/data about a port
     */
    addInfo?: object;
}
/**
 * Interface for a class PointPort
 */
export interface PointPortModel extends PortModel{
    /**
     * Defines the position of the port with respect to the boundaries of nodes/connector
     * @default new Point(0.5,0.5)
     */
    offset?: PointModel;
}
/**
 * Defines the behavior of connection ports
 */
export  abstract class Port extends base.ChildProperty<Port> {
    /**
     * Defines the unique id of the port
     * @default ''
     */
    id: string;
    /**
     * Sets the horizontal alignment of the port with respect to its immediate parent(node/connector)
     * @default 'Center'
     */
    horizontalAlignment: HorizontalAlignment;
    /**
     * Sets the vertical alignment of the port with respect to its immediate parent(node/connector)
     * @default 'Center'
     */
    verticalAlignment: VerticalAlignment;
    /**
     * Defines the space that the port has to be moved from its actual position
     * @default new Margin(0,0,0,0)
     */
    margin: MarginModel;
    /**
     * Sets the width of the port
     * @default 12
     */
    width: number;
    /**
     * Sets the height of the port
     * @default 12
     */
    height: number;
    /**
     * Defines the appearance of the port
     */
    style: ShapeStyleModel;
    /**
     * Defines the type of the port shape
     * @default 'Square'
     */
    shape: PortShapes;
    /**
     * Defines the type of the port visibility
     * @default PortVisibility.Visible
     */
    visibility: PortVisibility;
    /**
     * Defines the geometry of the port
     * @default ''
     */
    pathData: string;
    /**
     * Defines the type of the port
     */
    type: PortTypes;
    /**
     * Allows the user to save custom information/data about a port
     */
    addInfo: object;
}
/**
 * Defines the behavior of a port, that sticks to a point
 */
export  class PointPort extends Port {
    /**
     * Defines the position of the port with respect to the boundaries of nodes/connector
     * @default new Point(0.5,0.5)
     */
    offset: PointModel;
    constructor(parent: any, propName: string, defaultValue: Object, isArray?: boolean);
}
/**
 * ServiceLocator
 * @hidden
 */
export  class ServiceLocator {
    private services;
    register<T>(name: string, type: T): void;
    getService<T>(name: string): T;
}
/**
 * Snapping
 */
export  class SnappingController {
    private line;
    private diagram;
    private render;
    constructor(diagram: Diagram);
    /** @private */
    canSnap(): boolean;
    /**
     * Snap to object
     * @private
     */
    snapPoint(diagram: Diagram, selectedObject: SelectorModel, towardsLeft: boolean, towardsTop: boolean, delta: PointModel, startPoint: PointModel, endPoint: PointModel): PointModel;
    /**
     * @private
     */
    round(value: number, snapIntervals: number[], scale: number): number;
    /**
     * Snap to Object
     */
    private snapObject(diagram, selectedObject, g, horizontalSnap, verticalSnap, delta, ended);
    /**
     * @private
     */
    snapConnectorEnd(point: PointModel): PointModel;
    private canBeTarget(diagram, node);
    private snapSize(diagram, horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, selectedObject, ended);
    /**
     * Snap to object on top
     * @private
     */
    snapTop(horizontalSnap: Snap, verticalSnap: Snap, snapLine: SVGElement, deltaX: number, deltaY: number, shape: SelectorModel, ended: boolean, initialBoundsT: Rect): number;
    /**
     * Snap to object on right
     * @private
     */
    snapRight(horizontalSnap: Snap, verticalSnap: Snap, snapLine: SVGElement, deltaX: number, deltaY: number, shape: SelectorModel, ended: boolean, initialBound: Rect): number;
    /**
     * Snap to object on left
     * @private
     */
    snapLeft(horizontalSnap: Snap, verticalSnap: Snap, snapLine: SVGElement, deltaX: number, deltaY: number, shape: SelectorModel, ended: boolean, initialBoundsB: Rect): number;
    /**
     * Snap to object on bottom
     * @private
     */
    snapBottom(horizontalSnap: Snap, verticalSnap: Snap, snapLine: SVGElement, deltaX: number, deltaY: number, shape: SelectorModel, ended: boolean, initialRect: Rect): number;
    /**
     * To create the same width and same size lines
     */
    private createGuidelines(diagram, hTarget, vTarget, snapLine, horizontalSnap, verticalSnap, ended);
    /**
     * To create the alignment lines
     */
    private renderAlignmentLines(start, end, svg, transform);
    /**
     * To create Horizontal spacing lines
     */
    private createHSpacingLines(diagram, g, shape, objectsAtLeft, objectsAtRight, horizontalSnap, verticalSnap, ended, delta, snapObjDistance);
    /**
     * To create vertical spacing lines
     */
    private createVSpacingLines(diagram, g, shape, objectsAtTop, objectsAtBottom, horizontalSnap, verticalSnap, ended, delta, snapObjDistance);
    /**
     * Add the Horizontal spacing lines
     */
    private addHSpacingLines(diagram, g, equallySpaced, ended, top);
    /**
     * Add the vertical spacing lines
     */
    private addVSpacingLines(diagram, g, equallySpacedObjects, ended, right);
    /**
     * To add same width lines
     */
    private addSameWidthLines(diagram, snapLine, sameWidths, horizontalSnap, ended, shape);
    /**
     * To add same height lines
     */
    private addSameHeightLines(diagram, snapLine, sameHeights, verticalSnap, ended, shape);
    /**
     * Render spacing lines
     */
    private renderSpacingLines(start, end, snapLine, svg, transform);
    /**
     * To Create Snap object with position, initial bounds, and final bounds
     * @private
     */
    createSnapObject(targetBounds: Rect, bounds: Rect, snap: string): SnapObject;
    /**
     * Calculate the snap angle
     * @private
     */
    snapAngle(diagram: Diagram, angle: number): number;
    /**
     * Check whether the node to be snappd or not.
     */
    private canConsider(nameTable, selectedObject, target);
    /**
     * Find the total number of nodes in diagram usind SpatialSearch
     */
    private findNodes(spatialSearch, node, child, viewPort?, nodesInView?);
    private intersectsRect(child, bounds);
    /**
     * To remove grid lines on mouse move and mouse up
     * @private
     */
    removeGuidelines(diagram: Diagram): void;
    /**
     * Sort the objects by its distance
     */
    private sortByDistance(obj, value, ascending?);
    /**
     * To find nodes that are equally placed at left of the selected node
     */
    private findEquallySpacedNodesAtLeft(objectsAtLeft, equalDistance, top, equallySpaced);
    /**
     * To find nodes that are equally placed at right of the selected node
     */
    private findEquallySpacedNodesAtRight(objectsAtRight, equalDistance, top, equallySpaced, snapObjDistance);
    private findEquallySpacedNodesAtTop(objectsAtTop, equalDistance, right, equallySpaced);
    /**
     * To find nodes that are equally placed at bottom of the selected node
     */
    private findEquallySpacedNodesAtBottom(objectsAtBottom, equalDistance, right, equallySpaced, snapObjDistance);
    /**
     * To get Adoner layer to draw snapLine
     * @private
     */
    getLayer(): SVGElement;
    /**
     * Constructor for the snapping module
     * @private
     */
    /**
     * To destroy the snapping module
     * @return {void}
     * @private
     */
    destroy(): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
export interface Snap {
    snapped: boolean;
    offset: number;
    left?: boolean;
    bottom?: boolean;
    right?: boolean;
    top?: boolean;
}
/**
 * @private
 */
export interface SnapObject {
    start: PointModel;
    end: PointModel;
    offsetX: number;
    offsetY: number;
    type: string;
}
/**
 * @private
 */
export interface Objects {
    object: DiagramElement;
    distance: number;
}
/**
 * @private
 */
export interface SnapSize {
    source: NodeModel;
    difference: number;
    offset: number;
}

/**
 * Interface for a class DiagramTooltip
 */
export interface DiagramTooltipModel {
    /**
     * Defines the content of the base.Tooltip
     * @default ''
     */
    content?: string | HTMLElement;
    /**
     * Defines the position of the base.Tooltip
     * @default 'TopLeft'
     */
    position?: popups.Position;
    /**
     * Defines the relative mode of the base.Tooltip
     * @default 'Mouse'
     */
    relativeMode?: TooltipRelativeMode;
    /**
     * Defines if the base.Tooltip has tip pointer or not
     * @default true
     */
    showTipPointer?: boolean;
    /**
     * Sets the width of the base.Tooltip
     * @default 'auto'
     */
    width?: number | string;
    /**
     * Sets the height of the base.Tooltip
     * @default 'auto'
     */
    height?: number | string;
    /**
     * Allows to set the same or different animation option for the base.Tooltip, when it is opened or closed.
     * @default { open: { effect: 'FadeIn', duration: 150, delay: 0 }, close: { effect: 'FadeOut', duration: 150, delay: 0 } }
     */
    animation?: base.AnimationModel;
}
/**
 * Defines the behavior of popups.Tooltip
 */
export  abstract class DiagramTooltip extends base.ChildProperty<DiagramTooltip> {
    /**
     * Defines the content of the popups.Tooltip
     * @default ''
     */
    content: string | HTMLElement;
    /**
     * Defines the position of the popups.Tooltip
     * @default 'TopLeft'
     */
    position: popups.Position;
    /**
     * Defines the relative mode of the popups.Tooltip
     * @default 'Mouse'
     */
    relativeMode: TooltipRelativeMode;
    /**
     * Defines if the popups.Tooltip has tip pointer or not
     * @default true
     */
    showTipPointer: boolean;
    /**
     * Sets the width of the popups.Tooltip
     * @default 'auto'
     */
    width: number | string;
    /**
     * Sets the height of the popups.Tooltip
     * @default 'auto'
     */
    height: number | string;
    /**
     * Allows to set the same or different animation option for the popups.Tooltip, when it is opened or closed.
     * @default { open: { effect: 'FadeIn', duration: 150, delay: 0 }, close: { effect: 'FadeOut', duration: 150, delay: 0 } }
     */
    animation: popups.AnimationModel;
}
/**
 * @private
 * defines the popups.Tooltip.
 * @param diagram
 */
export  function initTooltip(diagram: Diagram): popups.Tooltip;
/**
 * @private
 * updates the contents of the tooltip.
 * @param diagram
 * @param node
 */
export  function updateTooltip(diagram: Diagram, node?: NodeModel | ConnectorModel): popups.Tooltip;
/**
 * @private
 * sets the offset of the tooltip.
 * @param diagram
 * @param mousePosition
 * @param node
 */
export  function getTooltipOffset(diagram: Diagram, mousePosition: PointModel, node: NodeModel | ConnectorModel): PointModel;
/**
 * Undo redo function used for revert and restore the changes
 */
export  class UndoRedo {
    private groupUndo;
    /** @private */
    initHistory(diagram: Diagram): void;
    /** @private */
    addHistoryEntry(entry: HistoryEntryModel, diagram: Diagram): void;
    /** @private */
    undo(diagram: Diagram): void;
    private undoEntry(entry, diagram);
    private recordPropertyChanged(entry, diagram, isRedo);
    private recordPositionChanged(object, diagram);
    private positionChanged(object, diagram);
    private recordSizeChanged(object, diagram);
    private sizeChanged(object, diagram);
    private recordRotationChanged(object, diagram);
    private rotationChanged(object, diagram);
    private recordConnectionChanged(object, diagram);
    private connectionChanged(object, diagram);
    private recordCollectionChanged(entry, diagram);
    /** @private */
    redo(diagram: Diagram): void;
    private redoEntry(historyEntry, diagram);
    private getUndoEntry(diagram);
    private getRedoEntry(diagram);
    /**
     * Constructor for the undo redo module
     * @private
     */
    constructor();
    /**
     * To destroy the undo redo module
     * @return {void}
     * @private
     */
    destroy(): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * Matrix module is used to transform points based on offsets, angle
 */
/** @private */
export  enum MatrixTypes {
    Identity = 0,
    Translation = 1,
    Scaling = 2,
    Unknown = 4,
}
/** @private */
export  class Matrix {
    m11: number;
    m12: number;
    m21: number;
    m22: number;
    offsetX: number;
    offsetY: number;
    type: MatrixTypes;
    constructor(m11: number, m12: number, m21: number, m22: number, offsetX: number, offsetY: number, type?: MatrixTypes);
}
/** @private */
export  function identityMatrix(): Matrix;
/** @private */
export  function transformPointByMatrix(matrix: Matrix, point: PointModel): PointModel;
/** @private */
export  function transformPointsByMatrix(matrix: Matrix, points: PointModel[]): PointModel[];
/** @private */
export  function rotateMatrix(matrix: Matrix, angle: number, centerX: number, centerY: number): void;
/** @private */
export  function scaleMatrix(matrix: Matrix, scaleX: number, scaleY: number, centerX?: number, centerY?: number): void;
/** @private */
export  function translateMatrix(matrix: Matrix, offsetX: number, offsetY: number): void;
/** @private */
export  function multiplyMatrix(matrix1: Matrix, matrix2: Matrix): void;
/**
 * Interface for a class Point
 */
export interface PointModel {
    /**
     * Sets the x-coordinate of a position
     * @default 0
     */
    x?: number;
    /**
     * Sets the y-coordinate of a position
     * @default 0
     */
    y?: number;
}
/**
 * Defines and processes coordinates
 */
export  class Point extends base.ChildProperty<Point> {
    /**
     * Sets the x-coordinate of a position
     * @default 0
     */
    x: number;
    /**
     * Sets the y-coordinate of a position
     * @default 0
     */
    y: number;
    static equals(point1: PointModel, point2: PointModel): boolean;
    /**
     * check whether the points are given
     */
    static isEmptyPoint(point: PointModel): boolean;
    static transform(point: PointModel, angle: number, length: number): PointModel;
    static findLength(s: PointModel, e: PointModel): number;
    static findAngle(point1: PointModel, point2: PointModel): number;
    static distancePoints(pt1: PointModel, pt2: PointModel): number;
    static adjustPoint(source: PointModel, target: PointModel, isStart: boolean, length: number): PointModel;
}
/**
 * Rect defines and processes rectangular regions
 */
export  class Rect {
    /**
     * Sets the x-coordinate of the starting point of a rectangular region
     * @default 0
     */
    x: number;
    /**
     * Sets the y-coordinate of the starting point of a rectangular region
     * @default 0
     */
    y: number;
    /**
     * Sets the width of a rectangular region
     * @default 0
     */
    width: number;
    /**
     * Sets the height of a rectangular region
     * @default 0
     */
    height: number;
    constructor(x?: number, y?: number, width?: number, height?: number);
    static empty: Rect;
    readonly left: number;
    readonly right: number;
    readonly top: number;
    readonly bottom: number;
    readonly topLeft: PointModel;
    readonly topRight: PointModel;
    readonly bottomLeft: PointModel;
    readonly bottomRight: PointModel;
    readonly middleLeft: PointModel;
    readonly middleRight: PointModel;
    readonly topCenter: PointModel;
    readonly bottomCenter: PointModel;
    readonly center: PointModel;
    equals(rect1: Rect, rect2: Rect): boolean;
    uniteRect(rect: Rect): Rect;
    unitePoint(point: PointModel): void;
    Inflate(padding: number): Rect;
    intersects(rect: Rect): boolean;
    containsRect(rect: Rect): boolean;
    containsPoint(point: PointModel, padding?: number): boolean;
    static toBounds(points: PointModel[]): Rect;
}
/**
 * Size defines and processes the size(width/height) of the objects
 */
export  class Size {
    /**
     * Sets the height of an object
     * @default 0
     */
    height: number;
    /**
     * Sets the width of an object
     * @default 0
     */
    width: number;
    constructor(width?: number, height?: number);
    isEmpty(): boolean;
    clone(): Size;
}
/**
 * Print and Export Settings
 */
export  class PrintAndExport {
    private diagram;
    constructor(diagram: Diagram);
    /**
     * To Export the diagram
     * @private
     */
    exportDiagram(options: IExportOptions): string | SVGElement;
    private setCanvas(options, bounds, margin, mode, customBounds, region, fileName);
    private exportImage(images, fileName, fileType, image);
    private getDiagramBounds(mode?);
    private setScaleValueforCanvas(options, bounds);
    private diagramAsSvg(options);
    private diagramAsCanvas(options, customBounds);
    private isImageExportable(backgroundImage);
    private getPrintCanvasStyle(img, options);
    private getMultipleImage(img, options, isExport?);
    private printImage(div, url, i);
    /**
     * To print the image
     * @private
     */
    print(options: IExportOptions): void;
    /**
     * To destroy the Print and Export module
     * @return {void}
     * @private
     */
    destroy(): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * canvas interface
 */
/** @private */
export interface StyleAttributes {
    fill: string;
    stroke: string;
    strokeWidth: number;
    dashArray: string;
    opacity: number;
    shadow?: ShadowModel;
    gradient?: GradientModel;
    class?: string;
}
/** @private */
export interface BaseAttributes extends StyleAttributes {
    id: string;
    x: number;
    y: number;
    width: number;
    height: number;
    angle: number;
    pivotX: number;
    pivotY: number;
    visible: boolean;
}
/** @private */
export interface LineAttributes extends BaseAttributes {
    startPoint: PointModel;
    endPoint: PointModel;
}
/** @private */
export interface CircleAttributes extends BaseAttributes {
    centerX: number;
    centerY: number;
    radius: number;
    id: string;
}
/** @private */
export interface Alignment {
    vAlign?: string;
    hAlign?: string;
}
/** @private */
export interface SegmentInfo {
    point?: PointModel;
    index?: number;
    angle?: number;
}
/** @private */
export interface RectAttributes extends BaseAttributes {
    cornerRadius?: number;
}
/** @private */
export interface PathAttributes extends BaseAttributes {
    data: string;
}
/** @private */
export interface ImageAttributes extends BaseAttributes {
    source: string;
    sourceX: number;
    sourceY: number;
    sourceWidth: number;
    sourceHeight: number;
    scale: Scale;
    alignment: ImageAlignment;
}
/** @private */
export interface NativeAttributes extends BaseAttributes {
    content: SVGElement;
    scale: Stretch;
}
/** @private */
export interface TextAttributes extends BaseAttributes {
    whiteSpace: string;
    content: string;
    breakWord: string;
    fontSize: number;
    fontFamily: string;
    bold: boolean;
    italic: boolean;
    textAlign: string;
    color: string;
    textOverflow: TextOverflow;
    textDecoration: string;
}
/** @private */
export interface SubTextElement {
    text: string;
    x: number;
    dy: number;
}
/** @private */
export interface TextBounds {
    x: number;
    width: number;
}
/** @private */
export interface PathSegment {
    command?: string;
    angle?: number;
    largeArc?: boolean;
    x2?: number;
    sweep?: boolean;
    x1?: number;
    y1?: number;
    y2?: number;
    x0?: number;
    y0?: number;
    x?: number;
    y?: number;
    r1?: number;
    r2?: number;
    centp?: {
        x?: number;
        y?: number;
    };
    xAxisRotation?: number;
    rx?: number;
    ry?: number;
    a1?: number;
    ad?: number;
}
/**
 * Canvas Renderer
 */
/** @private */
export  class CanvasRenderer implements IRenderer {
    static getContext(canvas: HTMLCanvasElement): CanvasRenderingContext2D;
    private static setCanvasSize(canvas, width, height);
    renderGradient(options: StyleAttributes, ctx: CanvasRenderingContext2D, x?: number, y?: number): CanvasRenderingContext2D;
    renderShadow(options: BaseAttributes, canvas: HTMLCanvasElement, collection?: Object[]): void;
    static createCanvas(id: string, width: number, height: number): HTMLCanvasElement;
    private setStyle(canvas, style);
    private rotateContext(canvas, angle, x, y);
    private setFontStyle(canvas, text);
    parseDashArray(dashArray: string): number[];
    drawRectangle(canvas: HTMLCanvasElement, options: RectAttributes): void;
    drawPath(canvas: HTMLCanvasElement, options: PathAttributes): void;
    renderPath(canvas: HTMLCanvasElement, options: PathAttributes, collection: Object[]): void;
    drawText(canvas: HTMLCanvasElement, options: TextAttributes): void;
    overFlow(text: string, ctx: CanvasRenderingContext2D, options: TextAttributes): string;
    middleElement(i: number, j: number): number;
    drawImage(canvas: HTMLCanvasElement, obj: ImageAttributes): void;
    private m(v);
    private r(u, v);
    private a(u, v);
    labelAlign(text: TextAttributes, wrapBounds: TextBounds, childNodes: SubTextElement[]): PointModel;
    wrapTextAlign(text: TextAttributes, childNodes: SubTextElement[], ctx: CanvasRenderingContext2D): TextBounds;
    wrapText(text: TextAttributes, ctx: CanvasRenderingContext2D): SubTextElement[];
    private wordWrapping(text, ctx);
}
/**
 * IRenderer interface defines the base of the SVG and Canvas renderer.
 */
/** @private */
export interface IRenderer {
    renderShadow(options: BaseAttributes, canvas: HTMLCanvasElement | SVGElement, collection: Object[]): void;
    parseDashArray(dashArray: string): number[];
    drawRectangle(canvas: HTMLCanvasElement | SVGElement, options: RectAttributes, onlyRect?: boolean, isSelector?: boolean, parentSvg?: SVGSVGElement): void;
    drawPath(canvas: HTMLCanvasElement | SVGElement, options: PathAttributes, isSelector?: boolean, parentSvg?: SVGSVGElement): void;
    renderPath(canvas: HTMLCanvasElement | SVGElement, options: PathAttributes, collection: Object[]): void;
    drawText(canvas: HTMLCanvasElement | SVGElement, options: TextAttributes, parentSvg?: SVGSVGElement): void;
    drawImage(canvas: HTMLCanvasElement | SVGElement | ImageElement, obj: ImageAttributes): void;
}

export class Transforms{}
/**
 * Renderer module is used to render basic diagram elements
 */
/** @private */
export  class DiagramRenderer {
    renderer: IRenderer;
    private diagramId;
    private isSvgMode;
    private svgRenderer;
    constructor(name: string, svgRender: IRenderer, isSvgMode: Boolean);
    setCursor(canvas: HTMLElement, cursor: string): void;
    private getDiagramLayerSvg();
    private getAdornerLayer();
    private getParentSvg(element, targetElement?);
    private getParentElement(element, defaultParent, svgElement);
    private createParentElement(element, canvas);
    renderElement(element: DiagramElement, canvas: HTMLCanvasElement | SVGElement, transform?: Transforms, parentSvg?: SVGSVGElement, createParent?: boolean): void;
    highlightSelectedRegion(x: number, y: number, w: number, h: number, canvas: HTMLCanvasElement | SVGElement, t: Transforms): void;
    /**
     * @private
     */
    renderHighlighter(element: DiagramElement, canvas: SVGElement, transform: Transforms): void;
    drawLine(canvas: SVGElement, options: LineAttributes): void;
    drawPath(canvas: SVGElement, options: PathAttributes): void;
    renderResizeHandle(element: DiagramElement, canvas: HTMLCanvasElement | SVGElement, constraints: ThumbsConstraints, selectorConstraints?: SelectorConstraints, transform?: Transforms): void;
    renderEndPointHandle(selector: ConnectorModel, canvas: HTMLCanvasElement | SVGElement, constraints: ThumbsConstraints, selectorConstraints: SelectorConstraints, transform: Transforms, connectedSource: boolean, connectedTarget?: boolean): void;
    renderPivotLine(element: DiagramElement, canvas: HTMLCanvasElement | SVGElement, transform?: Transforms, selectorConstraints?: SelectorConstraints): void;
    renderCircularHandle(selector: DiagramElement, cx: number, cy: number, canvas: HTMLCanvasElement | SVGElement, enableSelector: number, visible: boolean, t: Transforms, connected?: boolean): void;
    renderBorder(selector: DiagramElement, canvas: HTMLCanvasElement | SVGElement, transform?: Transforms): void;
    renderUserHandler(selectorItem: SelectorModel, canvas: HTMLCanvasElement | SVGElement, transform?: Transforms): void;
    renderRotateThumb(wrapper: DiagramElement, canvas: HTMLCanvasElement | SVGElement, transform?: Transforms, selectorConstraints?: SelectorConstraints): void;
    renderPathElement(element: PathElement, canvas: HTMLCanvasElement | SVGElement, transform?: Transforms, parentSvg?: SVGSVGElement): void;
    renderSvgGridlines(snapSettings: SnapSettingsModel, gridSvg: SVGElement, t: Transforms): void;
    private horizontalSvgGridlines(pattern, hWidth, scale, snapSettings);
    private verticalSvgGridlines(pattern, hHeight, scale, snapSettings);
    updateGrid(snapSettings: SnapSettingsModel, svgGrid: SVGSVGElement, transform: Transforms): void;
    private scaleSnapInterval(snapSettings, scale);
    renderTextElement(element: TextElement, canvas: HTMLCanvasElement | SVGElement, transform?: Transforms, parentSvg?: SVGSVGElement): void;
    private renderNativeElement(element, canvas, transform?, parentSvg?);
    renderImageElement(element: ImageElement, canvas: HTMLCanvasElement | SVGElement, transform?: Transforms, parentSvg?: SVGSVGElement): void;
    renderContainer(group: Container, canvas: HTMLCanvasElement | SVGElement, transform?: Transforms, parentSvg?: SVGSVGElement, createParent?: boolean): void;
    renderRect(element: DiagramElement, canvas: HTMLCanvasElement | SVGElement, transform?: Transforms, parentSvg?: SVGSVGElement): void;
    drawRect(canvas: SVGElement, options: RectAttributes): void;
    getBaseAttributes(element: DiagramElement, transform?: Transforms): BaseAttributes;
    static renderSvgBackGroundImage(background: BackgroundModel, diagramElement: HTMLElement, x: number, y: number, width: number, height: number): void;
    transformLayers(transform: Transforms, svgMode: boolean): void;
    updateNode(element: DiagramElement, svg: SVGElement): void;
}
/**
 * SVG Renderer
 */
/** @private */
export  class SvgRenderer implements IRenderer {
    renderShadow(options: BaseAttributes, canvas: SVGElement, collection?: Object[], parentSvg?: SVGSVGElement): void;
    parseDashArray(dashArray: string): number[];
    drawRectangle(svg: SVGElement, options: RectAttributes, onlyRect?: boolean, isSelector?: Boolean, parentSvg?: SVGSVGElement): void;
    updateSelectionRegion(gElement: SVGElement, options: RectAttributes): void;
    createGElement(elementType: string, attribute: Object): SVGGElement;
    /** @private */
    drawLine(gElement: SVGElement, options: LineAttributes): void;
    renderBezierLine(id: string, start: PointModel, end: PointModel, scale: number, svg: SVGElement, t: Transforms): void;
    /** @private */
    drawCircle(gElement: SVGElement, options: CircleAttributes, enableSelector?: number): void;
    drawPath(svg: SVGElement, options: PathAttributes, isSelector?: Boolean, parentSvg?: SVGSVGElement): void;
    renderPath(svg: SVGElement, options: PathAttributes, collection: Object[]): void;
    private setSvgFontStyle(text, options);
    drawText(canvas: SVGElement, options: TextAttributes, parentSvg?: SVGSVGElement): void;
    drawImage(canvas: SVGElement | HTMLCanvasElement, obj: ImageAttributes, parentSvg?: SVGSVGElement): void;
    /** @private */
    drawNativeContent(element: NativeElement, canvas: HTMLCanvasElement | SVGElement, height: number, width: number, parentSvg: SVGSVGElement): void;
    private setNativTransform(element, nativeElement, height, width);
    /**
     * used to crop the given native element into a rectangle of the given size
     * @private
     * @param node
     * @param group
     * @param height
     * @param width
     * @param parentSvg
     */
    drawClipPath(node: NativeElement, group: SVGElement, height: number, width: number, parentSvg: SVGSVGElement): SVGElement;
    renderGradient(options: StyleAttributes, svg: SVGElement): SVGElement;
    createLinearGradient(linear: LinearGradientModel): SVGElement;
    createRadialGradient(radial: RadialGradientModel): SVGElement;
    setSvgStyle(svg: SVGElement, style: StyleAttributes): void;
    svgLabelAlign(text: TextAttributes, wrapBound: TextBounds, childNodes: SubTextElement[]): PointModel;
    bBoxText(string: string, options: TextAttributes): number;
    wrapSvgTextAlign(text: TextAttributes, childNodes: SubTextElement[]): TextBounds;
    wrapSvgText(text: TextAttributes): SubTextElement[];
    private wordWrapping(text);
}
/**
 * Connector modules are used to dock and update the connectors
 */
/** @private */
export  function findConnectorPoints(element: Connector): PointModel[];
/** @private */
export  function findAngle(s: PointModel, e: PointModel): number;
/** @private */
export interface Segment {
    X1: number;
    X2: number;
    Y1: number;
    Y2: number;
}
/** @private */
export interface Intersection {
    enabled: boolean;
    intersectPt: PointModel;
}
/** @private */
export interface LengthFraction {
    lengthFractionIndex: number;
    fullLength: number;
    segmentIndex: number;
    pointIndex: number;
}
/** @private */
export interface BridgeSegment {
    bridgeStartPoint: PointModel[];
    bridges: Bridge[];
    segmentIndex: number;
}
/** @private */
export interface ArcSegment {
    angle: number;
    endPoint: PointModel;
    path: string;
    segmentPointIndex: number;
    startPoint: PointModel;
    sweep: number;
    target: string;
    rendered: boolean;
}
/** @private */
export interface Bridge {
    angle: number;
    endPoint: PointModel;
    path: string;
    segmentPointIndex: number;
    startPoint: PointModel;
    sweep: number;
    target: string;
    rendered: boolean;
}
/**
 * constraints-util module contains the common constraints
 */
/** @private */
export  function canSelect(node: ConnectorModel | NodeModel): number;
/** @private */
export  function canMove(node: ConnectorModel | NodeModel): number;
/** @private */
export  function canEnablePointerEvents(node: ConnectorModel | NodeModel, diagram: Diagram): number;
/** @private */
export  function canDelete(node: ConnectorModel | NodeModel): number;
/** @private */
export  function canBridge(connector: Connector, diagram: Diagram): number;
/** @private */
export  function canDragSourceEnd(connector: Connector): number;
/** @private */
export  function canDragTargetEnd(connector: Connector): number;
/** @private */
export  function canRotate(node: NodeModel): number;
/** @private */
export  function canShadow(node: NodeModel): number;
/** @private */
export  function canInConnect(node: NodeModel): number;
/** @private */
export  function canOutConnect(node: NodeModel): number;
/** @private */
export  function canResize(node: NodeModel, direction?: string): number;
/** @private */
export  function canAllowDrop(node: ConnectorModel | NodeModel): number;
/** @private */
export  function canEnableToolTip(node: ConnectorModel | NodeModel, diagram: Diagram): number;
/** @private */
export  function canSingleSelect(model: Diagram): number;
/** @private */
export  function canMultiSelect(model: Diagram): number;
/** @private */
export  function canZoomPan(model: Diagram): number;
/** @private */
export  function canContinuousDraw(model: Diagram): number;
/** @private */
export  function canDrawOnce(model: Diagram): number;
/** @private */
export  function defaultTool(model: Diagram): number;
/**
 * Defines the functionalities that need to access DOM
 */
/** @private */
export  function findSegmentPoints(element: PathElement): PointModel[];
/** @private */
export  function measurePath(data: string): Rect;
/** @private */
export  function measureText(style: TextStyleModel, content: string, width: number, height: number, maxWidth?: number): Size;
/** @private */
export  function measureImage(source: string, contentSize: Size): Size;
/** @private */
export  function measureNativeContent(nativeContent: SVGElement): Rect;
/** @private */
export  function updatePath(element: PathElement, bounds: SVGRect, child: PathElement): string;
/** @private */
export  function getDiagramLayerSvg(diagramId: string): SVGSVGElement;
/** @private */
export  function getDiagramElement(diagramId: string): HTMLElement;
/**
 * @private
 */
export  function getAdornerLayerSvg(diagramId: string): SVGSVGElement;
/** @private */
export  function getSelectorElement(diagramId: string): SVGElement;
/**
 * @private
 */
export  function getAdornerLayer(diagramId: string): SVGElement;
/** @private */
export  function getDiagramLayer(diagramId: string): SVGElement;
/** @private */
export  function getPortLayerSvg(diagramId: string): SVGSVGElement;
/** @private */
export  function getNativeLayerSvg(diagramId: string): SVGSVGElement;
/** @private */
export  function getGridLayerSvg(diagramId: string): SVGSVGElement;
/** @private */
export  function getBackgroundLayerSvg(diagramId: string): SVGSVGElement;
/** @private */
export  function getBackgroundImageLayer(diagramId: string): SVGSVGElement;
/** @private */
export  function getBackgroundLayer(diagramId: string): SVGSVGElement;
/** @private */
export  function getGridLayer(diagramId: string): SVGElement;
/** @private */
export  function getExpandCollapseLayer(diagramId: string): SVGElement;
/** @private */
export  function getPortsLayer(diagramId: string): SVGElement;
/** @private */
export  function getNativeLayer(diagramId: string): SVGElement;
/** @private */
export  function createHtmlElement(elementType: string, attribute: Object): HTMLElement;
/** @private */
export  function createSvgElement(elementType: string, attribute: Object): SVGElement;
/** @hidden */
export  function parentsUntil(elem: Element, selector: string, isID?: boolean): Element;
/** @hidden */
export  function getScrollerWidth(): number;
/**
 * Handles the touch pointer.
 * @return {boolean}
 * @private
 */
export  function addTouchPointer(touchList: ITouches[], e: PointerEvent, touches: TouchList): ITouches[];
/**
 * These utility methods help to process the data and to convert it to desired dimensions
 */
/** @private */
export  function processPathData(data: string): Object[];
/** @private */
export  function parsePathData(data: string): Object[];
/**
 * Used to find the path for rounded rect
 */
export  function getRectanglePath(cornerRadius: number, height: number, width: number): string;
/**
 * Used to find the path for polygon shapes
 */
export  function getPolygonPath(collection: PointModel[]): string;
/** @private */
export  function pathSegmentCollection(collection: Object[]): Object[];
/** @private */
export  function transformPath(arr: Object[], sX: number, sY: number, s: boolean, bX: number, bY: number, iX: number, iY: number): string;
/** @private */
export  function updatedSegment(segment: PathSegment, char: string, obj: PathSegment, isScale: boolean, sX: number, sY: number): Object;
/** @private */
export  function scalePathData(val: number, scaleFactor: number, oldOffset: number, newOffset: number): number;
/** @private */
export  function splitArrayCollection(arrayCollection: Object[]): Object[];
/** @private */
export  function getPathString(arrayCollection: Object[]): string;
/** @private */
export  function getString(obj: PathSegment): string;
/**
 * DiagramUtil module contains the common diagram functionalities
 */
export  function randomId(): string;
/** @private */
export  function rotateSize(size: Size, angle: number): Size;
/** @private */
export  function completeRegion(region: Rect, selectedObjects: (NodeModel | ConnectorModel)[]): (NodeModel | ConnectorModel)[];
/**
 * @private
 */
export  function findObjectType(drawingObject: NodeModel | ConnectorModel): string;
/** @private */
export  function findNearestPoint(reference: PointModel, start: PointModel, end: PointModel): PointModel;
/** @private */
export  function isPointOverConnector(connector: ConnectorModel, reference: PointModel): boolean;
/** @private */
export  function intersect3(lineUtil1: Segment, lineUtil2: Segment): Intersection;
/** @private */
export  function getPoints(element: DiagramElement, corners: Rect): PointModel[];
/** @private */
export  function getBounds(element: DiagramElement): Rect;
/** @private */
export  function sort(objects: (NodeModel | ConnectorModel)[]): (NodeModel | ConnectorModel)[];
/** @private */
export  function rotatePoint(angle: number, pivotX: number, pivotY: number, point: PointModel): PointModel;
/** @private */
export  function getOffset(topLeft: PointModel, obj: DiagramElement): PointModel;
/** @private */
export  function getAnnotationPosition(pts: PointModel[], annotation: PathAnnotation, bound: Rect): SegmentInfo;
/** @private */
export  function getOffsetOfConnector(points: PointModel[], annotation: PathAnnotation, bounds: Rect): SegmentInfo;
/** @private */
export  function getAlignedPosition(annotation: PathAnnotation): number;
/** @private */
export  function alignLabelOnSegments(obj: PathAnnotation, ang: number, pts: PointModel[]): Alignment;
/** @private */
export  function getBezierDirection(src: PointModel, tar: PointModel): string;
/** @private */
export  function whiteSpaceToString(value: WhiteSpace, wrap: TextWrap): string;
/** @private */
export  function textAlignToString(value: TextAlign): string;
/** @private */
export  function wordBreakToString(value: TextWrap): string;
/** @private */
export  function setAttributeSvg(svg: SVGElement, attributes: object): void;
/** @private */
export  function setAttributeHtml(element: HTMLElement, attributes: object): void;
/** @private */
export  function serialize(model: Diagram): string;
/** @private */
export  function deserialize(model: string, diagram: Diagram): object;
/** @private */
export  function cloneObject(obj: object, additionalProp?: Function, key?: string): object;
/** @private */
export  function getInternalProperties(propName: string): string[];
/** @private */
export  function cloneArray(sourceArray: object[], additionalProp?: Function, key?: string): object[];
/** @private */
export  function updateStyle(changedObject: TextStyleModel, target: DiagramElement): void;
/** @private */
export  function updateHyperlink(changedObject: HyperLinkModel, target: DiagramElement, actualAnnotation: AnnotationModel): void;
/** @private */
export  function updateShape(node: Node, actualObject: Node, oldObject: Node, diagram: Diagram): void;
/** @private */
export  function updateContent(newValues: Node, actualObject: Node): void;
/** @private */
export  function removeItem(array: String[], item: string): void;
/** @private */
export  function updateConnector(connector: Connector, points: PointModel[]): void;
/** @private */
export  function getUserHandlePosition(selectorItem: SelectorModel, handle: UserHandleModel): PointModel;
/** @private */
export  function canShowCorner(selectorConstraints: SelectorConstraints, action: string): boolean;
/** @private */
export  function checkPortRestriction(port: PointPortModel, portVisibility: PortVisibility): number;
/** @private */
export  function findAnnotation(nodes: NodeModel | ConnectorModel, id: string): ShapeAnnotationModel | PathAnnotationModel;
/** @private */
export  function scaleElement(element: DiagramElement, sw: number, sh: number, refObject: DiagramElement): void;
/** @private */
export  function insertObject(obj: NodeModel | ConnectorModel | GroupModel, key: string, collection: object[]): void;
/**
 * Diagram component exported items
 */
/**
 * Overview Components
 */
/**
 * Interface for a class Overview
 */
export interface OverviewModel extends base.ComponentModel{
    /**
     * Defines the width of the overview
     * @default undefined
     */
    width?: string | number;
    /**
     * Defines the height of the overview
     * @default undefined
     */
    height?: string | number;
    /**
     * Defines the ID of the overview
     * @default ''
     */
    sourceID?: string;
    /**
     * Triggers after render the diagram elements
     * @event
     */
    created?: any;
}
/**
 * Overview control
 * ```
 * <div id='overview'/>
 * <script>
 *   var overview = new overview({ width:'250px', height:'500px', sourceID: 'diagram' });
 *   overview.appendTo('#overview');
 * </script>
 * ```
 */
export  class Overview extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /**
     * Defines the width of the overview
     * @default undefined
     */
    width: string | number;
    /**
     * Defines the height of the overview
     * @default undefined
     */
    height: string | number;
    /**
     * Defines the ID of the overview
     * @default ''
     */
    sourceID: string;
    /**
     * Triggers after render the diagram elements
     * @event
     */
    created: base.EmitType<Object>;
    private parent;
    private canvas;
    private svg;
    /** @private */
    mode: RenderingMode;
    /** @private */
    id: string;
    private actionName;
    private startPoint;
    private currentPoint;
    private prevPoint;
    private resizeDirection;
    private scale;
    private inAction;
    private viewPortRatio;
    /** @private */
    contentWidth: number;
    /** @private */
    contentHeight: number;
    /** @private */
    diagramLayer: HTMLCanvasElement | SVGGElement;
    private diagramLayerDiv;
    private model;
    private helper;
    private event;
    constructor(options?: OverviewModel, element?: HTMLElement | string);
    /**
     * Updates the overview control when the objects are changed
     * @param newProp Lists the new values of the changed properties
     * @param oldProp Lists the old values of the changed properties
     */
    onPropertyChanged(newProp: OverviewModel, oldProp: OverviewModel): void;
    /**
     * Get the properties to be maintained in the persisted state.
     * @return {string}
     */
    getPersistData(): string;
    /**
     * Initialize nodes, connectors and renderer
     */
    protected preRender(): void;
    protected render(): void;
    private getSizeValue(real);
    private renderCanvas(options?);
    private setParent(id);
    private getDiagram(element, instance);
    private unWireEvents();
    private wireEvents();
    /**
     * @private
     */
    renderDocument(view: Overview): void;
    /** @private */
    removeDocument(view: Overview): void;
    private renderHtmlLayer(canvas);
    private renderNativeLayer(canvas, view);
    private addOverviewRectPanel(view);
    private renderOverviewCorner(name, parent);
    private updateOverviewRectangle();
    private updateHelper(difx?, dify?, size?, width?, height?);
    private updateOverviewrect(x, y, width, height);
    private updateOverviewCorner(name, x, y, width, height);
    private translateOverviewRectangle();
    private renderOverviewRect(x, y, width, height);
    private scrollOverviewRect(hoffset, voffset, currentZoom, scaled?);
    private updateParentView(zoom, x, y, width, height, focusPoint);
    /** @private */
    updateView(view: Overview): void;
    private scrolled(evt);
    private mouseWheel(evt);
    private updateCursor(evt);
    private mouseMove(evt);
    private documentMouseUp(evt);
    /** @private */
    mouseDown(evt: PointerEvent | TouchEvent): void;
    private mouseUp(evt);
    private initHelper();
    private mousePosition(evt);
    /**
     * To destroy the Overview
     * @return {void}
     * @private
     */
    destroy(): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * Exported symbol palette files
 */
/**
 * Interface for a class SearchSettings
 */
export interface SearchSettingsModel {
    /**
     * Sets to enable the search box for palette items.
     * @default true
     */
    enable?: boolean;
}
/**
 * Interface for a class Palette
 */
export interface PaletteModel {
    /**
     * Defines the unique id of a symbol group
     * @default ''
     */
    id?: string;
    /**
     * Sets the height of the symbol group
     * @default ''
     */
    height?: number;
    /**
     * Sets whether the symbol group is expanded or not
     * @default ''
     */
    expanded?: boolean;
    /**
     * Defines the content of the group icon
     * @default ''
     */
    iconCss?: string;
    /**
     * Defines the title of the group icon
     * @default ''
     */
    title?: string;
    /**
     * Defines the collection of predefined symbols
     */
    symbols?: (NodeModel | ConnectorModel)[];
}
/**
 * Interface for a class SymbolPreview
 */
export interface SymbolPreviewModel {
    /**
     * Sets the preview width of the symbols
     * @default undefined
     */
    width?: number;
    /**
     * Sets the preview height of the symbols
     * @default undefined
     */
    height?: number;
    /**
     * Defines the distance to be left between the cursor and symbol
     * @default 0
     */
    offset?: PointModel;
}
/**
 * Interface for a class SymbolPalette
 */
export interface SymbolPaletteModel extends base.ComponentModel{
    /**
     * Configures the key, when it pressed the symbol palette will be focused
     */
    accessKey?: string;
    /**
     * Defines the width of the symbol palette
     */
    width?: string | number;
    /**
     * Defines the height of the symbol palette
     */
    height?: string | number;
    /**
     * Defines the collection of symbol groups
     */
    palettes?: PaletteModel[];
    /**
     * Defines the size, appearance and description of a symbol
     */
    getSymbolInfo?: Function;
    /**
     * Defines the symbols to be added in search palette
     */
    filterSymbols?: Function;
    /**
     * Defines the content of a symbol
     */
    getSymbolTemplate?: Function;
    /**
     * Defines the width of the symbol
     */
    symbolWidth?: number;
    /**
     * Defines the height of the symbol
     */
    symbolHeight?: number;
    /**
     * Defines the space to be left around a symbol
     */
    symbolMargin?: MarginModel;
    /**
     * Enables/Disables dragging the symbols from palette
     */
    allowDrag?: boolean;
    /**
     * Defines the size and position of the symbol preview
     * @default undefined
     */
    symbolPreview?: SymbolPreviewModel;
    /**
     * Defines the search of symbol palette items
     * @default undefined
     */
    searchSettings?: SearchSettingsModel;
    /**
     * Enables/Disables animation when the palette header is expanded/collapsed
     */
    enableAnimation?: boolean;
    /**
     * Defines how many palettes can be at expanded mode at a time
     */
    expandMode?: any;
}
/**
 * Defines the search of palette items
 */
export  class SearchSettings extends base.ChildProperty<SearchSettings> {
    /**
     * Sets to enable the search box for palette items.
     * @default true
     */
    enable: boolean;
}
/**
 * Defines the behavior of a palette
 */
export  class Palette extends base.ChildProperty<Palette> {
    /**
     * Defines the unique id of a symbol group
     * @default ''
     */
    id: string;
    /**
     * Sets the height of the symbol group
     * @default ''
     */
    height: number;
    /**
     * Sets whether the symbol group is expanded or not
     * @default ''
     */
    expanded: boolean;
    /**
     * Defines the content of the group icon
     * @default ''
     */
    iconCss: string;
    /**
     * Defines the title of the group icon
     * @default ''
     */
    title: string;
    /**
     * Defines the collection of predefined symbols
     */
    symbols: (NodeModel | ConnectorModel)[];
}
/**
 * Defines the size and position of the symbol palette
 */
export  class SymbolPreview extends base.ChildProperty<SymbolPreview> {
    /**
     * Sets the preview width of the symbols
     * @default undefined
     */
    width: number;
    /**
     * Sets the preview height of the symbols
     * @default undefined
     */
    height: number;
    /**
     * Defines the distance to be left between the cursor and symbol
     * @default 0
     */
    offset: PointModel;
}
/**
 * Represents the Symbol Palette base.Component.
 * ```html
 * <div id="symbolpalette"></div>
 * <script>
 *  var palette = new SymbolPalatte({ allowDrag:true });
 *  palette.appendTo("#symbolpalette");
 * </script>
 * ```
 */
export  class SymbolPalette extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /**
     * Configures the key, when it pressed the symbol palette will be focused
     */
    accessKey: string;
    /**
     * Defines the width of the symbol palette
     */
    width: string | number;
    /**
     * Defines the height of the symbol palette
     */
    height: string | number;
    /**
     * Defines the collection of symbol groups
     */
    palettes: PaletteModel[];
    /**
     * Defines the size, appearance and description of a symbol
     */
    getSymbolInfo: Function;
    /**
     * Defines the symbols to be added in search palette
     */
    filterSymbols: Function;
    /**
     * Defines the content of a symbol
     */
    getSymbolTemplate: Function;
    /**
     * Defines the width of the symbol
     */
    symbolWidth: number;
    /**
     * Defines the height of the symbol
     */
    symbolHeight: number;
    /**
     * Defines the space to be left around a symbol
     */
    symbolMargin: MarginModel;
    /**
     * Enables/Disables dragging the symbols from palette
     */
    allowDrag: boolean;
    /**
     * Defines the size and position of the symbol preview
     * @default undefined
     */
    symbolPreview: SymbolPreviewModel;
    /**
     * Defines the search of symbol palette items
     * @default undefined
     */
    searchSettings: SearchSettingsModel;
    /**
     * Enables/Disables animation when the palette header is expanded/collapsed
     */
    enableAnimation: boolean;
    /**
     * Defines how many palettes can be at expanded mode at a time
     */
    expandMode: navigations.ExpandMode;
    /**
     * `bpmnModule` is used to add built-in BPMN Shapes to diagrams
     * @private
     */
    bpmnModule: BpmnDiagrams;
    /** @private */
    selectedSymbols: NodeModel | ConnectorModel;
    symbolTable: {};
    private diagramRenderer;
    private svgRenderer;
    private accordionElement;
    private highlightedSymbol;
    private selectedSymbol;
    private info;
    private timer;
    /**
     * Constructor for creating the component
     * @hidden
     */
    constructor(options?: SymbolPaletteModel, element?: Element);
    /**
     * Refreshes the panel when the symbol palette properties are updated
     * @param newProp Defines the new values of the changed properties
     * @param oldProp Defines the old values of the changed properties
     */
    onPropertyChanged(newProp: SymbolPaletteModel, oldProp: SymbolPaletteModel): void;
    /**
     * Get the properties to be maintained in the persisted state.
     * @return {string}
     */
    getPersistData(): string;
    /**
     * Initialize nodes, connectors and renderer
     */
    protected preRender(): void;
    /**
     * Renders nodes and connectors in the symbol palette
     */
    render(): void;
    /**
     * To get Module name
     *  @private
     */
    getModuleName(): string;
    /**
     * To provide the array of modules needed for control rendering
     * @return {base.ModuleDeclaration[]}
     * @private
     */
    requiredModules(): base.ModuleDeclaration[];
    /**
     * To destroy the symbol palette
     * @return {void}
     */
    destroy(): void;
    /**
     * Method to initialize the items in the symbols
     */
    private initSymbols(symbolGroup);
    /**
     * Method to create the palette
     */
    private renderPalette(symbolGroup);
    /**
     * Method to create the symbols in canvas
     */
    private prepareSymbol(symbol);
    /**
     * Method to get the symbol text description
     * @return {void}
     * @private
     */
    private getSymbolDescription(symbolInfo, width, parent);
    /**
     * Method to renders the symbols
     * @return {void}
     * @private
     */
    private renderSymbols(symbolGroup, parentDiv);
    /**
     * Method to clone the symbol for previewing the symbols
     * @return {void}
     * @private
     */
    private getSymbolPreview(symbol, evt);
    /**
     * Method to create canvas and render the symbol
     * @return {void}
     * @private
     */
    private getSymbolContainer(symbol, preview?);
    private getSymbolSize(symbol, symbolInfo);
    private getMousePosition(e);
    private mouseMove(e, touches);
    private mouseUp(evt);
    private keyUp(evt);
    private mouseDown(evt);
    private initDraggable();
    /**
     * helper method for draggable
     * @return {void}
     * @private
     */
    private helper;
    private dragStart(e);
    private dragStop(e);
    private scaleSymbol(symbol, symbolContainer, sw, sh, symbolInfo);
    private refreshPalettes();
    private updatePalettes();
    private createTextbox();
    private searchPalette(value);
    private createSearchPalette(paletteDiv);
    /**
     * Method to bind events for the symbol palette
     */
    private wireEvents();
    /**
     * Method to unbind events for the symbol palette
     */
    private unWireEvents();
}
/**
 * Defines the size and description of a symbol
 */
export interface SymbolInfo {
    /**
     * Defines the width of the symbol to be drawn over the palette
     * @default undefined
     */
    width?: number;
    /**
     * Defines the height of the symbol to be drawn over the palette
     * @default undefined
     */
    height?: number;
    /**
     * Defines whether the symbol has to be fit inside the size, that is defined by the symbol palette
     * @default true
     */
    fit?: boolean;
    /**
     * Define the template of the symbol that is to be drawn over the palette
     * @default null
     */
    template?: DiagramElement;
    /**
     * Define the text to be displayed and how that is to be handled.
     * @default null
     */
    description?: SymbolDescription;
}
/**
 * Defines the textual description of a symbol
 */
export interface SymbolDescription {
    /**
     * Defines the symbol description
     * @default undefined
     */
    text?: string;
    /**
     * Defines how to handle the text when its size exceeds the given symbol size
     * @default ellipsis
     */
    overflow?: TextOverflow;
    /**
     * Defines how to wrap the text
     * @default Wrap
     */
    wrap?: TextWrap;
}
 }
export namespace documenteditor { 

export interface DictionaryInfo<K, V> {
}
export  class Dictionary<K, V> implements DictionaryInfo<K, V> {
    private keys;
    private values;
    private item;
    readonly Count: number;
    readonly Keys: K[];
    getItem(): K[];
    add(key: K, value: V): number;
    get(key: K): V;
    set(key: K, value: V): void;
    remove(key: K): boolean;
    containsKey(key: K): boolean;
    clear(): void;
    destroy(): void;
}
/**
 * export types
 */
/**
 * Enum underline for character format
 */
export  type WUnderline = 'None' | 'Single' | 'Words' | 'Double' | 'Dotted' | 'Thick' | 'Dash' | 'DashLong' | 'DotDash' | 'DotDotDash' | 'Wavy' | 'DottedHeavy' | 'DashHeavy' | 'DashLongHeavy' | 'DotDashHeavy' | 'DotDotDashHeavy' | 'WavyHeavy' | 'WavyDouble';
/**
 * enum strikethrough for character format
 */
export  type WStrikethrough = 'None' | 'SingleStrike' | 'DoubleStrike';
/**
 * enum baseline alignment for character format
 */
export  type WBaselineAlignment = 'Normal' | 'Superscript' | 'Subscript';
/**
 * enum highlight color for character format
 */
export  type WHighlightColor = 'NoColor' | 'Yellow' | 'BrightGreen' | 'Turquoise' | 'Pink' | 'Blue' | 'Red' | 'DarkBlue' | 'Teal' | 'Green' | 'Violet' | 'DarkRed' | 'DarkYellow' | 'Gray50' | 'Gray25' | 'Black';
/**
 * Enum LineSpacingType For Paragraph Format Preservation
 */
export  type WLineSpacingType = 'AtLeast' | 'Exactly' | 'Multiple';
/**
 * Enum TextAlignment For Paragraph Format Preservation
 */
export  type WTextAlignment = 'Center' | 'Left' | 'Right' | 'Justify';
/**
 * Enum for Header Footer
 */
export  type WHeaderFooterType = 'EvenHeader' | 'OddHeader' | 'EvenFooter' | 'OddFooter' | 'FirstPageHeader' | 'FirstPageFooter';
/**
 * Enum for List type
 */
export  type WListType = 'None' | 'Bullet' | 'Numbering' | 'OutlineNumbering';
/**
 * Enum for List Level Pattern
 */
export  type WListLevelPattern = 'Arabic' | 'UpRoman' | 'LowRoman' | 'UpLetter' | 'LowLetter' | 'Ordinal' | 'Number' | 'OrdinalText' | 'LeadingZero' | 'Bullet' | 'FarEast' | 'Special' | 'None';
/**
 * Enum for follow character type
 */
export  type WFollowCharacterType = 'Tab' | 'Space' | 'None';
export  type WTableAlignment = 'Left' | 'Center' | 'Right';
export  type WWidthType = 'Auto' | 'Percent' | 'Point';
export  type WCellVerticalAlignment = 'Top' | 'Center' | 'Bottom';
export  type WHeightType = 'Auto' | 'AtLeast' | 'Exactly';
export  type WLineStyle = 'None' | 'Single' | 'Dot' | 'DashSmallGap' | 'DashLargeGap' | 'DashDot' | 'DashDotDot' | 'Double' | 'Triple' | 'ThinThickSmallGap' | 'ThickThinSmallGap' | 'ThinThickThinSmallGap' | 'ThinThickMediumGap' | 'ThickThinMediumGap' | 'ThinThickThinMediumGap' | 'ThinThickLargeGap' | 'ThickThinLargeGap' | 'ThinThickThinLargeGap' | 'SingleWavy' | 'DoubleWavy' | 'DashDotStroked' | 'Emboss3D' | 'Engrave3D' | 'Outset' | 'Inset' | 'Thick';
export  type WTextureStyle = 'TextureNone' | 'Texture2Pt5Percent' | 'Texture5Percent' | 'Texture7Pt5Percent' | 'Texture10Percent' | 'Texture12Pt5Percent' | 'Texture15Percent' | 'Texture17Pt5Percent' | 'Texture20Percent' | 'Texture22Pt5Percent' | 'Texture25Percent' | 'Texture27Pt5Percent' | 'Texture30Percent' | 'Texture32Pt5Percent' | 'Texture35Percent' | 'Texture37Pt5Percent' | 'Texture40Percent' | 'Texture42Pt5Percent' | 'Texture45Percent' | 'Texture47Pt5Percent' | 'Texture50Percent' | 'Texture52Pt5Percent' | 'Texture55Percent' | 'Texture57Pt5Percent' | 'Texture60Percent' | 'Texture62Pt5Percent' | 'Texture65Percent' | 'Texture67Pt5Percent' | 'Texture70Percent' | 'Texture72Pt5Percent' | 'Texture75Percent' | 'Texture77Pt5Percent' | 'Texture80Percent' | 'Texture82Pt5Percent' | 'Texture85Percent' | 'Texture87Pt5Percent' | 'Texture90Percent' | 'Texture92Pt5Percent' | 'Texture95Percent' | 'Texture97Pt5Percent' | 'TextureSolid' | 'TextureDarkHorizontal' | 'TextureDarkVertical' | 'TextureDarkDiagonalDown' | 'TextureDarkDiagonalUp' | 'TextureDarkCross' | 'TextureDarkDiagonalCross' | 'TextureHorizontal' | 'TextureVertical' | 'TextureDiagonalDown' | 'TextureDiagonalUp' | 'TextureCross' | 'TextureDiagonalCross';
export  type WFormatType = 'Docx' | 'Html' | 'Txt';
/**
 * Enum for find option
 */
export  type WFindOption = 'None' | 'WholeWord' | 'CaseSensitive' | 'CaseSensitiveWholeWord';
/**
 * WColor interface
 */
export interface WColor {
    r: number;
    g: number;
    b: number;
}
export  type Action = 'Insert' | 'Delete' | 'BackSpace' | 'Selection' | 'MultiSelection' | 'Enter' | 'ImageResizing' | 'ReplaceAll' | 'Cut' | 'CharacterFormat' | 'Bold' | 'Italic' | 'FontSize' | 'FontFamily' | 'FontColor' | 'HighlightColor' | 'BaselineAlignment' | 'StrikeThrough' | 'Underline' | 'InsertHyperlink' | 'Underline' | 'FontColor' | 'InsertInline' | 'RemoveHyperlink' | 'AutoFormatHyperlink' | 'TextAlignment' | 'LeftIndent' | 'AfterSpacing' | 'BeforeSpacing' | 'RightIndent' | 'LeftIndent' | 'FirstLineIndent' | 'LineSpacing' | 'LineSpacingType' | 'TextAlignment' | 'ListFormat' | 'ParagraphFormat' | 'List' | 'InsertRowAbove' | 'InsertRowBelow' | 'DeleteTable' | 'DeleteRow' | 'DeleteColumn' | 'InsertColumnLeft' | 'InsertColumnRight' | 'Paste' | 'TableFormat' | 'RowFormat' | 'CellFormat' | 'TableProperties' | 'Paste' | 'DeleteCells' | 'ClearCells' | 'InsertTable' | 'RowResizing' | 'CellResizing' | 'MergeCells' | 'ClearFormat' | 'ClearCharacterFormat' | 'ClearParagraphFormat' | 'AutoList' | 'BordersAndShading' | 'TableMarginsSelection' | 'CellMarginsSelection' | 'CellOptions' | 'TableOptions' | 'PreferredWidthType' | 'TableAlignment' | 'TableLeftIndent' | 'CellSpacing' | 'DefaultCellLeftMargin' | 'DefaultCellRightMargin' | 'TablePreferredWidthType' | 'TablePreferredWidth' | 'CellPreferredWidthType' | 'CellPreferredWidth' | 'DefaultCellTopMargin' | 'DefaultCellBottomMargin' | 'CellContentVerticalAlignment' | 'CellLeftMargin' | 'CellRightMargin' | 'CellTopMargin' | 'CellBottomMargin' | 'RowHeight' | 'RowHeightType' | 'RowHeader' | 'AllowBreakAcrossPages' | 'PageHeight' | 'PageWidth' | 'LeftMargin' | 'RightMargin' | 'TopMargin' | 'BottomMargin' | 'DefaultCellSpacing';
/**
 * Represent WUniqueFormatClass
 */
export  class WUniqueFormat {
    propertiesHash: Dictionary<number, object>;
    referenceCount: number;
    uniqueFormatType: number;
    constructor(type: number);
    isEqual(source: Dictionary<number, object>, property: string, modifiedValue: object): boolean;
    private isNotEqual(property, source, modifiedProperty, modifiedValue, uniqueFormatType);
    static getPropertyType(uniqueFormatType: number, property: string): number;
    private static getRowFormatType(property);
    private static getListFormatType(property);
    private static getTableFormatType(property);
    private static getListLevelType(property);
    private static getShadingPropertyType(property);
    private static getCellFormatPropertyType(property);
    private static getBorderPropertyType(property);
    private static getCharacterFormatPropertyType(property);
    private static getParaFormatPropertyType(property);
    private static getSectionFormatType(property);
    isBorderEqual(source: Dictionary<number, object>, modifiedProperty: string, modifiedValue: Object): boolean;
    isCharacterFormatEqual(source: Dictionary<number, object>, modifiedProperty: string, modifiedValue: object): boolean;
    private isParagraphFormatEqual(source, modifiedProperty, modifiedValue);
    isCellFormatEqual(source: Dictionary<number, object>, modifiedProperty: string, modifiedValue: Object): boolean;
    isShadingEqual(source: Dictionary<number, object>, modifiedProperty: string, modifiedValue: Object): boolean;
    isRowFormatEqual(source: Dictionary<number, object>, modifiedProperty: string, modifiedValue: Object): boolean;
    isListFormatEqual(source: Dictionary<number, object>, modifiedProperty: string, modifiedValue: Object): boolean;
    isTableFormatEqual(source: Dictionary<number, object>, modifiedProperty: string, modifiedValue: Object): boolean;
    isListLevelEqual(source: Dictionary<number, object>, modifiedProperty: string, modifiedValue: Object): boolean;
    isSectionFormatEqual(source: Dictionary<number, object>, modifiedProperty: string, modifiedValue: Object): boolean;
    cloneItems(format: WUniqueFormat, property: string, value: object, uniqueFormatType: number): void;
    destroy(): void;
}
/**
 * Represent WUniqueFormats Class
 */
export  class WUniqueFormats {
    items: WUniqueFormat[];
    constructor();
    addUniqueFormat(format: Dictionary<number, object>, type: number): WUniqueFormat;
    updateUniqueFormat(uniqueFormat: WUniqueFormat, property: string, value: object): WUniqueFormat;
    remove(uniqueFormat: WUniqueFormat): void;
    clear(): void;
    destroy(): void;
}
/**
 * Interface for a class DocumentEditor
 */
export interface DocumentEditorModel extends base.ComponentModel{
    /**
     * Gets or sets the zoom factor in document editor.
     * @default 1
     */
    zoomFactor?: number;
    /**
     * Gets or sets a value indicating whether to enable cursor in document editor on read only state or not.
     * @default false
     */
    enableCursorOnReadOnly?: boolean;
    /**
     * Gets or sets a value indicating whether the document editor is enabled in read only or not.
     * @default true
     */
    isReadOnly?: boolean;
    /**
     * enable or disable header footer content editing
     */
    enableHeaderAndFooter?: boolean;
    /**
     * Gets or Sets a value indicating whether tab key can be accepted as input or not.
     * @default false
     */
    acceptTab?: boolean;
    /**
     * Gets or sets a value indicating whether selection is enabled or not.
     * @default false
     */
    enableSelection?: boolean;
    /**
     * Gets or sets whether the history preserving is enable or not
     * @default false
     */
    enableHistory?: boolean;
    /**
     * Gets or sets a value indicating whether word export is enabled or not.
     * @default false
     */
    enableWordExport?: boolean;
    /**
     * Gets or Sets a value indicating whether holding Ctrl key is required to follow hyperlink on click.
     * @default true
     */
    useCtrlClickToFollowHyperlink​​​?: boolean;
    /**
     * Gets or sets a value indicating whether options pane is enabled or not.
     * @default false
     */
    enableOptionsPane?: boolean;
    /**
     * Gets or sets a value indicating whether search module is enabled or not.
     * @default false
     */
    enableSearch?: boolean;
    /**
     * An event to identify whenever document in the document editor changes.
     * @event
     */
    documentChange?: Function;
    /**
     * An event to identify whenever zoom factor in the document editor changes.
     * @event
     */
    zoomFactorChange?: Function;
    /**
     * An event to identify whenever selection in the document editor changes.
     * @event
     */
    selectionChange?: Function;
}
/**
 * Document Editor control
 */
export  class DocumentEditor extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /**
     * @hidden
     */
    viewer: LayoutViewer;
    private isDocumentLoadedIn;
    private disableHistoryIn;
    private parser;
    /**
     * Gets or sets the title of the document.
     */
    documentTitle: string;
    /**
     * @hidden
     */
    selectionModule: Selection;
    /**
     * @hidden
     */
    editorModule: Editor;
    /**
     * @hidden
     */
    wordExportModule: WordExport;
    /**
     * @hidden
     */
    historyModule: History;
    /**
     * @hidden
     */
    searchModule: Search;
    /**
     * Gets or sets the zoom factor in document editor.
     * @default 1
     */
    zoomFactor: number;
    /**
     * Gets or sets a value indicating whether to enable cursor in document editor on read only state or not.
     * @default false
     */
    enableCursorOnReadOnly: boolean;
    /**
     * Gets or sets a value indicating whether the document editor is enabled in read only or not.
     * @default true
     */
    isReadOnly: boolean;
    /**
     * enable or disable header footer content editing
     */
    enableHeaderAndFooter: boolean;
    /**
     * Gets or Sets a value indicating whether tab key can be accepted as input or not.
     * @default false
     */
    acceptTab: boolean;
    /**
     * Gets or sets a value indicating whether selection is enabled or not.
     * @default false
     */
    enableSelection: boolean;
    /**
     * Gets or sets whether the history preserving is enable or not
     * @default false
     */
    enableHistory: boolean;
    /**
     * Gets or sets a value indicating whether word export is enabled or not.
     * @default false
     */
    enableWordExport: boolean;
    /**
     * Gets or Sets a value indicating whether holding Ctrl key is required to follow hyperlink on click.
     * @default true
     */
    useCtrlClickToFollowHyperlink: boolean;
    /**
     * Gets or sets a value indicating whether options pane is enabled or not.
     * @default false
     */
    enableOptionsPane: boolean;
    /**
     * Gets or sets a value indicating whether search module is enabled or not.
     * @default false
     */
    enableSearch: boolean;
    /**
     * An event to identify whenever document in the document editor changes.
     * @event
     */
    documentChange: Function;
    /**
     * An event to identify whenever zoom factor in the document editor changes.
     * @event
     */
    zoomFactorChange: Function;
    /**
     * An event to identify whenever selection in the document editor changes.
     * @event
     */
    selectionChange: Function;
    /**
     * @hidden
     */
    optionsPaneModule: OptionsPane;
    /**
     * @hidden
     */
    isShiftingEnabled: boolean;
    /**
     * @hidden
     */
    isLayoutEnabled: boolean;
    /**
     * @hidden
     */
    isPastingContent: boolean;
    /**
     * @hidden
     */
    stackSize: number;
    /**
     * @hidden
     */
    private printModule;
    /**
     * @hidden
     */
    readonly containerId: string;
    /**
     * @hidden
     */
    isDocumentLoaded: boolean;
    /**
     * @hidden
     */
    findResultsList: string[];
    /**
     * @hidden
     */
    getDocumentEditorElement(): HTMLElement;
    /**
     * Specifies to enable history option
     * default - false
     */
    readonly enableHistoryMode: boolean;
    /**
     *  Gets the selection object of the document editor.
     * @returns Selection
     * @default undefined
     */
    readonly selection: Selection;
    /**
     * Gets the start text position in the document.
     * @default undefined
     */
    readonly documentStart: TextPosition;
    /**
     * Gets the end text position in the document.
     * @default undefined
     */
    readonly documentEnd: TextPosition;
    /**
     * @hidden
     */
    readonly isReadOnlyMode: boolean;
    /**
     * Gets the history object of the document editor.
     * @returns History
     */
    readonly history: History;
    /**
     * Initialize the constructor of DocumentEditor
     */
    constructor(options?: DocumentEditorModel, element?: string | HTMLElement);
    protected preRender(): void;
    protected render(): void;
    /**
     * Get component name
     * @hidden
     */
    getModuleName(): string;
    /**
     * Called internally if any of the property value changed.
     * @hidden
     */
    onPropertyChanged(model: DocumentEditorModel, oldProp: DocumentEditorModel): void;
    private setZoomFactor(value);
    private localizeDialogs();
    /**
     * Get the properties to be maintained in the persisted state.
     * @hidden
     */
    getPersistData(): string;
    /**
     * create Empty Document
     * @returns WordDocument
     * @hidden
     */
    createEmptyPage(): void;
    /**
     * @hidden
     */
    fireDocumentChange(): void;
    /**
     * @hidden
     */
    fireSelectionChange(): void;
    /**
     * @hidden
     */
    fireZoomFactorChange(): void;
    /**
     * Parse the given json string
     * @param  {string} json
     */
    parse(json: string): void;
    /**
     * Print the document
     * @param  {} undefined
     */
    print(): void;
    /**
     * Saves the document
     * @param  {string} fileName
     */
    save(fileName: string, type: WFormatType): void;
    protected requiredModules(): base.ModuleDeclaration[];
    /**
     * @hidden
     */
    defaultLocale: Object;
    /**
     * destroy document editor instance
     */
    destroy(): void;
    private destroyDependentModules();
}
/**
 * Editor module
 */
export  class Editor {
    private viewer;
    private startOffset;
    private startParagraph;
    private endOffset;
    private endParagraph;
    /**
     * Initialize the editor module
     * @param  {LayoutViewer} viewer
     */
    constructor(viewer: LayoutViewer);
    private readonly history;
    private getModuleName();
    /**
     * Inserts the specified text at cursor position
     * @param  {string} text
     * @param  {boolean} isReplace
     * @hidden
     */
    insertText(text: string, isReplace: boolean): void;
    private insertTextInline(element, selection, text, index);
    private insertFieldBeginText(fieldBegin, selection, text, index);
    private insertFieldSeperatorText(fieldSeperator, selection, text, index);
    private insertFieldEndText(fieldEnd, selection, text, index);
    private insertImageText(image, selection, text, index);
    /**
     * Handle tab character splitting
     * @param  {LayoutViewer} viewer
     * @param  {TextElementBox} span
     * @param  {number} index
     * @param  {string} spiltBy
     * @hidden
     */
    splitByTab(viewer: LayoutViewer, span: TextElementBox, index: number, spiltBy: string): void;
    private insertSpanText(span, selection, text, index);
    /**
     * Paste copied clipboard content on Paste event
     * @param  {ClipboardEvent} event
     * @param  {any} pasteWindow?
     * @hidden
     */
    paste(event: ClipboardEvent, pasteWindow?: any): void;
    private pasteContent(pasteContent);
    private insertInlineInternal(selection, element);
    private insertInline(curInline, newElement, index);
    /**
     * Insert new Block on specific index
     * @param  {Selection} selection
     * @param  {BlockWidget} block
     * @hidden
     */
    insertBlock(selection: Selection, block: BlockWidget): void;
    insertNewParagraphWidget(selection: Selection, newParagraph: ParagraphWidget, insertAfter: boolean): void;
    private insertParagraph(selection, newParagraph, lineWidget, offset, insertAfter);
    private moveInlines(currentParagraph, newParagraph, insertIndex, startLine, startOffset, endOffset);
    moveElementsToLine(line: LineWidget, sourceLine: LineWidget): void;
    /**
     * reLayout
     * @param selection
     * @param isSelectionChanged
     * @ hidden
     */
    reLayout(selection: Selection): void;
    /**
     * Get offset value to update in selection
     */
    private getOffsetValue(selection);
    /**
     * Change HighlightColor
     * @param  {WHighlightColor} highlightColor
     * Applies character format for selection.
     * @param {string} property
     * @param {Object} value
     * @param {boolean} update
     * @hidden
     */
    onApplyCharacterFormat(property: string, value: Object, update?: boolean): void;
    private updateInsertPosition();
    /**
     * preserve paragraph and offset value for selection
     * @hidden
     */
    setOffsetValue(selection: Selection): void;
    /**
     * Toggles the HighlightColor. If HighlightColor is assigned already. The HighlightColor will be changed
     * @hidden
     */
    toggleHighlightColor(): void;
    /**
     * Toggles the baseline alignment. If baseline alignment is assigned already, baselineAlignment will be changed
     * @param  {Selection} selection
     * @param  {WBaselineAlignment} baseAlignment
     * @hidden
     */
    toggleBaselineAlignment(selection: Selection, baseAlignment: WBaselineAlignment): void;
    /**
     * Toggles the specified property. If property is assigned already. Then property will be changed
     * @param  {Selection} selection
     * @param  {number} type
     * @param  {Object} value
     * @hidden
     */
    updateProperty(selection: Selection, type: number, value: Object): void;
    /**
     * Update Character format for selection
     * @hidden
     */
    updateSelectionCharacterFormatting(property: string, values: Object, update: boolean): void;
    /**
     * Update character format for selection range
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @returns void
     * @hidden
     */
    updateCharacterFormat(property: string, value: Object): void;
    private updateCharacterFormatWithUpdate(selection, property, value, update);
    private applyCharFormatSelectedContent(paragraph, selection, start, end, property, value, update);
    private applyCharFormatForSelectedPara(paragraph, selection, property, value, update);
    private applyCharFormat(paragraph, selection, start, end, property, value, update);
    private getCurrentSelectionValue(paragraph, selection, property, value);
    private updateFontSize(format, value);
    private applyCharFormatInline(inline, selection, startIndex, endIndex, property, value, update);
    private formatInline(inline, selection, startIndex, endIndex, property, value, update);
    private applyCharFormatCell(cell, selection, start, end, property, value, update);
    private applyCharFormatForSelectedCell(cell, selection, property, value, update);
    private applyCharFormatRow(row, selection, start, end, property, value, update);
    private applyCharFormatForTable(index, table, selection, start, end, property, value, update);
    private applyCharFormatForSelTable(tableWidget, selection, property, value, update);
    private applyCharFormatForTableCell(table, selection, startCell, endCell, property, value, update);
    private updateSelectedCellsInTable(start, end, endCellLeft, endCellRight);
    private getCharacterFormatValueOfCell(cell, selection, value, property);
    /**
     * Apply Character format for selection
     * @hidden
     */
    applyCharFormatValueInternal(selection: Selection, format: WCharacterFormat, property: string, value: Object): void;
    private applyCharFormatValue(format, property, value, update);
    /**Toggles the TextAlignment.
     * @param  {WTextAlignment} textAlignment
     * @hidden
     */
    toggleTextAlignment(textAlignment: WTextAlignment): void;
    /**
     * Applies paragraph format for the selection ranges.
     * @param {string} property
     * @param {Object} value
     * @param {boolean} update
     * @param {boolean} isSelectionChanged
     * @hidden
     */
    onApplyParagraphFormat(property: string, value: Object, update: boolean, isSelectionChanged: boolean): void;
    /**
     * Update the list level
     * @param  {boolean} increaseLevel
     * @hidden
     */
    updateListLevel(increaseLevel: boolean): void;
    /**
     * Applies list
     * @param  {WList} list
     * @param  {number} listLevelNumber
     * @hidden
     */
    onApplyListInternal(list: WList, listLevelNumber: number): void;
    /**
     * Apply paragraph format to selection range
     * @hidden
     */
    updateSelectionParagraphFormatting(property: string, value: Object, update: boolean): void;
    private getIndentIncrementValue(currentParagraph, incrementFactor);
    private getIndentIncrementValueInternal(position, incrementFactor);
    private updateParagraphFormatInternal(property, value, update);
    /**
     * Update paragraph format on undo
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @param  {boolean} update
     * @hidden
     */
    updateParagraphFormat(property: string, value: Object, update: boolean): void;
    private applyParaFormatSelectedContent(start, end, property, value, update);
    /**
     * Apply Paragraph format
     * @hidden
     */
    applyParaFormatProperty(paragraph: ParagraphWidget, property: string, value: Object, update: boolean): void;
    private onListFormatChange(paragraph, listFormat, paraFormat);
    private updateListParagraphFormat(paragraph, listFormat);
    /**
     * Copies list level paragraph format
     * @param  {WParagraphFormat} oldFormat
     * @param  {WParagraphFormat} newFormat
     * @hidden
     */
    copyFromListLevelParagraphFormat(oldFormat: WParagraphFormat, newFormat: WParagraphFormat): void;
    private applyParaFormat(paragraph, start, end, property, value, update);
    private applyParaFormatInCell(cell, start, end, property, value, update);
    private applyParaFormatCellInternal(cell, property, value, update);
    private getParaFormatValueInCell(cell, property, value);
    private applyParagraphFormatRow(wRow, start, end, property, value, update);
    private applyParaFormatTableCell(table, startCell, endCell, property, value, update);
    private applyParaFormatTable(table, start, end, property, value, update);
    private applyParagraphFormatTableInternal(table, property, value, update);
    /**
     * Apply section format selection changes
     * @param  {string} property
     * @param  {Object} value
     * @hidden
     */
    onApplySectionFormat(property: string, value: Object): void;
    /**
     * Update section format
     * @param  {string} property
     * @param  {Object} value
     * @returns TextPosition
     * @hidden
     */
    updateSectionFormat(property: string, value: Object): void;
    private applyPropertyValueForSection(sectionFormat, property, value, update);
    private layoutWholeDocument();
    private startSelectionReLayouting(paragraph, selection, start, end);
    private reLayoutSelection(paragraph, selection, start, end);
    private reLayoutSelectionOfBlock(block, selection, start, end);
    private layoutItemBlock(block, shiftNextWidget);
    /**
     * Relayout the paragraph specific index
     * @hidden
     */
    updateParagraphWidget(paragraph: ParagraphWidget, lineIndex: number, elementBoxIndex: number): void;
    removeSelectedContents(selection: Selection): boolean;
    private removeSelectedContentInternal(selection, startPosition, endPosition);
    private removeSelectedContent(paragraph, selection, start, end);
    private deleteSelectedContent(paragraph, selection, start, end, editAction);
    private deletePara(paragraph, start, end, editAction);
    private splitParagraph(paragraphAdv, startLine, startOffset, endOffset);
    removeBlock(block: BlockWidget): void;
    private addRemovedNodes(node);
    private deleteBlock(block, selection, start, end, editAction);
    private insertParagraphPaste(paragraph, currentParagraph, selection, start, end, isCombineNextParagraph, editAction);
    private removeInlines(paragraph, startLine, startOffset, endLine, endOffset, editAction);
    removeEmptyLine(paragraph: ParagraphWidget): void;
    getLineWidgetLength(lineWidget: LineWidget): number;
    /**
     * @hidden
     */
    removeOrMoveContent(lineWidget: LineWidget, startOffset: number, endOffset: number, paragraph?: ParagraphWidget, isRemove?: boolean): void;
    /**
     * clone the list level
     * @param  {WListLevel} source
     * @hidden
     */
    cloneListLevel(source: WListLevel): WListLevel;
    /**
     * Copies the list level
     * @param  {WListLevel} destination
     * @param  {WListLevel} listLevel
     * @hidden
     */
    copyListLevel(destination: WListLevel, listLevel: WListLevel): void;
    /**
     * Clone level override
     * @param  {WLevelOverride} source
     * @hidden
     */
    cloneLevelOverride(source: WLevelOverride): WLevelOverride;
    /**
     * Update List Paragraph
     * @hidden
     */
    updateListParagraphs(): void;
    private updateListParagraphsInBlock(block);
    /**
     * Applies list format
     * @param  {WList} list
     * @hidden
     */
    onApplyList(list: WList): void;
    /**
     * Applies bullets or numbering list
     * @param  {string} format
     * @param  {WListLevelPattern} listLevelPattern
     * @param  {string} fontFamily
     * @hidden
     */
    applyBulletOrNumbering(format: string, listLevelPattern: WListLevelPattern, fontFamily: string): void;
    private addListLevels(abstractListAdv, listName, selection);
    /**
     * @hidden
     */
    onEnter(): void;
    private splitParagraphInternal(selection, paragraphAdv, currentLine, offset);
    updateNextBlocksIndex(block: BlockWidget, increaseIndex: boolean): void;
    private updateEndPosition();
    /**
     * @hidden
     */
    onBackSpace(): void;
    deleteSelectedContents(selection: Selection, isBackSpace: boolean): boolean;
    singleBackspace(selection: Selection, isRedoing: boolean): void;
    private setPositionForHistory(editPosition?);
    private removeAtOffset(lineWidget, selection, offset);
    /**
     * @hidden
     */
    onDelete(): void;
    /**
     * Remove single character on right of cursor position
     * @param  {Selection} selection
     * @param  {boolean} isRedoing
     * @hidden
     */
    singleDelete(selection: Selection, isRedoing: boolean): void;
    private singleDeleteInternal(selection, isRedoing, paragraph);
    private deleteParagraphMark(paragraph, selection, editAction);
    private checkEndPositon(selection);
    private checkInsertPositon(selection);
    private checkIsNotRedoing(selection);
    private deleteSelectedContentInternal(selection, isBackSpace, startPosition, endPosition);
    /**
     * Init History
     * @hidden
     */
    initHistory(action: Action): void;
    /**
     * Insert image
     * @param  {string} base64String
     * @param  {number} width
     * @param  {number} height
     * @hidden
     */
    insertPicture(base64String: string, width: number, height: number): void;
    private insertPictureInternal(imageElementBox);
    private fitImageToPage(selection, imageElementBox);
    /**
     * @hidden
     */
    insertInlineInSelection(selection: Selection, elementBox: ElementBox): void;
    updateListItemsTillEnd(blockAdv: BlockWidget, updateNextBlockList: boolean): void;
    updateWholeListItems(block: BlockWidget): void;
    private updateListItemsSection(section, block);
    private updateListItems(blockAdv, block);
    updateRenderedListItems(block: BlockWidget): void;
    private updateListItemsForPara(paragraph, block);
    private updateRenderedListItemsForPara(paragraph);
    getParagraphInfo(inline: ElementBox, index: number): ParagraphInfo;
    destroy(): void;
}
/**
 * Represent WBorder Class
 */
export  class WBorder {
    private uniqueBorderFormat;
    private static uniqueBorderFormats;
    private static uniqueFormatType;
    ownerBase: WBorders;
    color: string;
    lineStyle: WLineStyle;
    lineWidth: number;
    shadow: boolean;
    space: number;
    hasNoneStyle: boolean;
    constructor(node?: WBorders);
    private getPropertyValue(property);
    private setPropertyValue(property, value);
    private initializeUniqueBorder(property, propValue);
    private addUniqueBorderFormat(property, modifiedProperty, propValue, uniqueBorderFormatTemp);
    private static getPropertyDefaultValue(property);
    getLineWidth(): number;
    private getBorderLineWidthArray(lineStyle, lineWidth);
    getBorderWeight(): number;
    private getBorderNumber();
    private getNumberOfLines();
    getPrecedence(): number;
    private hasValue(property);
    cloneFormat(): WBorder;
    destroy(): void;
    copyFormat(border: WBorder): void;
    static clear(): void;
}
/**
 * Represent WBorders Class
 */
export  class WBorders implements IWidget {
    private leftIn;
    private rightIn;
    private topIn;
    private bottomIn;
    private horizontalIn;
    private verticalIn;
    private diagonalUpIn;
    private diagonalDownIn;
    private lineWidthIn;
    private valueIn;
    ownerBase: IWidget;
    left: WBorder;
    right: WBorder;
    top: WBorder;
    bottom: WBorder;
    horizontal: WBorder;
    vertical: WBorder;
    diagonalUp: WBorder;
    diagonalDown: WBorder;
    constructor(node?: IWidget);
    destroy(): void;
    cloneFormat(): WBorders;
    copyFormat(borders: WBorders): void;
}
/**
 * Represent WCellFormat Class
 */
export  class WCellFormat {
    private uniqueCellFormat;
    private static uniqueCellFormats;
    private static uniqueFormatType;
    borders: WBorders;
    shading: WShading;
    ownerBase: IWidget;
    leftMargin: number;
    rightMargin: number;
    topMargin: number;
    bottomMargin: number;
    cellWidth: number;
    columnSpan: number;
    rowSpan: number;
    preferredWidth: number;
    verticalAlignment: WCellVerticalAlignment;
    preferredWidthType: WWidthType;
    constructor(node?: IWidget);
    getPropertyValue(property: string): Object;
    private setPropertyValue(property, value);
    private initializeUniqueCellFormat(property, propValue);
    private addUniqueCellFormat(property, modifiedProperty, propValue, uniqueCellFormatTemp);
    private static getPropertyDefaultValue(property);
    containsMargins(): boolean;
    destroy(): void;
    cloneFormat(): WCellFormat;
    hasValue(property: string): boolean;
    copyFormat(format: WCellFormat): void;
    static clear(): void;
}
/**
 * Character Format
 */
export  class WCharacterFormat {
    private uniqueCharacterFormat;
    private static uniqueCharacterFormats;
    private static uniqueFormatType;
    ownerBase: IWidget;
    bold: boolean;
    italic: boolean;
    fontSize: number;
    fontFamily: string;
    underline: WUnderline;
    strikeThrough: WStrikethrough;
    baselineAlignment: WBaselineAlignment;
    highlightColor: WHighlightColor;
    fontColor: string;
    constructor(node?: IWidget);
    getPropertyValue(property: string): Object;
    private setPropertyValue(property, value);
    private initializeUniqueCharacterFormat(property, propValue);
    private addUniqueCharacterFormat(property, modifiedProperty, propValue, uniqueCharFormatTemp);
    private static getPropertyDefaultValue(property);
    isEqualFormat(format: WCharacterFormat): boolean;
    cloneFormat(): WCharacterFormat;
    private hasValue(property);
    clearFormat(): void;
    destroy(): void;
    copyFormat(format: WCharacterFormat): void;
    static clear(): void;
}
/**
 * Formats Modules
 */
/**
 * List Format
 */
export  class WListFormat {
    private uniqueListFormat;
    private static uniqueListFormats;
    private static uniqueFormatType;
    listId: number;
    listLevelNumber: number;
    private getPropertyValue(property);
    private setPropertyValue(property, value);
    private initializeUniqueListFormat(property, propValue);
    private addUniqueListFormat(property, modifiedProperty, propValue, uniqueListFormatTemp);
    private static getPropertyDefaultValue(property);
    copyFormat(format: WListFormat): void;
    hasValue(property: string): boolean;
    clearFormat(): void;
    destroy(): void;
    static clear(): void;
}
/**
 * Paragraph Format Preservation
 */
export  class WParagraphFormat {
    private uniqueParagraphFormat;
    private static uniqueParagraphFormats;
    private static uniqueFormatType;
    listFormat: WListFormat;
    ownerBase: IWidget;
    leftIndent: number;
    rightIndent: number;
    firstLineIndent: number;
    beforeSpacing: number;
    afterSpacing: number;
    lineSpacing: number;
    lineSpacingType: WLineSpacingType;
    textAlignment: WTextAlignment;
    constructor(node?: IWidget);
    getPropertyValue(property: string): Object;
    private setPropertyValue(property, value);
    private initializeUniqueParagraphFormat(property, propValue);
    private addUniqueParaFormat(property, modifiedProperty, propValue, uniqueParaFormatTemp);
    private static getPropertyDefaultValue(property);
    clearFormat(): void;
    destroy(): void;
    copyFormat(format: WParagraphFormat): void;
    cloneFormat(): WParagraphFormat;
    private hasValue(property);
    static clear(): void;
}
/**
 * Represent WRowFormat class
 */
export  class WRowFormat {
    private uniqueRowFormat;
    private static uniqueRowFormats;
    private static uniqueFormatType;
    borders: WBorders;
    ownerBase: TableRowWidget;
    allowBreakAcrossPages: boolean;
    isHeader: boolean;
    height: number;
    heightType: WHeightType;
    constructor(node?: TableRowWidget);
    getPropertyValue(property: string): Object;
    private setPropertyValue(property, value);
    private initializeUniqueRowFormat(property, propValue);
    private addUniqueRowFormat(property, modifiedProperty, propValue, uniqueRowFormatTemp);
    private static getPropertyDefaultValue(property);
    cloneFormat(): WRowFormat;
    hasValue(property: string): boolean;
    copyFormat(format: WRowFormat): void;
    destroy(): void;
    static clear(): void;
}
/**
 * Section Format Preservation
 */
export  class WSectionFormat {
    private uniqueSectionFormat;
    private static uniqueSectionFormats;
    private static uniqueFormatType;
    ownerBase: IWidget;
    headerDistance: number;
    footerDistance: number;
    differentFirstPage: boolean;
    differentOddAndEvenPages: boolean;
    pageHeight: number;
    rightMargin: number;
    pageWidth: number;
    leftMargin: number;
    bottomMargin: number;
    topMargin: number;
    constructor(node?: IWidget);
    destroy(): void;
    private hasValue(property);
    private static getPropertyDefaultValue(property);
    getPropertyValue(property: string): Object;
    private setPropertyValue(property, value);
    private initializeUniqueSectionFormat(property, propValue);
    private addUniqueSectionFormat(property, modifiedProperty, propValue, uniqueSectionFormatTemp);
    copyFormat(format: WSectionFormat): void;
    cloneFormat(): WSectionFormat;
    static clear(): void;
}
/**
 * Represent WShading Class
 */
export  class WShading {
    private uniqueShadingFormat;
    private static uniqueShadingFormats;
    private static uniqueFormatType;
    ownerBase: IWidget;
    backgroundColor: string;
    foregroundColor: string;
    textureStyle: WTextureStyle;
    constructor(node?: IWidget);
    private getPropertyValue(property);
    private setPropertyValue(property, value);
    private static getPropertyDefaultValue(property);
    private initializeUniqueShading(property, propValue);
    private addUniqueShading(property, modifiedProperty, propValue, uniqueShadingTemp);
    destroy(): void;
    cloneFormat(): WShading;
    copyFormat(shading: WShading): void;
    private hasValue(property);
    static clear(): void;
}
/**
 * Represent WTableFormat Class
 */
export  class WTableFormat {
    private uniqueTableFormat;
    private static uniqueTableFormats;
    private static uniqueFormatType;
    borders: WBorders;
    shading: WShading;
    ownerBase: TableWidget;
    cellSpacing: number;
    leftMargin: number;
    topMargin: number;
    rightMargin: number;
    bottomMargin: number;
    leftIndent: number;
    tableAlignment: WTableAlignment;
    preferredWidth: number;
    preferredWidthType: WWidthType;
    constructor(owner?: TableWidget);
    getPropertyValue(property: string): Object;
    private setPropertyValue(property, value);
    private initializeUniqueTableFormat(property, propValue);
    private addUniqueTableFormat(property, modifiedProperty, propValue, uniqueTableFormatTemp);
    private static getPropertyDefaultValue(property);
    private assignTableMarginValue(left, top, right, bottom);
    destroy(): void;
    cloneFormat(): WTableFormat;
    hasValue(property: string): boolean;
    copyFormat(format: WTableFormat): void;
    static clear(): void;
}
/**
 * Helper methods
 */
export  class MathHelper {
    /**
     * Rounds the values with specified decimal digits.
     * @param {number} value
     * @param {number} decimalDigits
     * @hidden
     */
    static round(value: number, decimalDigits: number): number;
}
export  class HelperMethods {
    static wordBefore: string;
    static wordAfter: string;
    static wordSplitCharacters: string[];
    /**
     * Inserts text at specified index in string.
     * @param {string} spanText
     * @param {number} index
     * @param {string} text
     * @hidden
     */
    static insert(spanText: string, index: number, text: string): string;
    /**
     * Removes text from specified index in string.
     * @param {string} text
     * @param {number} index
     * @param {number} length
     * @hidden
     */
    static remove(text: string, index: number, length: number): string;
    /**
     * Returns the index of word split character in a string.
     * @param {string} text
     * @param {string[]} wordSplitCharacter
     * @hidden
     */
    static indexOfAny(text: string, wordSplitCharacter: string[]): any;
    /**
     * Returns the last index of word split character in a string.
     * @param {string} text
     * @param {string[]} wordSplitCharacter
     * @hidden
     */
    static lastIndexOfAny(text: string, wordSplitCharacter: string[]): number;
    /**
     * Adds css styles to document header.
     * @param {string} css
     * @hidden
     */
    static addCssStyle(css: string): void;
    /**
     * Gets highlight color code.
     * @param {WHighlightColor} highlightColor
     * @hidden
     */
    static getHighlightColorCode(highlightColor: WHighlightColor): string;
    /**
     * Converts point to pixel.
     * @param {number} point
     * @hidden
     */
    static convertPointToPixel(point: number): number;
    /**
     * Converts pixel to point.
     * @param {number} pixel
     * @hidden
     */
    static convertPixelToPoint(pixel: number): number;
    /**
     * Return true if field linked
     * @hidden
     */
    static isLinkedFieldCharacter(inline: ElementBox): boolean;
    /**
     * Returns field code.
     * @hidden
     * @param fieldBegin
     */
    static getFieldCode(fieldBegin: FieldElementBox): string;
    /**
     * Removes white space in a string.
     * @param {string} text
     * @hidden
     */
    static removeSpace(text: string): string;
    /**
     * Trims white space at start of the string.
     * @param {string} text
     * @hidden
     */
    static trimStart(text: string): string;
    /**
     * Trims white space at end of the string.
     * @param {string} text
     * @hidden
     */
    static trimEnd(text: string): string;
    /**
     * Checks whether string ends with whitespace.
     * @param {string} text
     * @hidden
     */
    static endsWith(text: string): boolean;
}
export  class Point {
    private xIn;
    private yIn;
    /**
     * Gets or sets x value.
     * @hidden
     */
    x: number;
    /**
     * Gets or sets y value.
     * @hidden
     */
    y: number;
    constructor(xPosition: number, yPosition: number);
    /**
     * Destroys the internal objects maintained.
     * @returns void
     */
    destroy(): void;
}
export  class Hyperlink {
    private navigationLinkIn;
    /**
     * Gets navigation link.
     * @returns string
     * @hidden
     */
    readonly navigationLink: string;
    constructor(fieldBeginAdv: FieldElementBox, selection: Selection);
    /**
     * Parse field value.
     * @param  {HyperLinkHelper} helper
     * @param  {number} switchLevel
     * @param  {string} endChar
     * @hidden
     */
    parseFieldValue(helper: HyperLinkHelper, switchLevel: number, endChar: string): void;
    /**
     * Parse field values
     * @param  {string} value
     * @returns Void
     */
    parseFieldValues(value: string): void;
}
export  class RequestNavigateEventArgs {
    private hyperLinkIn;
    /**
     * Gets hyperlink.
     * @returns HyperLink
     * @hidden
     */
    readonly hyperLink: Hyperlink;
    constructor(hyperLink: Hyperlink);
}
export interface HyperLinkHelper {
    value: string;
}
export interface SubWidthInfo {
    subWidth: number;
    spaceCount: number;
}
export interface LineElementInfo {
    topMargin: number;
    bottomMargin: number;
    addSubWidth: boolean;
    whiteSpaceCount: number;
}
export interface Color {
    r: number;
    g: number;
    b: number;
}
export interface ElementBoxInfo {
    element: ElementBox;
    index: number;
}
export interface CaretHeightInfo {
    height: number;
    topMargin: number;
    isItalic?: boolean;
}
export interface SizeInfo {
    width: number;
    height: number;
    topMargin: number;
    bottomMargin: number;
}
export interface FirstElementInfo {
    element: ElementBox;
    left: number;
}
export interface LineWidgetInfo {
    lineWidget: LineWidget;
    lineIndex: number;
    element: ElementBox;
}
export interface IndexInfo {
    index: string;
}
export interface ImagePointInfo {
    selectedElement: HTMLElement;
    resizePosition: string;
}
export interface HyperlinkTextInfo {
    displayText: string;
    isNestedField: boolean;
    format: WCharacterFormat;
}
export interface LineWidgetClearInfo {
    element: ElementBox;
    lineWidget: LineWidget;
}
export interface BodyWidgetInfo {
    bodyWidget: BodyWidget;
    index: number;
}
export interface ParagraphInfo {
    paragraph: ParagraphWidget;
    offset: number;
}
export interface CellInfo {
    start: number;
    end: number;
}
export interface FieldCodeInfo {
    isNested: boolean;
    isParsed: boolean;
}
export interface ElementInfo {
    inline: ElementBox;
    index: number;
}
export interface TextPositionInfo {
    inline: ElementBox;
    index: number;
    caretPosition: Point;
    isImageSelected: boolean;
}
/**
 * @hidden
 */
export  class BaseHistoryInfo {
    private ownerControlIn;
    private actionIn;
    private removedNodesIn;
    private modifiedPropertiesIn;
    private modifiedNodeLength;
    private selectionStartIn;
    private selectionEndIn;
    private insertPositionIn;
    private endPositionIn;
    private currentPropertyIndex;
    private ignoredWord;
    private viewer;
    /**
     * gets the owner control
     * @hidden
     */
    readonly ownerControl: DocumentEditor;
    /**
     * gets or sets action
     * @hidden
     */
    action: Action;
    /**
     * gets modified properties
     * @returns Object
     * @hidden
     */
    readonly modifiedProperties: Object[];
    /**
     * @hidden
     */
    readonly removedNodes: IWidget[];
    /**
     * Gets or Sets the selection start
     * @hidden
     */
    selectionStart: string;
    /**
     * Gets or Sets the selection end
     * @hidden
     */
    selectionEnd: string;
    /**
     * Gets or sets the insert position
     * @hidden
     */
    insertPosition: string;
    /**
     * Gets or sets end position
     * @hidden
     */
    endPosition: string;
    private readonly history;
    constructor(node: DocumentEditor);
    /**
     * Update the selection
     * @param selection
     * @hidden
     */
    updateSelection(): void;
    /**
     * Reverts this instance
     * @hidden
     */
    revert(): void;
    private redoAction();
    /**
     * Revert the modified nodes
     * @param  {WNode[]} deletedNodes
     * @param  {boolean} isRedoAction
     * @param  {string} start
     * @param  {boolean} isEmptySelection
     */
    private revertModifiedNodes(deletedNodes, isRedoAction, start, isEmptySelection);
    private insertRemovedNodes(deletedNodes);
    getTextPosition(hierarchicalIndex: string): TextPosition;
    /**
     * Add modified properties for section format
     * @param  {WSectionFormat} format
     * @param  {string} property
     * @param  {Object} value
     * @hidden
     */
    addModifiedPropertiesForSection(format: WSectionFormat, property: string, value: Object): Object;
    /**
     * Add the modified properties for character format
     * @param  {WCharacterFormat} format
     * @param  {string} property
     * @param  {Object} value
     * @hidden
     */
    addModifiedProperties(format: WCharacterFormat, property: string, value: Object): Object;
    /**
     * Add the modified properties for paragraph format
     * @param  {WParagraphFormat} format
     * @param  {string} property
     * @param  {Object} value
     * @hidden
     */
    addModifiedPropertiesForParagraphFormat(format: WParagraphFormat, property: string, value: Object): Object;
    /**
     * Add modified properties for list format
     * @param  {WListLevel} listLevel
     * @hidden
     */
    addModifiedPropertiesForList(listLevel: WListLevel): Object;
    /**
     * Revert the properties
     * @param  {SelectionRange} selectionRange
     */
    private revertProperties();
    private getProperty();
    private getCharacterPropertyValue(property, modifiedProperty);
    /**
     * @hidden
     */
    destroy(): void;
}
/**
 * @hidden
 */
export  class ModifiedLevel {
    private ownerListLevelIn;
    private modifiedListLevelIn;
    /**
     * @hidden
     */
    /**
     * @hidden
     */
    ownerListLevel: WListLevel;
    /**
     * @hidden
     */
    /**
     * @hidden
     */
    modifiedListLevel: WListLevel;
    constructor(owner: WListLevel, modified: WListLevel);
    /**
     * @hidden
     */
    destroy(): void;
}
/**
 * @hidden
 */
export  class ModifiedParagraphFormat {
    private ownerFormatIn;
    private modifiedFormatIn;
    /**
     * @hidden
     */
    /**
     * @hidden
     */
    ownerFormat: WParagraphFormat;
    /**
     * hidden
     */
    /**
     * @hidden
     */
    modifiedFormat: WParagraphFormat;
    constructor(ownerFormat: WParagraphFormat, modifiedFormat: WParagraphFormat);
    /**
     * @hidden
     */
    destroy(): void;
}
/**
 *  `History` Module class is used to handle history preservation
 */
export  class History {
    private undoStackIn;
    private redoStackIn;
    private ownerControlIn;
    /**
     * @hidden
     */
    isUndoing: boolean;
    /**
     * @hidden
     */
    isRedoing: boolean;
    /**
     * @hidden
     */
    currentBaseHistoryInfo: BaseHistoryInfo;
    /**
     * @hidden
     */
    currentHistoryInfo: HistoryInfo;
    /**
     * @hidden
     */
    modifiedParaFormats: Dictionary<BaseHistoryInfo, ModifiedParagraphFormat[]>;
    private viewer;
    /**
     * gets owner control
     * @hidden
     */
    readonly ownerControl: DocumentEditor;
    /**
     * gets undo stack
     * @hidden
     */
    readonly undoStack: BaseHistoryInfo[];
    /**
     * gets redo stack
     * @hidden
     */
    readonly redoStack: BaseHistoryInfo[];
    /**
     * Determines whether undo operation can be done
     * @returns boolean
     */
    canUndo(): boolean;
    /**
     * Determines whether redo operation can be done
     * @returns boolean
     */
    canRedo(): boolean;
    constructor(node: DocumentEditor);
    /**
     * @hidden
     */
    getModuleName(): string;
    /**
     * initialize History
     * @param  {Selection} selection
     * @param  {Action} action
     * @param  {SelectionRange} selectionRange
     * @hidden
     */
    initializeHistory(action: Action): void;
    /**
     * Record the changes
     * @param  {BaseHistoryInfo} baseHistoryInfo
     * @hidden
     */
    recordChanges(baseHistoryInfo: BaseHistoryInfo): void;
    /**
     * update History
     * @hidden
     */
    updateHistory(): void;
    /**
     * update list changes for history preservation
     * @param  {Selection} selection
     * @param  {WAbstractList} currentAbstractList
     * @param  {WList} list
     * @hidden
     */
    updateListChangesInHistory(currentAbstractList: WAbstractList, list: WList): Dictionary<number, ModifiedLevel>;
    /**
     * Apply list changes
     * @param  {Selection} selection
     * @param  {Dictionary<number, ModifiedLevel>} modifiedLevelsInternal
     * @hidden
     */
    applyListChanges(selection: Selection, modifiedLevelsInternal: Dictionary<number, ModifiedLevel>): void;
    /**
     * Update list changes
     * @param  {Dictionary<number, ModifiedLevel>} modifiedCollection
     * @param  {Selection} selection
     * @hidden
     */
    updateListChanges(modifiedCollection: Dictionary<number, ModifiedLevel>): void;
    /**
     * Revert list changes
     * @param  {Selection} selection
     */
    private revertListChanges();
    /**
     * Reverse the last editing action.
     */
    undo(): void;
    /**
     * Redo the last undone action.
     */
    redo(): void;
    /**
     * @hidden
     */
    destroy(): void;
    private clearHistory();
    private clearUndoStack();
    private clearRedoStack();
}
/**
 * History preservation class
 */
/**
 * @hidden
 */
export  class HistoryInfo extends BaseHistoryInfo {
    /**
     * @hidden
     */
    modifiedActions: BaseHistoryInfo[];
    private isChildHistoryInfo;
    /**
     * @hidden
     */
    readonly hasAction: boolean;
    constructor(node: DocumentEditor, isChild: boolean);
    /**
     * Adds the modified actions
     * @param  {BaseHistoryInfo} baseHistoryInfo
     * @hidden
     */
    addModifiedAction(baseHistoryInfo: BaseHistoryInfo): void;
    /**
     * @hidden
     */
    destroy(): void;
}
/**
 * History implementation
 */
/**
 * Document Editor implementation
 */
/**
 * parses json data to physical DOM.
 */
export  class Parser {
    private viewer;
    private fieldSeparator;
    constructor(viewer: LayoutViewer);
    /**
     * @hidden
     * @param json
     */
    convertJsonToDocument(json: string): any;
    private parseAbstractList(data, abstractLists);
    private parseListLevel(data, owner);
    private parseList(data, listCollection);
    private parseLevelOverride(data, list);
    private parseSections(data);
    private parseHeaderFooter(data, headerFooters);
    private parseTextBody(data, section);
    private parseTable(block, blocks, index, section);
    private parseParagraph(data, paragraph);
    private parseTableFormat(sourceFormat, tableFormat);
    private parseCellFormat(sourceFormat, cellFormat);
    private parseCellMargin(sourceFormat, cellFormat);
    private parseRowFormat(sourceFormat, rowFormat);
    private parseBorders(sourceBorders, destBorder);
    private parseBorder(sourceBorder, destBorder);
    private parseShading(sourceShading, destShading);
    private parseCharacterFormat(sourceFormat, characterFormat);
    private getColor(color);
    private parseParagraphFormat(sourceFormat, paragraphFormat);
    private parseListFormat(block, listFormat);
    private parseSectionFormat(data, sectionFormat);
}
/**
 * Writes physical DOM to json data.
 */
export  class JsonWriter {
    static write(viewer: LayoutViewer): any;
    private static writeHeaderFooters(hfs, section);
    private static writeHeaderFooter(widget);
    private static createSection(bodyWidget);
    private static writeBlocks(childWidgets, blocks);
    private static writeParagraph(paragraphWidget, paragraph);
    private static createParagraph(paragraphWidget);
    private static writeCharacterFormat(format);
    private static writeParagraphFormat(format);
    private static writeListFormat(format);
    private static writeTable(tableWidget, table);
    private static writeRow(rowWidget, row);
    private static createTable(tableWidget);
    private static createRow(rowWidget);
    private static createCell(cellWidget);
    private static writeShading(wShading);
    private static writeBorder(wBorder);
    private static writeBorders(wBorders);
    private static writeCellFormat(wCellFormat);
    private static writeRowFormat(wRowFormat);
    private static writeTableFormat(wTableFormat);
    private static writeLists(viewer, document);
    private static writeAbstractList(wAbstractList);
    private static writeList(wList);
    private static writeListLevel(wListLevel);
}
/**
 * layout the documents
 */
export  class Layout {
    private viewer;
    static paragraphModule: ParagraphWidget;
    private layoutEnable;
    private value;
    allowLayout: boolean;
    isInitialLoad: boolean;
    /**
     * module declaration
     */
    private renderModule;
    constructor(viewer: LayoutViewer);
    /**
     * Layouts the items
     * @param viewer
     * @hidden
     */
    layoutItems(viewer: LayoutViewer): void;
    /**
     * Layouts the items
     * @param section
     * @param viewer
     * @hidden
     */
    layoutSection(section: BodyWidget, index: number, viewer: LayoutViewer, ownerWidget?: Widget): void;
    /**
     * Layouts specified block.
     * @param block
     * @hidden
     */
    layoutBlock(block: BlockWidget, index: number, moveToLine?: boolean): void;
    /**
     * Layouts specified paragraph.
     * @hidden
     * @param paragraph
     */
    layoutParagraph(lineIndex: number, moveToLine?: boolean): void;
    layoutListInternal(paragraph: ParagraphWidget): void;
    /**
     * @hidden
     */
    clearListElementBox(paragraph: ParagraphWidget): void;
    /**
     * Gets list number.
     * @param listFormat
     * @param document
     * @hidden
     */
    getListNumber(listFormat: WListFormat): string;
    /**
     * Gets list start value
     * @param listLevelNumber
     * @param list
     * @hidden
     */
    getListStartValue(listLevelNumber: number, list: WList): number;
    /**
     * Updates list values.
     * @param list
     * @param listLevelNumber
     * @param document
     */
    private updateListValues(list, listLevelNumber);
    /**
     * Gets list text
     * @param listAdv
     * @param listLevelNumber
     * @param currentListLevel
     * @param document
     */
    private getListText(listAdv, listLevelNumber, currentListLevel);
    /**
     * Gets the roman letter.
     * @param number
     */
    private getAsLetter(number);
    /**
     * Gets list text using list level pattern.
     * @param listLevel
     * @param listValue
     * @hidden
     */
    getListTextListLevel(listLevel: WListLevel, listValue: number): string;
    /**
     * Generate roman number for the specified number.
     * @param number
     * @param magnitude
     * @param letter
     */
    private generateNumber(number, magnitude, letter);
    /**
     * Gets list value prefixed with zero, if less than 10
     * @param listValue
     */
    private getAsLeadingZero(listValue);
    /**
     * Gets the roman number
     * @param number
     */
    private getAsRoman(number);
    /**
     * Layouts list.
     * @param viewer
     * @hidden
     */
    layoutList(viewer: LayoutViewer): void;
    /**
     * Gets the list level
     * @param list
     * @param listLevelNumber
     * @hidden
     */
    getListLevel(list: WList, listLevelNumber: number): WListLevel;
    /**
     * Adds list level.
     * @param abstractList
     */
    private addListLevels(abstractList);
    /**
     * Gets tab width
     * @param paragraph
     * @param viewer
     */
    private getTabWidth(paragraph, viewer);
    /**
     * Gets list number.
     * @param listFormat
     * @param document
     * @hidden
     */
    /**
     * Adds body widget.
     * @param area
     * @param section
     * @hidden
     */
    addBodyWidget(area: Rect, widget?: BodyWidget): BodyWidget;
    /**
     * Adds paragraph widget.
     * @param area
     */
    private addParagraphWidget(area, paragraphWidget?);
    /**
     * Layouts empty line widget.
     */
    private layoutEmptyLineWidget(paragraph, isEmptyLine, line?);
    /**
     * Adds line widget.
     * @param paragraph
     * @hidden
     */
    addLineWidget(paragraphWidget: ParagraphWidget): LineWidget;
    /**
     * Updates widget to page.
     * @param viewer
     * @param block
     * @hidden
     */
    updateWidgetToPage(viewer: LayoutViewer, paragraphWidget: ParagraphWidget): void;
    /**
     * @param viewer
     */
    private moveToNextPage(viewer, layoutNext, element?);
    /**
     * Layouts field characters.
     */
    private layoutFieldCharacters(element);
    layoutInline(lineWidget: LineWidget, count: number, moveToLine: boolean): void;
    checkNextLineWidget(currentLineWidget: LineWidget, availableWidth: number): void;
    /**
     * Splits element for client area.
     * @param element
     */
    private splitElementForClientArea(paragraph, element);
    /**
     * Splits text for client area.
     * @param element
     * @param text
     * @param width
     * @param characterFormat
     */
    private splitTextForClientArea(lineWidget, element, text, width, characterFormat);
    /**
     * Checks previous element.
     * @param characterFormat
     */
    private checkPreviousElement(line, index, characterFormat);
    /**
     * Splits by word
     * @param elementBox
     * @param text
     * @param width
     * @param characterFormat
     */
    private splitByWord(lineWidget, paragraph, elementBox, text, width, characterFormat);
    private addSplittedLineWidget(lineWidget, elementIndex, splittedElementBox?);
    /**
     * Gets split index by word.
     * @param clientActiveWidth
     * @param text
     * @param width
     * @param characterFormat
     */
    private getSplitIndexByWord(clientActiveWidth, text, width, characterFormat);
    /**
     * Splits by character.
     * @param textElement
     * @param text
     * @param width
     * @param characterFormat
     */
    private splitByCharacter(lineWidget, textElement, text, width, characterFormat);
    /**
     * Gets split index by character
     * @param totalClientWidth
     * @param clientActiveAreaWidth
     * @param text
     * @param width
     * @param characterFormat
     */
    private getTextSplitIndexByCharacter(totalClientWidth, clientActiveAreaWidth, text, width, characterFormat);
    /**
     * Gets sub width.
     * @param justify
     * @param spaceCount
     * @param firstLineIndent
     */
    private getSubWidth(lineWidget, justify, spaceCount, firstLineIndent);
    /**
     * Gets before spacing.
     * @param paragraph
     * @hidden
     */
    getBeforeSpacing(paragraph: ParagraphWidget): number;
    /**
     * Gets line spacing.
     * @param paragraph
     * @param maxHeight
     * @hidden
     */
    getLineSpacing(paragraph: ParagraphWidget, maxHeight: number): number;
    /**
     * Checks whether current line is first line in a paragraph.
     * @param paragraph
     */
    private isParagraphFirstLine(paragraph, line);
    /**
     * Checks whether current line is last line in a paragraph.
     * @param paragraph
     */
    private isParagraphLastLine(element);
    /**
     * Aligns line elements
     * @param element
     * @param topMargin
     * @param bottomMargin
     * @param maxDescent
     * @param addSubWidth
     * @param subWidth
     * @param textAlignment
     * @param whiteSpaceCount
     * @param isLastElement
     */
    private alignLineElements(element, topMargin, bottomMargin, maxDescent, addSubWidth, subWidth, textAlignment, whiteSpaceCount, isLastElement);
    /**
     * Splits text element word by word.
     * @param textElement
     */
    private splitTextElementWordByWord(textElement);
    /**
     * Gets text index after space.
     * @param text
     * @param startIndex
     */
    private getTextIndexAfterSpace(text, startIndex);
    /**
     * Adds element to line.
     * @param element
     */
    private addElementToLine(paragraph, element);
    /**
     * Moves to next line.
     */
    private moveToNextLine(element, lineWidgetIndex?);
    /**
     * Adds table widget.
     * @param area
     * @param table
     * @hidden
     */
    addTableWidget(area: Rect, table: TableWidget[], create?: boolean): TableWidget;
    /**
     * Layouts table row.
     * @param row
     * @hidden
     */
    layoutTableRow(tableWidget: TableWidget[], row: TableRowWidget, moveNext: boolean): void;
    moveTableToNextPage(tableWidget: TableWidget[], rowWidgets: TableRowWidget[]): void;
    /**
     * Layouts cell
     * @param cell
     * @param maxCellMarginTop
     * @param maxCellMarginBottom
     */
    private layoutCell(cell, maxCellMarginTop, maxCellMarginBottom, owner);
    /**
     * Adds table row widget.
     * @param area
     * @param row
     */
    private addTableRowWidget(area, row);
    /**
     * Adds table cell widget.
     * @param cell
     * @param area
     * @param maxCellMarginTop
     * @param maxCellMarginBottom
     */
    private addTableCellWidget(cell, area, maxCellMarginTop, maxCellMarginBottom);
    /**
     * Adds specified row widget to table.
     * @param viewer
     * @param tableRowWidget
     * @param row
     */
    private addWidgetToTable(viewer, tableCollection, rowCollection, row);
    /**
     * Updates row height by spanned cell.
     * @param tableWidget
     * @param rowWidget
     * @param insertIndex
     * @param row
     * @hidden
     */
    updateRowHeightBySpannedCell(tableWidget: TableWidget, row: TableRowWidget, insertIndex: number): void;
    /**
     * Updates row height.
     * @param prevRowWidget
     * @param rowWidget
     * @param row
     */
    private updateRowHeight(prevRowWidget, row);
    private updateSpannedRowCollection(rowSpan, row);
    /**
     * Updates row height by cell spacing
     * @param rowWidget
     * @param viewer
     * @param row
     */
    private updateRowHeightByCellSpacing(tableCollection, row, viewer);
    /**
     * Checks whether row span is end.
     * @param row
     * @param viewer
     */
    private isRowSpanEnd(row, viewer);
    /**
     * Checks whether vertical merged cell to continue or not.
     * @param row
     * @hidden
     */
    isVerticalMergedCellContinue(row: TableRowWidget): boolean;
    /**
     * Splits widgets.
     * @param tableRowWidget
     * @param viewer
     * @param splittedWidget
     * @param row
     */
    private splitWidgets(tableRowWidget, viewer, tableCollection, rowCollection, splittedWidget);
    /**
     * Gets splitted widget for row.
     * @param bottom
     * @param tableRowWidget
     */
    private getSplittedWidgetForRow(bottom, tableCollection, rowCollection, tableRowWidget);
    /**
     * Updates widget to page.
     * @param table
     * @hidden
     */
    updateWidgetsToPage(tableCollection: TableWidget[], rowCollection: TableRowWidget[], table: TableWidget): void;
    /**
     * Updates widget to table.
     * @param row
     * @param viewer
     */
    private updateWidgetsToTable(tableCollection, rowCollection, row, viewer);
    /**
     * Gets header.
     * @param table
     * @hidden
     */
    getHeader(table: TableWidget): TableRowWidget;
    /**
     * Gets header height.
     * @param ownerTable
     * @param row
     */
    private getHeaderHeight(ownerTable, row, rowCollection);
    /**
     * Updates widgets to row.
     * @param cell
     */
    private updateWidgetToRow(cell);
    /**
     * Updates height for table widget.
     * @param viewer
     * @param tableWidget
     * @hidden
     */
    updateHeightForTableWidget(viewer: LayoutViewer, tableCollection: TableWidget[], rowCollection: TableRowWidget[], tableWidget: TableWidget): void;
    /**
     * Updates height for row widget.
     * @param viewer
     * @param isUpdateVerticalPosition
     * @param rowWidget
     */
    private updateHeightForRowWidget(viewer, isUpdateVerticalPosition, tableCollection, rowCollection, rowWidget);
    /**
     * Updates height for cell widget.
     * @param viewer
     * @param cellWidget
     */
    private updateHeightForCellWidget(viewer, tableWidget, rowCollection, cellWidget);
    /**
     * Gets row height.
     * @param row
     * @hidden
     */
    getRowHeight(row: TableRowWidget, rowCollection: TableRowWidget[]): number;
    /**
     * splits spanned cell widget.
     * @param cellWidget
     * @param viewer
     */
    private splitSpannedCellWidget(cellWidget, tableCollection, rowCollection, viewer);
    /**
     * Inserts splitted cell widgets.
     * @param viewer
     * @param rowWidget
     */
    private insertSplittedCellWidgets(viewer, tableCollection, rowWidget);
    /**
     * Inserts spanned row widget.
     * @param rowWidget
     * @param viewer
     * @param left
     * @param index
     */
    private insertRowSpannedWidget(rowWidget, viewer, left, index);
    /**
     * Inserts empty splitted cell widgets.
     * @param rowWidget
     * @param left
     * @param index
     */
    private insertEmptySplittedCellWidget(rowWidget, tableCollection, left, index);
    /**
     * Gets spllited widget.
     * @param bottom
     * @param splitMinimalWidget
     * @param cellWidget
     */
    private getSplittedWidget(bottom, splitMinimalWidget, tableCollection, rowCollection, cellWidget);
    /**
     * Gets list level pattern
     * @param value
     * @hidden
     */
    getListLevelPattern(value: number): WListLevelPattern;
    /**
     * Creates cell widget.
     * @param cell
     */
    private createCellWidget(cell);
    /**
     * Gets splitted widget for paragraph.
     * @param bottom
     * @param paragraphWidget
     */
    private getSplittedWidgetForPara(bottom, paragraphWidget);
    /**
     * Gets splitted table widget.
     * @param bottom
     * @param tableWidget
     * @hidden
     */
    getSplittedWidgetForTable(bottom: number, tableCollection: TableWidget[], tableWidget: TableWidget): TableWidget;
    /**
     * Checks whether first line fits for paragraph or not.
     * @param bottom
     * @param paraWidget
     */
    private isFirstLineFitForPara(bottom, paraWidget);
    /**
     * Checks whether first line fits for table or not.
     * @param bottom
     * @param tableWidget
     * @hidden
     */
    isFirstLineFitForTable(bottom: number, tableWidget: TableWidget): boolean;
    /**
     * Checks whether first line fits for row or not.
     * @param bottom
     * @param rowWidget
     */
    private isFirstLineFitForRow(bottom, rowWidget);
    /**
     * Checks whether first line fits for cell or not.
     * @param bottom
     * @param cellWidget
     */
    private isFirstLineFitForCell(bottom, cellWidget);
    /**
     * Updates widget location.
     * @param widget
     * @param table
     */
    private updateWidgetLocation(widget, table);
    /**
     * Gets maximum top or bottom cell margin.
     * @param row
     * @param topOrBottom
     */
    private getMaxTopOrBottomCellMargin(row, topOrBottom);
    /**
     * Updates child location for table.
     * @param top
     * @param tableWidget
     * @hidden
     */
    updateChildLocationForTable(top: number, tableWidget: TableWidget): void;
    /**
     * Updates child location for row.
     * @param top
     * @param rowWidget
     * @hidden
     */
    updateChildLocationForRow(top: number, rowWidget: TableRowWidget): void;
    /**
     * Updates child location for cell.
     * @param top
     * @param cellWidget
     */
    private updateChildLocationForCell(top, cellWidget);
    /**
     * Updates cell vertical position.
     * @param cellWidget
     * @param isUpdateToTop
     * @param isInsideTable
     * @hidden
     */
    updateCellVerticalPosition(cellWidget: TableCellWidget, isUpdateToTop: boolean, isInsideTable: boolean): void;
    /**
     * Updates cell content vertical position.
     * @param cellWidget
     * @param displacement
     * @param isUpdateToTop
     */
    private updateCellContentVerticalPosition(cellWidget, displacement, isUpdateToTop);
    /**
     * Updates table widget location.
     * @param tableWidget
     * @param location
     * @param isUpdateToTop
     */
    private updateTableWidgetLocation(tableWidget, location, isUpdateToTop);
    /**
     * Gets displacement.
     * @param cellWidget
     * @param isUpdateToTop
     */
    private getDisplacement(cellWidget, isUpdateToTop);
    /**
     * Gets cell content height.
     * @param cellWidget
     */
    private getCellContentHeight(cellWidget);
    /**
     * Gets table left borders.
     * @param borders
     * @hidden
     */
    getTableLeftBorder(borders: WBorders): WBorder;
    /**
     * Gets table right border.
     * @param borders
     * @hidden
     */
    getTableRightBorder(borders: WBorders): WBorder;
    /**
     * Get table top border.
     * @param borders
     * @hidden
     */
    getTableTopBorder(borders: WBorders): WBorder;
    /**
     * Gets table bottom border.
     * @param borders
     * @hidden
     */
    getTableBottomBorder(borders: WBorders): WBorder;
    /**
     * Get diagonal cell up border.
     * @param tableCell
     * @hidden
     */
    getCellDiagonalUpBorder(tableCell: TableCellWidget): WBorder;
    /**
     * Gets diagonal cell down border
     * @param tableCell
     * @hidden
     */
    getCellDiagonalDownBorder(tableCell: TableCellWidget): WBorder;
    /**
     * Gets table width.
     * @param table
     * @hidden
     */
    getTableWidth(table: TableWidget): number;
    /**
     * Layouts table.
     * @param table
     */
    private layoutTable(table, rowIndex, moveNext);
    getBlockByIndex(sectionIndex: number, blockIndex: number): BlockWidget;
    /**
     * @hidden
     */
    layoutNextItemsBlock(blockAdv: BlockWidget, viewer: LayoutViewer): void;
    /**
     * @hidden
     */
    shiftLayoutedItems(): void;
    private reLayoutOrShiftWidgets(blockAdv, viewer);
    private shiftWidgetsBlock(block, viewer);
    private shiftWidgetsForPara(paragraph, viewer);
    private shiftWidgetsForTable(table, viewer);
    private getSplittedWidgetCollection(containerWidget, block);
    mergeWidgets(ownerWidget: Widget, splittedWidget: Widget[]): Widget;
    private combineTableWidgets(viewer, table, cellWidget);
    private combineTableRowWidgets(viewer, rowWidgets, tableWidget);
    private combineTableCellWidgets(viewer, cellWidgets, rowWidget);
    private combineParagraphWidgets(viewer, paragraph, cellWidget);
    private updateWidgetHeight(cellWidget);
    private updateTableWidget(rowWidget, tableWidget, index);
    private updateTableRowWidget(cellWidget, rowWidget, index);
    private updateContainerWidgetForCell(widgetIn, cellWidget);
    private updateVerticalPositionToTop(table, isUpdateTop);
    private splitWidget(paragraphWidget, viewer, previousBodyWidget, index);
    private getMaxElementHeight(lineWidget, viewer);
    private createOrGetNextBodyWidget(bodyWidget, viewer);
    private isFitInClientArea(paragraphWidget, viewer);
    private shiftToPreviousWidget(paragraphWidget, viewer, previousWidget);
    private updateParagraphWidgetInternal(lineWidget, newParagraphWidget, index);
    private shiftNextWidgets(blockAdv);
    private updateContainerWidget(widget, bodyWidget, index);
    private getBodyWidgetOfPreviousBlock(block, index);
    private updateClientAreaForLine(paragraph, startLineWidget, elementIndex);
    /**
     * @hidden
     */
    reLayoutParargaph(paragraphWidget: ParagraphWidget, lineIndex: number, elementBoxIndex: number): void;
    /**
     * @hidden
     */
    reLayoutTable(block: BlockWidget): void;
    clearTableWidget(table: TableWidget): void;
    clearRowWidget(row: TableRowWidget): void;
    clearCellWidget(cell: TableCellWidget): void;
    combineLineWidget(paragraph: ParagraphWidget): void;
    getParentTable(block: BlockWidget): TableWidget;
    /**
     * @hidden
     */
    updateClientAreaAfterReLayout(block: BlockWidget): void;
    /**
     * @hidden
     */
    updateParagraphWidgetHeight(paragraphWidget: ParagraphWidget): void;
    /**
     * @param blockIndex
     * @param bodyWidget
     * @param block
     * @hidden
     */
    layoutBodyWidgetCollection(blockIndex: number, bodyWidget: Widget, block: BlockWidget, shiftNextWidget: boolean): void;
    /**
     * hidden
     */
    updateParagraph(paragraph: ParagraphWidget): void;
    /**
     * Releases un-managed and - optionally - managed resources.
     */
    destroy(): void;
}
/**
 * AbstractList class
 */
export  class WAbstractList {
    private abstractListIdIn;
    levels: WListLevel[];
    abstractListId: number;
    destroy(): void;
}
/**
 * List Export
 */
/**
 * LevelOverride class
 */
export  class WLevelOverride {
    startAt: number;
    levelNumber: number;
    overrideListLevel: WListLevel;
    destroy(): void;
}
/**
 * ListLevel class
 */
export  class WListLevel {
    static dotBullet: string;
    static squareBullet: string;
    static arrowBullet: string;
    static circleBullet: string;
    private uniqueListLevel;
    private static uniqueListLevels;
    private static uniqueFormatType;
    paragraphFormat: WParagraphFormat;
    characterFormat: WCharacterFormat;
    ownerBase: WAbstractList | WLevelOverride;
    listLevelPattern: WListLevelPattern;
    followCharacter: WFollowCharacterType;
    startAt: number;
    numberFormat: string;
    restartLevel: number;
    constructor(node: WAbstractList | WLevelOverride);
    getPropertyValue(property: string): Object;
    setPropertyValue(property: string, value: Object): void;
    initializeUniqueWListLevel(property: string, propValue: object): void;
    addUniqueWListLevel(property: string, modifiedProperty: string, propValue: object, uniqueCharFormatTemp: Dictionary<number, object>): void;
    static getPropertyDefaultValue(property: string): Object;
    destroy(): void;
    static clear(): void;
}
/**
 * List class
 */
export  class WList {
    listId: number;
    sourceListId: number;
    abstractListId: number;
    levelOverrides: WLevelOverride[];
    getLevelOverride(levelNumber: number): WLevelOverride;
    destroy(): void;
}
/**
 * Options Pane class.
 */
export  class OptionsPane {
    private viewer;
    optionsPane: HTMLElement;
    isOptionsPaneShow: boolean;
    private resultsListBlock;
    private messageDiv;
    private spanArrow;
    private results;
    private searchInput;
    private searchDiv;
    private searchTextBoxContainer;
    private findAndReplace;
    private replaceWith;
    private searchList;
    private findDiv;
    private replaceDiv;
    private replaceButton;
    private replaceAllButton;
    private occurrenceDiv;
    private findOption;
    private matchCase;
    private wholeWord;
    private regular;
    private searchText;
    private resultsText;
    private messageDivText;
    private replaceButtonText;
    private replaceAllButtonText;
    private occurrenceDivText;
    private focusedIndex;
    private focusedElement;
    private resultContainer;
    private navigateToPreviousResult;
    private navigateToNextResult;
    private closeButton;
    private isOptionsPane;
    private findTab;
    private findTabButton;
    private replaceTabButton;
    private searchIcon;
    private spinIcon;
    private divElement;
    private searchOptionsDiv;
    private matchDiv;
    private replacePaneText;
    private findPaneText;
    private matchDivReplaceText;
    private matchDivReplaceAllText;
    private matchInput;
    private wholeInput;
    private regularInput;
    tabInstance: navigations.Tab;
    private findTabContentDiv;
    private replaceTabContentDiv;
    private findTabButtonHeader;
    private replaceTabButtonHeader;
    isReplace: boolean;
    private localeValue;
    searchHighlighters: Dictionary<LineWidget, SearchWidgetInfo[]>;
    /**
     * Constructor for Options pane module
     * @param {LayoutViewer} layoutViewer
     */
    constructor(layoutViewer: LayoutViewer);
    /**
     * Get the module name.
     */
    private getModuleName();
    /**
     * Initialize the options pane.
     * @param {base.L10n} localeValue - Specifies the localization based on culture.
     * @hidden
     */
    initOptionsPane(localeValue: base.L10n): void;
    /**
     * Create replace pane instances.
     */
    private createReplacePane();
    /**
     * Gets selected tab item which tab is selected.
     * @param {navigations.SelectEventArgs} args - Specifies which tab will be opened.
     * @hidden
     */
    selectedTabItem: (args: navigations.SelectEventArgs) => void;
    /**
     * Create search options.
     */
    private createSearchOptions();
    /**
     * Apply find option based on whole words value.
     * @param {buttons.ChangeEventArgs} args - Specifies the search options value.
     * @hidden
     */
    wholeWordsChange: (args: buttons.ChangeEventArgs) => void;
    /**
     * Apply find option based on match value.
     * @param {buttons.ChangeEventArgs} args - Specifies the search options value.
     * @hidden
     */
    matchChange: (args: buttons.ChangeEventArgs) => void;
    /**
     * Apply find options based on regular value.
     * @param {buttons.ChangeEventArgs} args - Specifies the search options value.
     * @hidden
     */
    regularChange: (args: buttons.ChangeEventArgs) => void;
    /**
     * Close search options window.
     * @param {MouseEvent} event - Specifies close search option element.
     * @hidden
     */
    closeSearchOptions: (event: MouseEvent) => void;
    /**
     * Binding events from the element when optins pane creation.
     * @hidden
     */
    onWireEvents: () => void;
    /**
     * Fires on key down actions done.
     * @hidden
     */
    onKeyDownInternal(): void;
    /**
     * Enable find pane only.
     * @hidden
     */
    onFindPane: () => void;
    /**
     * Enable replace pane only.
     * @hidden
     */
    onReplacePane: () => void;
    /**
     * Fires on spin down.
     * @hidden
     */
    onSpinArrowClick: () => void;
    /**
     * Fires on key down on options pane.
     * @param {KeyboardEvent} event - Specifies the focus of current element.
     * @hidden
     */
    onKeyDownOnOptionPane: (event: KeyboardEvent) => void;
    /**
     * Fires on replace.
     * @hidden
     */
    onReplaceButtonClick: () => void;
    /**
     * Fires on replace all.
     * @hidden
     */
    onReplaceAllButtonClick: () => void;
    /**
     * Replace all.
     * @hidden
     */
    replaceAll(): void;
    /**
     * Fires on search icon.
     * @hidden
     */
    searchIconClickInternal: () => void;
    /**
     * Fires on getting next results.
     * @hidden
     */
    navigateNextResultButtonClick: () => void;
    /**
     * Fires on getting previous results.
     * @hidden
     */
    navigatePreviousResultButtonClick: () => void;
    /**
     * Scrolls to position.
     * @param {HTMLElement} list - Specifies the list element.
     * @hidden
     */
    scrollToPosition(list: HTMLElement): void;
    /**
     * Fires on key down
     * @param {KeyboardEvent} event - Speficies key down actions.
     * @hidden
     */
    onKeyDown: (event: KeyboardEvent) => void;
    /**
     * Clear the focus elements.
     * @hidden
     */
    clearFocusElement(): void;
    /**
     * Close the optios pane.
     * @hidden
     */
    close: () => void;
    /**
     * Fires on results list block.
     * @param {MouseEvent} args - Specifies which list was clicked.
     * @hidden
     */
    resultListBlockClick: (args: MouseEvent) => void;
    /**
     * Show or hide option pane based on boolean value.
     * @param {boolean} show - Specifies showing or hiding the options pane.
     * @hidden
     */
    showHideOptionsPane(show: boolean): void;
    /**
     * Adds search highlight border.
     * @hidden
     */
    addSearchHighlightBorder(lineWidget: LineWidget): SearchWidgetInfo;
    /**
     * Clears search results.
     * @hidden
     */
    clearSearchResultItems(): void;
    /**
     * Clears search highlight.
     * @hidden
     */
    clearSearchHighlight(): void;
    /**
     * Highlight search result
     * @hidden
     */
    highlightSearchResult(paragraph: ParagraphWidget, start: TextPosition, end: TextPosition): void;
    /**
     * @hidden
     */
    highlightSearchResultParaWidget(widget: ParagraphWidget, startIndex: number, endLine: LineWidget, endElement: ElementBox, endIndex: number): void;
    createHighlightBorder(lineWidget: LineWidget, width: number, left: number, top: number): void;
    /**
     * Dispose the internal objects which are maintained.
     * @hidden
     */
    destroy(): void;
    /**
     * Dispose the internal objects which are maintained.
     */
    private destroyInternal();
}
export  class SearchWidgetInfo {
    private leftInternal;
    private widthInternal;
    left: number;
    width: number;
    constructor(left: number, width: number);
}
/**
 * Rect class
 */
export  class Rect {
    width: number;
    height: number;
    x: number;
    y: number;
    private leftIn;
    private rightIn;
    private topIn;
    private bottomIn;
    readonly left: number;
    readonly right: number;
    readonly top: number;
    readonly bottom: number;
    constructor(x: number, y: number, width: number, height: number);
}
/**
 * Margin Class
 */
export  class Margin {
    private leftIn;
    private topIn;
    private rightIn;
    private bottomIn;
    left: number;
    top: number;
    right: number;
    bottom: number;
    constructor(leftMargin: number, topMargin: number, rightMargin: number, bottomMargin: number);
}
/**
 * IWidget interface
 */
export interface IWidget {
}
/**
 * Widget class
 */
export  abstract class Widget implements IWidget {
    childWidgets: IWidget[];
    x: number;
    y: number;
    width: number;
    height: number;
    containerWidget: Widget;
    margin: Margin;
    leftBorderWidth: number;
    rightBorderWidth: number;
    topBorderWidth: number;
    bottomBorderWidth: number;
    readonly previousNode: Widget;
    readonly nextNode: Widget;
    readonly firstNode: IWidget;
    readonly lastNode: IWidget;
    /**
     * Initialize the constructor of Widget
     */
    constructor();
}
/**
 * BodyWidget class
 */
export  class BodyWidget extends Widget {
    page: Page;
    sectionIndex: number;
    sectionFormat: WSectionFormat;
    /**
     * Initialize the constructor of BodyWidget
     */
    constructor();
    getHierarchicalIndex(hierarchicalIndex: string): string;
    renderedElement(currentBlockIndex: number, block: BlockWidget): BlockWidget[];
    destroy(): void;
}
/**
 * HeaderFooterWidget class
 */
export interface HeaderFooters {
    [key: number]: HeaderFooterWidget;
}
/**
 * HeaderFooterWidget class
 */
export  class HeaderFooterWidget extends Widget {
    private typeInternal;
    headerFooterType: WHeaderFooterType;
    constructor(type: WHeaderFooterType);
}
export  class BlockWidget extends Widget {
    blockIndex: number;
    readonly bodyWidget: BodyWidget;
    readonly leftIndent: number;
    readonly rightIndent: number;
    readonly isInsideTable: boolean;
    readonly associatedCell: TableCellWidget;
    renderedElement(): BlockWidget[];
    getHierarchicalIndex(hierarchicalIndex: string): string;
    getIndex(): number;
}
/**
 * ParagraphWidget class
 */
export  class ParagraphWidget extends BlockWidget {
    paragraphFormat: WParagraphFormat;
    characterFormat: WCharacterFormat;
    /**
     * Initialize the constructor of ParagraphWidget
     */
    constructor();
    isEmpty(): boolean;
    getInline(offset: number, indexInInline: number): ElementInfo;
    destroy(viewer: LayoutViewer): void;
}
export  class TableWidget extends BlockWidget {
    private flags;
    leftMargin: number;
    topMargin: number;
    rightMargin: number;
    bottomMargin: number;
    tableFormat: WTableFormat;
    spannedRowCollection: Dictionary<number, number>;
    tableGrids: number[];
    tableHolder: WTableHolder;
    headerHeight: number;
    description: string;
    title: string;
    isGridUpdated: boolean;
    continueHeader: boolean;
    header: boolean;
    constructor();
    contains(tableCell: TableCellWidget): boolean;
    getOwnerWidth(isBasedOnViewer: boolean): number;
    getTableClientWidth(clientWidth: number): number;
    getCellWidth(preferredWidth: number, preferredWidthType: WWidthType, containerWidth: number, cell: TableCellWidget): number;
    buildTableColumns(): void;
    setWidthToCells(): void;
    getFirstParagraphInFirstCell(): ParagraphWidget;
    static getTableOf(node: WBorders): TableWidget;
    destroy(viewer: LayoutViewer): void;
}
export  class TableRowWidget extends BlockWidget {
    topBorderWidth: number;
    bottomBorderWidth: number;
    rowFormat: WRowFormat;
    spannedRowCollection: TableRowWidget[];
    beforeWidth: number;
    afterWidth: number;
    readonly rowIndex: number;
    readonly ownerTable: TableWidget;
    gridBefore: number;
    gridAfter: number;
    gridBeforeWidth: number;
    gridAfterWidth: number;
    constructor();
    static getRowOf(node: WBorders): TableRowWidget;
    destroy(viewer: LayoutViewer): void;
}
export  class TableCellWidget extends BlockWidget {
    cellFormat: WCellFormat;
    columnIndex: number;
    readonly ownerColumn: WColumn;
    readonly leftMargin: number;
    readonly topMargin: number;
    readonly rightMargin: number;
    readonly bottomMargin: number;
    readonly cellIndex: number;
    isInHeaderFooter: boolean;
    readonly ownerTable: TableWidget;
    readonly ownerRow: TableRowWidget;
    constructor();
    static getCellLeftBorder(tableCell: TableCellWidget): WBorder;
    getLeftBorderWidth(): number;
    getRightBorderWidth(): number;
    getCellSpacing(): number;
    getMinimumPreferredWidth(): number;
    getPreviousCellLeftBorder(leftBorder: WBorder, previousCell: TableCellWidget): WBorder;
    getBorderBasedOnPriority(border: WBorder, adjacentBorder: WBorder): WBorder;
    getLeftBorderToRenderByHierarchy(leftBorder: WBorder, rowBorders: WBorders, tableBorders: WBorders): WBorder;
    static getCellRightBorder(tableCell: TableCellWidget): WBorder;
    getAdjacentCellRightBorder(rightBorder: WBorder, nextCell: TableCellWidget): WBorder;
    getRightBorderToRenderByHierarchy(rightBorder: WBorder, rowBorders: WBorders, tableBorders: WBorders): WBorder;
    static getCellTopBorder(tableCell: TableCellWidget): WBorder;
    getPreviousCellTopBorder(topBorder: WBorder, previousTopCell: TableCellWidget): WBorder;
    getTopBorderToRenderByHierarchy(topBorder: WBorder, rowBorders: WBorders, tableBorders: WBorders): WBorder;
    static getCellBottomBorder(tableCell: TableCellWidget): WBorder;
    getAdjacentCellBottomBorder(bottomBorder: WBorder, nextBottomCell: TableCellWidget): WBorder;
    getBottomBorderToRenderByHierarchy(bottomBorder: WBorder, rowBorders: WBorders, tableBorders: WBorders): WBorder;
    private convertHexToRGB(colorCode);
    static getCellOf(node: WBorders): TableCellWidget;
    destroy(viewer: LayoutViewer): void;
}
/**
 * LineWidget class
 */
export  class LineWidget implements IWidget {
    children: ElementBox[];
    currentParagraphWidget: ParagraphWidget;
    x: number;
    y: number;
    width: number;
    height: number;
    maxBaseLineOffset: number;
    maxTextElementHeight: number;
    maxTextElementBaselineOffset: number;
    /**
     * Initialize the constructor of LineWidget
     */
    constructor(paragraphWidget: ParagraphWidget);
    getOffset(inline: ElementBox, index: number): number;
    getEndOffset(): number;
    getInline(offset: number, indexInInline: number): ElementInfo;
    getHierarchicalIndex(hierarchicalIndex: string): string;
    destroy(): void;
    destroyInternal(viewer: LayoutViewer): void;
}
/**
 * ElementBox class
 */
export  abstract class ElementBox {
    x: number;
    y: number;
    width: number;
    height: number;
    margin: Margin;
    currentLineWidget: LineWidget;
    characterFormat: WCharacterFormat;
    private lengthIn;
    static objectCharacter: string;
    length: number;
    readonly nextNode: ElementBox;
    readonly previousNode: ElementBox;
    /**
     * @hidden
     */
    readonly paragraph: ParagraphWidget;
    /**
     * Initialize the constructor of ElementBox
     */
    constructor();
    abstract destroy(): void;
    abstract destroy(viewer: LayoutViewer): void;
    destroyInternal(viewer: LayoutViewer): void;
    abstract clone(element: ElementBox): ElementBox;
}
/**
 * Field element box class.
 */
export  class FieldElementBox extends ElementBox {
    fieldType: number;
    /**
     * @hidden
     */
    hasFieldEnd: boolean;
    private fieldBeginInternal;
    private fieldSeparatorInternal;
    private fieldEndInternal;
    fieldBegin: FieldElementBox;
    fieldSeparator: FieldElementBox;
    fieldEnd: FieldElementBox;
    readonly length: number;
    constructor(type: number);
    /**
     * @hidden
     */
    clone(field: FieldElementBox): FieldElementBox;
    destroy(): void;
}
/**
 * TextElementBox class
 */
export  class TextElementBox extends ElementBox {
    baselineOffset: number;
    index: number;
    length: number;
    private tex;
    text: string;
    constructor();
    /**
     * @hidden
     */
    clone(element: TextElementBox): TextElementBox;
    destroy(): void;
}
export  class ImageElementBox extends ElementBox {
    private imageStr;
    private isInlineImageIn;
    readonly isInlineImage: boolean;
    readonly length: number;
    imageString: string;
    constructor(isInlineImage?: boolean);
    /**
     * @hidden
     */
    clone(element: ImageElementBox): ImageElementBox;
    destroy(): void;
}
/**
 * ListTextElementBox class
 */
export  class ListTextElementBox extends ElementBox {
    baselineOffset: number;
    private textInternal;
    index: number;
    listLevel: WListLevel;
    isFollowCharacter: boolean;
    text: string;
    constructor(listLevel: WListLevel, isListFollowCharacter: boolean);
    /**
     * @hidden
     */
    clone(element: ListTextElementBox): ListTextElementBox;
    destroy(): void;
}
/**
 * Page class
 */
export  class Page {
    /**
     * Specifies the Viewer
     */
    viewer: LayoutViewer;
    /**
     * Specifies the section
     */
    section: BodyWidget;
    /**
     * Specifies the Bonding Rectangle
     */
    boundingRectangle: Rect;
    repeatHeaderRowTableWidget: boolean;
    /**
     * Specifies the bodyWidgets
     * @default []
     */
    bodyWidgets: BodyWidget[];
    headerWidget: HeaderFooterWidget;
    footerWidget: HeaderFooterWidget;
    /**
     * Initialize the constructor of Page
     */
    constructor();
    destroy(): void;
}
/**
 * Element Collection
 */
export  class ElementCollection {
    maxBaseLineOffset: number;
    maxTextElementHeight: number;
    maxTextElementBaselineOffset: number;
    skipClipImage: boolean;
    private collection;
    readonly length: number;
    getItem(index: number): ElementBox;
    push(item: ElementBox): number;
    add(item: ElementBox): number;
    insert(index: number, item: ElementBox): void;
    remove(item: ElementBox): boolean;
    toArray(): ElementBox[];
    removeAt(index: number): boolean;
    contains(item: ElementBox): boolean;
    clear(): void;
    private updateMaxElementHeight(element);
    protected shiftItems(index: number, forward: boolean): void;
    clearArray(): void;
}
export  class WTableHolder {
    private tableColumns;
    private tableWidth;
    readonly columns: WColumn[];
    getPreviousSpannedCellWidth(previousColumnIndex: number, curColumnIndex: number): number;
    addColumns(currentColumnIndex: number, columnSpan: number, width: number): void;
    getTotalWidth(): number;
    fitColumns(containerWidth: number, preferredTableWidth: number, isAutoWidth: boolean): void;
    getCellWidth(columnIndex: number, columnSpan: number): number;
    destroy(): void;
}
/**
 * Table Column Class
 */
export  class WColumn {
    preferredWidth: number;
    minWidth: number;
    maxWidth: number;
    destroy(): void;
}
/**
 * Print class
 */
export  class Print {
    /**
     * Gets module name.
     */
    private getModuleName();
    /**
     * Prints the current viewer
     * @param viewer
     * @param printWindow
     */
    print(viewer: PageLayoutViewer, printWindow?: Window): void;
    /**
     * Opens print window and displays current page to print.
     * @hidden
     */
    printWindow(viewer: PageLayoutViewer, browserUserAgent: string, printWindow?: Window): void;
    /**
     * Generates print content.
     * @hidden
     */
    generatePrintContent(viewer: PageLayoutViewer, element: HTMLDivElement): void;
    /**
     * Gets page width.
     * @param pages
     * @hidden
     */
    getPageWidth(pages: Page[]): number;
    /**
     *  Gets page height.
     * @hidden
     */
    getPageHeight(pages: Page[]): number;
    destroy(): void;
}
/**
 * Render module
 */
export  class Renderer {
    isPrinting: boolean;
    private pageLeft;
    private pageTop;
    private viewer;
    private pageCanvasIn;
    /**
     * Gets page canvas.
     * @hidden
     */
    readonly pageCanvas: HTMLCanvasElement;
    /**
     * Gets selection canvas.
     */
    private readonly selectionCanvas;
    /**
     * Gets page context.
     */
    private readonly pageContext;
    /**
     * Gets selection context.
     */
    private readonly selectionContext;
    constructor(viewer: LayoutViewer);
    /**
     * Renders widgets.
     * @param {Page} page
     * @param {number} left
     * @param {number} top
     * @param {number} width
     * @param {number} height
     * @hidden
     */
    renderWidgets(page: Page, left: number, top: number, width: number, height: number): void;
    /**
     * Sets page size.
     * @param {Page} page
     */
    private setPageSize(page);
    /**
     * Sets zoom transform for image resizer.
     * @param {Page} page
     * @hidden
     */
    /**
     * Renders header footer widget.
     * @param {Page} page
     * @param {HeaderFooterWidget} headFootWidget
     */
    private renderHeaderSeparator(page, left, top, widget);
    private getHeaderFooterType(page, isHeader);
    private renderDashLine(ctx, x, y, width);
    private renderHeaderFooterMark(ctx, x, y, w, h);
    private renderHeaderFooterMarkText(ctx, content, x, y);
    /**
     * Renders body widget.
     * @param {Page} page
     * @param {BodyWidget} bodyWidget
     */
    private render(page, bodyWidget);
    /**
     * Renders block widget.
     * @param {Page} page
     * @param {Widget} widget
     */
    private renderWidget(page, widget);
    /**
     * Renders header.
     * @param {Page} page
     * @param {TableWidget} widget
     * @param {WRow} header
     * @hidden
     */
    renderHeader(page: Page, widget: TableWidget, header: TableRowWidget): void;
    /**
     * Renders paragraph widget.
     * @param {Page} page
     * @param {ParagraphWidget} paraWidget
     */
    private renderParagraphWidget(page, paraWidget);
    /**
     * Renders table widget.
     * @param {Page} page
     * @param {TableWidget} tableWidget
     */
    private renderTableWidget(page, tableWidget);
    /**
     * Renders table row widget.
     * @param {Page} page
     * @param {Widget} rowWidget
     */
    private renderTableRowWidget(page, rowWidget);
    /**
     * Renders table cell widget.
     * @param {Page} page
     * @param {TableCellWidget} cellWidget
     */
    private renderTableCellWidget(page, cellWidget);
    /**
     * Checks whether current line is paragraph first line or not.
     * @param {LineWidget} lineWidget
     */
    private isParagraphFirstLine(lineWidget);
    /**
     * Renders line widget.
     * @param {LineWidget} lineWidget
     * @param {Page} page
     * @param {number} left
     * @param {number} top
     */
    private renderLine(lineWidget, page, left, top);
    /**
     * Gets underline y position.
     * @param {LineWidget} lineWidget
     */
    private getUnderlineYPosition(lineWidget);
    /**
     * Renders list element box
     * @param {ListTextElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     */
    private renderListTextElementBox(elementBox, left, top, underlineY);
    /**
     * Renders text element box.
     * @param {TextElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     */
    private renderTextElementBox(elementBox, left, top, underlineY);
    /**
     * Clips the rectangle with specified position.
     * @param {number} xPos
     * @param {number} yPos
     * @param {number} width
     * @param {number} height
     */
    private clipRect(xPos, yPos, width, height);
    /**
     * Renders underline.
     * @param {ElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     * @param {string} color
     * @param {WUnderline} underline
     * @param {WBaselineAlignment} baselineAlignment
     */
    private renderUnderline(elementBox, left, top, underlineY, color, underline, baselineAlignment);
    /**
     * Renders strike through.
     * @param {ElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {WStrikethrough} strikeThrough
     * @param {string} color
     * @param {WBaselineAlignment} baselineAlignment
     */
    private renderStrikeThrough(elementBox, left, top, strikeThrough, color, baselineAlignment);
    /**
     * Renders image element box.
     * @param {ImageElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     */
    private renderImageElementBox(elementBox, left, top, underlineY);
    /**
     * Renders table outline.
     * @param {TableWidget} tableWidget
     */
    private renderTableOutline(tableWidget);
    /**
     * Renders table cell outline.
     * @param {LayoutViewer} viewer
     * @param {TableCellWidget} cellWidget
     */
    private renderTableCellOutline(viewer, cellWidget);
    /**
     * Renders cell background.
     * @param {number} height
     * @param {TableCellWidget} cellWidget
     */
    private renderCellBackground(height, cellWidget);
    /**
     * Renders single border.
     * @param {WBorder} border
     * @param {number} startX
     * @param {number} startY
     * @param {number} endX
     * @param {number} endY
     * @param {number} lineWidth
     */
    private renderSingleBorder(border, startX, startY, endX, endY, lineWidth);
    /**
     * Gets scaled value.
     * @param {number} value
     * @param {number} type
     * @hidden
     */
    getScaledValue(value: number, type?: number): number;
    /**
     * Destroys the internal objects which is maintained.
     */
    destroy(): void;
}
/**
 * Search module
 */
export  class Search {
    private ownerControl;
    textSearch: TextSearch;
    textSearchResults: TextSearchResults;
    readonly viewer: LayoutViewer;
    constructor(owner: DocumentEditor);
    /**
     * Get the module name.
     */
    private getModuleName();
    /**
     * Finds the immediate occurrence of specified text from cursor position in the document.
     * @param  {string} text
     * @param  {WFindOption} findOption? - Default value of ‘findOptions’ parameter is 'None'.
     * @hidden
     */
    find(text: string, findOptions?: WFindOption): void;
    /**
     * Finds all occurrence of specified text in the document.
     * @param  {string} text
     * @param  {WFindOption} findOption? - Default value of ‘findOptions’ parameter is 'None'.
     * @hidden
     */
    findAll(text: string, findOptions?: WFindOption): void;
    /**
     * Find the textToFind string in current document and replace the specified string.
     * @param  {string} textToFind
     * @param  {string} textToReplace
     * @param  {WFindOption} findOptions? - Default value of ‘findOptions’ parameter is WFindOption.None.
     * @hidden
     */
    replaceAllInternal(textToFind: string, textToReplace: string, findOptions?: WFindOption): void;
    /**
     * Find the textToFind string in current document and replace the specified string.
     * @param  {string} textToFind
     * @param  {string} textToReplace
     * @param  {WFindOption} findOptions? - Default value of ‘findOptions’ parameter is WFindOption.None.
     * @hidden
     */
    replaceInternal(textToFind: string, textToReplace: string, findOptions?: WFindOption): void;
    navigate(textSearchResult: TextSearchResult): void;
    highlight(textSearchResults: TextSearchResults): void;
    highlightResult(result: TextSearchResult): void;
    addSearchResultItems(result: string): void;
    addFindResultView(textSearchResults: TextSearchResults): void;
    addFindResultViewForSearch(result: TextSearchResult): void;
    /**
     * Replace the searched string with specified string
     * @param  {string} replaceText
     * @param  {TextSearchResult} result
     * @param  {TextSearchResults} results
     * @hidden
     */
    replace(replaceText: string, result: TextSearchResult, results: TextSearchResults): number;
    /**
     * Replace all the searched string with specified string
     * @param  {string} replaceText
     * @param  {TextSearchResults} results
     * @hidden
     */
    replaceAll(replaceText: string, results: TextSearchResults): number;
    destroy(): void;
}
/**
 * TextSearchResult class
 */
export  class TextSearchResult {
    private startIn;
    private endIn;
    private owner;
    readonly viewer: LayoutViewer;
    start: TextPosition;
    end: TextPosition;
    readonly text: string;
    constructor(owner: DocumentEditor);
    destroy(): void;
}
/**
 * TextSearchResult class
 */
export  class TextSearchResults {
    innerList: TextSearchResult[];
    currentIndex: number;
    private owner;
    readonly length: number;
    readonly currentSearchResult: TextSearchResult;
    constructor(owner: DocumentEditor);
    addResult(): TextSearchResult;
    clearResults(): void;
    indexOf(result: TextSearchResult): number;
    destroy(): void;
}
/**
 * TextSearch class
 */
export  class TextSearch {
    private wordBefore;
    private wordAfter;
    private owner;
    readonly viewer: LayoutViewer;
    constructor(owner: DocumentEditor);
    find(pattern: string | RegExp, findOption?: WFindOption): TextSearchResult;
    findNext(pattern: string | RegExp, findOption?: WFindOption, hierarchicalPosition?: string): TextSearchResult;
    stringToRegex(textToFind: string, option: WFindOption): RegExp;
    isPatternEmpty(pattern: RegExp): boolean;
    findAll(pattern: string | RegExp, findOption?: WFindOption, hierarchicalPosition?: string): TextSearchResults;
    private findDocument(results, pattern, isFirstMatch, findOption?, hierachicalPosition?);
    private findInline(inlineElement, pattern, option, indexInInline, isFirstMatch, results, selectionEnd);
    private getTextPosition(lineWidget, hierarchicalIndex);
}
/**
 * Selection-Format Retrieve Classes
 */
export  class SelectionCharacterFormat {
    selection: Selection;
    private boldIn;
    private italicIn;
    private underlineIn;
    private strikeThroughIn;
    private baselineAlignmentIn;
    private highlightColorIn;
    private fontSizeIn;
    private fontFamilyIn;
    private fontColorIn;
    /**
     * Gets or sets font size.
     */
    fontSize: number;
    /**
     * Gets or sets font family.
     */
    fontFamily: string;
    /**
     * Gets or sets font color.
     */
    fontColor: string;
    /**
     * Gets or sets the value indicating whether selection character format represents bold.
     */
    bold: boolean;
    /**
     * Gets or sets the value indicating whether selection character format represents italic.
     */
    italic: boolean;
    /**
     * Gets or sets strikeThrough style.
     */
    strikeThrough: WStrikethrough;
    /**
     * Gets or sets baseline alignment.
     */
    baselineAlignment: WBaselineAlignment;
    /**
     * Gets or sets underline style.
     */
    underline: WUnderline;
    /**
     * Gets or sets highlight color.
     */
    highlightColor: WHighlightColor;
    constructor(selection: Selection);
    private getPropertyValue(property);
    /**
     * Notifies whenever property gets changed.
     * @param  {string} propertyName
     */
    private notifyPropertyChanged(propertyName);
    /**
     * Copies the source format.
     * @param  {WCharacterFormat} format
     * @returns void
     * @hidden
     */
    copyFormat(format: WCharacterFormat): void;
    /**
     * Combines the format.
     * @param  {WCharacterFormat} format
     * @hidden
     */
    combineFormat(format: WCharacterFormat): void;
    /**
     * Copies to format.
     * @param  {WCharacterFormat} format
     * @hidden
     */
    copyToFormat(format: WCharacterFormat): void;
    /**
     * Clones the format.
     * @param  {SelectionCharacterFormat} selectionCharacterFormat
     * @returns void
     * @hidden
     */
    cloneFormat(selectionCharacterFormat: SelectionCharacterFormat): void;
    /**
     * Checks whether current format is equal to the source format or not.
     * @param  {SelectionCharacterFormat} format
     * @returns boolean
     * @hidden
     */
    isEqualFormat(format: SelectionCharacterFormat): boolean;
    /**
     * Clears the format.
     * @returns void
     * @hidden
     */
    clearFormat(): void;
    /**
     * Destroys the maintained resources.
     * @returns void
     * @hidden
     */
    destroy(): void;
}
export  class SelectionParagraphFormat {
    private selection;
    private leftIndentIn;
    private rightIndentIn;
    private beforeSpacingIn;
    private afterSpacingIn;
    private textAlignmentIn;
    private firstLineIndentIn;
    private lineSpacingIn;
    private lineSpacingTypeIn;
    listId: number;
    private listLevelNumberIn;
    private viewer;
    /**
     * Gets or Sets the left indent for selected paragraphs.
     * @default undefined
     */
    leftIndent: number;
    /**
     * Gets or Sets the right indent for selected paragraphs.
     * @default undefined
     */
    rightIndent: number;
    /**
     * Gets or Sets the first line indent for selected paragraphs.
     * @default undefined
     */
    firstLineIndent: number;
    /**
     * Gets or Sets the text alignment for selected paragraphs.
     * @default undefined
     */
    textAlignment: WTextAlignment;
    /**
     * Gets or Sets the after spacing for selected paragraphs.
     * @default undefined
     */
    afterSpacing: number;
    /**
     * Gets or Sets the before spacing for selected paragraphs.
     * @default undefined
     */
    beforeSpacing: number;
    /**
     * Gets or Sets the line spacing for selected paragraphs.
     * @default undefined
     */
    lineSpacing: number;
    /**
     * Gets or Sets the line spacing type for selected paragraphs.
     * @default undefined
     */
    lineSpacingType: WLineSpacingType;
    /**
     * Gets or Sets the list level number for selected paragraphs.
     * @default undefined
     */
    listLevelNumber: number;
    constructor(selection: Selection, viewer: LayoutViewer);
    private getPropertyValue(property);
    /**
     * Notifies whenever the property gets changed.
     * @param  {string} propertyName
     */
    private notifyPropertyChanged(propertyName);
    /**
     * Copies the format.
     * @param  {WParagraphFormat} format
     * @returns void
     * @hidden
     */
    copyFormat(format: WParagraphFormat): void;
    /**
     * Copies to format.
     * @param  {WParagraphFormat} format
     * @hidden
     */
    copyToFormat(format: WParagraphFormat): void;
    /**
     * Combines the format.
     * @param  {WParagraphFormat} format
     * @hidden
     */
    combineFormat(format: WParagraphFormat): void;
    /**
     * Clears the format.
     * @returns void
     * @hidden
     */
    clearFormat(): void;
    /**
     * Gets the clone of list at current selection.
     * @returns WList
     */
    getList(): WList;
    /**
     * Modifies the list at current selection.
     * @param  {WList} listAdv
     */
    setList(listAdv: WList): void;
    /**
     * Destroys the managed resources.
     * @returns void
     */
    destroy(): void;
}
export  class SelectionSectionFormat {
    private selection;
    private differentFirstPageIn;
    private differentOddAndEvenPagesIn;
    private headerDistanceIn;
    private footerDistanceIn;
    private pageHeightIn;
    private pageWidthIn;
    private leftMarginIn;
    private topMarginIn;
    private rightMarginIn;
    private bottomMarginIn;
    /**
     * Gets or sets the page height.
     */
    pageHeight: number;
    /**
     * Gets or sets the page width.
     */
    pageWidth: number;
    /**
     * Gets or sets the page left margin.
     */
    leftMargin: number;
    /**
     * Gets or sets the page bottom margin.
     */
    bottomMargin: number;
    /**
     * Gets or sets the page top margin.
     */
    topMargin: number;
    /**
     * Gets or sets the page right margin.
     */
    rightMargin: number;
    /**
     * Gets or sets the header distance.
     */
    headerDistance: number;
    /**
     * Gets or sets the footer distance.
     */
    footerDistance: number;
    /**
     * Gets or sets a value indicating whether the section has different first page.
     */
    differentFirstPage: boolean;
    /**
     * Gets or sets a value indicating whether the section has different odd and even page.
     */
    differentOddAndEvenPages: boolean;
    constructor(selection: Selection);
    /**
     * Copies the format.
     * @param  {WSectionFormat} format
     * @returns void
     * @hidden
     */
    copyFormat(format: WSectionFormat): void;
    private notifyPropertyChanged(propertyName);
    private getPropertyvalue(propertyName);
    /**
     * Combines the format.
     * @param  {WSectionFormat} format
     * @hidden
     */
    combineFormat(format: WSectionFormat): void;
    /**
     * Clears the format.
     * @returns void
     * @hidden
     */
    clearFormat(): void;
    /**
     * Destroys the managed resources.
     * @returns void
     * @hidden
     */
    destroy(): void;
}
export  class SelectionTableFormat {
    private selection;
    private tableIn;
    private leftIndentIn;
    private backgroundIn;
    private tableAlignmentIn;
    private cellSpacingIn;
    private leftMarginIn;
    private rightMarginIn;
    private topMarginIn;
    private bottomMarginIn;
    private preferredWidthIn;
    private preferredWidthTypeIn;
    /**
     * Gets or sets the table.
     * @hidden
     */
    table: TableWidget;
    /**
     * Gets or Sets the left indent for selected table.
     * @hidden
     */
    leftIndent: number;
    /**
     * Gets or Sets the default top margin of cell for selected table.
     * @default undefined
     */
    topMargin: number;
    /**
     * Gets or Sets the background for selected table.
     * @default undefined
     */
    background: string;
    /**
     * Gets or Sets the table alignment for selected table.
     * @default undefined
     */
    tableAlignment: WTableAlignment;
    /**
     * Gets or Sets the default left margin of cell for selected table.
     * @default undefined
     */
    leftMargin: number;
    /**
     * Gets or Sets the default bottom margin of cell for selected table.
     * @default undefined
     */
    bottomMargin: number;
    /**
     * Gets or Sets the cell spacing for selected table.
     * @default undefined
     */
    cellSpacing: number;
    /**
     * Gets or Sets the default right margin of cell for selected table.
     * @default undefined
     */
    rightMargin: number;
    /**
     * Gets or Sets the preferred width for selected table.
     * @default undefined
     */
    preferredWidth: number;
    /**
     * Gets or Sets the preferred width type for selected table.
     * @default undefined
     */
    preferredWidthType: WWidthType;
    constructor(selection: Selection);
    private getPropertyValue(propertyName);
    private notifyPropertyChanged(propertyName);
    /**
     * Copies the format.
     * @param  {WTableFormat} format Format to copy.
     * @returns void
     * @hidden
     */
    copyFormat(format: WTableFormat): void;
    /**
     * Clears the format.
     * @returns void
     * @hidden
     */
    clearFormat(): void;
    /**
     * Destroys the managed resources.
     * @returns void
     * @hidden
     */
    destroy(): void;
}
export  class SelectionCellFormat {
    private selection;
    private verticalAlignmentIn;
    private leftMarginIn;
    private rightMarginIn;
    private topMarginIn;
    private bottomMarginIn;
    private backgroundIn;
    private preferredWidthIn;
    private preferredWidthTypeIn;
    /**
     * Gets or sets the vertical alignment of the selected cells.
     * @default undefined
     */
    verticalAlignment: WCellVerticalAlignment;
    /**
     * Gets or Sets the left margin for selected cells.
     * @default undefined
     */
    leftMargin: number;
    /**
     * Gets or Sets the right margin for selected cells.
     * @default undefined
     */
    rightMargin: number;
    /**
     * Gets or Sets the top margin for selected cells.
     * @default undefined
     */
    topMargin: number;
    /**
     * Gets or Sets the bottom margin for selected cells.
     * @default undefined
     */
    bottomMargin: number;
    /**
     * Gets or Sets the background for selected cells.
     * @default undefined
     */
    background: string;
    /**
     * Gets or Sets the preferred width type for selected cells.
     * @default undefined
     */
    preferredWidthType: WWidthType;
    /**
     * Gets or Sets the preferred width  for selected cells.
     * @default undefined
     */
    preferredWidth: number;
    constructor(selection: Selection);
    private notifyPropertyChanged(propertyName);
    private getPropertyValue(propertyName);
    /**
     * Copies the format.
     * @param  {WCellFormat} format Source Format to copy.
     * @returns void
     * @hidden
     */
    copyFormat(format: WCellFormat): void;
    /**
     * Clears the format.
     * @returns void
     * @hidden
     */
    clearCellFormat(): void;
    /**
     * Combines the format.
     * @param  {WCellFormat} format
     * @hidden
     */
    combineFormat(format: WCellFormat): void;
    /**
     * Clears the format.
     * @returns void
     * @hidden
     */
    clearFormat(): void;
    /**
     * Destroys the manages resources.
     * @returns void
     * @hidden
     */
    destroy(): void;
}
export  class SelectionRowFormat {
    private selection;
    private heightIn;
    private heightTypeIn;
    private isHeaderIn;
    private allowRowBreakAcrossPagesIn;
    /**
     * Gets or Sets the height for selected rows.
     * @default undefined
     */
    height: number;
    /**
     * Gets or Sets the height type for selected rows.
     * @default undefined
     */
    heightType: WHeightType;
    /**
     * Gets or Sets a value indicating whether the selected rows are header rows or not.
     * @default undefined
     */
    isHeader: boolean;
    /**
     * Gets or Sets a value indicating whether to allow break across pages for selected rows.
     * @default undefined
     */
    allowBreakAcrossPages: boolean;
    constructor(selection: Selection);
    private notifyPropertyChanged(propertyName);
    private getPropertyValue(propertyName);
    /**
     * Copies the format.
     * @param  {WRowFormat} format
     * @returns void
     * @hidden
     */
    copyFormat(format: WRowFormat): void;
    /**
     * Combines the format.
     * @param  {WRowFormat} format
     * @hidden
     */
    combineFormat(format: WRowFormat): void;
    /**
     * Clears the row format.
     * @returns void
     * @hidden
     */
    clearRowFormat(): void;
    /**
     * Clears the format.
     * @returns void
     */
    clearFormat(): void;
    /**
     * Destroys the managed resources.
     * @returns void
     */
    destroy(): void;
}
/**
 * Selection
 */
export  class Selection {
    private ownerControlIn;
    /**
     * @hidden
     */
    upDownSelectionLength: number;
    /**
     * @hidden
     */
    isSkipLayouting: boolean;
    /**
     * @hidden
     */
    isImageSelected: boolean;
    private viewer;
    private contextTypeInternal;
    /**
     * @hidden
     */
    isRetrieveFormatting: boolean;
    private characterFormatIn;
    private paragraphFormatIn;
    private sectionFormatIn;
    private tableFormatIn;
    private cellFormatIn;
    private rowFormatIn;
    /**
     * @hidden
     */
    skipFormatRetrieval: boolean;
    private startInternal;
    private endInternal;
    /**
     * @hidden
     */
    editPosition: string;
    /**
     * @hidden
     */
    selectedWidgets: Dictionary<IWidget, SelectionWidgetInfo>;
    /**
     * Gets the start text position of last range in the selection
     * @returns {TextPosition}
     */
    start: TextPosition;
    /**
     * Gets the instance of selection character format.
     * @default undefined
     * @return {SelectionCharacterFormat}
     */
    readonly characterFormat: SelectionCharacterFormat;
    /**
     * Gets the instance of selection paragraph format.
     * @default undefined
     * @return {SelectionParagraphFormat}
     */
    readonly paragraphFormat: SelectionParagraphFormat;
    /**
     * Gets the instance of selection section format.
     * @default undefined
     * @return {SelectionSectionFormat}
     */
    readonly sectionFormat: SelectionSectionFormat;
    /**
     * Gets the instance of selection table format.
     * @default undefined
     * @return {SelectionTableFormat}
     */
    readonly tableFormat: SelectionTableFormat;
    /**
     * Gets the instance of selection cell format.
     * @default undefined
     * @return {SelectionCellFormat}
     */
    readonly cellFormat: SelectionCellFormat;
    /**
     * Gets the instance of selection row format.
     * @default undefined
     * @returns SelectionRowFormat
     */
    readonly rowFormat: SelectionRowFormat;
    /**
     * Gets the start text position of selection range.
     */
    /**
     * For internal use
     * @private
     */
    end: TextPosition;
    /**
     * Determines whether the selection direction is forward or not.
     * @default false
     * @returns {boolean}
     */
    readonly isForward: boolean;
    /**
     * Determines whether the start and end positions are same or not.
     * @default false
     * @returns {boolean}
     */
    readonly isEmpty: boolean;
    /**
     * @hidden
     */
    readonly ownerControl: DocumentEditor;
    /**
     * Gets the text of last range in selection.
     * @default ''
     * @returns {string}
     */
    readonly text: string;
    /**
     * Gets the context type of current selection.
     */
    readonly contextType: string;
    /**
     * @hidden
     */
    readonly isCleared: boolean;
    constructor(documentEditor: DocumentEditor, viewer: LayoutViewer);
    private getModuleName();
    /**
     * Toggles the bold property of selected contents.
     */
    toggleBold(): void;
    /**
     * Toggles the italic property of selected contents.
     */
    toggleItalic(): void;
    /**
     * Toggles the underline property of selected contents.
     * @param underline Default value of ‘underline’ parameter is Single.
     */
    toggleUnderline(underline?: WUnderline): void;
    /**
     * Toggles the strike through property of selected contents.
     * @param {WStrikethrough} strikethrough Default value of strikethrough parameter is SingleStrike.
     */
    toggleStrikethrough(strikethrough?: WStrikethrough): void;
    /**
     * Toggles the highlight color property of selected contents.
     * @param {WHighlightColor} highlightColor Default value of ‘underline’ parameter is Yellow.
     */
    toggleHighlightColor(highlightColor?: WHighlightColor): void;
    /**
     * Toggles the subscript formatting of selected contents.
     */
    toggleSubscript(): void;
    /**
     * Toggles the superscript formatting of selected contents.
     */
    toggleSuperscript(): void;
    /**
     * Toggles the text alignment property of selected contents.
     * @param {WTextAlignment} textAlignment Default value of ‘textAlignment parameter is WTextAlignment.Left.
     */
    toggleTextAlignment(textAlignment: WTextAlignment): void;
    /**
     * Increases the left indent of selected paragraphs to a factor of 36 points.
     */
    increaseIndent(): void;
    /**
     * Decreases the left indent of selected paragraphs to a factor of 36 points.
     */
    decreaseIndent(): void;
    /**
     * Applies the bullet list to current selection
     * @param {string} bullet Bullet character
     * @param {string} fontFamily Bullet font family
     */
    applyBullet(bullet: string, fontFamily: string): void;
    /**
     * Applies the numbering list to current selection.
     * @param numberFormat  “%n” representations in ‘numberFormat’ parameter will be replaced by respective list level’s value.
     * `“%1)” will be displayed as “1)” `
     * @param listLevelPattern  Default value of ‘listLevelPattern’ parameter is WListLevelPattern.Arabic
     */
    applyNumbering(numberFormat: string, listLevelPattern?: WListLevelPattern): void;
    /**
     * Add selection highlight
     * @hidden
     */
    addSelectionHighlight(canvasContext: CanvasRenderingContext2D, widget: LineWidget, top: number): void;
    /**
     * Add Selection highlight inside table
     * @hidden
     */
    addSelectionHighlightTable(canvasContext: CanvasRenderingContext2D, tableCellWidget: TableCellWidget): void;
    /**
     * Clear selection highligh
     * @hidden
     */
    clearSelectionHighlightInternal(widget: IWidget): void;
    /**
     * Remove Selection highlight
     * @hidden
     */
    removeSelectionHighlight(widget: IWidget): void;
    private getTextPosition(hierarchicalIndex);
    /**
     * Update physical location for text position
     * @hidden
     */
    updateSelectionTextPosition(isSelectionChanged: boolean): void;
    /**
     * Get Selected text
     * @hidden
     */
    getText(includeObject: boolean): string;
    /**
     * Get selected text
     * @hidden
     */
    getTextInternal(start: TextPosition, end: TextPosition, includeObject: boolean): string;
    getTextInline(inlineElement: ElementBox, endParagraphWidget: ParagraphWidget, endInline: ElementBox, endIndex: number, includeObject: boolean): string;
    /**
     * Select Current word
     * @hidden
     */
    selectCurrentWord(): void;
    /**
     * Select current paragraph
     * @hidden
     */
    selectCurrentParagraph(): void;
    /**
     * Select current word range
     * @hidden
     */
    selectCurrentWordRange(startPosition: TextPosition, endPosition: TextPosition, excludeSpace: boolean): void;
    /**
     * Extend selection to paragraph start
     * @hidden
     */
    extendToParagraphStart(): void;
    /**
     * Extend selection to paragraph end
     * @hidden
     */
    extendToParagraphEnd(): void;
    /**
     * Move to next text position
     * @hidden
     */
    moveNextPosition(): void;
    /**
     * Move to next paragraph
     * @hidden
     */
    moveToNextParagraph(): void;
    /**
     * Move to previous text position
     * @hidden
     */
    movePreviousPosition(): void;
    /**
     * Move to previous paragraph
     */
    moveToPreviousParagraph(): void;
    /**
     * Extend selection to previous line
     * @hidden
     */
    extendToPreviousLine(): void;
    /**
     * Extend selection to line end
     * @hidden
     */
    extendToLineEnd(): void;
    /**
     * Extend to line start
     * @hidden
     */
    extendToLineStart(): void;
    moveUp(): void;
    moveDown(): void;
    getFirstBlockInFirstCell(table: TableWidget): BlockWidget;
    getFirstCellInRegion(row: TableRowWidget, startCell: TableCellWidget, selectionLength: number, isMovePrevious: boolean): TableCellWidget;
    getFirstParagraph(tableCell: TableCellWidget): ParagraphWidget;
    getPreviousBlock(block: BlockWidget): BlockWidget;
    /**
     * Get previous block
     * @hidden
     */
    getPreviousBlockInSection(section: BodyWidget): BlockWidget;
    /**
     * Get last block in last cell
     * @hidden
     */
    getLastBlockInLastCell(table: TableWidget): BlockWidget;
    /**
     * Select content in given text position
     * @hidden
     */
    selectContent(textPosition: TextPosition, clearMultiSelection: boolean): void;
    /**
     * Move to line start
     * @hidden
     */
    moveToLineStart(): void;
    /**
     * Move to line end
     * @hidden
     */
    moveToLineEnd(): void;
    /**
     * Select paragraph
     * @hidden
     */
    selectInternal(lineWidget: LineWidget, inline: ElementBox, index: number, physicalLocation: Point): void;
    selects(lineWidget: LineWidget, offset: number, skipSelectionChange: boolean): void;
    /**
     * @hidden
     */
    highlightSelection(isSelectionChanged: boolean): void;
    createHighlightBorder(lineWidget: LineWidget, width: number, left: number, top: number): void;
    /**
     * Create selection highlight inside table
     * @hidden
     */
    createHighlightBorderInsideTable(cellWidget: TableCellWidget): void;
    /**
     * @hidden
     */
    clipSelection(page: Page, pageTop: number): void;
    /**
     * Get Page top
     * @hidden
     */
    getPageTop(page: Page): number;
    /**
     * Move text position to cursor point
     * @hidden
     */
    moveTextPosition(cursorPoint: Point, textPosition: TextPosition, viewer: LayoutViewer): void;
    /**
     * Get document start position
     * @hidden
     */
    getDocumentStart(): TextPosition;
    /**
     * Get document end position
     * @hidden
     */
    getDocumentEnd(): TextPosition;
    /**
     * Select content between start and end position
     * @hidden
     */
    selectPosition(startPosition: TextPosition, endPosition: TextPosition): void;
    /**
     * @hidden
     * Handles control end key.
     */
    handleControlEndKey(): void;
    /**
     * @hidden
     * Handles control home key.
     */
    handleControlHomeKey(): void;
    /**
     * @hidden
     * Handles control left key.
     */
    handleControlLeftKey(): void;
    /**
     * @hidden
     * Handles control right key.
     */
    handleControlRightKey(): void;
    /**
     * Handles control down key.
     * @hidden
     */
    handleControlDownKey(): void;
    /**
     * Handles control up key.
     * @hidden
     */
    handleControlUpKey(): void;
    /**
     * @hidden
     * Handles shift left key.
     */
    handleShiftLeftKey(): void;
    /**
     * Handles shift up key.
     */
    handleShiftUpKey(): void;
    /**
     * Handles shift right key.
     * @hidden
     */
    handleShiftRightKey(): void;
    /**
     * Handles shift down key.
     * @hidden
     */
    handleShiftDownKey(): void;
    /**
     * @hidden
     * Handles control shift left key.
     */
    handleControlShiftLeftKey(): void;
    /**
     * Handles control shift up key.
     */
    handleControlShiftUpKey(): void;
    /**
     * Handles control shift right key
     * @hidden
     */
    handleControlShiftRightKey(): void;
    /**
     * Handles control shift down key.
     * @hidden
     */
    handleControlShiftDownKey(): void;
    /**
     * Handles left key.
     * @hidden
     */
    handleLeftKey(): void;
    /**
     * Handles up key.
     * @hidden
     */
    handleUpKey(): void;
    /**
     * Handles right key.
     * @hidden
     */
    handleRightKey(): void;
    /**
     * Handles end key.
     * @hidden
     */
    handleEndKey(): void;
    /**
     * Handles home key.
     * @hidden
     */
    handleHomeKey(): void;
    /**
     * Handles down key.
     * @hidden
     */
    handleDownKey(): void;
    /**
     * Handles shift end key.
     * @hidden
     */
    handleShiftEndKey(): void;
    /**
     * Handles shift home key.
     * @hidden
     */
    handleShiftHomeKey(): void;
    /**
     * Handles control shift end key.
     * @hidden
     */
    handleControlShiftEndKey(): void;
    /**
     * Handles control shift home key.
     * @hidden
     */
    handleControlShiftHomeKey(): void;
    /**
     * Handles tab key.
     * @param isNavigateInCell
     * @param isShiftTab
     * @hidden
     */
    handleTabKey(isNavigateInCell: boolean, isShiftTab: boolean): void;
    private selectPreviousCell();
    private selectNextCell();
    /**
     * Select given table cell
     * @hidden
     */
    selectTableCellInternal(tableCell: TableCellWidget, clearMultiSelection: boolean): void;
    /**
     * @hidden
     * Selects the entire document.
     */
    selectAll(): void;
    /**
     * Extend selection backward
     * @hidden
     */
    extendBackward(): void;
    /**
     * Extent selection forward
     * @hidden
     */
    extendForward(): void;
    /**
     * Extend selection to word start and end
     * @hidden
     */
    extendToWordStartEnd(): boolean;
    /**
     * Extend selection to word start
     * @hidden
     */
    extendToWordStart(isNavigation: boolean): void;
    /**
     * Extent selection to word end
     * @hidden
     */
    extendToWordEnd(isNavigation: boolean): void;
    /**
     * Extend selection to next line
     * @hidden
     */
    extendToNextLine(): void;
    /**
     * Get next paragraph
     * @hidden
     */
    getNextParagraph(section: BodyWidget): ParagraphWidget;
    /**
     * @hidden
     */
    getPreviousParagraph(section: BodyWidget): ParagraphWidget;
    /**
     * Get container table
     * @hidden
     */
    getContainerTable(block: BlockWidget): TableWidget;
    /**
     * @hidden
     */
    isExistBefore(start: BlockWidget, block: BlockWidget): boolean;
    /**
     * @hidden
     */
    isExistAfter(start: BlockWidget, block: BlockWidget): boolean;
    /**
     * Get next rendered block
     * @hidden
     */
    getNextRenderedBlock(block: BlockWidget): BlockWidget;
    /**
     * Get next rendered block
     * @hidden
     */
    getPreviousRenderedBlock(block: BlockWidget): BlockWidget;
    /**
     * Get Next paragraph in block
     * @hidden
     */
    getNextParagraphBlock(block: BlockWidget): ParagraphWidget;
    /**
     * Get previous paragraph in block
     * @hidden
     */
    getPreviousParagraphBlock(block: BlockWidget): ParagraphWidget;
    /**
     * Get first paragraph in block
     * @hidden
     */
    getFirstParagraphBlock(block: BlockWidget): ParagraphWidget;
    /**
     * Return true if paragraph has valid inline
     * @hidden
     */
    hasValidInline(paragraph: ParagraphWidget, start: ElementBox, end: ElementBox): boolean;
    /**
     * Get paragraph length
     * @hidden
     */
    getLength(paragraph: ParagraphWidget): number;
    /**
     * Get Line length
     * @hidden
     */
    getLineLength(lineWidget: LineWidget): number;
    /**
     * Get paragraph start offset
     * @hidden
     */
    getStartOffset(paragraph: ParagraphWidget): number;
    getStartLineOffset(line: LineWidget): number;
    /**
     * Get previous paragraph from selection
     * @hidden
     */
    getPreviousSelectionCell(cell: TableCellWidget): ParagraphWidget;
    /**
     * Get previous paragraph selection in selection
     * @hidden
     */
    getPreviousSelectionRow(row: TableRowWidget): ParagraphWidget;
    /**
     * @hidden
     */
    getNextSelectionBlock(block: BlockWidget): ParagraphWidget;
    /**
     * Get next paragraph from selected cell
     * @hidden
     */
    getNextSelectionCell(cell: TableCellWidget): ParagraphWidget;
    /**
     * Get next paragraph in selection
     * @hidden
     */
    getNextSelectionRow(row: TableRowWidget): ParagraphWidget;
    /**
     * Get next block with selection
     * @hidden
     */
    getNextSelection(section: BodyWidget): ParagraphWidget;
    /**
     * @hidden
     */
    getNextParagraphSelection(row: TableRowWidget): ParagraphWidget;
    /**
     * @hidden
     */
    getPreviousSelectionBlock(block: BlockWidget): ParagraphWidget;
    /**
     * Get previous paragraph in selection
     * @hidden
     */
    getPreviousSelection(section: BodyWidget): ParagraphWidget;
    /**
     * @hidden
     */
    getPreviousParagraphSelection(row: TableRowWidget): ParagraphWidget;
    /**
     * Get last cell in the selected region
     * @hidden
     */
    getLastCellInRegion(row: TableRowWidget, startCell: TableCellWidget, selLength: number, isMovePrev: boolean): TableCellWidget;
    /**
     * Get Container table
     *  @hidden
     */
    getCellInTable(table: TableWidget, tableCell: TableCellWidget): TableCellWidget;
    /**
     * Get first paragraph in last row
     * @hidden
     */
    getFirstParagraphInLastRow(table: TableWidget): ParagraphWidget;
    /**
     * Get previous valid offset
     * @hidden
     */
    getPreviousValidOffset(paragraph: ParagraphWidget, offset: number): number;
    /**
     * Get next valid offset
     * @hidden
     */
    getNextValidOffset(line: LineWidget, offset: number): number;
    /**
     * Get paragraph mark size info
     * @hidden
     */
    getParagraphMarkSize(paragraph: ParagraphWidget, topMargin: number, bottomMargin: number): SizeInfo;
    /**
     * @hidden
     */
    getPhysicalPositionInternal(line: LineWidget, offset: number, moveNextLine: boolean): Point;
    /**
     * Get Next start inline
     * @hidden
     */
    getNextStartInline(line: LineWidget, offset: number): ElementBox;
    /**
     * Get previous text inline
     * @hidden
     */
    getPreviousTextInline(inline: ElementBox): ElementBox;
    /**
     * Get next text inline
     * hidden
     */
    getNextTextInline(inline: ElementBox): ElementBox;
    /**
     * Highlight selected content
     * hidden
     */
    highlightSelectedContent(paragraph: ParagraphWidget, start: TextPosition, end: TextPosition): void;
    highlight(paragraph: ParagraphWidget, start: TextPosition, end: TextPosition): void;
    /**
     * Get start line widget
     * @hidden
     */
    getStartLineWidget(paragraph: ParagraphWidget, start: TextPosition, startElement: ElementBox, selectionStartIndex: number): LineWidgetInfo;
    /**
     * Get end line widget
     * @hidden
     */
    getEndLineWidget(end: TextPosition, endElement: ElementBox, selectionEndIndex: number): LineWidgetInfo;
    /**
     * Get line widget
     * @hidden
     */
    getLineWidgetInternal(line: LineWidget, offset: number, moveToNextLine: boolean): LineWidget;
    /**
     * Get last line widget
     * @hidden
     */
    getLineWidgetParagraph(offset: number, line: LineWidget): LineWidget;
    /**
     * Get last paragraph in last cell
     * @hidden
     */
    getLastParagraphInLastCell(table: TableWidget): ParagraphWidget;
    /**
     * Get last paragraph in first row
     * @hidden
     */
    getLastParagraphInFirstRow(table: TableWidget): ParagraphWidget;
    /**
     * Highlight selected cell
     * @hidden
     */
    highlightCells(table: TableWidget, startCell: TableCellWidget, endCell: TableCellWidget): void;
    /**
     * highlight selected table
     * @hidden
     */
    highlightTable(table: TableWidget, start: TextPosition, end: TextPosition): void;
    /**
     * Get cell left
     * @hidden
     */
    getCellLeft(row: TableRowWidget, cell: TableCellWidget): number;
    /**
     * Get next paragraph for row
     * @hidden
     */
    getNextParagraphRow(row: BlockWidget): ParagraphWidget;
    /**
     * Get previous paragraph from row
     * @hidden
     */
    getPreviousParagraphRow(row: TableRowWidget): ParagraphWidget;
    /**
     * Return true if row contain cell
     * @hidden
     */
    containsRow(row: TableRowWidget, tableCell: TableCellWidget): boolean;
    /**
     * Highlight selected row
     * @hidden
     */
    highlightRow(row: TableRowWidget, start: number, end: number): void;
    /**
     * @hidden
     */
    highlightInternal(row: TableRowWidget, start: TextPosition, end: TextPosition): void;
    /**
     * Get last paragraph in cell
     * @hidden
     */
    getLastParagraph(cell: TableCellWidget): ParagraphWidget;
    /**
     * Return true is source cell contain cell
     * @hidden
     */
    containsCell(sourceCell: TableCellWidget, cell: TableCellWidget): boolean;
    /**
     * Return true if cell is selected
     * @hidden
     */
    isCellSelected(cell: TableCellWidget, startPosition: TextPosition, endPosition: TextPosition): boolean;
    /**
     * Return Container cell
     * @hidden
     */
    getContainerCellOf(cell: TableCellWidget, tableCell: TableCellWidget): TableCellWidget;
    /**
     * Get Selected cell
     * @hidden
     */
    getSelectedCell(cell: TableCellWidget, containerCell: TableCellWidget): TableCellWidget;
    /**
     * Get Next paragraph from cell
     * @hidden
     */
    getNextParagraphCell(cell: TableCellWidget): ParagraphWidget;
    /**
     * Get previous paragraph from cell
     * @hidden
     */
    getPreviousParagraphCell(cell: TableCellWidget): ParagraphWidget;
    /**
     * Get cell's container cell
     * @hidden
     */
    getContainerCell(cell: TableCellWidget): TableCellWidget;
    /**
     * Highlight selected cell
     * @hidden
     */
    highlightCell(cell: TableCellWidget, selection: Selection, start: TextPosition, end: TextPosition): void;
    /**
     * @hidden
     */
    highlightInternalCell(cell: TableCellWidget): void;
    /**
     * @hidden
     */
    highlightContainer(cell: TableCellWidget, start: TextPosition, end: TextPosition): void;
    /**
     * Get previous valid inline
     * @hidden
     */
    getPreviousValidInline(inline: ElementBox): ElementBox;
    /**
     * Get next valid inline
     * @hidden
     */
    getNextValidInline(inline: ElementBox): ElementBox;
    /**
     * Return next valid inline with index
     * @hidden
     */
    validateTextPosition(inline: ElementBox, index: number): ElementInfo;
    /**
     * Get inline physical location
     * @hidden
     */
    getPhysicalPositionInline(inline: ElementBox, index: number, moveNextLine: boolean): Point;
    /**
     * Get field character position
     * @hidden
     */
    getFieldCharacterPosition(firstInline: ElementBox): Point;
    private getNextValidElementForField(firstInline);
    /**
     * Get paragraph end position
     * @hidden
     */
    getEndPosition(widget: ParagraphWidget): Point;
    /**
     * Get element box
     * @hidden
     */
    getElementBox(currentInline: ElementBox, index: number, moveToNextLine: boolean): ElementBoxInfo;
    getPreviousTextElement(inline: ElementBox): ElementBox;
    /**
     * Get next text inline
     * hidden
     */
    getNextTextElement(inline: ElementBox): ElementBox;
    getNextRenderedElementBox(inline: ElementBox, indexInInline: number): ElementBox;
    /**
     * hidden
     */
    getElementBoxInternal(inline: ElementBox, index: number): ElementBoxInfo;
    /**
     * Get Line widget
     * @hidden
     */
    getLineWidget(inline: ElementBox, index: number): LineWidget;
    /**
     * @hidden
     */
    getLineWidgetInternalInline(inline: ElementBox, index: number, moveToNextLine: boolean): LineWidget;
    /**
     * Get next line widget
     * @hidden
     */
    private getNextLineWidget(paragraph, element);
    /**
     * Get Caret height
     * @hidden
     */
    getCaretHeight(inline: ElementBox, index: number, format: WCharacterFormat, isEmptySelection: boolean, topMargin: number, isItalic: boolean): CaretHeightInfo;
    /**
     * Get field characters height
     * @hidden
     */
    getFieldCharacterHeight(startInline: FieldElementBox, format: WCharacterFormat, isEmptySelection: boolean, topMargin: number, isItalic: boolean): CaretHeightInfo;
    /**
     * Get rendered inline
     * @hidden
     */
    getRenderedInline(inline: FieldElementBox, inlineIndex: number): ElementInfo;
    /**
     * Get rendered field
     * @hidden2568/2919
     */
    getRenderedField(fieldBegin: FieldElementBox): FieldElementBox;
    /**
     * Return true is inline is tha last inline
     * @hidden
     */
    isLastRenderedInline(inline: ElementBox, index: number): boolean;
    /**
     * Get page
     * @hidden
     */
    getPage(widget: Widget): Page;
    /**
     * Clear Selection highlight
     * @hidden
     */
    clearSelectionHighlightInSelectedWidgets(): boolean;
    /**
     * Clear selection highlight
     * @hidden
     */
    clearChildSelectionHighlight(widget: Widget): void;
    /**
     * Get line widget from paragraph widget
     * @hidden
     */
    getLineWidgetBodyWidget(widget: Widget, point: Point): LineWidget;
    /**
     * Get line widget from paragraph widget
     * @hidden
     */
    getLineWidgetParaWidget(widget: ParagraphWidget, point: Point): LineWidget;
    /**
     * highlight paragraph widget
     * @hidden
     */
    highlightParagraphWidget(widget: ParagraphWidget, startIndex: number, endLine: LineWidget, endElement: ElementBox, endIndex: number): void;
    /**
     * Get line widget form table widget
     * @hidden
     */
    getLineWidgetTableWidget(widget: TableWidget, point: Point): LineWidget;
    /**
     * Get line widget fom row
     * @hidden
     */
    getLineWidgetRowWidget(widget: TableRowWidget, point: Point): LineWidget;
    getFirstBlock(cell: TableCellWidget): BlockWidget;
    /**
     * Highlight selected cell widget
     * @hidden
     */
    highlightCellWidget(widget: TableCellWidget): void;
    /**
     * Clear selection highlight
     * @hidden
     */
    clearSelectionHighlight(widget: TableCellWidget): void;
    /**
     * Get line widget from cell widget
     * @hidden
     */
    getLineWidgetCellWidget(widget: TableCellWidget, point: Point): LineWidget;
    /**
     * update text position
     * @hidden
     */
    updateTextPosition(viewer: LayoutViewer, widget: LineWidget, documentEditor: DocumentEditor, point: Point): void;
    updateTextPositionIn(viewer: LayoutViewer, widget: LineWidget, rte: DocumentEditor, inline: ElementBox, index: number, caretPosition: Point, includeParagraphMark: boolean): TextPositionInfo;
    /**
     * Get text length if the line widget
     * @hidden
     */
    getTextLength(viewer: LayoutViewer, widget: LineWidget, element: ElementBox): number;
    /**
     * Get Line widget left
     * @hidden
     */
    getLeft(widget: LineWidget): number;
    /**
     * Get line widget top
     * @hidden
     */
    getTop(widget: LineWidget): number;
    /**
     * Get first element the widget
     * @hidden
     */
    getFirstElement(widget: LineWidget, left: number): FirstElementInfo;
    /**
     * Return true if widget is first inline of paragraph
     * @hidden
     */
    isParagraphFirstLine(widget: LineWidget): boolean;
    /**
     * Return line widget width
     * @hidden
     */
    getWidth(widget: LineWidget, includeParagraphMark: boolean): number;
    /**
     * Return line widget left
     * @hidden
     */
    getLeftInternal(widget: LineWidget, elementBox: ElementBox, index: number): number;
    /**
     * Return line widget start offset
     * @hidden
     */
    getLineStartLeft(widget: LineWidget): number;
    /**
     * Update text position
     * @hidden
     */
    updateTextPositionWidget(widget: LineWidget, rte: DocumentEditor, point: Point, textPosition: TextPosition, includeParagraphMark: boolean): void;
    /**
     * Clear selection highlight
     * @hidden
     */
    clearSelectionHighlightLineWidget(widget: LineWidget): void;
    /**
     * Return first element from line widget
     * @hidden
     */
    getFirstElementInternal(widget: LineWidget): ElementBox;
    /**
     * Return inline index
     * @hidden
     */
    getIndexInInline(elementBox: ElementBox): number;
    /**
     * Select content between given range
     * @hidden
     */
    selectRange(startPosition: TextPosition, endPosition: TextPosition): void;
    /**
     * Selects current paragraph
     * @hidden
     */
    selectParagraph(paragraph: ParagraphWidget, positionAtStart: boolean): void;
    /**
     * Notify selection change event
     * @hidden
     */
    fireSelectionChanged(isSelectionChanged: boolean): void;
    /**
     * Retrieve all current selection format
     * @hidden
     */
    retrieveCurrentFormatProperties(): void;
    /**
     * Retrieve selection table format
     * @hidden
     */
    retrieveTableFormat(start: TextPosition, end: TextPosition): void;
    /**
     * Retrieve selection cell format
     * @hidden
     */
    retrieveCellFormat(start: TextPosition, end: TextPosition): void;
    /**
     * Retrieve selection row format
     * @hidden
     */
    retrieveRowFormat(start: TextPosition, end: TextPosition): void;
    /**
     * Get selected cell format
     * @hidden
     */
    getCellFormat(table: TableWidget, start: TextPosition, end: TextPosition): void;
    /**
     * Get selected row format
     * @hidden
     */
    getRowFormat(table: TableWidget, start: TextPosition, end: TextPosition): void;
    /**
     * Return table with given text position
     * @hidden
     */
    getTable(startPosition: TextPosition, endPosition: TextPosition): TableWidget;
    private getContainerWidget(block);
    /**
     * Retrieve selection section format
     * @hidden
     */
    retrieveSectionFormat(start: TextPosition, end: TextPosition): void;
    /**
     * Retrieve selection paragraph format
     * @hidden
     */
    retrieveParagraphFormat(start: TextPosition, end: TextPosition): void;
    /**
     * @hidden
     */
    getParagraphFormatForSelection(paragraph: ParagraphWidget, selection: Selection, start: TextPosition, end: TextPosition): void;
    /**
     * @hidden
     */
    getParagraphFormatInternalInParagraph(paragraph: ParagraphWidget, start: TextPosition, end: TextPosition): void;
    /**
     * @hidden
     */
    getParagraphFormatInternalInBlock(block: BlockWidget, start: TextPosition, end: TextPosition): void;
    /**
     * @hidden
     */
    getParagraphFormatInternalInTable(table: TableWidget, start: TextPosition, end: TextPosition): void;
    /**
     * Get paragraph format in cell
     * @hidden
     */
    getParagraphFormatInCell(cell: TableCellWidget): void;
    /**
     * @hidden
     */
    getParagraphFormatInBlock(block: BlockWidget): void;
    /**
     * @hidden
     */
    getParagraphFormatInTable(tableAdv: TableWidget): void;
    /**
     * @hidden
     */
    getParagraphFormatInParagraph(paragraph: ParagraphWidget): void;
    /**
     * Get paragraph format in cell
     * @hidden
     */
    getParagraphFormatInternalInCell(cellAdv: TableCellWidget, start: TextPosition, end: TextPosition): void;
    /**
     * @hidden
     */
    getParaFormatForCell(table: TableWidget, startCell: TableCellWidget, endCell: TableCellWidget): void;
    /**
     * Get paragraph format ins row
     * @hidden
     */
    getParagraphFormatInRow(tableRow: TableRowWidget, start: TextPosition, end: TextPosition): void;
    /**
     * Retrieve Selection character format
     * @hidden
     */
    retrieveCharacterFormat(start: TextPosition, end: TextPosition): void;
    /**
     * @hidden
     */
    getCharacterFormatForSelection(paragraph: ParagraphWidget, selection: Selection, startPosition: TextPosition, endPosition: TextPosition): void;
    /**
     * Get Character format
     * @hidden
     */
    getCharacterFormatForTableRow(tableRowAdv: TableRowWidget, start: TextPosition, end: TextPosition): void;
    /**
     * Get Character format in table
     * @hidden
     */
    getCharacterFormatInTableCell(tableCell: TableCellWidget, selection: Selection, start: TextPosition, end: TextPosition): void;
    /**
     * @hidden
     */
    getCharacterFormatInternalInTable(table: TableWidget, startCell: TableCellWidget, endCell: TableCellWidget, startPosition: TextPosition, endPosition: TextPosition): void;
    /**
     * Get character format with in selection
     * @hidden
     */
    getCharacterFormat(paragraph: ParagraphWidget, start: TextPosition, end: TextPosition): void;
    private setCharacterFormat(para, startPos, endPos, length);
    /**
     * @hidden
     */
    getCharacterFormatForBlock(block: BlockWidget, start: TextPosition, end: TextPosition): void;
    /**
     * @hidden
     */
    getCharacterFormatInTable(table: TableWidget, start: TextPosition, end: TextPosition): void;
    /**
     * Get character format in selection
     * @hidden
     */
    getCharacterFormatForSelectionCell(cell: TableCellWidget, start: TextPosition, end: TextPosition): void;
    /**
     * @hidden
     */
    getCharacterFormatInternal(paragraph: ParagraphWidget, selection: Selection): void;
    /**
     * Get next valid character format from inline
     * @hidden
     */
    getNextValidCharacterFormat(inline: ElementBox): WCharacterFormat;
    /**
     * Get next valid paragraph format from field
     * @hidden
     */
    getNextValidCharacterFormatOfField(fieldBegin: FieldElementBox): WCharacterFormat;
    /**
     * Return true if cursor point with in selection range
     * @hidden
     */
    checkCursorIsInSelection(widget: IWidget, point: Point): boolean;
    /**
     * Copy character format to selection character format
     * @hidden
     */
    copySelectionCharacterFormat(): WCharacterFormat;
    /**
     * Copy paragarph for to selection paragraph format
     * @hidden
     */
    copySelectionParagraphFormat(): WParagraphFormat;
    /**
     * Inserts the image with specified size at cursor position in the document editor.
     * @param {string} imageString  Base64 string, web URL or file URL as valid.
     * @param {number} width? Image width
     * @param {number} height? Image width
     */
    insertImage(imageString: string, width?: number, height?: number): void;
    /**
     * @hidden
     */
    destroy(): void;
}
export  class TextPosition {
    /**
     * @hidden
     */
    currentWidget: LineWidget;
    /**
     * @hidden
     */
    offset: number;
    /**
     * @hidden
     */
    ownerControl: DocumentEditor;
    /**
     * @hidden
     */
    location: Point;
    private viewer;
    /**
     * @hidden
     */
    isUpdateLocation: boolean;
    /**
     * @hidden
     */
    readonly paragraph: ParagraphWidget;
    /**
     * @hidden
     */
    readonly isAtParagraphStart: boolean;
    /**
     * @hidden
     */
    readonly selection: Selection;
    /**
     * Gets the hierarchical position of logical text position in the document
     * @returns {string}
     */
    readonly hierarchicalPosition: string;
    constructor(owner: DocumentEditor, viewer: LayoutViewer);
    /**
     * Return clone of current text position
     * @hidden
     */
    clone(): TextPosition;
    /**
     * Set text position for paragraph and inline
     * @hidden
     */
    setPositionForSelection(line: LineWidget, inline: ElementBox, index: number, physicalLocation: Point): void;
    /**
     * Set text position
     * @hidden
     */
    setPosition(line: LineWidget, positionAtStart: boolean): void;
    /**
     * Set position for text position
     * @hidden
     */
    setPositionInternal(textPosition: TextPosition): void;
    /**
     * Set position for current index
     * @hidden
     */
    setPositionForCurrentIndex(hierarchicalIndex: string): void;
    getParagraphWidget(position: IndexInfo): LineWidget;
    getLineWidget(widget: Widget, position: IndexInfo, page?: Page): LineWidget;
    /**
     * update physical location for field
     * @hidden
     */
    updateTextPositionOnFieldCharacter(startPosition: TextPosition): void;
    /**
     * Update physical location of paragraph
     * @hidden
     */
    updatePhysicalPosition(moveNextLine: boolean): void;
    /**
     * Return true if text position are in same paragraph and offset
     * @hidden
     */
    isAtSamePosition(textPosition: TextPosition): boolean;
    /**
     * Return true if text position is in same paragraph
     * @hidden
     */
    isInSameParagraph(textPosition: TextPosition): boolean;
    /**
     * Return true is current text position exist before given text position
     * @hidden
     */
    isExistBefore(textPosition: TextPosition): boolean;
    /**
     * Return true is current text position exist after given text position
     * @hidden
     */
    isExistAfter(textPosition: TextPosition): boolean;
    /**
     * Return hierarchical index of current text position
     * @hidden
     */
    getHierarchicalIndexInternal(): string;
    getHierarchicalIndex(line: LineWidget, hierarchicalIndex: string): string;
    setPositionParagraph(line: LineWidget, offsetInLine: number): void;
    setPositionForLineWidget(lineWidget: LineWidget, offset: number): void;
    /**
     * move to next text position
     * @hidden
     */
    moveNextPosition(): void;
    /**
     * Move text position to previous paragraph inside table
     * @hidden
     */
    moveToPreviousParagraphInTable(selection: Selection): void;
    private updateOffsetToNextParagraph(indexInInline, isHighlight);
    private updateOffsetToPrevPosition(index, isHighlight);
    /**
     * Moves the text position to start of the next paragraph.
     */
    moveToNextParagraphStartInternal(selection: Selection): void;
    /**
     * Move to previous position
     * @hidden
     */
    movePreviousPosition(): void;
    /**
     * Move to next position
     * @hidden
     */
    moveNextPositionInternal(fieldBegin: FieldElementBox): void;
    /**
     * Move text position backward
     * @hidden
     */
    moveBackward(): void;
    /**
     * Move text position forward
     * @hidden
     */
    moveForward(): void;
    /**
     * Move to given inline
     * @hidden
     */
    moveToInline(inline: ElementBox, index: number): void;
    /**
     * Return true is start element exist before end element
     * @hidden
     */
    static isForwardSelection(start: string, end: string): boolean;
    /**
     * Move to previous position offset
     * @hidden
     */
    movePreviousPositionInternal(fieldEnd: FieldElementBox): void;
    /**
     * Moves the text position to start of the word.
     * @hidden
     */
    moveToWordStartInternal(type: number, selection: Selection): void;
    /**
     * Get next word offset
     * @hidden
     */
    getNextWordOffset(inline: ElementBox, indexInInline: number, type: number, isInField: boolean, endSelection: boolean, endPosition: TextPosition, excludeSpace: boolean): void;
    /**
     * get next word offset from field begin
     * @hidden
     */
    getNextWordOffsetFieldBegin(fieldBegin: FieldElementBox, indexInInline: number, type: number, isInField: boolean, endSelection: boolean, endPosition: TextPosition, excludeSpace: boolean): void;
    /**
     * get next word offset from image
     * @hidden
     */
    getNextWordOffsetImage(image: ImageElementBox, indexInInline: number, type: number, isInField: boolean, endSelection: boolean, endPosition: TextPosition, excludeSpace: boolean): void;
    /**
     * get next word offset from span
     * @hidden
     */
    getNextWordOffsetSpan(span: TextElementBox, indexInInline: number, type: number, isInField: boolean, endSelection: boolean, endPosition: TextPosition, excludeSpace: boolean): void;
    /**
     * get next word offset from field separator
     * @hidden
     */
    getNextWordOffsetFieldSeperator(fieldSeparator: FieldElementBox, indexInInline: number, type: number, isInField: boolean, endSelection: boolean, endPosition: TextPosition, excludeSpace: boolean): void;
    /**
     * get next word offset from field end
     * @hidden
     */
    getNextWordOffsetFieldEnd(fieldEnd: FieldElementBox, indexInInline: number, type: number, isInField: boolean, endSelection: boolean, endPosition: TextPosition, excludeSpace: boolean): void;
    /**
     * Get previous word offset
     * @hidden
     */
    getPreviousWordOffset(inline: ElementBox, selection: Selection, indexInInline: number, type: number, isInField: boolean, isStarted: boolean, endSelection: boolean, endPosition: TextPosition): void;
    /**
     * get previous word offset from field end
     * @hidden
     */
    getPreviousWordOffsetFieldEnd(fieldEnd: FieldElementBox, selection: Selection, indexInInline: number, type: number, isInField: boolean, isStarted: boolean, endSelection: boolean, endPosition: TextPosition): void;
    /**
     * get previous word offset from field separator
     * @hidden
     */
    getPreviousWordOffsetFieldSeparator(fieldSeparator: FieldElementBox, selection: Selection, indexInInline: number, type: number, isInField: boolean, isStarted: boolean, endSelection: boolean, endPosition: TextPosition): void;
    /**
     * get previous word offset from field begin
     * @hidden
     */
    getPreviousWordOffsetFieldBegin(fieldBegin: FieldElementBox, selection: Selection, indexInInline: number, type: number, isInField: boolean, isStarted: boolean, endSelection: boolean, endPosition: TextPosition): void;
    /**
     * get previous word offset from image
     * @hidden
     */
    getPreviousWordOffsetImage(image: ImageElementBox, selection: Selection, indexInInline: number, type: number, isInField: boolean, isStarted: boolean, endSelection: boolean, endPosition: TextPosition): void;
    /**
     * Get previous word offset from span
     * @hidden
     */
    getPreviousWordOffsetSpan(span: TextElementBox, selection: Selection, indexInInline: number, type: number, isInField: boolean, isStarted: boolean, endSelection: boolean, endPosition: TextPosition): void;
    /**
     * set previous word offset in span
     * @hidden
     */
    private setPreviousWordOffset(span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
    /**
     * Validate if text position is in field forward
     * @hidden
     */
    validateForwardFieldSelection(currentIndex: string, selectionEndIndex: string): void;
    /**
     * Validate if text position is in field backward
     * @hidden
     */
    validateBackwardFieldSelection(currentIndex: string, selectionEndIndex: string): void;
    paragraphStartInternal(selection: Selection, moveToPreviousParagraph: boolean): void;
    calculateOffset(): void;
    /**
     * Moves the text position to end of the paragraph.
     * @hidden
     */
    moveToParagraphEndInternal(selection: Selection, moveToNextParagraph: boolean): void;
    moveUp(selection: Selection, left: number): void;
    moveDown(selection: Selection, left: number): void;
    /**
     * Moves the text position to start of the line.
     * @hidden
     */
    moveToLineStartInternal(selection: Selection, moveToPreviousLine: boolean): void;
    /**
     * Check paragraph is inside table
     * @hidden
     */
    moveToNextParagraphInTableCheck(): boolean;
    /**
     * Moves the text position to end of the word.
     * @hidden
     */
    moveToWordEndInternal(type: number, excludeSpace: boolean): void;
    /**
     * move text position to next paragraph inside table
     * @hidden
     */
    moveToNextParagraphInTable(): void;
    /**
     * Moves the text position to start of the previous paragraph.
     */
    moveToPreviousParagraph(selection: Selection): void;
    /**
     * Move to previous line from current position
     * @hidden
     */
    moveToPreviousLine(selection: Selection, left: number): void;
    moveToLineEndInternal(selection: Selection, moveToNextLine: boolean): void;
    /**
     * Move to next line
     * @hidden
     */
    moveToNextLine(selection: Selection, left: number): void;
    /**
     * Move upward in table
     * @hidden
     */
    private moveUpInTable(selection);
    /**
     * Move down inside table
     * @hidden
     */
    private moveDownInTable(selection);
    /**
     * @hidden
     */
    destroy(): void;
}
export  class SelectionWidgetInfo {
    private leftIn;
    private widthIn;
    left: number;
    width: number;
    constructor(left: number, width: number);
    destroy(): void;
}
/**
 * Specifies TextSize Info
 */
export interface TextSizeInfo {
    Height?: number;
    BaselineOffset?: number;
    Width?: number;
}
export interface TextHeightInfo {
    [key: string]: TextSizeInfo;
}
/**
 * Text Helper class
 */
export  class TextHelper {
    private owner;
    private context;
    private readonly paragraphMark;
    private readonly lineBreakMark;
    constructor(viewer: LayoutViewer);
    /**
     * @hidden
     */
    getParagraphMarkWidth(characterFormat: WCharacterFormat): number;
    /**
     * @hidden
     */
    getParagraphMarkSize(characterFormat: WCharacterFormat): TextSizeInfo;
    /**
     * @hidden
     */
    getTextSize(elementBox: TextElementBox, characterFormat: WCharacterFormat): void;
    /**
     * @hidden
     */
    getHeight(characterFormat: WCharacterFormat): TextSizeInfo;
    /**
     * @hidden
     */
    getFormatText(characterFormat: WCharacterFormat): string;
    /**
     * @hidden
     */
    getHeightInternal(characterFormat: WCharacterFormat): TextSizeInfo;
    /**
     * @hidden
     */
    measureTextExcludingSpaceAtEnd(text: string, characterFormat: WCharacterFormat): number;
    /**
     * @hidden
     */
    getWidth(text: string, characterFormat: WCharacterFormat): number;
    /**
     * @hidden
     */
    applyStyle(spanElement: HTMLSpanElement, characterFormat: WCharacterFormat): void;
    /**
     * @hidden
     */
    measureText(text: string, characterFormat: WCharacterFormat): TextSizeInfo;
    /**
     * @hidden
     */
    updateTextSize(elementBox: ListTextElementBox): void;
    destroy(): void;
}
/**
 * LayoutViewer class
 */
export  abstract class LayoutViewer {
    ownerControl: DocumentEditor;
    private visibleBoundsIn;
    pageContainer: HTMLElement;
    viewerContainer: HTMLElement;
    pages: Page[];
    clientActiveArea: Rect;
    clientArea: Rect;
    isFieldCode: boolean;
    textWrap: boolean;
    currentPage: Page;
    private selectionStartPageIn;
    private selectionEndPageIn;
    private caretIn;
    editableDiv: HTMLDivElement;
    fieldStacks: FieldElementBox[];
    splittedCellWidgets: TableCellWidget[];
    tableLefts: number[];
    private tapCount;
    private timer;
    private isTimerStarted;
    isFirstLineFitInShiftWidgets: boolean;
    preZoomFactor: number;
    preDifference: number;
    backgroundColor: string;
    layoutModule: Layout;
    renderModule: Renderer;
    searchModule: Search;
    containerTop: number;
    containerLeft: number;
    private containerCanvasIn;
    private selectionCanvasIn;
    zoomModule: Zoom;
    isMouseDown: boolean;
    isSelectionChangedOnMouseMoved: boolean;
    isControlPressed: boolean;
    touchStart: HTMLElement;
    touchEnd: HTMLElement;
    isTouchInput: boolean;
    useTouchSelectionMark: boolean;
    touchDownOnSelectionMark: number;
    textHelper: TextHelper;
    isCompositionStart: boolean;
    isCompositionUpdated: boolean;
    isCompositionCanceled: boolean;
    isCompositionEnd: boolean;
    prefix: string;
    suffix: string;
    /**
     * @hidden
     */
    blockToShift: BlockWidget;
    /**
     * @hidden
     */
    lineToLayout: LineWidget;
    /**
     * @hidden
     */
    heightInfoCollection: TextHeightInfo;
    private animationTimer;
    isListTextSelected: boolean;
    selectionLineWidget: LineWidget;
    sections: BodyWidget[];
    characterFormat: WCharacterFormat;
    renderedLists: Dictionary<WAbstractList, Dictionary<number, number>>;
    headerFooters: HeaderFooters[];
    private fieldSeparator;
    defaultTabWidth: number;
    lists: WList[];
    abstractLists: WAbstractList[];
    listParagraphs: ParagraphWidget[];
    /**
     * Gets container canvas.
     * @hidden
     */
    readonly containerCanvas: HTMLCanvasElement;
    /**
     * Gets selection canvas.
     * @hidden
     */
    readonly selectionCanvas: HTMLCanvasElement;
    /**
     * Gets container context.
     * @hidden
     */
    readonly containerContext: CanvasRenderingContext2D;
    /**
     * Gets selection context.
     * @hidden
     */
    readonly selectionContext: CanvasRenderingContext2D;
    /**
     * Gets the current rendering page.
     */
    readonly currentRenderingPage: Page;
    /**
     * Gets visible bounds.
     * @hidden
     */
    readonly visibleBounds: Rect;
    /**
     * Gets or sets zoom factor.
     * @hidden
     */
    zoomFactor: number;
    /**
     * Gets the selection.
     * @hidden
     */
    readonly selection: Selection;
    /**
     * Gets or sets selection start page.
     * @hidden
     */
    selectionStartPage: Page;
    /**
     * Gets or sets selection end page.
     * @hidden
     */
    selectionEndPage: Page;
    /**
     * Gets or sets html div element.
     * @hidden
     */
    caret: HTMLDivElement;
    constructor(owner: DocumentEditor);
    /**
     * @hidden
     */
    getAbstractListById(id: number): WAbstractList;
    /**
     * @hidden
     */
    getListById(id: number): WList;
    /**
     * @hidden
     */
    static getListLevelNumber(listLevel: WListLevel): number;
    /**
     * Updates line widget maximum height.
     * @hidden
     */
    updateLineWidget(line: LineWidget): void;
    /**
     * Initializes components.
     * @hidden
     */
    initializeComponents(): void;
    /**
     * Wires events and methods.
     */
    private wireEvent();
    /**
     * Fires when editable div loses focus.
     */
    private onFocusOut;
    /**
     * Updates focus to editor area.
     * @hidden
     */
    updateFocus: () => void;
    onTextInputInternal: (event: KeyboardEvent) => void;
    /**
     * @hidden
     */
    handleTextInput(text: string): void;
    /**
     * Handles back key.
     * @hidden
     */
    private handleBackKey();
    /**
     * Handles delete
     * @hidden
     */
    handleDelete(): void;
    /**
     * Handles enter key.
     * @hidden
     */
    private handleEnterKey();
    /**
     * Clears the context.
     * @hidden
     */
    clearContent(): void;
    /**
     * Fired when the document gets changed.
     * @param {WordDocument} document
     */
    onDocumentChanged(): void;
    /**
     * Initializes caret.
     */
    private initCaret();
    /**
     * Fires on scrolling.
     */
    private scrollHandler;
    /**
     * Fires when the window gets resized.
     * @hidden
     */
    onWindowResize: () => void;
    /**
     * Called on mouse down.
     * @param {MouseEvent} event
     * @hidden
     */
    onMouseDownInternal: (event: MouseEvent) => void;
    /**
     * Called on mouse move.
     * @param {MouseEvent} event
     * @hidden
     */
    onMouseMoveInternal: (event: MouseEvent) => void;
    /**
     * Fired on double tap.
     * @param {MouseEvent} event
     * @hidden
     */
    onDoubleTap: (event: MouseEvent) => void;
    /**
     * Called on mouse up.
     * @param {MouseEvent} event
     * @hidden
     */
    onMouseUpInternal: (event: MouseEvent) => void;
    /**
     * Checks whether left mouse button is pressed or not.
     */
    private isLeftButtonPressed(event);
    /**
     * Fired on touch move.
     * @param {TouchEvent} event
     * @hidden
     */
    onTouchMoveInternal: (event: TouchEvent) => void;
    /**
     * Fired on pinch zoom in.
     * @param {TouchEvent} event
     */
    private onPinchInInternal(event);
    /**
     * Fired on pinch zoom out.
     * @param {TouchEvent} event
     */
    private onPinchOutInternal(event);
    /**
     * Gets page width.
     * @hidden
     */
    getPageWidth(page: Page): number;
    /**
     * Removes specified page.
     * @hidden
     */
    removePage(page: Page): void;
    /**
     * Fired on paste.
     * @param {ClipboardEvent} event
     * @hidden
     */
    onPaste: (event: ClipboardEvent) => void;
    /**
     * Updates viewer size on window resize.
     * @hidden
     */
    updateViewerSizeOnWindowResize(): void;
    /**
     * Updates viewer size.
     */
    private updateViewerSize(element);
    /**
     * Updates client area for block.
     * @hidden
     */
    updateClientAreaForBlock(block: BlockWidget, beforeLayout: boolean, tableCollection?: TableWidget[]): void;
    /**
     * Updates client active area left.
     * @hidden
     */
    cutFromLeft(x: number): void;
    /**
     * Updates client active area top.
     * @hidden
     */
    cutFromTop(y: number): void;
    /**
     * Updates client width.
     * @hidden
     */
    updateClientWidth(width: number): void;
    /**
     * Inserts page in specified index.
     * @hidden
     */
    insertPage(index: number, page: Page): void;
    /**
     * Updates client area.
     * @hidden
     */
    updateClientArea(sectionFormat: WSectionFormat): void;
    /**
     * Updates client area left or top position.
     * @hidden
     */
    updateClientAreaTopOrLeft(tableWidget: TableWidget, beforeLayout: boolean): void;
    /**
     * Updates client area for table.
     * @hidden
     */
    updateClientAreaForTable(tableWidget: TableWidget): void;
    /**
     * Updates client area for row.
     * @hidden
     */
    updateClientAreaForRow(row: TableRowWidget, beforeLayout: boolean): void;
    /**
     * Updates client area for cell.
     * @hidden
     */
    updateClientAreaForCell(cell: TableCellWidget, beforeLayout: boolean): void;
    /**
     * Updates client area location.
     * @param widget
     * @param area
     * @hidden
     */
    updateClientAreaLocation(widget: Widget, area: Rect): void;
    /**
     * Updates text position for selection.
     * @param cursorPoint
     * @param tapCount
     * @param clearMultiSelection
     */
    private updateTextPositionForSelection(cursorPoint, tapCount);
    /**
     * Scrolls to specified position.
     * @param startPosition
     * @param endPosition
     * @hidden
     */
    scrollToPosition(startPosition: TextPosition, endPosition: TextPosition): void;
    /**
     * Updates caret position.
     * @hidden
     */
    updateCaretPosition(): void;
    /**
     * Updates caret to page.
     */
    private updateCaretToPage(startPosition, endPage);
    /**
     * Gets current selected page
     */
    private getSelectionPage(position);
    /**
     * Updates caret size.
     */
    private updateCaretSize(textPosition);
    /**
     * Gets line widget using cursor point.
     * @hidden
     */
    getLineWidget(cursorPoint: Point): LineWidget;
    /**
     * Gets line widget.
     * @hidden
     */
    getLineWidgetInternal(cursorPoint: Point, isMouseDragged: boolean): LineWidget;
    /**
     * Clears selection highlight.
     * @hidden
     */
    clearSelectionHighlight(): void;
    /**
     * Checks for cursor visibility.
     * @param isTouch
     * @hidden
     */
    checkForCursorVisibility(isTouch: boolean): void;
    /**
     * Shows caret in current selection position.
     * @hidden
     */
    showCaret(): void;
    /**
     * Fired on keyup event.
     * @hidden
     */
    onKeyUpInternal: (event: KeyboardEvent) => void;
    /**
     * Fired on keydown.
     * @hidden
     */
    onKeyDownInternal: (event: KeyboardEvent) => void;
    private setEditableDivCaretPosition(index);
    /**
     * Hides caret.
     * @hidden
     */
    hideCaret: () => void;
    /**
     * Destroys the internal objects maintained for control.
     */
    destroy(): void;
    /**
     * Un-Wires events and methods
     */
    private unWireEvent();
    abstract createNewPage(section: BodyWidget): Page;
    abstract renderVisiblePages(): void;
    abstract updateScrollBars(): void;
    protected abstract updateCursor(event: MouseEvent): void;
    abstract findFocusedPage(point: Point, updateCurrentPage: boolean): Point;
}
/**
 * PageLayoutViewer
 */
export  class PageLayoutViewer extends LayoutViewer {
    private pageLeft;
    pageGap: number;
    visiblePages: Page[];
    /**
     * Initialize the constructor of PageLayoutViewer
     */
    constructor(owner: DocumentEditor);
    /**
     * Creates new page.
     * @hidden
     */
    createNewPage(section: BodyWidget): Page;
    /**
     * Updates cursor.
     */
    protected updateCursor(event: MouseEvent): void;
    /**
     * Finds focused page.
     * @hidden
     */
    findFocusedPage(currentPoint: Point, updateCurrentPage: boolean): Point;
    /**
     * Updates scroll bars.
     * @hidden
     */
    updateScrollBars(): void;
    updateScrollBarPosition(containerWidth: number, containerHeight: number, viewerWidth: number, viewerHeight: number, width: number, height: number): void;
    /**
     * Updates visible pages.
     * @hidden
     */
    updateVisiblePages(): void;
    /**
     * Adds visible pages.
     */
    private addVisiblePage(page, x, y);
    /**
     * Render specified page widgets.
     */
    private renderPage(page, x, y, width, height);
    /**
     * Renders visible pages.
     * @hidden
     */
    renderVisiblePages(): void;
}
/**
 * Word Export module
 */
export  class WordExport {
    private getModuleName();
    private documentPath;
    private stylePath;
    private numberingPath;
    private settingsPath;
    private headerPath;
    private footerPath;
    private imagePath;
    private appPath;
    private corePath;
    private contentTypesPath;
    private generalRelationPath;
    private wordRelationPath;
    private headerRelationPath;
    private footerRelationPath;
    private xmlContentType;
    private fontContentType;
    private documentContentType;
    private settingsContentType;
    private footerContentType;
    private headerContentType;
    private numberingContentType;
    private stylesContentType;
    private webSettingsContentType;
    private appContentType;
    private coreContentType;
    private customContentType;
    private customXmlContentType;
    private relationContentType;
    private tableStyleContentType;
    private settingsRelType;
    private footerRelType;
    private headerRelType;
    private documentRelType;
    private numberingRelType;
    private stylesRelType;
    private fontRelType;
    private tableStyleRelType;
    private coreRelType;
    private appRelType;
    private customRelType;
    private imageRelType;
    private hyperlinkRelType;
    private controlRelType;
    private packageRelType;
    private customXmlRelType;
    private customUIRelType;
    private attachedTemplateRelType;
    private wNamespace;
    private wpNamespace;
    private pictureNamespace;
    private aNamespace;
    private a14Namespace;
    private rNamespace;
    private rpNamespace;
    private vNamespace;
    private oNamespace;
    private xmlNamespace;
    private w10Namespace;
    private cpNamespace;
    private dcNamespace;
    private docPropsNamespace;
    private veNamespace;
    private mNamespace;
    private wneNamespace;
    private customPropsNamespace;
    private vtNamespace;
    private chartNamespace;
    private slNamespace;
    private dtNamespace;
    private wmlNamespace;
    private w14Namespace;
    private wpCanvasNamespace;
    private wpDrawingNamespace;
    private wpGroupNamespace;
    private wpInkNamespace;
    private wpShapeNamespace;
    private w15Namespace;
    private diagramNamespace;
    private eNamespace;
    private pNamespace;
    private certNamespace;
    private cRelationshipsTag;
    private cRelationshipTag;
    private cIdTag;
    private cTypeTag;
    private cTargetTag;
    private cUserShapesTag;
    private cExternalData;
    private twipsInOnePoint;
    private twentiethOfPoint;
    private borderMultiplier;
    private percentageFactor;
    private emusPerPoint;
    private cConditionalTableStyleTag;
    private cTableFormatTag;
    private cTowFormatTag;
    private cCellFormatTag;
    private cParagraphFormatTag;
    private cCharacterFormatTag;
    private packageType;
    private relsPartPath;
    private documentRelsPartPath;
    private webSettingsPath;
    private wordMLDocumentPath;
    private wordMLStylePath;
    private wordMLNumberingPath;
    private wordMLSettingsPath;
    private wordMLHeaderPath;
    private wordMLFooterPath;
    private wordMLCommentsPath;
    private wordMLImagePath;
    private wordMLFootnotesPath;
    private wordMLEndnotesPath;
    private wordMLAppPath;
    private wordMLCorePath;
    private wordMLCustomPath;
    private wordMLFontTablePath;
    private wordMLChartsPath;
    private wordMLDefaultEmbeddingPath;
    private wordMLEmbeddingPath;
    private wordMLDrawingPath;
    private wordMLThemePath;
    private wordMLFontsPath;
    private wordMLDiagramPath;
    private wordMLControlPath;
    private wordMLVbaProject;
    private wordMLVbaData;
    private wordMLVbaProjectPath;
    private wordMLVbaDataPath;
    private wordMLWebSettingsPath;
    private wordMLCustomItemProp1Path;
    private wordMLFootnoteRelPath;
    private wordMLEndnoteRelPath;
    private wordMLSettingsRelPath;
    private wordMLNumberingRelPath;
    private wordMLFontTableRelPath;
    private wordMLCustomXmlPropsRelType;
    private wordMLControlRelType;
    private wordMLDiagramContentType;
    private section;
    private lastSection;
    private blockOwner;
    private paragraph;
    private table;
    private row;
    private headerFooter;
    private document;
    private mSections;
    private mLists;
    private mAbstractLists;
    private defCharacterFormat;
    private defParagraphFormat;
    private defaultTabWidthValue;
    private mRelationShipID;
    private mDocPrID;
    private mDifferentFirstPage;
    private mHeaderFooterColl;
    private mVerticalMerge;
    private mGridSpans;
    private mDocumentImages;
    private mExternalLinkImages;
    private mHeaderFooterImages;
    private mArchive;
    private readonly documentImages;
    private readonly externalImages;
    private readonly headerFooterImages;
    private readonly headersFooters;
    /**
     * @hidden
     */
    save(viewer: LayoutViewer, fileName: string): void;
    /**
     * @hidden
     */
    saveAsBlob(viewer: LayoutViewer): Promise<{
        blobData: Blob;
    }>;
    /**
     * @hidden
     */
    destroy(): void;
    private serialize(viewer);
    private setDocument(document);
    private clearDocument();
    private serializeDocument();
    private writeCommonAttributeStrings(writer);
    private writeDup(writer);
    private writeCustom(writer);
    private serializeDocumentBody(writer);
    private serializeSection(writer, section, last);
    private serializeSectionProperties(writer, section);
    private serializeColumns(writer, section);
    private serializePageSetup(writer, pageSetup);
    private serializePageSize(writer, pageSetup);
    private serializePageMargins(writer, pageSetup);
    private serializeSectionType(writer, sectionBreakCode);
    private serializeHFReference(writer, headerFooters);
    private addHeaderFooter(hf, hfType, id);
    private serializeBodyItems(writer, blockCollection, isLastSection);
    private serializeBodyItem(writer, item, isLastSection);
    private serializeParagraph(writer, paragraph, isLastSection);
    private serializeParagraphItems(writer, paraItems);
    private serializePicture(writer, image);
    private serializeDrawing(writer, image);
    private serializeInlinePicture(writer, image);
    private startsWith(sourceString, startString);
    private serializeDrawingGraphics(writer, picture);
    private updateShapeId(picture);
    private addImageRelation(imageCollection, image);
    private updateHFImageRels(hf, image);
    private serializeTable(writer, table);
    private serializeTableGrid(writer, table);
    private serializeTableRows(writer, rows);
    private serializeRow(writer, row);
    private serializeRowFormat(writer, row);
    private serializeCells(writer, cells);
    private serializeCell(writer, cell);
    private serializeCellFormat(writer, cellFormat);
    private serializeCellWidth(writer, cell);
    private serializeCellMerge(writer, cellFormat);
    private createMerge(writer, collKey, cell);
    private serializeColumnSpan(collKey, writer);
    private checkMergeCell(collKey);
    private serializeGridSpan(writer, cell);
    private serializeTableCellDirection(writer, cellFormat);
    private serializeCellVerticalAlign(writer, alignment);
    private serializeGridColumns(writer, grid);
    private serializeTableFormat(writer, format, table);
    private serializeShading(writer, format);
    private getTextureStyle(textureStyle);
    private serializeTableBorders(writer, format);
    private serializeBorders(writer, borders, multipler);
    private serializeTblLayout(writer, format);
    private serializeBorder(writer, border, tagName, multiplier);
    private getBorderStyle(borderStyle);
    private serializeTableIndentation(writer, format);
    private serializeCellSpacing(writer, format);
    private serializeTableWidth(writer, table);
    private serializeTableAlignment(writer, format);
    private serializeFieldCharacter(writer, field);
    private serializeTextRange(writer, span, previousNode);
    private serializeParagraphFormat(writer, paragraphFormat, paragraph);
    private serializeListParagraph(writer, paragraph);
    private serializeListFormat(writer, lf);
    private serializeNumPr(writer, listId, listLevel);
    private serializeParagraphAlignment(writer, txtAlignment);
    private serializeParagraphSpacing(writer, paragraphFormat);
    private serializeIndentation(writer, paragraphFormat);
    private serializeStyles();
    private serializeDefaultStyles(writer);
    private serializeCharactetFormat(writer, characterFormat);
    private getUnderlineStyle(underlineStyle);
    private getHighlightColor(highlight);
    private serializeBoolProperty(writer, tag, value);
    private serializeNumberings();
    private serializeAbstractListStyles(writer, listStyles);
    private serializeListInstances(writer, listStyles);
    private generateHex();
    private roundToTwoDecimal(num);
    private serializeListLevel(writer, listLevel, levelIndex);
    private getLevelPattern(levelPattern);
    private serializeLevelText(writer, listLevel, lvlIndex);
    private serializeLevelFollow(writer, listLevel);
    private serializeSettings();
    private serializeCoreProperties();
    private serializeAppProperties();
    private serializeFontTable(contentType);
    private serializeSettingsRelation();
    private serializeHeaderFooters();
    private serializeHeaderFooter(hfType);
    private serializeHeader(header, id, headerFooterPath, headerFooterRelsPath);
    private serializeHFRelations(hfId, headerFooterRelsPath);
    private writeHFCommonAttributes(writer);
    private serializeFooter(footer, id, headerFooterPath, headerFooterRelsPath);
    private serializeDocumentRelations();
    private serializeImagesRelations(images, writer);
    encodedString(input: string): Uint8Array;
    private serializeExternalLinkImages(writer);
    private serializeHeaderFooterRelations(writer);
    private serializeHFRelation(writer, hfType);
    private serializeRelationShip(writer, relationshipID, relationshipType, targetPath);
    private getNextRelationShipID();
    private serializeGeneralRelations();
    private serializeContentTypes(contentType);
    private serializeHFContentTypes(writer);
    private serializeHeaderFootersContentType(writer, headerFooterType);
    private serializeOverrideContentType(writer, partName, contentType);
    private serializeDefaultContentType(writer, extension, contentType);
    private resetRelationShipID();
    private close();
}
/**
 * Zoom module is used to handle zooming functionality
 */
export  class Zoom {
    private viewer;
    setZoomFactor(value: number): void;
    constructor(viewer: LayoutViewer);
    private onZoomFactorChanged();
    private zoom();
    onMouseWheelInternal: (event: WheelEvent) => void;
}
/**
 * export document editor modules
 */
 }
export namespace dropdowns { 

/**
 * Interface for a class AutoComplete
 */
export interface AutoCompleteModel extends ComboBoxModel{
    /**
     * The `fields` property maps the columns of the data table and binds the data to the component.
     * * text - Maps the text column from data table for each list item
     * * value - Maps the value column from data table for each list item
     * * iconCss - Maps the icon class column from data table for each list item
     * * groupBy - Group the list items with it's related items by mapping groupBy field
     * 
     * > For more details about the field mapping refer to [`Data binding`](./data-binding.html) documentation.
     * @default { value: null, iconCss: null, groupBy: null}
     */
    fields?: FieldSettingsModel;
    /**
     * When set to ‘false’, consider the [`case-sensitive`](./filtering.html#case-sensitive-filtering) 
     * on performing the search to find suggestions.
     * By default consider the casing.
     * @default true.
     */
    ignoreCase?: boolean;
    /**
     * Allows you to either show or hide the popup button on the component.
     * @default false.
     */
    showPopupButton?: boolean;
    /**
     * When set to ‘true’, highlight the searched characters on suggested list items.
     * > For more details about the highlight refer to [`Custom highlight search`](./how-to.html#custom-highlight-search) documentation. 
     * @default false.
     */
    highlight?: boolean;
    /**
     * Supports the [`specified number`](./filtering.html#filter-item-count) 
     * of list items on the suggestion popup.
     * @default 20.
     */
    suggestionCount?: number;
    /**
     * Allows additional HTML base.attributes such as title, name, etc., and
     * accepts n number of base.attributes in a key-value pair format.
     * 
     * {% codeBlock src="autocomplete/html-base.attributes-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="autocomplete/html-base.attributes-api/index.html" %}{% endcodeBlock %}
     * @default {}.
     */
    htmlAttributes?: { [key: string]: string; };
    /**
     * Accepts the external [`query`](./api-query.html)
     * that execute along with data processing.
     * 
     * {% codeBlock src="autocomplete/query-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="autocomplete/query-api/index.html" %}{% endcodeBlock %}
     * @default null.
     */
    query?: data.Query;
    /**
     * Allows you to set [`the minimum search character length']
     * (./filtering.html#limit-the-minimum-filter-character),
     * the search action will perform after typed minimum characters.
     * @default 1.
     */
    minLength?: number;
    /**
     * Determines on which filter type, the component needs to be considered on search action. 
     * The available [`FilterType`](./filtering.html#change-the-filter-type) 
     * and its supported data types are 
     * 
     * <table> 
     * <tr> 
     * <td colSpan=1 rowSpan=1> 
     * FilterType<br/></td><td colSpan=1 rowSpan=1> 
     * Description<br/></td><td colSpan=1 rowSpan=1> 
     * Supported Types<br/></td></tr> 
     * <tr> 
     * <td colSpan=1 rowSpan=1> 
     * StartsWith<br/></td><td colSpan=1 rowSpan=1> 
     * Checks whether a value begins with the specified value.<br/></td><td colSpan=1 rowSpan=1> 
     * String<br/></td></tr> 
     * <tr> 
     * <td colSpan=1 rowSpan=1> 
     * EndsWith<br/></td><td colSpan=1 rowSpan=1> 
     * Checks whether a value ends with specified value.<br/><br/></td><td colSpan=1 rowSpan=1> 
     * <br/>String<br/></td></tr> 
     * <tr> 
     * <td colSpan=1 rowSpan=1> 
     * Contains<br/></td><td colSpan=1 rowSpan=1> 
     * Checks whether a value contains with specified value.<br/><br/></td><td colSpan=1 rowSpan=1> 
     * <br/>String<br/></td></tr> 
     * </table> 
     * 
     * {% codeBlock src="autocomplete/filter-type-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="autocomplete/filter-type-api/index.html" %}{% endcodeBlock %}
     * 
     * The default value set to `Contains`, all the suggestion items which contain typed characters to listed in the suggestion popup.
     * @default 'Contains'.
     */
    filterType?: FilterType;
    /**
     * Triggers on typing a character in the component.
     * @event
     */
    filtering?: base.EmitType<FilteringEventArgs>;
    /**
     * Not applicable to this component.
     * @default null.
     * @private
     */
    index?: number;
    /**
     * Specifies whether to display the floating label above the input element.
     * Possible values are:
     * * Never: The label will never float in the input when the placeholder is available.
     * * Always: The floating label will always float above the input.
     * * Auto: The floating label will float above the input after focusing or entering a value in the input.
     * 
     * {% codeBlock src="autocomplete/float-label-type-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="autocomplete/float-label-type-api/index.html" %}{% endcodeBlock %}
     * 
     *  @default 'Never'.
     */
    floatLabelType?: inputs.FloatLabelType;
    /**
     * Not applicable to this component.
     * @default null.
     * @private
     */
    valueTemplate?: string;
    /**
     * Not applicable to this component.
     * @default null.
     * @private
     */
    filterBarPlaceholder?: string;
    /**
     * Not applicable to this component. 
     * @default false.
     * @private
     */
    allowFiltering?: boolean;
    /**
     * Not applicable to this component. 
     * @default null.
     * @private
     */
    text?: string;
}

export  type FilterType = 'Contains' | 'StartsWith' | 'EndsWith';
/**
 * The AutoComplete component provides the matched suggestion list when type into the input,
 * from which the user can select one.
 * ```html
 * <input id="list" type="text"/>
 * ```
 * ```typescript
 *   let atcObj:AutoComplete = new AutoComplete();
 *   atcObj.appendTo("#list");
 * ```
 */
export  class AutoComplete extends ComboBox {
    private isFiltered;
    /**
     * The `fields` property maps the columns of the data table and binds the data to the component.
     * * text - Maps the text column from data table for each list item
     * * value - Maps the value column from data table for each list item
     * * iconCss - Maps the icon class column from data table for each list item
     * * groupBy - Group the list items with it's related items by mapping groupBy field
     *
     * > For more details about the field mapping refer to [`Data binding`](./data-binding.html) documentation.
     * @default { value: null, iconCss: null, groupBy: null}
     */
    fields: FieldSettingsModel;
    /**
     * When set to ‘false’, consider the [`case-sensitive`](./filtering.html#case-sensitive-filtering)
     * on performing the search to find suggestions.
     * By default consider the casing.
     * @default true.
     */
    ignoreCase: boolean;
    /**
     * Allows you to either show or hide the popup button on the component.
     * @default false.
     */
    showPopupButton: boolean;
    /**
     * When set to ‘true’, highlight the searched characters on suggested list items.
     * > For more details about the highlight refer to [`Custom highlight search`](./how-to.html#custom-highlight-search) documentation.
     * @default false.
     */
    highlight: boolean;
    /**
     * Supports the [`specified number`](./filtering.html#filter-item-count)
     * of list items on the suggestion popup.
     * @default 20.
     */
    suggestionCount: number;
    /**
     * Allows additional HTML attributes such as title, name, etc., and
     * accepts n number of attributes in a key-value pair format.
     *
     * {% codeBlock src="autocomplete/html-attributes-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="autocomplete/html-attributes-api/index.html" %}{% endcodeBlock %}
     * @default {}.
     */
    htmlAttributes: {
        [key: string]: string;
    };
    /**
     * Accepts the external [`query`](./api-query.html)
     * that execute along with data processing.
     *
     * {% codeBlock src="autocomplete/query-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="autocomplete/query-api/index.html" %}{% endcodeBlock %}
     * @default null.
     */
    query: data.Query;
    /**
     * Allows you to set [`the minimum search character length']
     * (./filtering.html#limit-the-minimum-filter-character),
     * the search action will perform after typed minimum characters.
     * @default 1.
     */
    minLength: number;
    /**
     * Determines on which filter type, the component needs to be considered on search action.
     * The available [`FilterType`](./filtering.html#change-the-filter-type)
     * and its supported data types are
     *
     * <table>
     * <tr>
     * <td colSpan=1 rowSpan=1>
     * FilterType<br/></td><td colSpan=1 rowSpan=1>
     * Description<br/></td><td colSpan=1 rowSpan=1>
     * Supported Types<br/></td></tr>
     * <tr>
     * <td colSpan=1 rowSpan=1>
     * StartsWith<br/></td><td colSpan=1 rowSpan=1>
     * Checks whether a value begins with the specified value.<br/></td><td colSpan=1 rowSpan=1>
     * String<br/></td></tr>
     * <tr>
     * <td colSpan=1 rowSpan=1>
     * EndsWith<br/></td><td colSpan=1 rowSpan=1>
     * Checks whether a value ends with specified value.<br/><br/></td><td colSpan=1 rowSpan=1>
     * <br/>String<br/></td></tr>
     * <tr>
     * <td colSpan=1 rowSpan=1>
     * Contains<br/></td><td colSpan=1 rowSpan=1>
     * Checks whether a value contains with specified value.<br/><br/></td><td colSpan=1 rowSpan=1>
     * <br/>String<br/></td></tr>
     * </table>
     *
     * {% codeBlock src="autocomplete/filter-type-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="autocomplete/filter-type-api/index.html" %}{% endcodeBlock %}
     *
     * The default value set to `Contains`, all the suggestion items which contain typed characters to listed in the suggestion popup.
     * @default 'Contains'.
     */
    filterType: FilterType;
    /**
     * Triggers on typing a character in the component.
     * @event
     */
    filtering: base.EmitType<FilteringEventArgs>;
    /**
     * Not applicable to this component.
     * @default null.
     * @private
     */
    index: number;
    /**
     * Specifies whether to display the floating label above the input element.
     * Possible values are:
     * * Never: The label will never float in the input when the placeholder is available.
     * * Always: The floating label will always float above the input.
     * * Auto: The floating label will float above the input after focusing or entering a value in the input.
     *
     * {% codeBlock src="autocomplete/float-label-type-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="autocomplete/float-label-type-api/index.html" %}{% endcodeBlock %}
     *
     *  @default 'Never'.
     */
    floatLabelType: inputs.FloatLabelType;
    /**
     * Not applicable to this component.
     * @default null.
     * @private
     */
    valueTemplate: string;
    /**
     * Not applicable to this component.
     * @default null.
     * @private
     */
    filterBarPlaceholder: string;
    /**
     * Not applicable to this component.
     * @default false.
     * @private
     */
    allowFiltering: boolean;
    /**
     * Not applicable to this component.
     * @default null.
     * @private
     */
    text: string;
    /**
     * * Constructor for creating the widget
     */
    constructor(options?: AutoCompleteModel, element?: string | HTMLElement);
    /**
     * Initialize the event handler
     * @private
     */
    protected preRender(): void;
    protected getNgDirective(): string;
    protected getQuery(query: data.Query): data.Query;
    protected searchLists(e: base.KeyboardEventArgs): void;
    private filterAction(dataSource, query?, fields?);
    protected clear(e?: MouseEvent, property?: string): void;
    protected onActionComplete(ulElement: HTMLElement, list: {
        [key: string]: Object;
    }[], e?: Object, isUpdated?: boolean): void;
    private postBackAction();
    protected setSelection(li: Element, e: MouseEvent | base.KeyboardEventArgs | TouchEvent): void;
    protected listOption(dataSource: {
        [key: string]: Object;
    }[], fieldsSettings: FieldSettingsModel): FieldSettingsModel;
    protected showSpinner(): void;
    protected hideSpinner(): void;
    protected isFiltering(): boolean;
    protected renderPopup(): void;
    protected isEditTextBox(): boolean;
    protected isPopupButton(): boolean;
    protected isSelectFocusItem(element: Element): boolean;
    /**
     * Search the entered text and show it in the suggestion list if available.
     * @returns void.
     */
    showPopup(): void;
    /**
     * Hides the popup if it is in open state.
     * @returns void.
     */
    hidePopup(): void;
    /**
     * Dynamically change the value of properties.
     * @private
     */
    onPropertyChanged(newProp: AutoCompleteModel, oldProp: AutoCompleteModel): void;
    /**
     * Return the module name of this component.
     * @private
     */
    getModuleName(): string;
    /**
     * To initialize the control rendering
     * @private
     */
    render(): void;
}
/**
 * export all modules from current location
 */
/**
 * Interface for a class ComboBox
 */
export interface ComboBoxModel extends DropDownListModel{
    /**
     * Specifies whether suggest a first matched item in input when searching. No action happens when no matches found.
     * @default false.
     */
    autofill?: boolean;
    /**
     * Specifies whether the component allows user defined value which does not exist in data source.    
     * @default true.
     */
    allowCustom?: boolean;
    /**
     * Allows additional HTML attributes such as title, name, etc., and
     * accepts n number of attributes in a key-value pair format.
     * 
     * {% codeBlock src="combobox/html-attributes-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="combobox/html-attributes-api/index.html" %}{% endcodeBlock %}
     * @default {}.
     */
    htmlAttributes?: { [key: string]: string; };
    /**
     * When allowFiltering is set to true, show the filter bar (search box) of the component.
     * The filter action retrieves matched items through the `filtering` event based on
     * the characters typed in the search TextBox.
     * If no match is found, the value of the `noRecordsTemplate` property will be displayed.
     * 
     * {% codeBlock src="combobox/allow-filtering-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="combobox/allow-filtering-api/index.html" %}{% endcodeBlock %}
     * @default false.
     */
    allowFiltering?: boolean;
    /**
     * Accepts the external [`data.Query`](./api-query.html)
     * that execute along with [`data processing`](./data-binding.html).
     * 
     * {% codeBlock src="combobox/query-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="combobox/query-api/index.html" %}{% endcodeBlock %}
     * @default null.
     */
    query?: data.Query;
    /**
     * Gets or sets the index of the selected item in the component.
     * 
     * {% codeBlock src="combobox/index-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="combobox/index-api/index.html" %}{% endcodeBlock %}
     * 
     * @default null.
     */
    index?: number;
    /**
     * Specifies whether to show or hide the clear button. 
     * When the clear button is clicked, `value`, `text`, and `index` properties are reset to null.
     * @default true.
     */
    showClearButton?: boolean;
    /**
     * Triggers on set a 
     * [`custom value`](./getting-started.html#custom-values) to this component.
     * @event
     */
    customValueSpecifier?: base.EmitType<CustomValueSpecifierEventArgs>;
    /**
     * Triggers on typing a character in the component.
     * > For more details about the filtering refer to [`Filtering`](./filtering.html) documentation.
     * @event
     */
    filtering?: base.EmitType<FilteringEventArgs>;
    /**
     * Not applicable to this component.
     * @default null.
     * @private
     */
    valueTemplate?: string;
    /**
     * Specifies whether to display the floating label above the input element.
     * Possible values are:
     * * Never: The label will never float in the input when the placeholder is available.
     * * Always: The floating label will always float above the input.
     * * Auto: The floating label will float above the input after focusing or entering a value in the input.
     * 
     * {% codeBlock src="combobox/float-label-type-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="combobox/float-label-type-api/index.html" %}{% endcodeBlock %}
     * 
     *  @default 'Never'.
     */
    floatLabelType?: inputs.FloatLabelType;
    /**
     * Not applicable to this component.
     * @default null.
     * @private
     */
    filterBarPlaceholder?: string;
}

/**
 * The ComboBox component allows the user to type a value or choose an option from the list of predefined options.
 * ```html
 * <select id="list">
 *      <option value='1'>Badminton</option>
 *      <option value='2'>Basketball</option>
 *      <option value='3'>Cricket</option>
 *      <option value='4'>Football</option>
 *      <option value='5'>Tennis</option>
 * </select>
 * ```
 * ```typescript
 *   let games:ComboBox = new ComboBox();
 *   games.appendTo("#list");
 * ```
 */
export  class ComboBox extends DropDownList {
    /**
     * Specifies whether suggest a first matched item in input when searching. No action happens when no matches found.
     * @default false.
     */
    autofill: boolean;
    /**
     * Specifies whether the component allows user defined value which does not exist in data source.
     * @default true.
     */
    allowCustom: boolean;
    /**
     * Allows additional HTML attributes such as title, name, etc., and
     * accepts n number of attributes in a key-value pair format.
     *
     * {% codeBlock src="combobox/html-attributes-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="combobox/html-attributes-api/index.html" %}{% endcodeBlock %}
     * @default {}.
     */
    htmlAttributes: {
        [key: string]: string;
    };
    /**
     * When allowFiltering is set to true, show the filter bar (search box) of the component.
     * The filter action retrieves matched items through the `filtering` event based on
     * the characters typed in the search TextBox.
     * If no match is found, the value of the `noRecordsTemplate` property will be displayed.
     *
     * {% codeBlock src="combobox/allow-filtering-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="combobox/allow-filtering-api/index.html" %}{% endcodeBlock %}
     * @default false.
     */
    allowFiltering: boolean;
    /**
     * Accepts the external [`data.Query`](./api-query.html)
     * that execute along with [`data processing`](./data-binding.html).
     *
     * {% codeBlock src="combobox/query-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="combobox/query-api/index.html" %}{% endcodeBlock %}
     * @default null.
     */
    query: data.Query;
    /**
     * Gets or sets the index of the selected item in the component.
     *
     * {% codeBlock src="combobox/index-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="combobox/index-api/index.html" %}{% endcodeBlock %}
     *
     * @default null.
     */
    index: number;
    /**
     * Specifies whether to show or hide the clear button.
     * When the clear button is clicked, `value`, `text`, and `index` properties are reset to null.
     * @default true.
     */
    showClearButton: boolean;
    /**
     * Triggers on set a
     * [`custom value`](./getting-started.html#custom-values) to this component.
     * @event
     */
    customValueSpecifier: base.EmitType<CustomValueSpecifierEventArgs>;
    /**
     * Triggers on typing a character in the component.
     * > For more details about the filtering refer to [`Filtering`](./filtering.html) documentation.
     * @event
     */
    filtering: base.EmitType<FilteringEventArgs>;
    /**
     * Not applicable to this component.
     * @default null.
     * @private
     */
    valueTemplate: string;
    /**
     * Specifies whether to display the floating label above the input element.
     * Possible values are:
     * * Never: The label will never float in the input when the placeholder is available.
     * * Always: The floating label will always float above the input.
     * * Auto: The floating label will float above the input after focusing or entering a value in the input.
     *
     * {% codeBlock src="combobox/float-label-type-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="combobox/float-label-type-api/index.html" %}{% endcodeBlock %}
     *
     *  @default 'Never'.
     */
    floatLabelType: inputs.FloatLabelType;
    /**
     * Not applicable to this component.
     * @default null.
     * @private
     */
    filterBarPlaceholder: string;
    /**
     * *Constructor for creating the component
     */
    constructor(options?: ComboBoxModel, element?: string | HTMLElement);
    /**
     * Initialize the event handler
     * @private
     */
    protected preRender(): void;
    protected wireEvent(): void;
    private preventBlur(e);
    protected targetElement(): HTMLElement | HTMLInputElement;
    protected setOldText(text: string): void;
    protected setOldValue(value: string | number): void;
    private valueMuteChange(value);
    protected updateValues(): void;
    protected getAriaAttributes(): {
        [key: string]: string;
    };
    protected searchLists(e: base.KeyboardEventArgs): void;
    protected getNgDirective(): string;
    protected setSearchBox(): inputs.InputObject;
    protected onActionComplete(ulElement: HTMLElement, list: {
        [key: string]: Object;
    }[], e?: Object, isUpdated?: boolean): void;
    protected getFocusElement(): Element;
    protected setValue(e?: base.KeyboardEventArgs): boolean;
    protected showSpinner(): void;
    protected hideSpinner(): void;
    protected setAutoFill(activeElement: Element, isHover?: boolean): void;
    private isAndroidAutoFill(value);
    protected isSelectFocusItem(element: Element): boolean;
    private inlineSearch(e?);
    protected incrementalSearch(e: base.KeyboardEventArgs): void;
    private setAutoFillSelection(currentValue);
    protected getValueByText(text: string): string | number;
    protected unWireEvent(): void;
    protected setSelection(li: Element, e: MouseEvent | base.KeyboardEventArgs | TouchEvent): void;
    protected selectCurrentItem(e: base.KeyboardEventArgs): void;
    protected setHoverList(li: Element): void;
    private targetFocus(e);
    protected dropDownClick(e: MouseEvent): void;
    private customValue();
    /**
     * Dynamically change the value of properties.
     * @private
     */
    onPropertyChanged(newProp: ComboBoxModel, oldProp: ComboBoxModel): void;
    /**
     * To initialize the control rendering.
     * @private
     */
    render(): void;
    /**
     * Return the module name of this component.
     * @private
     */
    getModuleName(): string;
    /**
     * Hides the popup if it is in open state.
     * @returns void.
     */
    hidePopup(): void;
    /**
     * Sets the focus to the component for interaction.
     * @returns void.
     */
    focusIn(): void;
}
export interface CustomValueSpecifierEventArgs {
    /**
     * Gets the typed custom text to make a own text format and assign it to `item` argument.
     */
    text: string;
    /**
     * Sets the text custom format data for set a `value` and `text`.
     */
    item: {
        [key: string]: string | Object;
    };
}
/**
 * export all modules from current location
 */
export  type HightLightType = 'Contains' | 'StartsWith' | 'EndsWith';
/**
 * Function helps to find which highlightSearch is to call based on your data.
 * @param  {HTMLElement} element - Specifies an li element.
 * @param  {string} query - Specifies the string to be highlighted.
 * @param  {boolean} ignoreCase - Specifies the ignoreCase option.
 * @param  {HightLightType} type - Specifies the type of highlight.
 */
export  function highlightSearch(element: HTMLElement, query: string, ignoreCase: boolean, type?: HightLightType): void;
/**
 * Function helps to remove highlighted element based on your data.
 * @param  {HTMLElement} content - Specifies an content element.
 */
export  function revertHighlightSearch(content: HTMLElement): void;
export  type SearchType = 'StartsWith' | 'Equal';
/**
 * Search and focus the list item based on key code matches with list text content
 * @param  { number } keyCode - Specifies the key code which pressed on keyboard events.
 * @param  { HTMLElement[]] } items - Specifies an array of HTMLElement, from which matches find has done.
 * @param { number } selectedIndex - Specifies the selected item in list item, so that search will happen
 * after selected item otherwise it will do from initial.
 * @param  { boolean } ignoreCase - Specifies the case consideration when search has done.
 */
export  function incrementalSearch(keyCode: number, items: HTMLElement[], selectedIndex: number, ignoreCase: boolean): Element;
export  function Search(inputVal: string, items: HTMLElement[], searchType: SearchType, ignoreCase?: boolean): {
    [key: string]: Element | number;
};
/**
 * Common source
 */
/**
 * Interface for a class FieldSettings
 */
export interface FieldSettingsModel {
    /**
     * Maps the text column from data table for each list item
     * @default null.
     */
    text?: string;
    /**
     * Maps the value column from data table for each list item
     * @default null.
     */
    value?: string;
    /**
     * Maps the icon class column from data table for each list item.
     * @default null.
     */
    iconCss?: string;
    /**
     * Group the list items with it's related items by mapping groupBy field.
     * @default null.
     */
    groupBy?: string;
    /**
     * Allows additional attributes such as title, disabled, etc., to configure the elements 
     * in various ways to meet the criteria.
     * @default null.
     */
    htmlAttributes?: string;
}
/**
 * Interface for a class DropDownBase
 */
export interface DropDownBaseModel extends base.ComponentModel{
    /**
     * The `fields` property maps the columns of the data table and binds the data to the component.
     * * text - Maps the text column from data table for each list item.
     * * value - Maps the value column from data table for each list item.
     * * iconCss - Maps the icon class column from data table for each list item.
     * * groupBy - Group the list items with it's related items by mapping groupBy field.
     * ```html
     * <input type="text" tabindex="1" id="list"> </input>
     * ```
     * ```typescript  
     *   let customers: DropDownList = new DropDownList({
     *      dataSource:new data.DataManager({ url:'http://js.syncfusion.com/demos/ejServices/Wcf/Northwind.svc/' }),
     *      query: new data.Query().from('Customers').select(['ContactName', 'CustomerID']).take(5),
     *      fields: { text: 'ContactName', value: 'CustomerID' },
     *      placeholder: 'Select a customer'
     *   });
     *   customers.appendTo("#list");
     * ```
     * @default {text: null, value: null, iconCss: null, groupBy: null}
     */
    fields?: FieldSettingsModel;
    /**
     * When set to true, enables RTL mode of the component that 
     * displays the content in the right-to-left direction.
     * @default false.
     */
    enableRtl?: boolean;
    /**
     * Enable or disable persisting component's state between page reloads. 
     * If enabled, following list of states will be persisted.
     * 1. value
     * @default false.
     */
    enablePersistence?: boolean;
    /**
     * Accepts the template design and assigns it to each list item present in the popup.
     * We have built-in [`template engine`](./template-engine.html)
     * 
     * which provides options to base.compile template string into a executable function. 
     * For EX: We have expression evolution as like ES6 expression string literals. 
     * @default null.
     */
    itemTemplate?: string;
    /**
     * Accepts the template design and assigns it to the group headers present in the popup list.
     * @default null.
     */
    groupTemplate?: string;
    /**
     * Accepts the template design and assigns it to popup list of component
     * when no data is available on the component.
     * @default 'No Records Found'.
     */
    noRecordsTemplate?: string;
    /**
     * Accepts the template and assigns it to the popup list content of the component
     * when the data fetch request from the remote server fails.
     * @default 'The Request Failed'.
     */
    actionFailureTemplate?: string;
    /**
     * Specifies the `sortOrder` to sort the data source. The available type of sort orders are
     * * `None` - The data source is not sorting.
     * * `Ascending` - The data source is sorting with ascending order.
     * * `Descending` - The data source is sorting with descending order.
     * @default None.
     */
    sortOrder?: any;
    /**
     * Specifies a value that indicates whether the component is enabled or not.
     * @default true.
     */
    enabled?: boolean;
    /**
     * Accepts the list items either through local or remote service and binds it to the component.
     * It can be an array of JSON Objects or an instance of
     * [`data.DataManager`](./api-dataManager.html).
     * @default [].
     */
    dataSource?: { [key: string]: Object }[] | data.DataManager | string[] | number[];
    /**
     * Accepts the external [`data.Query`](./api-query.html)
     * which will execute along with the data processing.
     * @default null.
     */
    query?: data.Query;
    /**
     * specifies the z-index value of the component popup element.
     * @default 1000
     */
    zIndex?: number;
    /**
     * ignoreAccent set to true, then ignores the diacritic characters or accents when filtering.
     */
    ignoreAccent?: boolean;
    /**
     * Triggers before fetching data from the remote server.
     * @event
     */
    actionBegin?: base.EmitType<Object>;
    /**
     * Triggers after data is fetched successfully from the remote server.
     * @event
     */
    actionComplete?: base.EmitType<Object>;
    /**
     * Triggers when the data fetch request from the remote server fails.
     * @event
     */
    actionFailure?: base.EmitType<Object>;
    /**
     * Triggers when an item in the popup is selected by the user either with mouse/tap or with keyboard navigation.
     * @event
     */
    select?: base.EmitType<SelectEventArgs>;
    /**
     * Triggers when data source is populated in the popup list..
     * @event
     */
    dataBound?: base.EmitType<Object>;
    /**
     * Triggers when the component is created.
     * @event 
     */
    created?: base.EmitType<Object>;
    /**
     * Triggers when the component is destroyed.
     * @event 
     */
    destroyed?: base.EmitType<Object>;
}
export  class FieldSettings extends base.ChildProperty<FieldSettings> {
    /**
     * Maps the text column from data table for each list item
     * @default null.
     */
    text: string;
    /**
     * Maps the value column from data table for each list item
     * @default null.
     */
    value: string;
    /**
     * Maps the icon class column from data table for each list item.
     * @default null.
     */
    iconCss: string;
    /**
     * Group the list items with it's related items by mapping groupBy field.
     * @default null.
     */
    groupBy: string;
    /**
     * Allows additional attributes such as title, disabled, etc., to configure the elements
     * in various ways to meet the criteria.
     * @default null.
     */
    htmlAttributes: string;
}
export  const dropDownBaseClasses: DropDownBaseClassList;
export interface DropDownBaseClassList {
    root: string;
    rtl: string;
    content: string;
    selected: string;
    hover: string;
    noData: string;
    fixedHead: string;
    focus: string;
    li: string;
    disabled: string;
    group: string;
    grouping: string;
}
export interface SelectEventArgs {
    /**
     * If the event is triggered by interaction, it returns true. Otherwise, it returns false.
     */
    isInteracted: boolean;
    /**
     * Returns the selected list item
     */
    item: HTMLLIElement;
    /**
     * Returns the selected item as JSON Object from the data source.
     */
    itemData: FieldSettingsModel;
    /**
     * Specifies the original event arguments.
     */
    e: MouseEvent | KeyboardEvent | TouchEvent;
    /**
     * Illustrates whether the current action needs to be prevented or not.
     */
    cancel?: boolean;
}
/**
 * DropDownBase component will generate the list items based on given data and act as base class to drop-down related components
 */
export  class DropDownBase extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    protected listData: {
        [key: string]: Object;
    }[];
    protected ulElement: HTMLElement;
    protected liCollections: HTMLElement[];
    private bindEvent;
    private scrollTimer;
    protected list: HTMLElement;
    protected fixedHeaderElement: HTMLElement;
    protected keyboardModule: base.KeyboardEvents;
    protected enableRtlElements: HTMLElement[];
    protected rippleFun: Function;
    protected l10n: base.L10n;
    protected item: HTMLLIElement;
    protected itemData: {
        [key: string]: Object;
    };
    protected isActive: boolean;
    protected isRequested: boolean;
    protected queryString: string;
    /**
     * The `fields` property maps the columns of the data table and binds the data to the component.
     * * text - Maps the text column from data table for each list item.
     * * value - Maps the value column from data table for each list item.
     * * iconCss - Maps the icon class column from data table for each list item.
     * * groupBy - Group the list items with it's related items by mapping groupBy field.
     * ```html
     * <input type="text" tabindex="1" id="list"> </input>
     * ```
     * ```typescript
     *   let customers: DropDownList = new DropDownList({
     *      dataSource:new data.DataManager({ url:'http://js.syncfusion.com/demos/ejServices/Wcf/Northwind.svc/' }),
     *      query: new data.Query().from('Customers').select(['ContactName', 'CustomerID']).take(5),
     *      fields: { text: 'ContactName', value: 'CustomerID' },
     *      placeholder: 'Select a customer'
     *   });
     *   customers.appendTo("#list");
     * ```
     * @default {text: null, value: null, iconCss: null, groupBy: null}
     */
    fields: FieldSettingsModel;
    /**
     * When set to true, enables RTL mode of the component that
     * displays the content in the right-to-left direction.
     * @default false.
     */
    enableRtl: boolean;
    /**
     * Enable or disable persisting component's state between page reloads.
     * If enabled, following list of states will be persisted.
     * 1. value
     * @default false.
     */
    enablePersistence: boolean;
    /**
     * Accepts the template design and assigns it to each list item present in the popup.
     * We have built-in [`template engine`](./template-engine.html)
     *
     * which provides options to compile template string into a executable function.
     * For EX: We have expression evolution as like ES6 expression string literals.
     * @default null.
     */
    itemTemplate: string;
    /**
     * Accepts the template design and assigns it to the group headers present in the popup list.
     * @default null.
     */
    groupTemplate: string;
    /**
     * Accepts the template design and assigns it to popup list of component
     * when no data is available on the component.
     * @default 'No Records Found'.
     */
    noRecordsTemplate: string;
    /**
     * Accepts the template and assigns it to the popup list content of the component
     * when the data fetch request from the remote server fails.
     * @default 'The Request Failed'.
     */
    actionFailureTemplate: string;
    /**
     * Specifies the `sortOrder` to sort the data source. The available type of sort orders are
     * * `None` - The data source is not sorting.
     * * `Ascending` - The data source is sorting with ascending order.
     * * `Descending` - The data source is sorting with descending order.
     * @default None.
     */
    sortOrder: lists.SortOrder;
    /**
     * Specifies a value that indicates whether the component is enabled or not.
     * @default true.
     */
    enabled: boolean;
    /**
     * Accepts the list items either through local or remote service and binds it to the component.
     * It can be an array of JSON Objects or an instance of
     * [`data.DataManager`](./api-dataManager.html).
     * @default [].
     */
    dataSource: {
        [key: string]: Object;
    }[] | data.DataManager | string[] | number[];
    /**
     * Accepts the external [`data.Query`](./api-query.html)
     * which will execute along with the data processing.
     * @default null.
     */
    query: data.Query;
    /**
     * specifies the z-index value of the component popup element.
     * @default 1000
     */
    zIndex: number;
    /**
     * ignoreAccent set to true, then ignores the diacritic characters or accents when filtering.
     */
    ignoreAccent: boolean;
    /**
     * Triggers before fetching data from the remote server.
     * @event
     */
    actionBegin: base.EmitType<Object>;
    /**
     * Triggers after data is fetched successfully from the remote server.
     * @event
     */
    actionComplete: base.EmitType<Object>;
    /**
     * Triggers when the data fetch request from the remote server fails.
     * @event
     */
    actionFailure: base.EmitType<Object>;
    /**
     * Triggers when an item in the popup is selected by the user either with mouse/tap or with keyboard navigation.
     * @event
     */
    select: base.EmitType<SelectEventArgs>;
    /**
     * Triggers when data source is populated in the popup list..
     * @event
     */
    dataBound: base.EmitType<Object>;
    /**
     * Triggers when the component is created.
     * @event
     */
    created: base.EmitType<Object>;
    /**
     * Triggers when the component is destroyed.
     * @event
     */
    destroyed: base.EmitType<Object>;
    /**
     * * Constructor for DropDownBase class
     */
    constructor(options?: DropDownBaseModel, element?: string | HTMLElement);
    protected getPropObject(prop: string, newProp: {
        [key: string]: string;
    }, oldProp: {
        [key: string]: string;
    }): {
        [key: string]: Object;
    };
    protected getValueByText(text: string, ignoreCase?: boolean): string | number;
    protected l10nUpdate(actionFailure?: boolean): void;
    protected getTextByValue(value: string | number): string;
    protected getFormattedValue(value: string): string | number;
    /**
     * Sets RTL to dropdownbase wrapper
     */
    protected setEnableRtl(): void;
    /**
     * Initialize the base.Component.
     */
    private initialize();
    /**
     * Get the properties to be maintained in persisted state.
     */
    protected getPersistData(): string;
    /**
     * Sets the enabled state to DropDownBase.
     */
    protected setEnabled(): void;
    private renderItemsBySelect();
    private getJSONfromOption(items, options, fields);
    /**
     * Execute before render the list items
     * @private
     */
    protected preRender(): void;
    /**
     * Creates the list items of DropDownBase component.
     */
    private setListData(dataSource, fields, query);
    protected showSpinner(): void;
    protected hideSpinner(): void;
    protected onActionFailure(e: Object): void;
    protected onActionComplete(ulElement: HTMLElement, list: {
        [key: string]: Object;
    }[], e?: Object): void;
    protected postRender(listElement: HTMLElement, list: {
        [key: string]: Object;
    }[], bindEvent: boolean): void;
    /**
     * Get the query to do the data operation before list item generation.
     */
    protected getQuery(query: data.Query): data.Query;
    /**
     * To render the template content for group header element.
     */
    private renderGroupTemplate(listEle);
    /**
     * To create the ul li list items
     */
    private createListItems(dataSource, fields);
    protected listOption(dataSource: {
        [key: string]: Object;
    }[], fields: FieldSettingsModel): FieldSettingsModel;
    protected setFloatingHeader(e: Event): void;
    private scrollStop(e);
    /**
     * To render the list items
     */
    private renderItems(listData, fields);
    protected templateListItem(dataSource: {
        [key: string]: Object;
    }[], fields: FieldSettingsModel): HTMLElement;
    protected typeOfData(items: {
        [key: string]: Object;
    }[] | string[]): {
        [key: string]: Object;
    };
    protected setFixedHeader(): void;
    private getSortedDataSource(dataSource);
    /**
     * Return the index of item which matched with given value in data source
     */
    protected getIndexByValue(value: string | number): number;
    /**
     * To dispatch the event manually
     */
    protected dispatchEvent(element: HTMLElement, type: string): void;
    /**
     * To set the current fields
     */
    protected setFields(): void;
    /**
     * reset the items list.
     */
    protected resetList(dataSource?: {
        [key: string]: Object;
    }[] | data.DataManager | string[] | number[], fields?: FieldSettingsModel, query?: data.Query): void;
    protected updateSelection(): void;
    protected renderList(): void;
    protected updateDataSource(prop?: string): void;
    protected setUpdateInitial(props: string[], newProp: {
        [key: string]: string;
    }): void;
    /**
     * When property value changes happened, then onPropertyChanged method will execute the respective changes in this component.
     * @private
     */
    onPropertyChanged(newProp: DropDownBaseModel, oldProp: DropDownBaseModel): void;
    /**
     * Build and render the component
     * @private
     */
    render(isEmptyData?: boolean): void;
    /**
     * Return the module name of this component.
     * @private
     */
    getModuleName(): string;
    /**
     * Gets all the list items bound on this component.
     * @returns Element[].
     */
    getItems(): Element[];
    /**
     * Adds a new item to the popup list. By default, new item appends to the list as the last item,
     * but you can insert based on the index parameter.
     * @param  { Object[] } items - Specifies an array of JSON data or a JSON data.
     * @param { number } itemIndex - Specifies the index to place the newly added item in the popup list.
     * @return {void}.
     */
    addItem(items: {
        [key: string]: Object;
    }[] | {
        [key: string]: Object;
    }, itemIndex?: number): void;
    protected validationAttribute(target: HTMLElement, hidden: Element): void;
    protected setZIndex(): void;
    protected updateActionCompleteData(li: HTMLElement, item: {
        [key: string]: Object;
    }): void;
    /**
     * Gets the data Object that matches the given value.
     * @param { string | number } value - Specifies the value of the list item.
     * @returns Object.
     */
    getDataByValue(value: string | number): {
        [key: string]: Object;
    };
    /**
     * Removes the component from the DOM and detaches all its related event handlers. It also removes the attributes and classes.
     * @method destroy
     * @return {void}.
     */
    destroy(): void;
}
export interface FilteringEventArgs {
    /**
     * To prevent the internal filtering action.
     */
    preventDefaultAction: boolean;
    /**
     * Gets the `keyup` event arguments.
     */
    baseEventArgs: Object;
    /**
     * Illustrates whether the current action needs to be prevented or not.
     */
    cancel: boolean;
    /**
     * Search text value.
     */
    text: string;
    /**
     * To filter the data from given data source by using query
     * @param  {Object[] | data.DataManager } dataSource - Set the data source to filter.
     * @param  {data.Query} query - Specify the query to filter the data.
     * @param  {FieldSettingsModel} fields - Specify the fields to map the column in the data table.
     * @return {void}.
     */
    updateData(dataSource: {
        [key: string]: Object;
    }[] | data.DataManager | string[] | number[], query?: data.Query, fields?: FieldSettingsModel): void;
}
export interface PopupEventArgs {
    /**
     * Specifies the popup Object.
     */
    popup: popups.Popup;
    /**
     * Illustrates whether the current action needs to be prevented or not.
     */
    cancel?: boolean;
}
/**
 * export all modules from current location
 */
/**
 * Interface for a class DropDownList
 */
export interface DropDownListModel extends DropDownBaseModel{
    /**
     * Sets CSS classes to the root element of the component that allows customization of appearance.
     * @default null.
     */
    cssClass?: string;
    /**
     * Specifies the width of the component. By default, the component width sets based on the width of 
     * its parent container. You can also set the width in pixel values.
     * @default '100%'.
     */
    width?: string | number;
    /**
     * Specifies the height of the popup list.  
     * > For more details about the popup configuration refer to 
     * [`base.Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
     * @default '300px'.
     */
    popupHeight?: string | number;
    /**
     * Specifies the width of the popup list. By default, the popup width sets based on the width of 
     * the component.
     * > For more details about the popup configuration refer to 
     * [`base.Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
     * @default '100%'.
     */
    popupWidth?: string | number;
    /**
     * Specifies a short hint that describes the expected value of the DropDownList component.
     * @default null.
     */
    placeholder?: string;
    /**
     * Accepts the value to be displayed as a watermark text on the filter bar. 
     * @default null.
     */
    filterBarPlaceholder?: string;
    /**
     * Allows additional HTML base.attributes such as title, name, etc., and
     * accepts n number of base.attributes in a key-value pair format.
     * 
     * {% codeBlock src="dropdownlist/html-base.attributes-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="dropdownlist/html-base.attributes-api/index.html" %}{% endcodeBlock %}
     *
     * @default {}.
     */
    htmlAttributes?: { [key: string]: string; };
    /**
     * Accepts the external [`data.Query`](./api-query.html)
     * that execute along with data processing.
     * 
     * {% codeBlock src="dropdownlist/query-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="dropdownlist/query-api/index.html" %}{% endcodeBlock %}
     * 
     * @default null.
     */
    query?: data.Query;
    /**
     * Accepts the template design and assigns it to the selected list item in the input element of the component.
     * For more details about the available template options refer to 
     * [`Template`](./templates.html) documentation.
     * 
     * We have built-in [`template engine`](./template-engine.html) 
     * which provides options to base.compile template string into a executable function. 
     * For EX: We have expression evolution as like ES6 expression string literals.
     * @default null.
     */
    valueTemplate?: string;
    /**
     * Accepts the template design and assigns it to the header container of the popup list.
     * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
     * @default null.
     */
    headerTemplate?: string;
    /**
     * Accepts the template design and assigns it to the footer container of the popup list.
     * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
     * @default null.
     */
    footerTemplate?: string;
    /**
     * When allowFiltering is set to true, show the filter bar (search box) of the component.
     * The filter action retrieves matched items through the `filtering` event based on
     * the characters typed in the search TextBox.
     * 
     * If no match is found, the value of the `noRecordsTemplate` property will be displayed.
     * > For more details about the filtering refer to [`Filtering`](./filtering.html) documentation.
     * 
     * {% codeBlock src="dropdownlist/allow-filtering-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="dropdownlist/allow-filtering-api/index.html" %}{% endcodeBlock %}
     * @default false.
     */
    allowFiltering?: boolean;
    /**
     * When set to true, the user interactions on the component are disabled.
     * @default false.
     */
    readonly?: boolean;
    /**
     * Gets or sets the display text of the selected item in the component.
     * @default null.
     */
    text?: string;
    /**
     * Gets or sets the value of the selected item in the component.
     * @default null.
     */
    value?: number | string;
    /**
     * Gets or sets the index of the selected item in the component.
     * 
     * {% codeBlock src="dropdownlist/index-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="dropdownlist/index-api/index.html" %}{% endcodeBlock %}
     * 
     * @default null.
     */
    index?: number;
    /**
     * Specifies whether to display the floating label above the input element.
     * Possible values are:
     * * Never: The label will never float in the input when the placeholder is available.
     * * Always: The floating label will always float above the input.
     * * Auto: The floating label will float above the input after focusing or entering a value in the input.
     * 
     * {% codeBlock src="dropdownlist/float-label-type-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="dropdownlist/float-label-type-api/index.html" %}{% endcodeBlock %}
     * 
     *  @default 'Never'.
     */
    floatLabelType?: inputs.FloatLabelType;
    /**
     * Specifies whether to show or hide the clear button. 
     * When the clear button is clicked, `value`, `text`, and `index` properties are reset to null.
     * @default false.
     */
    showClearButton?: boolean;
    /**
     * Triggers on typing a character in the filter bar when the 
     * [`allowFiltering`](./api-dropDownList.html#allowfiltering) 
     * is enabled.
     * > For more details about the filtering refer to [`Filtering`](./filtering.html) documentation.
     * 
     * @event
     */
    filtering?: base.EmitType<FilteringEventArgs>;
    /**
     * Triggers when an item in a popup is selected or when the model value is changed by user.
     * Use change event to 
     * [`Configure the Cascading DropDownList`](./how-to.html#configure-the-cascading-dropdownlist)
     * @event
     */
    change?: base.EmitType<ChangeEventArgs>;
    /**
     * Triggers when the popup opens.
     * @event
     */
    open?: base.EmitType<PopupEventArgs>;
    /**
     * Triggers when the popup is closed.
     * @event
     */
    close?: base.EmitType<PopupEventArgs>;
    /**
     * Triggers when focus moves out from the component.
     * @event
     */
    blur?: base.EmitType<Object>;
    /**
     * Triggers when the component is focused.
     * @event
     */
    focus?: base.EmitType<Object>;
}

export interface ChangeEventArgs extends SelectEventArgs {
    /**
     * Returns the selected value
     */
    value: number | string;
}
export  const dropDownListClasses: DropDownListClassList;
/**
 * The DropDownList component contains a list of predefined values from which you can
 * choose a single value.
 * ```html
 * <input type="text" tabindex="1" id="list"> </input>
 * ```
 * ```typescript
 *   let dropDownListObj:DropDownList = new DropDownList();
 *   dropDownListObj.appendTo("#list");
 * ```
 */
export  class DropDownList extends DropDownBase implements inputs.IInput {
    protected inputWrapper: inputs.InputObject;
    protected inputElement: HTMLInputElement;
    private valueTempElement;
    private listObject;
    private header;
    private footer;
    protected selectedLI: HTMLElement;
    private listHeight;
    protected hiddenElement: HTMLSelectElement;
    protected isPopupOpen: boolean;
    private isDocumentClick;
    protected isInteracted: boolean;
    private isFilterFocus;
    protected beforePopupOpen: boolean;
    protected initial: boolean;
    private initRemoteRender;
    private searchBoxHeight;
    private popupObj;
    private backIconElement;
    private clearIconElement;
    private containerStyle;
    protected previousValue: string | number;
    protected activeIndex: number;
    protected filterInput: HTMLInputElement;
    private searchKeyModule;
    private tabIndex;
    private isNotSearchList;
    protected isTyped: boolean;
    protected isSelected: boolean;
    protected preventFocus: boolean;
    protected preventAutoFill: boolean;
    protected queryString: string;
    protected isValidKey: boolean;
    protected typedString: string;
    protected isEscapeKey: boolean;
    private isPreventBlur;
    protected isTabKey: boolean;
    private actionCompleteData;
    protected prevSelectPoints: {
        [key: string]: number;
    };
    protected isSelectCustom: boolean;
    protected isDropDownClick: boolean;
    protected preventAltUp: boolean;
    private searchKeyEvent;
    private filterInputObj;
    protected spinnerElement: HTMLElement;
    protected keyConfigure: {
        [key: string]: string;
    };
    protected isCustomFilter: boolean;
    private isSecondClick;
    /**
     * Sets CSS classes to the root element of the component that allows customization of appearance.
     * @default null.
     */
    cssClass: string;
    /**
     * Specifies the width of the component. By default, the component width sets based on the width of
     * its parent container. You can also set the width in pixel values.
     * @default '100%'.
     */
    width: string | number;
    /**
     * Specifies the height of the popup list.
     * > For more details about the popup configuration refer to
     * [`Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
     * @default '300px'.
     */
    popupHeight: string | number;
    /**
     * Specifies the width of the popup list. By default, the popup width sets based on the width of
     * the component.
     * > For more details about the popup configuration refer to
     * [`Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
     * @default '100%'.
     */
    popupWidth: string | number;
    /**
     * Specifies a short hint that describes the expected value of the DropDownList component.
     * @default null.
     */
    placeholder: string;
    /**
     * Accepts the value to be displayed as a watermark text on the filter bar.
     * @default null.
     */
    filterBarPlaceholder: string;
    /**
     * Allows additional HTML attributes such as title, name, etc., and
     * accepts n number of attributes in a key-value pair format.
     *
     * {% codeBlock src="dropdownlist/html-attributes-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="dropdownlist/html-attributes-api/index.html" %}{% endcodeBlock %}
     *
     * @default {}.
     */
    htmlAttributes: {
        [key: string]: string;
    };
    /**
     * Accepts the external [`data.Query`](./api-query.html)
     * that execute along with data processing.
     *
     * {% codeBlock src="dropdownlist/query-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="dropdownlist/query-api/index.html" %}{% endcodeBlock %}
     *
     * @default null.
     */
    query: data.Query;
    /**
     * Accepts the template design and assigns it to the selected list item in the input element of the component.
     * For more details about the available template options refer to
     * [`Template`](./templates.html) documentation.
     *
     * We have built-in [`template engine`](./template-engine.html)
     * which provides options to compile template string into a executable function.
     * For EX: We have expression evolution as like ES6 expression string literals.
     * @default null.
     */
    valueTemplate: string;
    /**
     * Accepts the template design and assigns it to the header container of the popup list.
     * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
     * @default null.
     */
    headerTemplate: string;
    /**
     * Accepts the template design and assigns it to the footer container of the popup list.
     * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
     * @default null.
     */
    footerTemplate: string;
    /**
     * When allowFiltering is set to true, show the filter bar (search box) of the component.
     * The filter action retrieves matched items through the `filtering` event based on
     * the characters typed in the search TextBox.
     *
     * If no match is found, the value of the `noRecordsTemplate` property will be displayed.
     * > For more details about the filtering refer to [`Filtering`](./filtering.html) documentation.
     *
     * {% codeBlock src="dropdownlist/allow-filtering-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="dropdownlist/allow-filtering-api/index.html" %}{% endcodeBlock %}
     * @default false.
     */
    allowFiltering: boolean;
    /**
     * When set to true, the user interactions on the component are disabled.
     * @default false.
     */
    readonly: boolean;
    /**
     * Gets or sets the display text of the selected item in the component.
     * @default null.
     */
    text: string;
    /**
     * Gets or sets the value of the selected item in the component.
     * @default null.
     */
    value: number | string;
    /**
     * Gets or sets the index of the selected item in the component.
     *
     * {% codeBlock src="dropdownlist/index-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="dropdownlist/index-api/index.html" %}{% endcodeBlock %}
     *
     * @default null.
     */
    index: number;
    /**
     * Specifies whether to display the floating label above the input element.
     * Possible values are:
     * * Never: The label will never float in the input when the placeholder is available.
     * * Always: The floating label will always float above the input.
     * * Auto: The floating label will float above the input after focusing or entering a value in the input.
     *
     * {% codeBlock src="dropdownlist/float-label-type-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="dropdownlist/float-label-type-api/index.html" %}{% endcodeBlock %}
     *
     *  @default 'Never'.
     */
    floatLabelType: inputs.FloatLabelType;
    /**
     * Specifies whether to show or hide the clear button.
     * When the clear button is clicked, `value`, `text`, and `index` properties are reset to null.
     * @default false.
     */
    showClearButton: boolean;
    /**
     * Triggers on typing a character in the filter bar when the
     * [`allowFiltering`](./api-dropDownList.html#allowfiltering)
     * is enabled.
     * > For more details about the filtering refer to [`Filtering`](./filtering.html) documentation.
     *
     * @event
     */
    filtering: base.EmitType<FilteringEventArgs>;
    /**
     * Triggers when an item in a popup is selected or when the model value is changed by user.
     * Use change event to
     * [`Configure the Cascading DropDownList`](./how-to.html#configure-the-cascading-dropdownlist)
     * @event
     */
    change: base.EmitType<ChangeEventArgs>;
    /**
     * Triggers when the popup opens.
     * @event
     */
    open: base.EmitType<PopupEventArgs>;
    /**
     * Triggers when the popup is closed.
     * @event
     */
    close: base.EmitType<PopupEventArgs>;
    /**
     * Triggers when focus moves out from the component.
     * @event
     */
    blur: base.EmitType<Object>;
    /**
     * Triggers when the component is focused.
     * @event
     */
    focus: base.EmitType<Object>;
    /**
     * * Constructor for creating the DropDownList component.
     */
    constructor(options?: DropDownListModel, element?: string | HTMLElement);
    /**
     * Initialize the event handler.
     * @private
     */
    protected preRender(): void;
    private initializeData();
    protected setZIndex(): void;
    protected renderList(isEmptyData?: boolean): void;
    private floatLabelChange();
    protected resetHandler(e: MouseEvent): void;
    protected resetFocusElement(): void;
    protected clear(e?: MouseEvent | base.KeyboardEventArgs, property?: string): void;
    private resetSelection();
    private setHTMLAttributes();
    protected getAriaAttributes(): {
        [key: string]: string;
    };
    protected setEnableRtl(): void;
    private setEnable();
    /**
     * Get the properties to be maintained in the persisted state.
     */
    protected getPersistData(): string;
    private preventTabIndex(element);
    protected targetElement(): HTMLElement | HTMLInputElement;
    protected getNgDirective(): string;
    protected getElementByText(text: string): Element;
    protected getElementByValue(value: string | number): Element;
    private initValue();
    protected updateValues(): void;
    protected onBlur(e: MouseEvent): void;
    protected focusOutAction(): void;
    protected onFocusOut(): void;
    protected onFocus(): void;
    protected wireEvent(): void;
    protected bindCommonEvent(): void;
    private bindClearEvent();
    protected unBindCommonEvent(): void;
    protected updateIconState(): void;
    /**
     * Event binding for list
     */
    private wireListEvents();
    private onSearch(e);
    protected onMouseClick(e: MouseEvent): void;
    private onMouseOver(e);
    private setHover(li);
    private onMouseLeave(e);
    private removeHover();
    protected isValidLI(li: Element | HTMLElement): boolean;
    protected incrementalSearch(e: base.KeyboardEventArgs): void;
    protected hideSpinner(): void;
    protected showSpinner(): void;
    protected keyActionHandler(e: base.KeyboardEventArgs): void;
    protected selectCurrentItem(e: base.KeyboardEventArgs): void;
    protected isSelectFocusItem(element: Element): boolean;
    private getPageCount();
    private pageUpSelection(steps, event);
    private pageDownSelection(steps, event);
    protected unWireEvent(): void;
    /**
     * Event un binding for list items.
     */
    private unWireListEvents();
    protected onDocumentClick(e: MouseEvent): void;
    private activeStateChange();
    private focusDropDown(e?);
    protected dropDownClick(e: MouseEvent): void;
    protected cloneElements(): void;
    protected updateSelectedItem(li: Element, e: MouseEvent | KeyboardEvent | TouchEvent, preventSelect?: boolean): boolean;
    protected activeItem(li: Element): void;
    protected setValue(e?: base.KeyboardEventArgs): boolean;
    protected setSelection(li: Element, e: MouseEvent | base.KeyboardEventArgs | TouchEvent): void;
    private setValueTemplate();
    protected removeSelection(): void;
    protected getItemData(): {
        [key: string]: string;
    };
    /**
     * To trigger the change event for list.
     */
    protected onChangeEvent(eve: MouseEvent | KeyboardEvent | TouchEvent): void;
    protected detachChangeEvent(eve: MouseEvent | KeyboardEvent | TouchEvent): void;
    protected setHiddenValue(): void;
    /**
     * Filter bar implementation
     */
    protected onFilterUp(e: base.KeyboardEventArgs): void;
    protected onFilterDown(e: base.KeyboardEventArgs): void;
    protected removeFillSelection(): void;
    protected getSelectionPoints(): {
        [key: string]: number;
    };
    protected searchLists(e: base.KeyboardEventArgs): void;
    private filteringAction(dataSource, query?, fields?);
    protected setSearchBox(popupElement: HTMLElement): inputs.InputObject;
    protected onInput(): void;
    protected onActionFailure(e: Object): void;
    protected onActionComplete(ulElement: HTMLElement, list: {
        [key: string]: Object;
    }[], e?: Object, isUpdated?: boolean): void;
    private addNewItem(listData, newElement);
    protected updateActionCompleteData(li: HTMLElement, item: {
        [key: string]: Object;
    }): void;
    private focusIndexItem();
    protected updateSelection(): void;
    protected removeFocus(): void;
    protected renderPopup(): void;
    private checkCollision(popupEle);
    private getOffsetValue(popupEle);
    private createPopup(element, offsetValue, left);
    private isEmptyList();
    protected getFocusElement(): void;
    private isFilterLayout();
    private scrollHandler();
    private setSearchBoxPosition();
    private setPopupPosition(border?);
    private setWidth();
    private scrollBottom(isInitial?);
    private scrollTop();
    protected isEditTextBox(): boolean;
    protected isFiltering(): boolean;
    protected isPopupButton(): boolean;
    protected setScrollPosition(e?: base.KeyboardEventArgs): void;
    private clearText();
    private listScroll();
    private closePopup(delay?);
    private destroyPopup();
    private clickOnBackIcon();
    /**
     * To Initialize the control rendering
     * @private
     */
    render(): void;
    private setFooterTemplate(popupEle);
    protected setOldText(text: string): void;
    protected setOldValue(value: string | number): void;
    protected refreshPopup(): void;
    protected updateDataSource(prop?: string): void;
    /**
     * Dynamically change the value of properties.
     * @private
     */
    onPropertyChanged(newProp: DropDownListModel, oldProp: DropDownListModel): void;
    /**
     * Return the module name.
     * @private
     */
    getModuleName(): string;
    /**
     * Opens the popup that displays the list of items.
     * @returns void.
     */
    showPopup(): void;
    /**
     * Hides the popup if it is in an open state.
     * @returns void.
     */
    hidePopup(): void;
    /**
     * Sets the focus on the component for interaction.
     * @returns void.
     */
    focusIn(): void;
    /**
     * Moves the focus from the component if the component is already focused.
     * @returns void.
     */
    focusOut(): void;
    /**
     * Removes the component from the DOM and detaches all its related event handlers. Also it removes the attributes and classes.
     * @method destroy
     * @return {void}.
     */
    destroy(): void;
}
export interface DropDownListClassList {
    root: string;
    hover: string;
    selected: string;
    rtl: string;
    base: string;
    disable: string;
    input: string;
    inputFocus: string;
    li: string;
    icon: string;
    iconAnimation: string;
    value: string;
    focus: string;
    device: string;
    backIcon: string;
    filterBarClearIcon: string;
    filterInput: string;
    filterParent: string;
    mobileFilter: string;
    footer: string;
    header: string;
    clearIcon: string;
    clearIconHide: string;
    popupFullScreen: string;
    disableIcon: string;
    hiddenElement: string;
}
/**
 * export all modules from current location
 */
/**
 * export all modules from current location
 */
/**
 * The Multiselect enable CheckBoxSelection call this inject module.
 */
export  class CheckBoxSelection {
    private parent;
    private checkAllParent;
    private selectAllSpan;
    filterInput: HTMLInputElement;
    private filterParent;
    private filterInputObj;
    private backIconElement;
    private clearIconElement;
    private checkWrapper;
    list: HTMLElement;
    private activeLi;
    private activeEle;
    constructor(parent?: IMulitSelect);
    getModuleName(): string;
    addEventListener(): void;
    removeEventListener(): void;
    listOption(args: {
        [key: string]: Object;
    }): void;
    private setPlaceholder(props);
    private checboxCreate(e);
    private setSelectAll();
    destroy(): void;
    listSelection(args: IUpdateListArgs): void;
    private validateCheckNode(checkWrap, isCheck, li?, e?, selectAll?);
    private clickHandler(e);
    private changeState(wrapper, state, e?, isPrevent?, selectAll?);
    protected setSearchBox(args: IUpdateListArgs): inputs.InputObject | void;
    private clickOnBackIcon(e);
    private clearText(e);
    private setDeviceSearchBox();
    private setSearchBoxPosition();
    protected targetElement(): string;
    private onBlur(e);
    protected onDocumentClick(e: MouseEvent): void;
    private getFocus(e);
    private checkSelectAll(e);
    private setLocale(unSelect?);
    private getActiveList(args);
    private setReorder(args);
}
export interface ItemCreatedArgs {
    curData: {
        [key: string]: Object;
    };
    item: HTMLElement;
    text: string;
}
export interface IUpdateListArgs {
    module: string;
    enable: boolean;
    li: HTMLElement;
    e: MouseEvent | base.KeyboardEventArgs;
    popupElement: HTMLElement;
    value: string;
    index: number;
}
/**
 * export all modules from current location
 */
/**
 * Specifies mulitselct interfaces.
 * @hidden
 */
export interface IMulitSelect extends base.Component<HTMLElement> {
    listCurrentOptions?: {
        [key: string]: Object;
    };
    inputElement?: HTMLInputElement;
    popupWrapper?: HTMLDivElement;
    selectAll?(state?: boolean): void;
    selectAllHeight?: number;
    searchBoxHeight?: number;
    onInput?(): void;
    filterInput?: HTMLInputElement;
    KeyUp?(e?: base.KeyboardEventArgs): void;
    onKeyDown?(e?: base.KeyboardEventArgs): void;
    mainList?: HTMLElement;
    list?: HTMLElement;
    targetElement?(): string;
    targetInputElement?: HTMLInputElement | string;
    selectAllText?: string;
    unSelectAllText?: string;
    popupObj?: popups.Popup;
    onDocumentFocus?: boolean;
    hidePopup?(): void;
    refreshPopup?(): void;
    refreshListItems?(data?: string): void;
    filterBarPlaceholder?: string;
    overAllWrapper?: HTMLDivElement;
    templateList?: {
        [key: string]: Object;
    };
    itemTemplate?: string;
    headerTemplate?: string;
    mobFilter?: boolean;
    header?: HTMLElement;
    updateDelimView?(): void;
    updateValueState?(event?: base.KeyboardEventArgs | MouseEvent, newVal?: [string | number], oldVal?: [string | number]): void;
    tempValues?: [number | string];
    value?: [number | string];
    refreshInputHight?(): void;
    refreshPlaceHolder?(): void;
    ulElement?: HTMLElement;
    hiddenElement?: HTMLSelectElement;
    dispatchEvent?(element?: HTMLElement, type?: string): void;
    inputFocus?: boolean;
    enableSelectionOrder?: boolean;
    focusAtFirstListItem(): void;
    isPopupOpen(): boolean;
    showSelectAll: boolean;
    scrollFocusStatus: boolean;
    focused: boolean;
    onBlur(eve?: MouseEvent): void;
}
/**
 * Interface for a class MultiSelect
 */
export interface MultiSelectModel extends DropDownBaseModel{
    /**
     * Sets the CSS classes to root element of this component which helps to customize the
     * complete styles.
     * @default null
     */
    cssClass?: string;
    /**
     * Gets or sets the width of the component. By default, it sizes based on its parent.
     * container dimension.
     * @default '100%'
     */
    width?: string | number;
    /**
     * Gets or sets the height of the popup list. By default it renders based on its list item.
     * > For more details about the popup configuration refer to 
     * [`Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
     * 
     * @default '300px'
     */
    popupHeight?: string | number;
    /**
     * Gets or sets the width of the popup list and percentage values has calculated based on input width.
     * > For more details about the popup configuration refer to 
     * [`Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
     * 
     * @default '100%'
     */
    popupWidth?: string | number;
    /**
     * Gets or sets the placeholder in the component to display the given information
     * in input when no item selected. 
     * @default null
     */
    placeholder?: string;
    /**
     * Accepts the value to be displayed as a watermark text on the filter bar. 
     * @default null.
     */
    filterBarPlaceholder?: string;
    /**
     * Gets or sets the additional attribute to `HtmlAttributes` property in MultiSelect,
     * which helps to add attribute like title, name etc, input should be key value pair.
     * 
     * {% codeBlock src="multiselect/html-attributes-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="multiselect/html-attributes-api/index.html" %}{% endcodeBlock %}
     * @default {}
     */
    htmlAttributes?: { [key: string]: string; };
    /**
     * Accepts the template design and assigns it to the selected list item in the input element of the component.
     * For more details about the available template options refer to 
     * [`Template`](./templates.html) documentation.
     * 
     * We have built-in [`template engine`](./template-engine.html) 
     * which provides options to compile template string into a executable function. 
     * For EX: We have expression evolution as like ES6 expression string literals.
     * @default null
     */
    valueTemplate?: string;
    /**
     * Accepts the template design and assigns it to the header container of the popup list.
     * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
     * 
     * @default null
     */
    headerTemplate?: string;
    /**
     * Accepts the template design and assigns it to the footer container of the popup list.
     * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
     * 
     * @default null
     */
    footerTemplate?: string;
    /**
     * Accepts the template design and assigns it to each list item present in the popup.
     * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
     * 
     * We have built-in [`template engine`](./template-engine.html) 
     * which provides options to compile template string into a executable function. 
     * For EX: We have expression evolution as like ES6 expression string literals.
     * @default null
     */
    itemTemplate?: string;
    /**
     * To enable the filtering option in this component. 
     * Filter action performs when type in search box and collect the matched item through `filtering` event.
     * If searching character does not match, `noRecordsTemplate` property value will be shown.
     * 
     * {% codeBlock src="multiselect/allow-filtering-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="multiselect/allow-filtering-api/index.html" %}{% endcodeBlock %}
     * 
     * @default false
     */
    allowFiltering?: boolean;
    /**
     * Allows user to add a 
     * [`custom value`](./custom-value.html), the value which is not present in the suggestion list. 
     * @default false
     */
    allowCustomValue?: boolean;
    /**
     * Enables close icon with the each selected item.
     * @default true
     */
    showClearButton?: boolean;
    /**
     * Sets limitation to the value selection.
     * based on the limitation, list selection will be prevented.
     * @default 1000
     */
    maximumSelectionLength?: number;
    /**
     * Gets or sets the `readonly` to input or not. Once enabled, just you can copy or highlight 
     * the text however tab key action will perform.
     * 
     * @default false
     */
    readonly?: boolean;
    /**
     * Selects the list item which maps the data `text` field in the component.
     * @default null
     */
    text?: string;
    /**
     * Selects the list item which maps the data `value` field in the component.
     * @default null
     */
    value?: number[] | string[];
    /**
     * Hides the selected item from the list item.
     * @default true
     */
    hideSelectedItem?: boolean;
    /**
     * Based on the property, when item get select popup visibility state will changed.
     * @default true
     */
    closePopupOnSelect?: boolean;
    /**
     * configures visibility mode for component interaction.
     * 
     *   - `Box` - selected items will be visualized in chip.
     * 
     *   - `Delimiter` - selected items will be visualized in text content.
     * 
     *   - `Default` - on `focus in` component will act in `box` mode.
     *    on `blur` component will act in `delimiter` mode.
     * 
     *   - `CheckBox` - The 'checkbox' will be visualized in list item.
     * 
     * {% codeBlock src="multiselect/visual-mode-api/index.ts" %}{% endcodeBlock %}
     * 
     * {% codeBlock src="multiselect/visual-mode-api/index.html" %}{% endcodeBlock %}
     * 
     * @default Default
     */
    mode?: visualMode;
    /**
     * Sets the delimiter character for 'default' and 'delimiter' visibility modes.
     * @default ,
     */
    delimiterChar?: string;
    /**
     * Sets [`case sensitive`](./filtering.html#case-sensitive-filtering) 
     * option for filter operation.
     * @default true
     */
    ignoreCase?: boolean;
    /**
     * Allows you to either show or hide the DropDown button on the component
     * 
     * @default false
     */
    showDropDownIcon?: boolean;
    /**
     * Allows you to either show or hide the selectAll option on the component.
     * 
     * @default false
     */
    showSelectAll?: boolean;
    /**
     * Specifies the selectAllText to be displayed on the component.
     * 
     * @default 'select All'
     */
    selectAllText?: string;
    /**
     * Specifies the UnSelectAllText to be displayed on the component.
     * 
     * @default 'select All'
     */
    unSelectAllText?: string;
    /**
     * Reorder the selected items in popup visibility state.
     * 
     * @default true
     */
    enableSelectionOrder?: boolean;
    /**
     * Whether to automatically open the popup when the control is clicked.
     * @default true
     */
    openOnClick?: boolean;
    /**
     * Fires each time when selection changes happened in list items after model and input value get affected.
     * @event
     */
    change?: base.EmitType<MultiSelectChangeEventArgs>;
    /**
     * Fires before the selected item removed from the widget.
     * @event
     */
    removing?: base.EmitType<RemoveEventArgs>;
    /**
     * Fires after the selected item removed from the widget.
     * @event
     */
    removed?: base.EmitType<RemoveEventArgs>;
    /**
     * Fires when popup opens after animation completion.
     * @event
     */
    open?: base.EmitType<PopupEventArgs>;
    /**
     * Fires when popup close after animation completion.
     * @event
     */
    close?: base.EmitType<PopupEventArgs>;
    /**
     * Event triggers when the input get focus-out.
     * @event
     */
    blur?: base.EmitType<Object>;
    /**
     * Event triggers when the input get focused.
     * @event
     */
    focus?: base.EmitType<Object>;
    /**
     * Event triggers when the chip selection.
     * @event
     */
    chipSelection?: base.EmitType<Object>;
    /**
     * Triggers event,when user types a text in search box.
     * > For more details about filtering, refer to [`Filtering`](./filtering.html) documentation.
     * 
     * @event
     */
    filtering?: base.EmitType<FilteringEventArgs>;
    /**
     * Fires before set the selected item as chip in the component.
     * > For more details about chip customization refer [`Chip Customization`](./chip-customization.html)
     * 
     * @event
     */
    tagging?: base.EmitType<TaggingEventArgs>;
    /**
     * Triggers when the [`customValue`](./custom-value.html) is selected.
     * @event
     */
    customValueSelection?: base.EmitType<CustomValueEventArgs>;
}

export interface RemoveEventArgs extends SelectEventArgs {
}
/**
 * The Multiselect allows the user to pick a more than one value from list of predefined values.
 * ```html
 * <select id="list">
 *      <option value='1'>Badminton</option>
 *      <option value='2'>Basketball</option>
 *      <option value='3'>Cricket</option>
 *      <option value='4'>Football</option>
 *      <option value='5'>Tennis</option>
 * </select>
 * ```
 * ```typescript
 * <script>
 *   var multiselectObj = new Multiselect();
 *   multiselectObj.appendTo("#list");
 * </script>
 * ```
 */
export  class MultiSelect extends DropDownBase implements inputs.IInput {
    private spinnerElement;
    private selectAllAction;
    private setInitialValue;
    private setDynValue;
    private listCurrentOptions;
    private targetInputElement;
    private selectAllHeight?;
    private searchBoxHeight?;
    private mobFilter?;
    private isFiltered;
    private isFirstClick;
    private focused;
    private initial;
    private backCommand;
    /**
     * Sets the CSS classes to root element of this component which helps to customize the
     * complete styles.
     * @default null
     */
    cssClass: string;
    /**
     * Gets or sets the width of the component. By default, it sizes based on its parent.
     * container dimension.
     * @default '100%'
     */
    width: string | number;
    /**
     * Gets or sets the height of the popup list. By default it renders based on its list item.
     * > For more details about the popup configuration refer to
     * [`Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
     *
     * @default '300px'
     */
    popupHeight: string | number;
    /**
     * Gets or sets the width of the popup list and percentage values has calculated based on input width.
     * > For more details about the popup configuration refer to
     * [`Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
     *
     * @default '100%'
     */
    popupWidth: string | number;
    /**
     * Gets or sets the placeholder in the component to display the given information
     * in input when no item selected.
     * @default null
     */
    placeholder: string;
    /**
     * Accepts the value to be displayed as a watermark text on the filter bar.
     * @default null.
     */
    filterBarPlaceholder: string;
    /**
     * Gets or sets the additional attribute to `HtmlAttributes` property in MultiSelect,
     * which helps to add attribute like title, name etc, input should be key value pair.
     *
     * {% codeBlock src="multiselect/html-attributes-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="multiselect/html-attributes-api/index.html" %}{% endcodeBlock %}
     * @default {}
     */
    htmlAttributes: {
        [key: string]: string;
    };
    /**
     * Accepts the template design and assigns it to the selected list item in the input element of the component.
     * For more details about the available template options refer to
     * [`Template`](./templates.html) documentation.
     *
     * We have built-in [`template engine`](./template-engine.html)
     * which provides options to compile template string into a executable function.
     * For EX: We have expression evolution as like ES6 expression string literals.
     * @default null
     */
    valueTemplate: string;
    /**
     * Accepts the template design and assigns it to the header container of the popup list.
     * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
     *
     * @default null
     */
    headerTemplate: string;
    /**
     * Accepts the template design and assigns it to the footer container of the popup list.
     * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
     *
     * @default null
     */
    footerTemplate: string;
    /**
     * Accepts the template design and assigns it to each list item present in the popup.
     * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
     *
     * We have built-in [`template engine`](./template-engine.html)
     * which provides options to compile template string into a executable function.
     * For EX: We have expression evolution as like ES6 expression string literals.
     * @default null
     */
    itemTemplate: string;
    /**
     * To enable the filtering option in this component.
     * Filter action performs when type in search box and collect the matched item through `filtering` event.
     * If searching character does not match, `noRecordsTemplate` property value will be shown.
     *
     * {% codeBlock src="multiselect/allow-filtering-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="multiselect/allow-filtering-api/index.html" %}{% endcodeBlock %}
     *
     * @default false
     */
    allowFiltering: boolean;
    /**
     * Allows user to add a
     * [`custom value`](./custom-value.html), the value which is not present in the suggestion list.
     * @default false
     */
    allowCustomValue: boolean;
    /**
     * Enables close icon with the each selected item.
     * @default true
     */
    showClearButton: boolean;
    /**
     * Sets limitation to the value selection.
     * based on the limitation, list selection will be prevented.
     * @default 1000
     */
    maximumSelectionLength: number;
    /**
     * Gets or sets the `readonly` to input or not. Once enabled, just you can copy or highlight
     * the text however tab key action will perform.
     *
     * @default false
     */
    readonly: boolean;
    /**
     * Selects the list item which maps the data `text` field in the component.
     * @default null
     */
    text: string;
    /**
     * Selects the list item which maps the data `value` field in the component.
     * @default null
     */
    value: number[] | string[];
    /**
     * Hides the selected item from the list item.
     * @default true
     */
    hideSelectedItem: boolean;
    /**
     * Based on the property, when item get select popup visibility state will changed.
     * @default true
     */
    closePopupOnSelect: boolean;
    /**
     * configures visibility mode for component interaction.
     *
     *   - `Box` - selected items will be visualized in chip.
     *
     *   - `Delimiter` - selected items will be visualized in text content.
     *
     *   - `Default` - on `focus in` component will act in `box` mode.
     *    on `blur` component will act in `delimiter` mode.
     *
     *   - `CheckBox` - The 'checkbox' will be visualized in list item.
     *
     * {% codeBlock src="multiselect/visual-mode-api/index.ts" %}{% endcodeBlock %}
     *
     * {% codeBlock src="multiselect/visual-mode-api/index.html" %}{% endcodeBlock %}
     *
     * @default Default
     */
    mode: visualMode;
    /**
     * Sets the delimiter character for 'default' and 'delimiter' visibility modes.
     * @default ,
     */
    delimiterChar: string;
    /**
     * Sets [`case sensitive`](./filtering.html#case-sensitive-filtering)
     * option for filter operation.
     * @default true
     */
    ignoreCase: boolean;
    /**
     * Allows you to either show or hide the DropDown button on the component
     *
     * @default false
     */
    showDropDownIcon: boolean;
    /**
     * Allows you to either show or hide the selectAll option on the component.
     *
     * @default false
     */
    showSelectAll: boolean;
    /**
     * Specifies the selectAllText to be displayed on the component.
     *
     * @default 'select All'
     */
    selectAllText: string;
    /**
     * Specifies the UnSelectAllText to be displayed on the component.
     *
     * @default 'select All'
     */
    unSelectAllText: string;
    /**
     * Reorder the selected items in popup visibility state.
     *
     * @default true
     */
    enableSelectionOrder: boolean;
    /**
     * Whether to automatically open the popup when the control is clicked.
     * @default true
     */
    openOnClick: boolean;
    /**
     * Fires each time when selection changes happened in list items after model and input value get affected.
     * @event
     */
    change: base.EmitType<MultiSelectChangeEventArgs>;
    /**
     * Fires before the selected item removed from the widget.
     * @event
     */
    removing: base.EmitType<RemoveEventArgs>;
    /**
     * Fires after the selected item removed from the widget.
     * @event
     */
    removed: base.EmitType<RemoveEventArgs>;
    /**
     * Fires when popup opens after animation completion.
     * @event
     */
    open: base.EmitType<PopupEventArgs>;
    /**
     * Fires when popup close after animation completion.
     * @event
     */
    close: base.EmitType<PopupEventArgs>;
    /**
     * Event triggers when the input get focus-out.
     * @event
     */
    blur: base.EmitType<Object>;
    /**
     * Event triggers when the input get focused.
     * @event
     */
    focus: base.EmitType<Object>;
    /**
     * Event triggers when the chip selection.
     * @event
     */
    chipSelection: base.EmitType<Object>;
    /**
     * Triggers event,when user types a text in search box.
     * > For more details about filtering, refer to [`Filtering`](./filtering.html) documentation.
     *
     * @event
     */
    filtering: base.EmitType<FilteringEventArgs>;
    /**
     * Fires before set the selected item as chip in the component.
     * > For more details about chip customization refer [`Chip Customization`](./chip-customization.html)
     *
     * @event
     */
    tagging: base.EmitType<TaggingEventArgs>;
    /**
     * Triggers when the [`customValue`](./custom-value.html) is selected.
     * @event
     */
    customValueSelection: base.EmitType<CustomValueEventArgs>;
    /**
     * Constructor for creating the DropDownList widget.
     */
    constructor(option?: MultiSelectModel, element?: string | HTMLElement);
    private isValidKey;
    private mainList;
    ulElement: HTMLElement;
    private mainData;
    private mainListCollection;
    private customValueFlag;
    private inputElement;
    private componentWrapper;
    private overAllWrapper;
    private searchWrapper;
    private viewWrapper;
    private chipCollectionWrapper;
    private overAllClear;
    private dropIcon;
    private hiddenElement;
    private delimiterWrapper;
    private popupObj;
    private inputFocus;
    private header;
    private footer;
    private initStatus;
    private popupWrapper;
    private keyCode;
    private beforePopupOpen;
    private remoteCustomValue;
    private filterAction;
    private enableRTL(state);
    requiredModules(): base.ModuleDeclaration[];
    private updateHTMLAttribute();
    private updateReadonly(state);
    private updateClearButton(state);
    private updateCssClass();
    private onPopupShown();
    private focusAtFirstListItem();
    private focusAtLastListItem(data);
    protected getAriaAttributes(): {
        [key: string]: string;
    };
    private updateListARIA();
    private removelastSelection(e);
    protected onActionFailure(e: Object): void;
    protected targetElement(): string;
    protected onActionComplete(ulElement: HTMLElement, list: {
        [key: string]: Object;
    }[], e?: Object, isUpdated?: boolean): void;
    private refreshSelection();
    private hideGroupItem(value);
    private checkSelectAll();
    private openClick(e);
    private KeyUp(e);
    protected getQuery(query: data.Query): data.Query;
    private dataUpdater(dataSource, query?, fields?);
    private tempQuery;
    private tempValues;
    private checkForCustomValue(query?, fields?);
    protected getNgDirective(): string;
    private wrapperClick(e);
    private enable(state);
    private scrollFocusStatus;
    private keyDownStatus;
    private onBlur(eve?);
    private refreshInputHight();
    private validateValues(newValue, oldValue);
    private updateValueState(event, newVal, oldVal);
    private getPagingCount();
    private pageUpSelection(steps);
    private pageDownSelection(steps);
    getItems(): Element[];
    private focusIn();
    private showDelimWrapper();
    private hideDelimWrapper();
    private expandTextbox();
    private isPopupOpen();
    private refreshPopup();
    private checkTextLength();
    private popupKeyActions(keyCode);
    private updateAriaAttribute();
    private onKeyDown(e);
    private checkBackCommand(e);
    private keyNavigation(e);
    private selectByKey(e);
    private escapeAction();
    private scrollBottom(selectedLI, activeIndex);
    private scrollTop(selectedLI, activeIndex);
    private selectListByKey(e);
    private refreshListItems(data);
    private removeSelectedChip(e);
    private moveByTop(state);
    private moveByList(position);
    private moveBy(position, e?);
    private chipClick(e);
    private removeChipSelection();
    private addChipSelection(element, e?);
    private onChipRemove(e);
    private makeTextBoxEmpty();
    private refreshPlaceHolder();
    private removeValue(value, eve);
    private updateMainList(state, value);
    private removeChip(value);
    private updateChipStatus();
    private addValue(value, text, eve);
    private checkMaxSelection();
    private dispatchSelect(value, eve, element, isNotTrigger);
    private addChip(text, value, e?);
    private removeChipFocus();
    private onMobileChipInteraction(e);
    private getChip(data, value, e?);
    private calcPopupWidth();
    private mouseIn();
    private mouseOut();
    protected listOption(dataSource: {
        [key: string]: Object;
    }[], fields: FieldSettingsModel): FieldSettingsModel;
    private renderPopup();
    private ClearAll(e);
    private windowResize();
    protected wireEvent(): void;
    private onInput();
    protected preRender(): void;
    private initializeData();
    private updateData(delimiterChar);
    private initialValueUpdate();
    protected isValidLI(li: Element | HTMLElement): boolean;
    protected updateListSelection(li: Element, e: MouseEvent | base.KeyboardEventArgs): void;
    protected removeListSelection(): void;
    private removeHover();
    private removeFocus();
    private addListHover(li);
    private addListFocus(element);
    private addListSelection(element);
    private updateDelimeter(delimChar);
    private onMouseClick(e);
    private onMouseOver(e);
    private onMouseLeave(e);
    private onListMouseDown(e);
    private onDocumentClick(e);
    private wireListEvents();
    private unwireListEvents();
    private hideOverAllClear();
    private showOverAllClear();
    protected showSpinner(): void;
    protected hideSpinner(): void;
    private updateDelimView();
    private unWireEvent();
    private selectAllItem(state);
    protected setZIndex(): void;
    protected updateDataSource(prop?: string): void;
    private onLoadSelect();
    /**
     * Get the properties to be maintained in the persisted state.
     */
    protected getPersistData(): string;
    /**
     * Dynamically change the value of properties.
     * @private
     */
    onPropertyChanged(newProp: MultiSelectModel, oldProp: MultiSelectModel): void;
    /**
     * Hides the popup, if the popup in a open state.
     * @returns void
     */
    hidePopup(): void;
    /**
     * Shows the popup, if the popup in a closed state.
     * @returns void
     */
    showPopup(): void;
    /**
     * Based on the state parameter, entire list item will be selected/deselected.
     * parameter
     * `true`   - Selects entire list items.
     * `false`  - Un Selects entire list items.
     * @returns void
     */
    selectAll(state: boolean): void;
    getModuleName(): string;
    /**
     * To Initialize the control rendering
     * @private
     */
    render(): void;
    private dropDownIcon();
    private initialUpdate();
    /**
     * Removes the component from the DOM and detaches all its related event handlers. Also it removes the attributes and classes.
     * @method destroy
     * @return {void}
     */
    destroy(): void;
}
export interface CustomValueEventArgs {
    /**
     * Gets the newly added data.
     */
    newData: Object;
    /**
     * Illustrates whether the current action needs to be prevented or not.
     */
    cancel: boolean;
}
export interface TaggingEventArgs {
    /**
     * If the event is triggered by interaction, it returns true. Otherwise, it returns false.
     */
    isInteracted: boolean;
    /**
     * Returns the selected item as JSON Object from the data source.
     */
    itemData: FieldSettingsModel;
    /**
     * Specifies the original event arguments.
     */
    e: MouseEvent | KeyboardEvent | TouchEvent;
    /**
     * To set the classes to chip element
     * @param  { string } classes - Specify the classes to chip element.
     * @return {void}.
     */
    setClass: Function;
}
export interface MultiSelectChangeEventArgs {
    /**
     * If the event is triggered by interaction, it returns true. Otherwise, it returns false.
     */
    isInteracted: boolean;
    /**
     * Returns the component initial Value.
     */
    oldValue: number[] | string[];
    /**
     * Returns the updated component Values.
     */
    value: number[] | string[];
    /**
     * Specifies the original event arguments.
     */
    e: MouseEvent | KeyboardEvent | TouchEvent;
}
export  type visualMode = 'Default' | 'Delimiter' | 'Box' | 'CheckBox';
 }
export namespace excelexport { 

/**
 * BlobHelper class
 */
export  class BlobHelper {
    private parts;
    private blob;
    append(part: any): void;
    getBlob(): Blob;
}
/**
 * CellStyle class
 */
export  class CellStyle {
    name: string;
    index: number;
    backColor: string;
    numFmtId: number;
    borders: Borders;
    fontName: string;
    fontSize: number;
    fontColor: string;
    italic: boolean;
    bold: boolean;
    hAlign: HAlignType;
    vAlign: VAlignType;
    underline: boolean;
    wrapText: boolean;
    numberFormat: string;
    type: string;
    isGlobalStyle: boolean;
    constructor();
}
export  class Font {
    b: boolean;
    i: boolean;
    u: boolean;
    sz: number;
    name: string;
    color: string;
    constructor();
}
export  class CellXfs {
    numFmtId: number;
    fontId: number;
    fillId: number;
    borderId: number;
    xfId: number;
    applyAlignment: number;
    alignment: Alignment;
}
export  class Alignment {
    horizontal: string;
    vertical: string;
    wrapText: number;
}
export  class CellStyleXfs {
    numFmtId: number;
    fontId: number;
    fillId: number;
    borderId: number;
    applyAlignment: number;
    alignment: Alignment;
}
export  class CellStyles {
    name: string;
    xfId: number;
    constructor();
}
export  class NumFmt {
    numFmtId: number;
    formatCode: string;
    constructor();
    constructor(id: number, code: string);
}
/**
 * Border class
 */
export  class Border {
    lineStyle: LineStyle;
    color: string;
    constructor();
    constructor(mLine: LineStyle, mColor: string);
}
/**
 * Border class
 */
export  class Borders {
    left: Border;
    right: Border;
    bottom: Border;
    top: Border;
    all: Border;
    constructor();
}
/**
 * Worksheet class
 */
export  class Cell {
    index: number;
    rowSpan: number;
    colSpan: number;
    value: string | Date | number | boolean;
    cellStyle: CellStyle;
    styleIndex: number;
    sharedStringIndex: number;
    saveType: string;
    type: string;
    refName: string;
}
/**
 * Rows class
 */
export  class Cells extends Array {
    add: (cell: Cell) => void;
}
/**
 * Column class
 */
export  class Column {
    index: number;
    width: number;
}
/**
 * CsvHelper class
 */
export  class CsvHelper {
    private isMicrosoftBrowser;
    private buffer;
    private csvStr;
    private formatter;
    private globalStyles;
    constructor(json: any);
    private parseWorksheet(json);
    private parseRows(rows);
    private parseRow(row);
    private parseCell(cell);
    private parseCellValue(value);
    /**
     * Saves the file with specified name and sends the file to client browser
     * @param  {string} fileName- file name to save.
     * @param  {Blob} buffer- the content to write in file
     */
    save(fileName: string): void;
    saveAsBlob(): Blob;
}
/**
 * LineStyle
 */
export  type LineStyle = 'thin' | 'thick' | 'medium' | 'none';
export  type HAlignType = 'center ' | 'justify' | 'left' | 'right' | 'general';
export  type VAlignType = 'bottom' | 'center' | 'top';
export  type HyperLinkType = 'none' | 'url' | 'file' | 'unc' | 'workbook';
export  type SaveType = 'xlsx' | 'csv';
export  type CellType = 'b' | 'e' | 'inlineStr' | 'n' | 's' | 'str';
export  type BlobSaveType = 'text/csv' | 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
/**
 * index class
 */
/**
 * Worksheet class
 */
export  class Row {
    height: number;
    index: number;
    cells: Cells;
    spans: string;
    grouping: Grouping;
}
/**
 * Rows class
 */
export  class Rows extends Array {
    add: (row: Row) => void;
}
/**
 * ValueFormatter class to globalize the value.
 * @hidden
 */
export  class ValueFormatter {
    private intl;
    constructor(cultureName?: string);
    getFormatFunction(format: base.NumberFormatOptions | base.DateFormatOptions): Function;
    toView(value: number | Date, format: Function): string | Object;
    displayText(value: any, format: base.NumberFormatOptions | base.DateFormatOptions): string;
}
/**
 * Workbook class
 */
export  class Workbook {
    private mArchive;
    private sharedString;
    private sharedStringCount;
    cellStyles: any;
    private worksheets;
    private builtInProperties;
    private mFonts;
    private mBorders;
    private mFills;
    private mNumFmt;
    private mStyles;
    private mCellXfs;
    private mCellStyleXfs;
    private mergeCells;
    private csvHelper;
    private mSaveType;
    private mHyperLinks;
    private unitsProportions;
    private hyperlinkStyle;
    private printTitles;
    private culture;
    private intl;
    private globalStyles;
    constructor(json: any, saveType: SaveType, culture?: string);
    private parserBuiltInProperties(jsonBuiltInProperties, builtInProperties);
    private parserWorksheets(json);
    private mergeOptions(fromJson, toJson);
    private applyProperties(sourceJson, destJson);
    private getCellName(row, column);
    private getColumnName(col);
    private parserPrintTitle(json, sheet);
    private parserFreezePanes(json, sheet);
    private parserColumns(json, sheet);
    private parserRows(json, sheet);
    private parserRow(json, rowIndex);
    private parseGrouping(json, row);
    private parseCells(json, row);
    private applyGlobalStyle(json, cellStyle);
    private compareStyleXfs(toCompareStyle);
    private parserCellStyle(json, cellStyle, cellType);
    private parserCellStyle(json, cellStyle, cellType, defStyleIndex);
    private switchNumberFormat(numberFormat, type);
    private getNumberFormat(numberFormat, type);
    private parserBorder(json, border);
    private processCellStyle(style);
    private isNewFont(toCompareStyle);
    private isNewBorder(toCompareStyle);
    private isAllBorder(toCompareBorder);
    private compareStyle(toCompareStyle);
    private contains(array, item);
    private getCellValueType(value);
    private parseCellType(cell);
    saveAsBlob(blobSaveType: BlobSaveType): Promise<{
        blobData: Blob;
    }>;
    save(fileName: string, proxyUrl?: string): void;
    private saveInternal();
    private saveWorkbook();
    private saveWorksheets();
    private saveWorksheet(sheet, index);
    private pixelsToColumnWidth(pixels);
    private trunc(x);
    private pixelsToRowHeight(pixels);
    private saveSheetRelations(sheet);
    private saveFreezePanes(sheet);
    private saveSharedString();
    private processString(value);
    private saveStyles();
    private saveNumberFormats();
    private saveFonts();
    private saveFills();
    private saveBorders();
    private saveCellStyles();
    private saveCellStyleXfs();
    private saveCellXfs();
    private saveApp(builtInProperties);
    private saveCore(builtInProperties);
    private saveTopLevelRelation();
    private saveWorkbookRelation();
    private saveContentType();
    private addToArchive(xmlString, itemName);
    private processMergeCells(cell, rowIndex, mergeCells);
    /**
     * Returns the tick count corresponding to the given year, month, and day.
     * @param year number value of year
     * @param month number value of month
     * @param day number value of day
     */
    private dateToTicks(year, month, day);
    /**
     * Return the tick count corresponding to the given hour, minute, second.
     * @param hour number value of hour
     * @param minute number value if minute
     * @param second number value of second
     */
    private timeToTicks(hour, minute, second);
    /**
     * Checks if given year is a leap year.
     * @param year Year value.
     */
    isLeapYear(year: number): boolean;
    /**
     * Converts `DateTime` to the equivalent OLE Automation date.
     */
    private toOADate(date);
}
export  class BuiltInProperties {
    author: string;
    comments: string;
    category: string;
    company: string;
    manager: string;
    subject: string;
    title: string;
    createdDate: Date;
    modifiedDate: Date;
    tags: string;
    status: string;
}
/**
 * Worksheet class
 */
export  class Worksheet {
    isSummaryRowBelow: boolean;
    index: number;
    columns: Column[];
    rows: Rows;
    freezePanes: FreezePane;
    name: string;
    mergeCells: MergeCells;
    hyperLinks: HyperLink[];
}
export  class HyperLink {
    ref: string;
    rId: number;
    toolTip: string;
    location: string;
    display: string;
    target: string;
    type: HyperLinkType;
}
export  class Grouping {
    outlineLevel: number;
    isCollapsed: boolean;
    isHidden: boolean;
}
export  class FreezePane {
    row: number;
    column: number;
    leftCell: string;
}
export  class MergeCell {
    ref: string;
    x: number;
    width: number;
    y: number;
    height: number;
}
/**
 * MergeCells class
 */
export  class MergeCells extends Array {
    add: (mergeCell: MergeCell) => void;
    static isIntersecting(base: MergeCell, compare: MergeCell): boolean;
}
/**
 * Worksheets class
 */
export  class Worksheets extends Array<Worksheet> {
}
 }
export namespace fileutils { 

/**
 * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).
 * ```typescript
 * let encoding : Encoding = new Encoding();
 * encoding.type = 'Utf8';
 * encoding.getBytes('Encoding', 0, 5);
 * ```
 */
export  class Encoding {
    private emitBOM;
    private encodingType;
    /**
     * Gets a value indicating whether to write a Unicode byte order mark
     * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false
     */
    readonly includeBom: boolean;
    /**
     * Gets the encoding type.
     * @returns EncodingType
     */
    /**
     * Sets the encoding type.
     * @param  {EncodingType} value
     */
    type: EncodingType;
    /**
     * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark
     * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.
     */
    constructor(includeBom?: boolean);
    /**
     * Initialize the includeBom to emit BOM or Not
     * @param  {boolean} includeBom
     */
    private initBOM(includeBom);
    /**
     * Calculates the number of bytes produced by encoding the characters in the specified string
     * @param  {string} chars - The string containing the set of characters to encode
     * @returns {number} - The number of bytes produced by encoding the specified characters
     */
    getByteCount(chars: string): number;
    /**
     * Return the Byte of character
     * @param  {number} codePoint
     * @returns {number}
     */
    private utf8Len(codePoint);
    /**
     * for 4 byte character return surrogate pair true, otherwise false
     * @param  {number} codeUnit
     * @returns {boolean}
     */
    private isHighSurrogate(codeUnit);
    /**
     * for 4byte character generate the surrogate pair
     * @param  {number} highCodeUnit
     * @param  {number} lowCodeUnit
     */
    private toCodepoint(highCodeUnit, lowCodeUnit);
    /**
     * private method to get the byte count for specific charindex and count
     * @param  {string} chars
     * @param  {number} charIndex
     * @param  {number} charCount
     */
    private getByteCountInternal(chars, charIndex, charCount);
    /**
     * Encodes a set of characters from the specified string into the ArrayBuffer.
     * @param  {string} s- The string containing the set of characters to encode
     * @param  {number} charIndex-The index of the first character to encode.
     * @param  {number} charCount- The number of characters to encode.
     * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.
     */
    getBytes(s: string, charIndex: number, charCount: number): ArrayBuffer;
    /**
     * Decodes a sequence of bytes from the specified ArrayBuffer into the string.
     * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.
     * @param  {number} index- The index of the first byte to decode.
     * @param  {number} count- The number of bytes to decode.
     * @returns {string} - The string that contains the resulting set of characters.
     */
    getString(bytes: ArrayBuffer, index: number, count: number): string;
    private getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);
    private getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);
    private getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);
    private getStringOfUtf8Encoding(byteCal, index, count);
    private getStringofUnicodeEncoding(byteUni, index, count);
    /**
     * To clear the encoding instance
     * @return {void}
     */
    destroy(): void;
}
/**
 * EncodingType : Specifies the encoding type
 */
export  type EncodingType = 'Ansi' | 'Utf8' | 'Unicode';
/**
 * To check the object is null or undefined and throw error if it is null or undefined
 * @param {Object} value - object to check is null or undefined
 * @return {boolean}
 * @throws {ArgumentException} - if the value is null or undefined
 * @private
 */
export  function validateNullOrUndefined(value: Object, message: string): void;
/**
 * file utils modules
 */
/**
 * Save class provide method to save file
 * ```typescript
 * let blob : Blob = new Blob([''], { type: 'text/plain' });
 * Save.save('fileName.txt',blob);
 */
export  class Save {
    static isMicrosoftBrowser: boolean;
    /**
     * Initialize new instance of {save}
     */
    constructor();
    /**
     * Saves the file with specified name and sends the file to client browser
     * @param  {string} fileName- file name to save.
     * @param  {Blob} buffer- the content to write in file
     * @param  {boolean} isMicrosoftBrowser- specify whether microsoft browser or not
     * @returns {void}
     */
    static save(fileName: string, buffer: Blob): void;
    private static saveInternal(fileName, extension, buffer, downloadLink, hasDownloadAttribute);
    /**
     *
     * @param {string} extension - get mime type of the specified extension
     * @private
     */
    static getMimeType(extension: string): string;
}
/**
 * StreamWriter class contains the implementation for writing characters to a file in a particular encoding
 * ```typescript
 * let writer = new StreamWriter();
 * writer.write('Hello World');
 * writer.save('Sample.txt');
 * writer.dispose();
 * ```
 */
export  class StreamWriter {
    private bufferBlob;
    private bufferText;
    private enc;
    /**
     * Gets the content written to the StreamWriter as Blob.
     * @returns Blob
     */
    readonly buffer: Blob;
    /**
     * Gets the encoding.
     * @returns Encoding
     */
    readonly encoding: Encoding;
    /**
     * Initializes a new instance of the StreamWriter class by using the specified encoding.
     * @param  {Encoding} encoding?- The character encoding to use.
     */
    constructor(encoding?: Encoding);
    private init(encoding);
    /**
     * Private method to set Byte Order Mark(BOM) value based on EncodingType
     */
    private setBomByte();
    /**
     * Saves the file with specified name and sends the file to client browser
     * @param  {string} fileName - The file name to save
     * @returns {void}
     */
    save(fileName: string): void;
    /**
     * Writes the specified string.
     * @param  {string} value - The string to write. If value is null or undefined, nothing is written.
     * @returns {void}
     */
    write(value: string): void;
    private flush();
    /**
     * Writes the specified string followed by a line terminator
     * @param  {string} value - The string to write. If value is null or undefined, nothing is written
     * @returns {void}
     */
    writeLine(value: string): void;
    /**
     * Releases the resources used by the StreamWriter
     * @returns {void}
     */
    destroy(): void;
}
/**
 * specifies current write state of XmlWriter
 */
export  type XmlWriteState = 'Initial' | 'StartDocument' | 'EndDocument' | 'StartElement' | 'EndElement' | 'ElementContent';
/**
 * specifies namespace kind
 */
export  type NamespaceKind = 'Written' | 'NeedToWrite' | 'Implied' | 'Special';
/**
 * XmlWriter class provide method to create XML data
 */
export  class XmlWriter {
    private bufferText;
    private bufferBlob;
    private currentState;
    private namespaceStack;
    private elementStack;
    private contentPos;
    private attributeStack;
    /**
     * Gets the content written to the {XmlWriter} as Blob.
     * @returns {Blob}
     */
    readonly buffer: Blob;
    /**
     * Initialize new instance of {XmlWriter}
     */
    constructor();
    /**
     * Writes processing instruction with a space between the name and text
     * @param {string} name - name of the processing instruction
     * @param {string} text - text to write in the processing instruction
     * @throws ArgumentException
     * @throws InvalidArgumentException
     * @throws InvalidOperationException
     */
    writeProcessingInstruction(name: string, text: string): void;
    /**
     * Writes Xml declaration with version and standalone attribute
     * @param {boolean} standalone - if true it write standalone=yes else standalone=no
     * @throws InvalidOperation
     */
    writeStartDocument(standalone?: boolean): void;
    /**
     * Closes any open tag or attribute and write the state back to start
     */
    writeEndDocument(): void;
    /**
     * Writes the specified start tag and associates it with the given namespace and prefix.
     * @param {string} prefix - namespace prefix of element
     * @param {string} localName -localName of element
     * @param {string} namespace - namespace URI associate with element
     * @throws ArgumentException
     * @throws InvalidOperationException
     */
    writeStartElement(prefix: string, localName: string, namespace: string): void;
    /**
     * Closes one element and pop corresponding namespace scope
     */
    writeEndElement(): void;
    /**
     * Writes an element with the specified prefix, local name, namespace URI, and value.
     * @param {string} prefix - namespace prefix of element
     * @param {string} localName - localName of element
     * @param {string} namespace - namespace URI associate with element
     * @param {string} value - value of element
     */
    writeElementString(prefix: string, localName: string, namespace: string, value: string): void;
    /**
     * Writes out the attribute with the specified prefix, local name, namespace URI, and value
     * @param {string} prefix - namespace prefix of element
     * @param {string} localName - localName of element
     * @param {string} namespace - namespace URI associate with element
     * @param {string} value - value of element
     */
    writeAttributeString(prefix: string, localName: string, namespace: string, value: string): void;
    /**
     * Writes the given text content
     * @param {string} text - text to write
     * @throws InvalidOperationException
     */
    writeString(text: string): void;
    /**
     * Write given text as raw data
     * @param {string} text - text to write
     * @throws InvalidOperationException
     */
    writeRaw(text: string): void;
    private writeInternal(text, isRawString);
    /**
     * Saves the file with specified name and sends the file to client browser
     * @param {string} fileName - file name
     */
    save(fileName: string): void;
    /**
     * Releases the resources used by XmlWriter.
     */
    destroy(): void;
    private flush();
    private writeProcessingInstructionInternal(name, text);
    private writeStartAttribute(prefix, localName, namespace, value);
    private writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value);
    private writeStartAttributeSpecialAttribute(prefix, localName, namespace, value);
    private writeEndAttribute();
    private writeStartElementInternal(prefix, localName, namespace);
    private writeEndElementInternal(prefix, localName);
    private writeStartAttributeInternal(prefix, localName, namespaceName);
    private writeNamespaceDeclaration(prefix, namespaceUri);
    private writeStartNamespaceDeclaration(prefix);
    private writeStringInternal(text, inAttributeValue);
    private startElementContent();
    private rawText(text);
    private addNamespace(prefix, ns, kind);
    private lookupPrefix(namespace);
    private lookupNamespace(prefix);
    private lookupNamespaceIndex(prefix);
    private pushNamespaceImplicit(prefix, ns);
    private pushNamespaceExplicit(prefix, ns);
    private addAttribute(prefix, localName, namespaceName);
    private skipPushAndWrite(prefix, localName, namespace);
    private checkName(text);
}
/**
 * class for managing namespace collection
 */
export  class Namespace {
    /**
     * specifies namespace's prefix
     */
    prefix: string;
    /**
     * specifies namespace URI
     */
    namespaceUri: string;
    /**
     * specifies namespace kind
     */
    kind: NamespaceKind;
    /**
     * set value for current namespace instance
     * @param {string} prefix namespace's prefix
     * @param {string} namespaceUri namespace URI
     * @param {string} kind namespace kind
     */
    set(prefix: string, namespaceUri: string, kind: NamespaceKind): void;
    /**
     * Releases the resources used by Namespace
     */
    destroy(): void;
}
/**
 * class for managing element collection
 */
export  class XmlElement {
    /**
     * specifies previous namespace top
     */
    previousTop: number;
    /**
     * specifies element prefix
     */
    prefix: string;
    /**
     * specifies element localName
     */
    localName: string;
    /**
     * specified namespace URI
     */
    namespaceUri: string;
    /**
     * set value of current element
     * @param {string} prefix - element prefix
     * @param {string} localName - element local name
     * @param {string} namespaceUri -namespace URI
     * @param {string} previousTop - previous namespace top
     */
    set(prefix: string, localName: string, namespaceUri: string, previousTop: number): void;
    /**
     * Releases the resources used by XmlElement
     */
    destroy(): void;
}
/**
 * class for managing attribute collection
 */
export  class XmlAttribute {
    /**
     * specifies namespace's prefix
     */
    prefix: string;
    /**
     * specifies namespace URI
     */
    namespaceUri: string;
    /**
     * specifies attribute local name
     */
    localName: string;
    /**
     * set value of current attribute
     * @param {string} prefix - namespace's prefix
     * @param {string} namespaceUri - namespace URI
     * @param {string} localName - attribute localName
     */
    set(prefix: string, localName: string, namespaceUri: string): void;
    /**
     * get whether the attribute is duplicate or not
     * @param {string} prefix - namespace's prefix
     * @param {string} namespaceUri - namespace URI
     * @param {string} localName - attribute localName
     */
    isDuplicate(prefix: string, localName: string, namespaceUri: string): boolean;
    /**
     * Releases the resources used by XmlAttribute
     */
    destroy(): void;
}
 }
export namespace grids { 

/**
 * Action export
 */
/**
 * Summary Action controller.
 */
export  class Aggregate implements IAction {
    private parent;
    private locator;
    private footerRenderer;
    constructor(parent: IGrid, locator?: ServiceLocator);
    getModuleName(): string;
    private initiateRender();
    private prepareSummaryInfo();
    private getFormatFromType(format, type);
    onPropertyChanged(e: NotifyArgs): void;
    addEventListener(): void;
    removeEventListener(): void;
    destroy(): void;
}
/**
 * @private
 */
export  function summaryIterator(aggregates: AggregateRowModel[], callback: Function): void;
/**
 * `BatchEdit` module is used to handle batch editing actions.
 * @hidden
 */
export  class BatchEdit {
    private parent;
    private serviceLocator;
    private form;
    formObj: inputs.FormValidator;
    private renderer;
    private focus;
    private dataBoundFunction;
    private cellDetails;
    private isColored;
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator, renderer?: EditRender);
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    private dataBound();
    /**
     * @hidden
     */
    destroy(): void;
    protected clickHandler(e: MouseEvent): void;
    protected dblClickHandler(e: MouseEvent): void;
    private onBeforeCellFocused(e);
    private onCellFocused(e);
    private isAddRow(index);
    private editCellFromIndex(rowIdx, cellIdx);
    closeEdit(): void;
    deleteRecord(fieldname?: string, data?: Object): void;
    addRecord(data?: Object): void;
    endEdit(data?: Object): void;
    private validateFormObj();
    batchSave(): void;
    getBatchChanges(): Object;
    private mergeBatchChanges(row, mRow, frzCols);
    /**
     * @hidden
     */
    removeRowObjectFromUID(uid: string): void;
    /**
     * @hidden
     */
    addRowObject(row: Row<Column>): void;
    private bulkDelete(fieldname?, data?);
    private refreshRowIdx();
    private getIndexFromData(data);
    private bulkAddRow(data?);
    private renderMovable(ele);
    private findNextEditableCell(columnIndex, isAdd);
    private checkNPCell(col);
    private getDefaultData();
    private setCellIdx(target);
    editCell(index: number, field: string, isAdd?: boolean): void;
    updateCell(rowIndex: number, field: string, value: string | number | boolean | Date): void;
    private setChanges(rowObj, field, value);
    updateRow(index: number, data: Object): void;
    private getCellIdx(uid);
    private refreshTD(td, column, rowObj, value);
    private getColIndex(cells, index);
    saveCell(isForceSave?: boolean): void;
    protected getDataByIndex(index: number): Object;
}
/**
 * @hidden
 * `CheckBoxFilter` module is used to handle filtering action.
 */
export  class CheckBoxFilter {
    protected sBox: HTMLElement;
    protected isExcel: boolean;
    protected id: string;
    protected colType: string;
    protected fullData: Object[];
    protected filteredData: Object[];
    protected isFiltered: boolean | number;
    protected dlg: Element;
    protected dialogObj: popups.Dialog;
    protected cBox: HTMLElement;
    protected spinner: HTMLElement;
    protected searchBox: Element;
    protected sInput: HTMLInputElement;
    protected sIcon: Element;
    protected options: IFilterArgs;
    protected filterSettings: FilterSettings;
    protected existingPredicate: {
        [key: string]: PredicateModel[];
    };
    protected foreignKeyData: Object[];
    protected filterState: boolean;
    protected defaultConstants: Object;
    protected values: Object;
    private cBoxTrue;
    private cBoxFalse;
    private itemsCnt;
    private result;
    protected parent: IGrid;
    protected serviceLocator: ServiceLocator;
    protected localeObj: base.L10n;
    protected valueFormatter: ValueFormatter;
    /**
     * Constructor for checkbox filtering module
     * @hidden
     */
    constructor(parent?: IGrid, filterSettings?: FilterSettings, serviceLocator?: ServiceLocator);
    protected initLocale(constants: Object): void;
    /**
     * To destroy the filter bar.
     * @return {void}
     * @hidden
     */
    destroy(): void;
    private wireEvents();
    private unWireEvents();
    private searchBoxClick(e);
    private searchBoxKeyUp(e?);
    private updateSearchIcon();
    /**
     * Gets the localized label by locale keyword.
     * @param  {string} key
     * @return {string}
     */
    getLocalizedLabel(key: string): string;
    private updateDataSource();
    protected updateModel(options: IFilterArgs): void;
    protected getAndSetChkElem(options: IFilterArgs): HTMLElement;
    protected showDialog(options: IFilterArgs): void;
    private dialogCreated(e);
    openDialog(options: IFilterArgs): void;
    closeDialog(): void;
    protected clearFilter(): void;
    private btnClick(e);
    private fltrBtnHandler();
    private initiateFilter(fColl);
    private refreshCheckboxes();
    private getPredicateFromCols(columns);
    private getAllData();
    private dataSuccess(e);
    private processDataSource(query?, isInitial?);
    private updateResult();
    private clickHandler(e);
    private updateAllCBoxes(checked);
    private dialogOpen();
    private createCheckbox(value, checked);
    private updateIndeterminatenBtn();
    private createFilterItems(data, isInitial?);
    private getCheckedState(isColFiltered, value);
    static getDistinct(json: Object[], field: string, column?: Column, foreignKeyData?: Object[]): Object;
    static getPredicate(columns: PredicateModel[]): data.Predicate;
    private static generatePredicate(cols);
    private static getCaseValue(filter);
    private static updateDateFilter(filter);
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
}
/**
 * The `Clipboard` module is used to handle clipboard copy action.
 */
export  class Clipboard implements IAction {
    private clipBoardTextArea;
    private copyContent;
    private isSelect;
    private parent;
    /**
     * Constructor for the Grid clipboard module
     * @hidden
     */
    constructor(parent?: IGrid);
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    private initialEnd();
    private keyDownHandler(e);
    private setCopyData(withHeader?);
    private getCopyData(cells, isCell, splitKey, withHeader?);
    /**
     * Copy selected rows or cells data into clipboard.
     * @param {boolean} withHeader - Specifies whether the column header data need to be copied or not.
     */
    copy(withHeader?: boolean): void;
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    /**
     * To destroy the clipboard
     * @return {void}
     * @hidden
     */
    destroy(): void;
    private checkBoxSelection();
}
/**
 * The `ColumnChooser` module is used to show or hide columns dynamically.
 */
export  class ColumnChooser implements IAction {
    private dataManager;
    private column;
    private parent;
    private serviceLocator;
    private l10n;
    private dlgObj;
    private searchValue;
    private flag;
    private timer;
    getShowHideService: ShowHide;
    private showColumn;
    private hideColumn;
    private mainDiv;
    private innerDiv;
    private ulElement;
    private isDlgOpen;
    private dlghide;
    private initialOpenDlg;
    private stateChangeColumns;
    private dlgDiv;
    private isInitialOpen;
    private isCustomizeOpenCC;
    private cBoxTrue;
    private cBoxFalse;
    private searchBoxObj;
    /**
     * Constructor for the Grid ColumnChooser module
     * @hidden
     */
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
    private destroy();
    private rtlUpdate();
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    private render();
    private clickHandler(e);
    private hideDialog();
    /**
     * To render columnChooser when showColumnChooser enabled.
     * @return {void}
     * @hidden
     */
    renderColumnChooser(x?: number, y?: number, target?: Element): void;
    /**
     * Column chooser can be displayed on screen by given position(X and Y axis).
     * @param  {number} X - Defines the X axis.
     * @param  {number} Y - Defines the Y axis.
     * @return {void}
     */
    openColumnChooser(X?: number, Y?: number): void;
    private enableAfterRenderEle(e);
    private customDialogOpen();
    private customDialogClose();
    private getColumns();
    private renderDlgContent();
    private renderChooserList();
    private confirmDlgBtnClick(args);
    private columnStateChange(stateColumns, state);
    private clearActions();
    private checkstatecolumn(isChecked, coluid);
    private columnChooserSearch(searchVal);
    private wireEvents();
    private unWireEvents();
    private checkBoxClickHandler(e);
    private refreshCheckboxList(gdCol, searchVal?);
    private refreshCheckboxState();
    private checkState(element, state);
    private createCheckBox(label, checked, uid);
    private renderCheckbox(column);
    private columnChooserManualSearch(e);
    private startTimer(e);
    private stopTimer();
    private addcancelIcon();
    private removeCancelIcon();
    private mOpenDlg();
    private getModuleName();
}
/**
 * 'column menu module used to handle column menu actions'
 */
export  class ColumnMenu implements IAction {
    private element;
    private gridID;
    private parent;
    private serviceLocator;
    private columnMenu;
    private l10n;
    private defaultItems;
    private localeText;
    private targetColumn;
    private disableItems;
    private hiddenItems;
    private headerCell;
    private isOpen;
    private eventArgs;
    private GROUP;
    private UNGROUP;
    private ASCENDING;
    private DESCENDING;
    private ROOT;
    private FILTER;
    private POP;
    private WRAP;
    private CHOOSER;
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
    wireEvents(): void;
    unwireEvents(): void;
    /**
     * To destroy the resize
     * @return {void}
     * @hidden
     */
    destroy(): void;
    columnMenuHandlerClick(e: Event): void;
    private openColumnMenu(e);
    columnMenuHandlerDown(e: Event): void;
    private getColumnMenuHandlers();
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    private enableAfterRenderMenu(e);
    private render();
    private wireFilterEvents();
    private unwireFilterEvents();
    private beforeMenuItemRender(args);
    private columnMenuBeforeClose(args);
    private isChooserItem(item);
    private columnMenuBeforeOpen(args);
    private ensureDisabledStatus(item);
    private columnMenuItemClick(args);
    private columnMenuOnClose(args);
    private getDefaultItems();
    private getItems();
    private getDefaultItem(item);
    private getLocaleText(item);
    private generateID(item, append?);
    private getKeyFromId(id, append?);
    getColumnMenu(): HTMLElement;
    private getModuleName();
    private setLocaleKey();
    private getHeaderCell(e);
    private getColumn();
    private createChooserItems();
    private appendFilter(e);
    private getFilter(target, id, isClose?);
    private setPosition(li, ul);
    private filterPosition(e);
    private getDefault();
    private isFilterPopupOpen();
    private getFilterPop();
    private isFilterItemAdded();
}
/**
 * `CommandColumn` used to handle the command column actions.
 * @hidden
 */
export  class CommandColumn {
    private parent;
    private previousClickedTD;
    private locator;
    private clickedButton;
    constructor(parent: IGrid, locator?: ServiceLocator);
    private initiateRender();
    private commandClickHandler(e);
    /**
     * For internal use only - Get the module name.
     */
    private getModuleName();
    /**
     * To destroy CommandColumn.
     * @method destroy
     * @return {void}
     */
    private destroy();
    private removeEventListener();
    private addEventListener();
    private keyPressHandler(e);
}
export  const menuClass: CMenuClassList;
export interface CMenuClassList {
    header: string;
    content: string;
    edit: string;
    batchEdit: string;
    editIcon: string;
    pager: string;
    cancel: string;
    save: string;
    delete: string;
    copy: string;
    pdf: string;
    group: string;
    ungroup: string;
    csv: string;
    excel: string;
    fPage: string;
    lPage: string;
    nPage: string;
    pPage: string;
    ascending: string;
    descending: string;
    groupHeader: string;
    touchPop: string;
}
/**
 * The `ContextMenu` module is used to handle context menu actions.
 */
export  class ContextMenu implements IAction {
    private element;
    contextMenu: navigations.ContextMenu;
    private defaultItems;
    private disableItems;
    private hiddenItems;
    private gridID;
    private parent;
    private serviceLocator;
    private l10n;
    private localeText;
    private targetColumn;
    private eventArgs;
    isOpen: boolean;
    row: HTMLTableRowElement;
    cell: HTMLTableCellElement;
    private keyPressHandlerFunction;
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    private keyDownHandler(e);
    private render();
    private enableAfterRenderMenu(e);
    private getMenuItems();
    private getLastPage();
    private contextMenuOpen();
    private contextMenuItemClick(args);
    private contextMenuOnClose(args);
    private getLocaleText(item);
    private updateItemStatus();
    private contextMenuBeforeOpen(args);
    private ensureTarget(targetElement, selector);
    private ensureFrozenHeader(targetElement);
    private ensureDisabledStatus(item);
    /**
     * Gets the context menu element from the Grid.
     * @return {Element}
     */
    getContextMenu(): Element;
    /**
     * Destroys the context menu component in the Grid.
     * @method destroy
     * @return {void}
     * @hidden
     */
    destroy(): void;
    private getModuleName();
    private generateID(item);
    private getKeyFromId(id);
    private buildDefaultItems(item);
    private getDefaultItems();
    private setLocaleKey();
    private getColumn(e);
    private selectRow(e, isSelectable);
}
/**
 * Grid data module is used to generate query and data source.
 * @hidden
 */
export  class Data implements IDataProcessor {
    dataManager: data.DataManager;
    protected parent: IGrid;
    protected serviceLocator: ServiceLocator;
    protected dataState: PendingState;
    /**
     * Constructor for data module.
     * @hidden
     */
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
    /**
     * The function used to initialize dataManager and external query
     * @return {void}
     */
    private initDataManager();
    /**
     * The function is used to generate updated data.Query from Grid model.
     * @return {data.Query}
     * @hidden
     */
    generateQuery(skipPage?: boolean): data.Query;
    protected aggregateQuery(query: data.Query, isForeign?: boolean): data.Query;
    protected pageQuery(query: data.Query, skipPage?: boolean): data.Query;
    protected groupQuery(query: data.Query): data.Query;
    protected sortQuery(query: data.Query): data.Query;
    protected searchQuery(query: data.Query): data.Query;
    protected filterQuery(query: data.Query, column?: PredicateModel[], skipFoerign?: boolean): data.Query;
    private fGeneratePredicate(col, predicateList);
    /**
     * The function is used to get dataManager promise by executing given data.Query.
     * @param  {data.Query} query - Defines the query which will execute along with data processing.
     * @return {Promise<Object>}
     * @hidden
     */
    getData(args?: {
        requestType?: string;
        foreignKeyData?: string[];
        data?: Object;
        index?: number;
    }, query?: data.Query): Promise<Object>;
    private formatGroupColumn(value, field);
    private crudActions(args);
    /** @hidden */
    saveChanges(changes: Object, key: string): Promise<Object>;
    private getKey(keys);
    /** @hidden */
    isRemote(): boolean;
    private addRows(e);
    private removeRows(e);
    private getColumnByField(field);
    protected destroy(): void;
    getState(): PendingState;
    setState(state: PendingState): Object;
    getStateEventArgument(query: data.Query): PendingState;
    private eventPromise(args, query?, key?);
}
/**
 * The `DetailRow` module is used to handle detail template and hierarchy Grid operations.
 */
export  class DetailRow {
    private aria;
    private parent;
    private focus;
    /**
     * Constructor for the Grid detail template module
     * @hidden
     */
    constructor(parent?: IGrid, locator?: ServiceLocator);
    private clickHandler(e);
    private toogleExpandcollapse(target);
    private isDetailRow(row);
    private destroy();
    private getTDfromIndex(index, className);
    /**
     * Expands a detail row with the given target.
     * @param  {Element} target - Defines the collapsed element to expand.
     * @return {void}
     */
    expand(target: number | Element): void;
    /**
     * Collapses a detail row with the given target.
     * @param  {Element} target - Defines the expanded element to collapse.
     * @return {void}
     */
    collapse(target: number | Element): void;
    /**
     * Expands all the detail rows of the Grid.
     * @return {void}
     */
    expandAll(): void;
    /**
     * Collapses all the detail rows of the Grid.
     * @return {void}
     */
    collapseAll(): void;
    private expandCollapse(isExpand);
    private keyPressHandler(e);
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
}
/**
 * `DialogEdit` module is used to handle dialog editing actions.
 * @hidden
 */
export  class DialogEdit extends NormalEdit {
    protected parent: IGrid;
    protected serviceLocator: ServiceLocator;
    protected renderer: EditRender;
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator, renderer?: EditRender);
    closeEdit(): void;
    addRecord(data?: Object, index?: number): void;
    updateRow(index: number, data?: Object): void;
    endEdit(): void;
    deleteRecord(fieldname?: string, data?: Object): void;
    protected startEdit(tr?: Element): void;
}
/**
 * The `Edit` module is used to handle editing actions.
 */
export  class Edit implements IAction {
    private edit;
    protected renderer: EditRender;
    private editModule;
    /** @hidden */
    formObj: inputs.FormValidator;
    mFormObj: inputs.FormValidator;
    private editCellType;
    private editType;
    protected parent: IGrid;
    protected serviceLocator: ServiceLocator;
    protected l10n: base.L10n;
    private dialogObj;
    private alertDObj;
    private actionBeginFunction;
    private actionCompleteFunction;
    private preventObj;
    /**
     * Constructor for the Grid editing module
     * @hidden
     */
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
    private updateColTypeObj();
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    /**
     * @hidden
     */
    onPropertyChanged(e: NotifyArgs): void;
    private updateEditObj();
    private initialEnd();
    private wireEvents();
    private unwireEvents();
    private tapEvent(e);
    private getUserAgent();
    /**
     * Edits any bound record in the Grid by TR element.
     * @param {HTMLTableRowElement} tr - Defines the table row to be edited.
     */
    startEdit(tr?: HTMLTableRowElement): void;
    /**
     * Cancels edited state.
     */
    closeEdit(): void;
    protected refreshToolbar(): void;
    /**
     * To adds a new row at the top with the given data. When data is not passed, it will add empty rows.
     * > `editSettings.allowEditing` should be true.
     * @param {Object} data - Defines the new add record data.
     * @param {number} index - Defines the row index to be added
     */
    addRecord(data?: Object, index?: number): void;
    /**
     * Deletes a record with the given options. If fieldname and data are not given, the Grid will delete the selected record.
     * > `editSettings.allowDeleting` should be true.
     * @param {string} fieldname - Defines the primary key field name of the column.
     * @param {Object} data - Defines the JSON data record to be deleted.
     */
    deleteRecord(fieldname?: string, data?: Object): void;
    /**
     * Deletes a visible row by TR element.
     * @param {HTMLTableRowElement} tr - Defines the table row element.
     */
    deleteRow(tr: HTMLTableRowElement): void;
    /**
     * If Grid is in editable state, you can save a record by invoking endEdit.
     */
    endEdit(): void;
    /**
     * To update the specified cell by given value without changing into edited state.
     * @param {number} rowIndex Defines the row index.
     * @param {string} field Defines the column field.
     * @param {string | number | boolean | Date} value - Defines the value to be changed.
     */
    updateCell(rowIndex: number, field: string, value: string | number | boolean | Date): void;
    /**
     * To update the specified row by given values without changing into edited state.
     * @param {number} index Defines the row index.
     * @param {Object} data Defines the data object to be updated.
     */
    updateRow(index: number, data: Object): void;
    /**
     * Resets added, edited, and deleted records in the batch mode.
     */
    batchCancel(): void;
    /**
     * Bulk saves added, edited, and deleted records in the batch mode.
     */
    batchSave(): void;
    /**
     * Changes a particular cell into edited state based on the row index and field name provided in the `batch` mode.
     * @param {number} index - Defines row index to edit a particular cell.
     * @param {string} field - Defines the field name of the column to perform batch edit.
     */
    editCell(index: number, field: string): void;
    /**
     * Checks the status of validation at the time of editing. If validation is passed, it returns true.
     * @return {boolean}
     */
    editFormValidate(): boolean;
    /**
     * Gets the added, edited,and deleted data before bulk save to the DataSource in batch mode.
     * @return {Object}
     */
    getBatchChanges(): Object;
    /**
     * Gets the current value of the edited component.
     */
    getCurrentEditCellData(): string;
    /**
     * Saves the cell that is currently edited. It does not save the value to the DataSource.
     */
    saveCell(): void;
    private endEditing();
    private showDialog(content, obj);
    getValueFromType(col: Column, value: string | Date | boolean): number | string | Date | boolean;
    private destroyToolTip();
    private createConfirmDlg();
    private createAlertDlg();
    private alertClick();
    private dlgWidget(btnOptions, name);
    private dlgCancel();
    private dlgOk(e);
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    private actionComplete(e);
    /**
     * @hidden
     */
    getCurrentEditedData(form: Element, editedData: Object): Object;
    /**
     * @hidden
     */
    onActionBegin(e: NotifyArgs): void;
    /**
     * @hidden
     */
    destroyWidgets(cols?: Column[]): void;
    /**
     * @hidden
     */
    destroyForm(): void;
    /**
     * To destroy the editing.
     * @return {void}
     * @hidden
     */
    destroy(): void;
    private keyPressHandler(e);
    private preventBatch(args);
    private executeAction();
    /**
     * @hidden
     */
    applyFormValidation(cols?: Column[]): void;
    private createFormObj(form, rules);
    private valErrorPlacement(inputElement, error);
    private getElemTable(inputElement);
    private validationComplete(args);
    private createTooltip(element, error, name, display);
}
/** @hidden */
export  namespace Global {
    let timer: Object;
}
/**
 * @hidden
 * `ExcelExport` module is used to handle the Excel export action.
 */
export  class ExcelExport {
    private parent;
    private isExporting;
    private theme;
    private book;
    private workSheet;
    private rows;
    private columns;
    private styles;
    private data;
    private rowLength;
    private footer;
    private expType;
    private includeHiddenColumn;
    private isCsvExport;
    private isBlob;
    private blobPromise;
    private exportValueFormatter;
    private isElementIdChanged;
    private helper;
    private foreignKeyData;
    /**
     * Constructor for the Grid Excel Export module.
     * @hidden
     */
    constructor(parent?: IGrid);
    /**
     * For internal use only - Get the module name.
     */
    private getModuleName();
    private init(gObj);
    /**
     * Export Grid to Excel file.
     * @param  {exportProperties} exportProperties - Defines the export properties of the Grid.
     * @param  {isMultipleExport} isMultipleExport - Defines is multiple Grid's are exported.
     * @param  {workbook} workbook - Defined the Workbook if multiple Grid is exported.
     * @param  {isCsv} isCsv - true if export to CSV.
     * @return {Promise<any>}
     */
    Map(grid: IGrid, exportProperties: ExcelExportProperties, isMultipleExport: boolean, workbook: any, isCsv: boolean, isBlob: boolean): Promise<any>;
    private processRecords(gObj, exportProperties, isMultipleExport, workbook);
    private processInnerRecords(gObj, exportProperties, isMultipleExport, workbook, r);
    private processRecordContent(gObj, returnType, headerRow, isMultipleExport, currentViewRecords?);
    private processGroupedRows(gObj, dataSource, headerRow, level);
    private processRecordRows(gObj, record, headerRow, level);
    private processAggregates(gObj, rec, currentViewRecords?, indent?, byGroup?);
    private fillAggregates(gObj, cells, indent, customIndex?);
    private getAggreateValue(cellType, template, cell, row);
    private mergeOptions(JSON1, JSON2);
    private getColumnStyle(gObj, columnIndex);
    private processHeaderContent(gObj, headerRow, exportProperties, indent);
    private getHeaderThemeStyle(theme);
    private updateThemeStyle(themestyle, style);
    private getCaptionThemeStyle(theme);
    private getRecordThemeStyle(theme);
    private processExcelHeader(header);
    private updatedCellIndex(json);
    private processExcelFooter(footer);
    private getIndex(spannedCells, rowIndex, columnIndex);
    private parseStyles(gObj, col, style, index);
    /**
     * To destroy the excel export
     * @return {void}
     * @hidden
     */
    destroy(): void;
}
/**
 * @hidden
 * `ExcelFilter` module is used to handle filtering action.
 */
export  class ExcelFilter extends CheckBoxFilter {
    private datePicker;
    private actObj;
    private numericTxtObj;
    private dlgDiv;
    private l10n;
    private dlgObj;
    private menuEle;
    private customFilterOperators;
    private dropOptr;
    private optrData;
    private menuItem;
    private menu;
    private cmenu;
    protected menuObj: navigations.ContextMenu;
    private isCMenuOpen;
    private localeConstants;
    /**
     * Constructor for excel filtering module
     * @hidden
     */
    constructor(parent?: IGrid, filterSettings?: FilterSettings, serviceLocator?: ServiceLocator, customFltrOperators?: Object);
    private getCMenuDS(type, operator?);
    /**
     * To destroy the filter bar.
     * @return {void}
     * @hidden
     */
    destroy(): void;
    private createMenu(type, isFiltered, isCheckIcon);
    private createMenuElem(val, className?, iconName?, isSubMenu?);
    private wireExEvents();
    private unwireExEvents();
    private clickExHandler(e);
    private destroyCMenu();
    private hoverHandler(e);
    private ensureTextFilter();
    private preventClose(args);
    private getContextBounds(context);
    private getCMenuYPosition(target, context);
    openDialog(options: IFilterArgs): void;
    closeDialog(): void;
    private selectHandler(e);
    private renderDialogue(e);
    private removeDialog();
    private clearBtnClick(field);
    private createdDialog(target, column);
    private renderCustomFilter(target, column);
    private filterBtnClick(col);
    /**
     * Filters grid row by column name with given options.
     * @param {string} fieldName - Defines the field name of the filter column.
     * @param {string} firstOperator - Defines the first operator by how to filter records.
     * @param {string | number | Date | boolean} firstValue - Defines the first value which is used to filter records.
     * @param  {string} predicate - Defines the relationship between one filter query with another by using AND or OR predicate.
     * @param {boolean} matchCase - If ignore case set to true, then filter records with exact match or else
     * filter records with case insensitive(uppercase and lowercase letters treated as same).
     * @param {boolean} ignoreAccent - If ignoreAccent set to true, then ignores the diacritic characters or accents when filtering.
     * @param {string} secondOperator - Defines the second operator by how to filter records.
     * @param {string | number | Date | boolean} secondValue - Defines the first value which is used to filter records.
     */
    private filterByColumn(fieldName, firstOperator, firstValue, predicate?, matchCase?, ignoreAccent?, secondOperator?, secondValue?);
    private renderOperatorUI(column, table, elementID, predicates, isFirst?);
    private dropDownOpen(args);
    private getSelectedValue(text);
    private dropSelectedVal(col, predicates, isFirst?);
    private getSelectedText(operator);
    private renderFilterUI(column, dlgConetntEle);
    private renderRadioButton(column, tr, predicates);
    private removeObjects(elements);
    private renderFlValueUI(column, optr, elementId, predicates, isFirst?);
    private renderMatchCase(column, tr, matchCase, elementId, predicates);
    private renderDate(options, column, inputValue, fValue, isRtl);
    private completeAction(e);
    private renderNumericTextBox(options, column, inputValue, fValue, isRtl);
    private renderAutoComplete(options, column, inputValue, fValue, isRtl);
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
}
/**
 * @hidden
 * `ExportHelper` for `PdfExport` & `ExcelExport`
 */
export  class ExportHelper {
    parent: IGrid;
    private colDepth;
    private hideColumnInclude;
    private foreignKeyData;
    constructor(parent: IGrid);
    static getQuery(parent: IGrid, data: Data): data.Query;
    getFData(value: string, column: Column): Object;
    getColumnData(gridObj: Grid): Promise<Object>;
    getHeaders(column: any[], isHideColumnInclude?: boolean): {
        rows: any[];
        columns: Column[];
    };
    getConvertedWidth(input: string): number;
    private generateActualColumns(column, actualColumns);
    private removeCellFromRow(cells, cellIndex);
    private processHeaderCells(rows);
    private appendGridCells(cols, gridRows, index, isFirstObj, isFirstColumn, isLastColumn);
    private generateCell(gridColumn, cellType?, rowSpan?, className?, rowIndex?, columnIndex?);
    private processColumns(rows);
    private getCellCount(column, count);
    private measureColumnDepth(column);
    private checkDepth(col, index);
}
/**
 * @hidden
 * `ExportValueFormatter` for `PdfExport` & `ExcelExport`
 */
export  class ExportValueFormatter {
    private internationalization;
    private valueFormatter;
    constructor();
    private returnFormattedValue(args, customFormat);
    formatCellValue(args: any): string;
}
/**
 *
 * The `Filter` module is used to handle filtering action.
 */
export  class Filter implements IAction {
    private filterSettings;
    private element;
    private value;
    private predicate;
    private operator;
    private column;
    private fieldName;
    private matchCase;
    private ignoreAccent;
    private timer;
    private filterStatusMsg;
    private currentFilterObject;
    private isRemove;
    private contentRefresh;
    private values;
    private nextFlMenuOpen;
    private type;
    private filterModule;
    private filterOperators;
    private fltrDlgDetails;
    private customOperators;
    private parent;
    private serviceLocator;
    private l10n;
    private valueFormatter;
    private actualPredicate;
    /**
     * Constructor for Grid filtering module
     * @hidden
     */
    constructor(parent?: IGrid, filterSettings?: FilterSettings, serviceLocator?: ServiceLocator);
    /**
     * To render filter bar when filtering enabled.
     * @return {void}
     * @hidden
     */
    render(e?: NotifyArgs): void;
    /**
     * To destroy the filter bar.
     * @return {void}
     * @hidden
     */
    destroy(): void;
    private generateRow(index?);
    private generateCells();
    private generateCell(column, cellType?);
    /**
     * To update filterSettings when applying filter.
     * @return {void}
     * @hidden
     */
    updateModel(): void;
    private getFilteredColsIndexByField(col);
    /**
     * To trigger action complete event.
     * @return {void}
     * @hidden
     */
    onActionComplete(e: NotifyArgs): void;
    private wireEvents();
    private unWireEvents();
    private enableAfterRender(e);
    private initialEnd();
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    private filterMenuClose(args);
    /**
     * Filters the Grid row by fieldName, filterOperator, and filterValue.
     * @param  {string} fieldName - Defines the field name of the filter column.
     * @param  {string} filterOperator - Defines the operator to filter records.
     * @param  {string | number | Date | boolean} filterValue - Defines the value which is used to filter records.
     * @param  {string} predicate - Defines the relationship of one filter query with another by using AND or OR predicate.
     * @param  {boolean} matchCase - If match case is set to true, then the filter records
     * the exact match or <br> filters records that are case insensitive (uppercase and lowercase letters treated the same).
     * @param {boolean} ignoreAccent - If ignoreAccent set to true, then filter ignores the diacritic characters or accents while filtering.
     * @param  {string} actualFilterValue - Defines the actual filter value for the filter column.
     * @param  {string} actualOperator - Defines the actual filter operator for the filter column.
     * @return {void}
     */
    filterByColumn(fieldName: string, filterOperator: string, filterValue: string | number | Date | boolean, predicate?: string, matchCase?: boolean, ignoreAccent?: boolean, actualFilterValue?: Object, actualOperator?: Object): void;
    private onPropertyChanged(e);
    /**
     * Clears all the filtered rows of the Grid.
     * @return {void}
     */
    clearFiltering(): void;
    private checkAlreadyColFiltered(field);
    private columnMenuFilter(args);
    private filterDialogOpen(col, target, left?, top?);
    /**
     * Removes filtered column by field name.
     * @param  {string} field - Defines column field name to remove filter.
     * @param  {boolean} isClearFilterBar -  Specifies whether the filter bar value needs to be cleared.
     * @return {void}
     * @hidden
     */
    removeFilteredColsByField(field: string, isClearFilterBar?: boolean): void;
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    private keyUpHandler(e);
    private updateCrossIcon(element);
    private updateFilterMsg();
    private setFormatForFlColumn(value, column);
    private checkForSkipInput(column, value);
    private processFilter(e);
    private startTimer(e);
    private stopTimer();
    private onTimerTick();
    private validateFilterValue(value);
    private getOperator(value);
    private columnPositionChanged(e);
    private getLocalizedCustomOperators();
    private filterIconClickHandler(e);
    private clickHandler(e);
    private filterHandler(args);
}
/**
 * `ForeignKey` module is used to handle foreign key column's actions.
 */
export  class ForeignKey extends Data {
    constructor(parent: IGrid, serviceLocator: ServiceLocator);
    private initEvent();
    private initForeignKeyColumns(columns);
    private getForeignKeyData(args);
    private generateQueryFormData(args);
    private genarateQuery(column, e?, fromData?, needQuery?);
    private genarateColumnQuery(column);
    private isFiltered(column);
    protected getModuleName(): string;
    protected destroy(): void;
    private destroyEvent();
}
/**
 * `Freeze` module is used to handle Frozen rows and columns.
 * @hidden
 */
export  class Freeze implements IAction {
    private locator;
    private parent;
    constructor(parent: IGrid, locator?: ServiceLocator);
    getModuleName(): string;
    addEventListener(): void;
    private wireEvents();
    private dblClickHandler(e);
    private instantiateRenderer();
    removeEventListener(): void;
    destroy(): void;
}
/**
 *
 * The `Group` module is used to handle group action.
 */
export  class Group implements IAction {
    private groupSettings;
    private element;
    private colName;
    private column;
    private isAppliedGroup;
    private isAppliedUnGroup;
    private visualElement;
    private helper;
    private dragStart;
    private drag;
    private dragStop;
    private drop;
    private parent;
    private serviceLocator;
    private contentRefresh;
    private sortedColumns;
    private l10n;
    private aria;
    private focus;
    /**
     * Constructor for Grid group module
     * @hidden
     */
    constructor(parent?: IGrid, groupSettings?: GroupSettingsModel, sortedColumns?: string[], serviceLocator?: ServiceLocator);
    private columnDrag(e);
    private columnDragStart(e);
    private columnDrop(e);
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    private initialEnd();
    private keyPressHandler(e);
    private clickHandler(e);
    private unGroupFromTarget(target);
    private toogleGroupFromHeader(target);
    private applySortFromTarget(target);
    /**
     * Expands or collapses grouped rows by target element.
     * @param  {Element} target - Defines the target element of the grouped row.
     * @return {void}
     */
    expandCollapseRows(target: Element): void;
    private expandCollapse(isExpand);
    /**
     * Expands all the grouped rows of the Grid.
     * @return {void}
     */
    expandAll(): void;
    /**
     * Collapses all the grouped rows of the Grid.
     * @return {void}
     */
    collapseAll(): void;
    /**
     * The function is used to render grouping
     * @return {Element}
     * @hidden
     */
    render(): void;
    private renderGroupDropArea();
    private updateGroupDropArea();
    private initDragAndDrop();
    private initializeGHeaderDrag();
    private initializeGHeaderDrop();
    /**
     * Groups a column by column name.
     * @param  {string} columnName - Defines the column name to group.
     * @return {void}
     */
    groupColumn(columnName: string): void;
    /**
     * Ungroups a column by column name.
     * @param  {string} columnName - Defines the column name to ungroup.
     * @return {void}
     */
    ungroupColumn(columnName: string): void;
    /**
     * The function used to update groupSettings
     * @return {void}
     * @hidden
     */
    updateModel(): void;
    /**
     * The function used to trigger onActionComplete
     * @return {void}
     * @hidden
     */
    onActionComplete(e: NotifyArgs): void;
    private groupAddSortingQuery(colName);
    private addColToGroupDrop(field);
    private refreshToggleBtn(isRemove?);
    private removeColFromGroupDrop(field);
    private onPropertyChanged(e);
    private updateGroupedColumn(isVisible);
    private updateButtonVisibility(isVisible, className);
    private enableAfterRender(e);
    /**
     * To destroy the reorder
     * @return {void}
     * @hidden
     */
    destroy(): void;
    /**
     * Clears all the grouped columns of the Grid.
     * @return {void}
     */
    clearGrouping(): void;
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    private refreshSortIcons(e?);
    private getGHeaderCell(field);
}
/**
 * `InlineEdit` module is used to handle inline editing actions.
 * @hidden
 */
export  class InlineEdit extends NormalEdit {
    protected parent: IGrid;
    protected serviceLocator: ServiceLocator;
    protected renderer: EditRender;
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator, renderer?: EditRender);
    closeEdit(): void;
    addRecord(data?: Object, index?: number): void;
    endEdit(): void;
    updateRow(index: number, data?: Object): void;
    deleteRecord(fieldname?: string, data?: Object): void;
    protected startEdit(tr?: Element): void;
}
/**
 * `NormalEdit` module is used to handle normal('inline, dialog, external') editing actions.
 * @hidden
 */
export  class NormalEdit {
    protected parent: IGrid;
    protected serviceLocator: ServiceLocator;
    protected renderer: EditRender;
    formObj: inputs.FormValidator;
    protected previousData: Object;
    private editRowIndex;
    private rowIndex;
    private addedRowIndex;
    private uid;
    private args;
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator, renderer?: EditRender);
    protected clickHandler(e: MouseEvent): void;
    protected dblClickHandler(e: MouseEvent): void;
    /**
     * The function used to trigger editComplete
     * @return {void}
     * @hidden
     */
    editComplete(e: NotifyArgs): void;
    protected startEdit(tr: Element): void;
    protected updateRow(index: number, data: Object): void;
    protected endEdit(): void;
    private destroyElements();
    private editHandler(args);
    private edSucc(e, args);
    private edFail(e);
    private editSuccess(e, args);
    private editFailure(e);
    private refreshRow(data);
    protected closeEdit(): void;
    protected addRecord(data?: Object, index?: number): void;
    protected deleteRecord(fieldname?: string, data?: Object): void;
    private stopEditStatus();
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    /**
     * @hidden
     */
    destroy(): void;
}
/**
 * The `Page` module is used to render pager and handle paging action.
 */
export  class Page implements IAction {
    private element;
    private pageSettings;
    private isForceCancel;
    private parent;
    private pagerObj;
    private handlers;
    /**
     * Constructor for the Grid paging module
     * @hidden
     */
    constructor(parent?: IGrid, pageSettings?: PageSettingsModel);
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    /**
     * The function used to render pager from grid pageSettings
     * @return {void}
     * @hidden
     */
    render(): void;
    private onSelect(e);
    private addAriaAttr();
    private dataReady(e?);
    /**
     * Refreshes the page count, pager information, and external message.
     * @return {void}
     */
    refresh(): void;
    /**
     * Navigates to the target page according to the given number.
     * @param  {number} pageNo - Defines the page number to navigate.
     * @return {void}
     */
    goToPage(pageNo: number): void;
    /**
     * The function used to update pageSettings model
     * @return {void}
     * @hidden
     */
    updateModel(e?: NotifyArgs): void;
    /**
     * The function used to trigger onActionComplete
     * @return {void}
     * @hidden
     */
    onActionComplete(e: NotifyArgs): void;
    /**
     * @hidden
     */
    onPropertyChanged(e: NotifyArgs): void;
    private clickHandler(e);
    private keyPressHandler(e);
    /**
     * Defines the text of the external message.
     * @param  {string} message - Defines the message to update.
     * @return {void}
     */
    updateExternalMessage(message: string): void;
    private appendToElement(e?);
    private enableAfterRender(e?);
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    /**
     * To destroy the pager
     * @return {void}
     * @hidden
     */
    destroy(): void;
    private pagerDestroy();
}
/**
 * `PDF Export` module is used to handle the exportToPDF action.
 * @hidden
 */
export  class PdfExport {
    private parent;
    private isExporting;
    private data;
    private pdfDocument;
    private hideColumnInclude;
    private currentViewData;
    private customDataSource;
    private exportValueFormatter;
    private gridTheme;
    private isGrouping;
    private helper;
    private isBlob;
    private blobPromise;
    /**
     * Constructor for the Grid PDF Export module
     * @hidden
     */
    constructor(parent?: IGrid);
    /**
     * For internal use only - Get the module name.
     */
    private getModuleName();
    private init(parent);
    /**
     * Used to map the input data
     * @return {void}
     */
    Map(parent?: IGrid, pdfExportProperties?: PdfExportProperties, isMultipleExport?: boolean, pdfDoc?: Object, isBlob?: boolean): Promise<Object>;
    private processExport(gObj, returnType, pdfExportProperties, isMultipleExport);
    private getSummaryCaptionThemeStyle();
    private getHeaderThemeStyle();
    private processGroupedRecords(pdfGrid, dataSource, gridColumns, gObj, border, level, font, brush, backgroundBrush, returnType);
    private processGridHeaders(childLevels, pdfGrid, rows, gridColumns, border, headerFont, headerBrush);
    private processExportProperties(pdfExportProperties, dataSource, section);
    private drawPageTemplate(template, element);
    private processContentValidation(content);
    private drawText(pageTemplate, content);
    private drawPageNumber(documentHeader, content);
    private drawImage(documentHeader, content);
    private drawLine(documentHeader, content);
    private processAggregates(sRows, pdfGrid, border, font, brush, backgroundBrush, isCaption, captionRow?, groupIndex?);
    private getTemplateFunction(templateFn, index, leastCaptionSummaryIndex, column);
    private getSummaryWithoutTemplate(data);
    private setColumnProperties(gridColumns, pdfGrid);
    /**
     * set default style properties of each rows in exporting grid
     * @private
     */
    private setRecordThemeStyle(row, border);
    /**
     * generate the formatted cell values
     * @private
     */
    private processRecord(border, columns, gObj, dataSource, pdfGrid, groupIndex?);
    private processCellStyle(cell, args);
    /**
     * set text alignment of each columns in exporting grid
     * @private
     */
    private getHorizontalAlignment(textAlign, format?);
    /**
     * set vertical alignment of each columns in exporting grid
     * @private
     */
    private getVerticalAlignment(verticalAlign, format?, textAlign?);
    private getFontFamily(fontFamily);
    private getFont(content);
    private getPageNumberStyle(pageNumberType);
    private setContentFormat(content, format);
    private getPageSize(pageSize);
    private getDashStyle(dashStyle);
    private getPenFromContent(content);
    private getBrushFromContent(content);
    private hexToRgb(hex);
    /**
     * To destroy the pdf export
     * @return {void}
     * @hidden
     */
    destroy(): void;
}
/**
 *
 * The `Print` module is used to handle print action.
 */
export  class Print {
    private parent;
    private printWind;
    private scrollModule;
    private isAsyncPrint;
    private printing;
    private static printGridProp;
    /**
     * Constructor for the Grid print module
     * @hidden
     */
    constructor(parent?: IGrid, scrollModule?: Scroll);
    /**
     * By default, prints all the Grid pages and hides the pager.
     * > You can customize print options using the
     * [`printMode`](./api-grid.html#printmode-string).
     * @return {void}
     */
    print(): void;
    private onEmpty();
    private actionBegin();
    private renderPrintGrid();
    private contentReady();
    private printGrid();
    private removeColGroup(depth, element);
    private isPrintGrid();
    /**
     * To destroy the print
     * @return {void}
     * @hidden
     */
    destroy(): void;
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
}
/**
 *
 * The `Reorder` module is used for reordering columns.
 */
export  class Reorder implements IAction {
    private element;
    private upArrow;
    private downArrow;
    private x;
    private timer;
    private parent;
    /**
     * Constructor for the Grid reorder module
     * @hidden
     */
    constructor(parent?: IGrid);
    private chkDropPosition(srcElem, destElem);
    private chkDropAllCols(srcElem, destElem);
    private findColParent(col, cols, parent);
    private getColumnsModel(cols);
    private headerDrop(e);
    private isActionPrevent(gObj);
    private moveColumns(destIndex, column);
    private targetParentContainerIndex(srcElem, destElem);
    private getHeaderCells();
    private getColParent(column, columns);
    /**
     * Changes the position of the Grid columns by field names.
     * @param  {string} fromFName - Defines the origin field name.
     * @param  {string} toFName - Defines the destination field name.
     * @return {void}
     */
    reorderColumns(fromFName: string, toFName: string): void;
    private enableAfterRender(e);
    private createReorderElement();
    /**
     * The function used to trigger onActionComplete
     * @return {void}
     * @hidden
     */
    onActionComplete(e: NotifyArgs): void;
    /**
     * To destroy the reorder
     * @return {void}
     * @hidden
     */
    destroy(): void;
    private drag(e);
    private updateScrollPostion(e);
    private setScrollLeft(scrollElem, isLeft);
    private stopTimer();
    private updateArrowPosition(target, isLeft);
    private dragStart(e);
    private dragStop(e);
    private setDisplay(display);
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
}
export  const resizeClassList: ResizeClasses;
export interface ResizeClasses {
    root: string;
    suppress: string;
    icon: string;
    helper: string;
    header: string;
    cursor: string;
}
/**
 * `Resize` module is used to handle Resize to fit for columns.
 * @hidden
 * @private
 */
export  class Resize implements IAction {
    private content;
    private header;
    private pageX;
    private column;
    private element;
    private helper;
    private tapped;
    private isDblClk;
    private minMove;
    private parentElementWidth;
    private parent;
    private widthService;
    /**
     * Constructor for the Grid resize module
     * @hidden
     */
    constructor(parent?: IGrid);
    /**
     * Resize by field names.
     * @param  {string|string[]} fName - Defines the field name.
     * @return {void}
     */
    autoFitColumns(fName: string | string[]): void;
    private resizeColumn(fName, index, id?);
    /**
     * To destroy the resize
     * @return {void}
     * @hidden
     */
    destroy(): void;
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    private findColumn(fName);
    /**
     * To create table for autofit
     * @hidden
     */
    protected createTable(table: Element, text: Element[], tag: string): number;
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    /**
     * @hidden
     */
    render(): void;
    private wireEvents();
    private unwireEvents();
    private getResizeHandlers();
    private setHandlerHeight();
    private callAutoFit(e);
    private resizeStart(e);
    private cancelResizeAction(removeEvents?);
    private getWidth(width, minWidth, maxWidth);
    private resizing(e);
    private resizeEnd(e);
    private getPointX(e);
    private refreshColumnWidth();
    private getTargetColumn(e);
    private updateCursor(action);
    private refresh();
    private appendHelper();
    private setHelperHeight();
    private getScrollBarWidth(height?);
    private removeHelper(e);
    private updateHelper();
    private calcPos(elem);
    private doubleTapEvent(e);
    private getUserAgent();
    private timeoutHandler();
}
/**
 *
 * Reorder module is used to handle row reordering.
 * @hidden
 */
export  class RowDD implements IAction {
    private selectedRows;
    private isDragStop;
    private helper;
    private dragStart;
    private drag;
    private dragStop;
    private parent;
    /**
     * Constructor for the Grid print module
     * @hidden
     */
    constructor(parent?: IGrid);
    private initializeDrag();
    private getElementFromPosition(element, event);
    /**
     * The function used to trigger onActionComplete
     * @return {void}
     * @hidden
     */
    onActionComplete(e: NotifyArgs): void;
    private getTargetIdx(targetRow);
    private columnDrop(e);
    private enableAfterRender(e);
    /**
     * To destroy the print
     * @return {void}
     * @hidden
     */
    destroy(): void;
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
}
/**
 * The `Scroll` module is used to handle scrolling behaviour.
 */
export  class Scroll implements IAction {
    private parent;
    private lastScrollTop;
    private previousValues;
    private oneTimeReady;
    private content;
    private header;
    private widthService;
    private pageXY;
    /**
     * Constructor for the Grid scrolling.
     * @hidden
     */
    constructor(parent?: IGrid);
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    /**
     * @hidden
     */
    setWidth(): void;
    /**
     * @hidden
     */
    setHeight(): void;
    /**
     * @hidden
     */
    setPadding(): void;
    /**
     * @hidden
     */
    removePadding(rtl?: boolean): void;
    /**
     * Refresh makes the Grid adoptable with the height of parent container.
     *
     * > The [`height`](./api-grid.html#height) must be set to 100%.
     * @return
     */
    refresh(): void;
    private getThreshold();
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    private onContentScroll(scrollTarget);
    private onFreezeContentScroll(scrollTarget);
    private onWheelScroll(scrollTarget);
    private onTouchScroll(scrollTarget);
    private setPageXY();
    private getPointXY(e);
    private wireEvents();
    /**
     * @hidden
     */
    getCssProperties(rtl?: boolean): ScrollCss;
    private ensureOverflow(content);
    private onPropertyChanged(e);
    /**
     * @hidden
     */
    destroy(): void;
    /**
     * Function to get the scrollbar width of the browser.
     * @return {number}
     * @hidden
     */
    static getScrollBarWidth(): number;
}
/**
 * @hidden
 */
export interface ScrollCss {
    padding?: string;
    border?: string;
}
/**
 * The `Search` module is used to handle search action.
 */
export  class Search implements IAction {
    private parent;
    private refreshSearch;
    private actionCompleteFunc;
    /**
     * Constructor for Grid search module.
     * @hidden
     */
    constructor(parent?: IGrid);
    /**
     * Searches Grid records by given key.
     *
     * > You can customize the default search action by using [`searchSettings`](./api-grid.html#searchsettings-searchsettingsmodel).
     * @param  {string} searchString - Defines the key.
     * @return {void}
     */
    search(searchString: string): void;
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    /**
     * To destroy the print
     * @return {void}
     * @hidden
     */
    destroy(): void;
    /**
     * @hidden
     */
    onPropertyChanged(e: NotifyArgs): void;
    /**
     * The function used to trigger onActionComplete
     * @return {void}
     * @hidden
     */
    onSearchComplete(e: NotifyArgs): void;
    onActionComplete(e: NotifyArgs): void;
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
}
/**
 * The `Selection` module is used to handle cell and row selection.
 */
export  class Selection implements IAction {
    /**
     * @hidden
     */
    selectedRowIndexes: number[];
    /**
     * @hidden
     */
    selectedRowCellIndexes: ISelectedCell[];
    /**
     * @hidden
     */
    selectedRecords: Element[];
    /**
     * @hidden
     */
    isRowSelected: boolean;
    /**
     * @hidden
     */
    isCellSelected: boolean;
    private selectionSettings;
    private prevRowIndex;
    private prevCIdxs;
    private prevECIdxs;
    private preventFocus;
    private selectedRowIndex;
    private isMultiShiftRequest;
    private isMultiCtrlRequest;
    private enableSelectMultiTouch;
    private element;
    private startIndex;
    private startCellIndex;
    private currentIndex;
    private isDragged;
    private isCellDrag;
    private x;
    private y;
    private target;
    private preSelectedCellIndex;
    private factory;
    private contentRenderer;
    private checkedTarget;
    private primaryKey;
    private chkField;
    private selectedRowState;
    private totalRecordsCount;
    private chkAllCollec;
    private isCheckedOnAdd;
    private persistSelectedData;
    private onDataBoundFunction;
    private actionBeginFunction;
    private actionCompleteFunction;
    private actionCompleteFunc;
    private parent;
    private focus;
    /**
     * Constructor for the Grid selection module
     * @hidden
     */
    constructor(parent?: IGrid, selectionSettings?: SelectionSettings, locator?: ServiceLocator);
    private initializeSelection();
    /**
     * The function used to trigger onActionBegin
     * @return {void}
     * @hidden
     */
    onActionBegin(args: Object, type: string): void;
    private fDataUpdate(args);
    /**
     * The function used to trigger onActionComplete
     * @return {void}
     * @hidden
     */
    onActionComplete(args: Object, type: string): void;
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    /**
     * To destroy the selection
     * @return {void}
     * @hidden
     */
    destroy(): void;
    private isEditing();
    private getSelectedMovableRow(index);
    /**
     * Selects a row by the given index.
     * @param  {number} index - Defines the row index.
     * @param  {boolean} isToggle - If set to true, then it toggles the selection.
     * @return {void}
     */
    selectRow(index: number, isToggle?: boolean): void;
    private addMovableArgs(targetObj, mRow);
    /**
     * Selects a range of rows from start and end row indexes.
     * @param  {number} startIndex - Specifies the start row index.
     * @param  {number} endIndex - Specifies the end row index.
     * @return {void}
     */
    selectRowsByRange(startIndex: number, endIndex?: number): void;
    /**
     * Selects a collection of rows by index.
     * @param  {number[]} rowIndexes - Specifies an array of row indexes.
     * @return {void}
     */
    selectRows(rowIndexes: number[]): void;
    /**
     * Select rows with existing row selection by passing row indexes.
     * @param  {number} startIndex - Specifies the row indexes.
     * @return {void}
     * @hidden
     */
    addRowsToSelection(rowIndexes: number[]): void;
    private getCollectionFromIndexes(startIndex, endIndex);
    private clearRow();
    private updateRowProps(startIndex);
    private updatePersistCollection(selectedRow, chkState);
    private updateCheckBoxes(row, chkState?);
    private updateRowSelection(selectedRow, startIndex);
    /**
     * Deselects the currently selected rows and cells.
     * @return {void}
     */
    clearSelection(): void;
    /**
     * Deselects the currently selected rows.
     * @return {void}
     */
    clearRowSelection(): void;
    private rowDeselect(type, rowIndex, data, row, foreignKeyData, mRow?);
    private getRowObj(row?);
    private getSelectedMovableCell(cellIndex);
    /**
     * Selects a cell by the given index.
     * @param  {IIndex} cellIndex - Defines the row and column indexes.
     * @param  {boolean} isToggle - If set to true, then it toggles the selection.
     * @return {void}
     */
    selectCell(cellIndex: IIndex, isToggle?: boolean): void;
    private getCellIndex(rIdx, cIdx);
    /**
     * Selects a range of cells from start and end indexes.
     * @param  {IIndex} startIndex - Specifies the row and column's start index.
     * @param  {IIndex} endIndex - Specifies the row and column's end index.
     * @return {void}
     */
    selectCellsByRange(startIndex: IIndex, endIndex?: IIndex): void;
    /**
     * Selects a collection of cells by row and column indexes.
     * @param  {ISelectedCell[]} rowCellIndexes - Specifies the row and column indexes.
     * @return {void}
     */
    selectCells(rowCellIndexes: ISelectedCell[]): void;
    /**
     * Select cells with existing cell selection by passing row and column index.
     * @param  {IIndex} startIndex - Defines the collection of row and column index.
     * @return {void}
     * @hidden
     */
    addCellsToSelection(cellIndexes: IIndex[]): void;
    private getColIndex(rowIndex, index);
    private getLastColIndex(rowIndex);
    private clearCell();
    private cellDeselect(type, cellIndexes, data, cells, foreignKeyData);
    private updateCellSelection(selectedCell, rowIndex?, cellIndex?);
    private addAttribute(cell);
    private updateCellProps(startIndex, endIndex);
    private addRowCellIndex(rowCellIndex);
    /**
     * Deselects the currently selected cells.
     * @return {void}
     */
    clearCellSelection(): void;
    private getSelectedCellsElement();
    private mouseMoveHandler(e);
    private selectLikeExcel(rowIndex, cellIndex);
    private mouseUpHandler(e);
    private mouseDownHandler(e);
    private clearSelAfterRefresh(e);
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    private columnPositionChanged();
    private refreshHeader();
    private rowsRemoved(e);
    dataReady(e: {
        requestType: string;
    }): void;
    private getCheckAllBox();
    private onPropertyChanged(e);
    private hidePopUp();
    private initialEnd();
    private checkBoxSelectionChanged();
    private initPerisistSelection();
    private ensureCheckboxFieldSelection();
    private dataSuccess(res);
    private setRowSelection(state);
    private getData();
    private refreshPersistSelection();
    private actionBegin(e);
    private actionComplete(e);
    private onDataBound();
    private checkSelectAllAction(checkState);
    private checkSelectAll(checkBox);
    private getCheckAllStatus(ele?);
    private checkSelect(checkBox);
    private moveIntoUncheckCollection(row);
    private triggerChkChangeEvent(checkBox, checkState);
    private setCheckAllState(isInteraction?);
    private clickHandler(e);
    private popUpClickHandler(e);
    private showPopup(e);
    private rowCellSelectionHandler(rowIndex, cellIndex);
    private onCellFocused(e);
    /**
     * Apply ctrl + A key selection
     * @return {void}
     * @hidden
     */
    ctrlPlusA(): void;
    private applySpaceSelection(target);
    private applyDownUpKey(rowIndex?, cellIndex?);
    private applyUpDown(rowIndex);
    private applyRightLeftKey(rowIndex?, cellIndex?);
    private applyHomeEndKey(rowIndex?, cellIndex?);
    /**
     * Apply shift+down key selection
     * @return {void}
     * @hidden
     */
    shiftDownKey(rowIndex?: number, cellIndex?: number): void;
    private applyShiftLeftRightKey(rowIndex?, cellIndex?);
    private applyCtrlHomeEndKey(rowIndex, cellIndex);
    private addRemoveClassesForRow(row, isAdd, clearAll, ...args);
    private isRowType();
    private isCellType();
    private isSingleSel();
    private getRenderer();
    /**
     * Gets the collection of selected records.
     * @return {Object[]}
     */
    getSelectedRecords(): Object[];
    private addEventListener_checkbox();
    removeEventListener_checkbox(): void;
    private actionCompleteHandler(e);
}
/**
 * The `ShowHide` module is used to control column visibility.
 */
export  class ShowHide {
    private parent;
    /**
     * Constructor for the show hide module.
     * @hidden
     */
    constructor(parent: IGrid);
    /**
     * Shows a column by column name.
     * @param  {string|string[]} columnName - Defines a single or collection of column names to show.
     * @param  {string} showBy - Defines the column key either as field name or header text.
     * @return {void}
     */
    show(columnName: string | string[], showBy?: string): void;
    /**
     * Hides a column by column name.
     * @param  {string|string[]} columnName - Defines a single or collection of column names to hide.
     * @param  {string} hideBy - Defines the column key either as field name or header text.
     * @return {void}
     */
    hide(columnName: string | string[], hideBy?: string): void;
    private getToggleFields(key);
    private getColumns(keys, getKeyBy?);
    /**
     * Shows or hides columns by given column collection.
     * @private
     * @param  {Column[]} columns - Specifies the columns.
     * @return {void}
     */
    setVisible(columns?: Column[]): void;
}
/**
 *
 * The `Sort` module is used to handle sorting action.
 */
export  class Sort implements IAction {
    private columnName;
    private direction;
    private isMultiSort;
    private lastSortedCol;
    private sortSettings;
    private enableSortMultiTouch;
    private contentRefresh;
    private isRemove;
    private sortedColumns;
    private isModelChanged;
    private aria;
    private focus;
    private parent;
    /**
     * Constructor for Grid sorting module
     * @hidden
     */
    constructor(parent?: IGrid, sortSettings?: SortSettings, sortedColumns?: string[], locator?: ServiceLocator);
    /**
     * The function used to update sortSettings
     * @return {void}
     * @hidden
     */
    updateModel(): void;
    /**
     * The function used to trigger onActionComplete
     * @return {void}
     * @hidden
     */
    onActionComplete(e: NotifyArgs): void;
    /**
     * Sorts a column with the given options.
     * @param {string} columnName - Defines the column name to sort.
     * @param {SortDirection} direction - Defines the direction of sorting field.
     * @param {boolean} isMultiSort - Specifies whether the previously sorted columns are to be maintained.
     * @return {void}
     */
    sortColumn(columnName: string, direction: SortDirection, isMultiSort?: boolean): void;
    private updateSortedCols(columnName, isMultiSort);
    /**
     * @hidden
     */
    onPropertyChanged(e: NotifyArgs): void;
    /**
     * Clears all the sorted columns of the Grid.
     * @return {void}
     */
    clearSorting(): void;
    private isActionPrevent();
    /**
     * Remove sorted column by field name.
     * @param {string} field - Defines the column field name to remove sort.
     * @return {void}
     * @hidden
     */
    removeSortColumn(field: string): void;
    private getSortedColsIndexByField(field, sortedColumns?);
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    private initialEnd();
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    /**
     * To destroy the sorting
     * @return {void}
     * @hidden
     */
    destroy(): void;
    private clickHandler(e);
    private keyPressed(e);
    private initiateSort(target, e, column);
    private showPopUp(e);
    private popUpClickHandler(e);
    private addSortIcons();
    private removeSortIcons(position?);
    private getSortColumnFromField(field);
    private updateAriaAttr();
    private refreshSortIcons();
}
/**
 * The `Toolbar` module is used to handle ToolBar actions.
 * @hidden
 */
export  class Toolbar {
    private element;
    private predefinedItems;
    toolbar: navigations.Toolbar;
    private searchElement;
    private gridID;
    private parent;
    private serviceLocator;
    private l10n;
    private items;
    private searchBoxObj;
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
    private render();
    /**
     * Gets the toolbar of the Grid.
     * @return {Element}
     * @hidden
     */
    getToolbar(): Element;
    /**
     * Destroys the ToolBar.
     * @method destroy
     * @return {void}
     */
    destroy(): void;
    private createToolbar();
    private refreshToolbarItems(args?);
    private getItems();
    private getItem(itemObject);
    private getItemObject(itemName);
    /**
     * Enables or disables ToolBar items.
     * @param {string[]} items - Defines the collection of itemID of ToolBar items.
     * @param {boolean} isEnable - Defines the items to be enabled or disabled.
     * @return {void}
     * @hidden
     */
    enableItems(items: string[], isEnable: boolean): void;
    private toolbarClickHandler(args);
    private modelChanged(e);
    protected onPropertyChanged(e: NotifyArgs): void;
    private keyUpHandler(e);
    private search();
    private updateSearchBox();
    private wireEvent();
    private unWireEvent();
    protected addEventListener(): void;
    protected removeEventListener(): void;
    /**
     * For internal use only - Get the module name.
     */
    private getModuleName();
}
/**
 * Virtual Scrolling class
 */
export  class VirtualScroll implements IAction {
    private parent;
    private blockSize;
    private locator;
    constructor(parent: IGrid, locator?: ServiceLocator);
    getModuleName(): string;
    private instantiateRenderer();
    ensurePageSize(): void;
    addEventListener(): void;
    removeEventListener(): void;
    private refreshVirtualElement(args);
    destroy(): void;
}
/** @hidden */
export  const created: string;
/** @hidden */
export  const destroyed: string;
/** @hidden */
export  const load: string;
/** @hidden */
export  const rowDataBound: string;
/** @hidden */
export  const queryCellInfo: string;
/** @hidden */
export  const actionBegin: string;
/** @hidden */
export  const actionComplete: string;
/** @hidden */
export  const actionFailure: string;
/** @hidden */
export  const dataBound: string;
/** @hidden */
export  const rowSelecting: string;
/** @hidden */
export  const rowSelected: string;
/** @hidden */
export  const rowDeselecting: string;
/** @hidden */
export  const rowDeselected: string;
/** @hidden */
export  const cellSelecting: string;
/** @hidden */
export  const cellSelected: string;
/** @hidden */
export  const cellDeselecting: string;
/** @hidden */
export  const cellDeselected: string;
/** @hidden */
export  const columnDragStart: string;
/** @hidden */
export  const columnDrag: string;
/** @hidden */
export  const columnDrop: string;
/** @hidden */
export  const rowDragStart: string;
/** @hidden */
export  const rowDrag: string;
/** @hidden */
export  const rowDrop: string;
/** @hidden */
export  const beforePrint: string;
/** @hidden */
export  const printComplete: string;
/** @hidden */
export  const detailDataBound: string;
/** @hidden */
export  const toolbarClick: string;
/** @hidden */
export  const batchAdd: string;
/** @hidden */
export  const batchCancel: string;
/** @hidden */
export  const batchDelete: string;
/** @hidden */
export  const beforeBatchAdd: string;
/** @hidden */
export  const beforeBatchDelete: string;
/** @hidden */
export  const beforeBatchSave: string;
/** @hidden */
export  const beginEdit: string;
/** @hidden */
export  const cellEdit: string;
/** @hidden */
export  const cellSave: string;
/** @hidden */
export  const endAdd: string;
/** @hidden */
export  const endDelete: string;
/** @hidden */
export  const endEdit: string;
/** @hidden */
export  const recordDoubleClick: string;
/** @hidden */
export  const recordClick: string;
/** @hidden */
export  const beforeDataBound: string;
/** @hidden */
export  const beforeOpenColumnChooser: string;
/** @hidden */
export  const resizeStart: string;
/** @hidden */
export  const onResize: string;
/** @hidden */
export  const resizeStop: string;
/** @hidden */
export  const checkBoxChange: string;
/** @hidden */
export  const beforeCopy: string;
/** @hidden */
export  const filterChoiceRequest: string;
/** @hidden */
export  const filterAfterOpen: string;
/** @hidden */
export  const filterBeforeOpen: string;
/**
 * Specifies grid internal events
 */
/** @hidden */
export  const initialLoad: string;
/** @hidden */
export  const initialEnd: string;
/** @hidden */
export  const dataReady: string;
/** @hidden */
export  const contentReady: string;
/** @hidden */
export  const uiUpdate: string;
/** @hidden */
export  const onEmpty: string;
/** @hidden */
export  const inBoundModelChanged: string;
/** @hidden */
export  const modelChanged: string;
/** @hidden */
export  const colGroupRefresh: string;
/** @hidden */
export  const headerRefreshed: string;
/** @hidden */
export  const pageBegin: string;
/** @hidden */
export  const pageComplete: string;
/** @hidden */
export  const sortBegin: string;
/** @hidden */
export  const sortComplete: string;
/** @hidden */
export  const filterBegin: string;
/** @hidden */
export  const filterComplete: string;
/** @hidden */
export  const searchBegin: string;
/** @hidden */
export  const searchComplete: string;
/** @hidden */
export  const reorderBegin: string;
/** @hidden */
export  const reorderComplete: string;
/** @hidden */
export  const rowDragAndDropBegin: string;
/** @hidden */
export  const rowDragAndDropComplete: string;
/** @hidden */
export  const groupBegin: string;
/** @hidden */
export  const groupComplete: string;
/** @hidden */
export  const ungroupBegin: string;
/** @hidden */
export  const ungroupComplete: string;
/** @hidden */
export  const rowSelectionBegin: string;
/** @hidden */
export  const rowSelectionComplete: string;
/** @hidden */
export  const columnSelectionBegin: string;
/** @hidden */
export  const columnSelectionComplete: string;
/** @hidden */
export  const cellSelectionBegin: string;
/** @hidden */
export  const cellSelectionComplete: string;
/** @hidden */
export  const beforeCellFocused: string;
/** @hidden */
export  const cellFocused: string;
/** @hidden */
export  const keyPressed: string;
/** @hidden */
export  const click: string;
/** @hidden */
export  const destroy: string;
/** @hidden */
export  const columnVisibilityChanged: string;
/** @hidden */
export  const scroll: string;
/** @hidden */
export  const columnWidthChanged: string;
/** @hidden */
export  const columnPositionChanged: string;
/** @hidden */
export  const rowDragAndDrop: string;
/** @hidden */
export  const rowsAdded: string;
/** @hidden */
export  const rowsRemoved: string;
/** @hidden */
export  const columnDragStop: string;
/** @hidden */
export  const headerDrop: string;
/** @hidden */
export  const dataSourceModified: string;
/** @hidden */
export  const refreshComplete: string;
/** @hidden */
export  const refreshVirtualBlock: string;
/** @hidden */
export  const dblclick: string;
/** @hidden */
export  const toolbarRefresh: string;
/** @hidden */
export  const bulkSave: string;
/** @hidden */
export  const autoCol: string;
/** @hidden */
export  const tooltipDestroy: string;
/** @hidden */
export  const updateData: string;
/** @hidden */
export  const editBegin: string;
/** @hidden */
export  const editComplete: string;
/** @hidden */
export  const addBegin: string;
/** @hidden */
export  const addComplete: string;
/** @hidden */
export  const saveComplete: string;
/** @hidden */
export  const deleteBegin: string;
/** @hidden */
export  const deleteComplete: string;
/** @hidden */
export  const preventBatch: string;
/** @hidden */
export  const dialogDestroy: string;
/** @hidden */
export  const crudAction: string;
/** @hidden */
export  const addDeleteAction: string;
/** @hidden */
export  const destroyForm: string;
/** @hidden */
export  const doubleTap: string;
/** @hidden */
export  const beforeExcelExport: string;
/** @hidden */
export  const excelExportComplete: string;
/** @hidden */
export  const excelQueryCellInfo: string;
/** @hidden */
export  const beforePdfExport: string;
/** @hidden */
export  const pdfExportComplete: string;
/** @hidden */
export  const pdfQueryCellInfo: string;
/** @hidden */
export  const accessPredicate: string;
/** @hidden */
export  const contextMenuClick: string;
/** @hidden */
export  const freezeRender: string;
/** @hidden */
export  const freezeRefresh: string;
/** @hidden */
export  const contextMenuOpen: string;
/** @hidden */
export  const columnMenuClick: string;
/** @hidden */
export  const columnMenuOpen: string;
/** @hidden */
export  const filterOpen: string;
/** @hidden */
export  const filterDialogCreated: string;
/** @hidden */
export  const filterMenuClose: string;
/** @hidden */
export  const initForeignKeyColumn: string;
/** @hidden */
export  const getForeignKeyData: string;
/** @hidden */
export  const generateQuery: string;
/** @hidden */
export  const showEmptyGrid: string;
/** @hidden */
export  const foreignKeyData: string;
/** @hidden */
export  const dataStateChange: string;
/** @hidden */
export  const dataSourceChanged: string;
/** @hidden */
export  const rtlUpdated: string;
/**
 * Defines Actions of the Grid. They are
 * * paging
 * * refresh
 * * sorting
 * * filtering
 * * selection
 * * rowdraganddrop
 * * reorder
 * * grouping
 * * ungrouping
 */
export  type Action = 'paging' | 'refresh' | 'sorting' | 'selection' | 'filtering' | 'searching' | 'rowdraganddrop' | 'reorder' | 'grouping' | 'ungrouping' | 'batchsave' | 'virtualscroll' | 'print';
/**
 * Defines directions of Sorting. They are
 * * Ascending
 * * Descending
 */
export  type SortDirection = 'Ascending' | 'Descending';
/**
 * Defines types of Selection. They are
 * * Single - Allows user to select a row or cell.
 * * Multiple - Allows user to select multiple rows or cells.
 */
export  type SelectionType = 'Single' | 'Multiple';
/**
 * Defines alignments of text, they are
 * * Left
 * * Right
 * * Center
 * * Justify
 */
export  type TextAlign = 'Left' | 'Right' | 'Center' | 'Justify';
/**
 * Defines types of Cell
 * @hidden
 */
export  enum CellType {
    /**  Defines CellType as Data */
    Data = 0,
    /**  Defines CellType as Header */
    Header = 1,
    /**  Defines CellType as Summary */
    Summary = 2,
    /**  Defines CellType as GroupSummary */
    GroupSummary = 3,
    /**  Defines CellType as CaptionSummary */
    CaptionSummary = 4,
    /**  Defines CellType as Filter */
    Filter = 5,
    /**  Defines CellType as Indent */
    Indent = 6,
    /**  Defines CellType as GroupCaption */
    GroupCaption = 7,
    /**  Defines CellType as GroupCaptionEmpty */
    GroupCaptionEmpty = 8,
    /**  Defines CellType as Expand */
    Expand = 9,
    /**  Defines CellType as HeaderIndent */
    HeaderIndent = 10,
    /**  Defines CellType as StackedHeader */
    StackedHeader = 11,
    /**  Defines CellType as DetailHeader */
    DetailHeader = 12,
    /**  Defines CellType as DetailExpand */
    DetailExpand = 13,
    /**  Defines CellType as CommandColumn */
    CommandColumn = 14,
}
/**
 * Defines modes of GridLine, They are
 * * Both - Displays both the horizontal and vertical grid lines.
 * * None - No grid lines are displayed.
 * * Horizontal - Displays the horizontal grid lines only.
 * * Vertical - Displays the vertical grid lines only.
 * * Default - Displays grid lines based on the theme.
 */
export  type GridLine = 'Both' | 'None' | 'Horizontal' | 'Vertical' | 'Default';
/**
 * Defines types of Render
 * @hidden
 */
export  enum RenderType {
    /**  Defines RenderType as Header */
    Header = 0,
    /**  Defines RenderType as Content */
    Content = 1,
    /**  Defines RenderType as Summary */
    Summary = 2,
}
/**
 * Defines modes of Selection, They are
 * * Row
 * * Cell
 * * Both
 */
export  type SelectionMode = 'Cell' | 'Row' | 'Both';
/**
 * Print mode options are
 * * AllPages - Print all pages records of the Grid.
 * * CurrentPage - Print current page records of the Grid.
 */
export  type PrintMode = 'AllPages' | 'CurrentPage';
/**
 * Defines types of Filter
 * * Menu - Specifies the filter type as menu.
 * * Excel - Specifies the filter type as excel.
 * * FilterBar - Specifies the filter type as filter bar.
 * * CheckBox - Specifies the filter type as check box.
 */
export  type FilterType = 'FilterBar' | 'Excel' | 'Menu' | 'CheckBox';
/**
 * Filter bar mode options are
 * * OnEnter - Initiate filter operation after Enter key is pressed.
 * * Immediate -  Initiate filter operation after certain time interval. By default time interval is 1500 ms.
 */
export  type FilterBarMode = 'OnEnter' | 'Immediate';
/**
 * Defines the aggregate types.
 */
export  type AggregateType = 'Sum' | 'Average' | 'Max' | 'Min' | 'Count' | 'TrueCount' | 'FalseCount' | 'Custom';
/**
 * Defines the wrap mode.
 * * Both -  Wraps both header and content.
 * * Header - Wraps header alone.
 * * Content - Wraps content alone.
 */
export  type WrapMode = 'Both' | 'Header' | 'Content';
/**
 * Defines Multiple Export Type.
 */
export  type MultipleExportType = 'AppendToSheet' | 'NewSheet';
/**
 * Defines Predefined toolbar items.
 * @hidden
 */
export  type ToolbarItems = 'Add' | 'Delete' | 'Update' | 'Cancel' | 'Edit' | 'Search' | 'ColumnChooser' | 'Print' | 'PdfExport' | 'ExcelExport' | 'CsvExport' | 'WordExport';
/**
 * Defines the cell content's overflow mode. The available modes are
 * * `Clip` -  Truncates the cell content when it overflows its area.
 * * `Ellipsis` -  Displays ellipsis when the cell content overflows its area.
 * * `EllipsisWithTooltip` - Displays ellipsis when the cell content overflows its area
 * also it will display tooltip while hover on ellipsis applied cell.
 */
export  type ClipMode = 'Clip' | 'Ellipsis' | 'EllipsisWithTooltip';
/**
 * Defines the Command Buttons type.
 * * Edit -  Edit the current record.
 * * Delete - Delete the current record.
 * * Save - Save the current edited record.
 * * Cancel - Cancel the edited state.
 */
export  type CommandButtonType = 'Edit' | 'Delete' | 'Save' | 'Cancel';
/**
 * Defines the default items of context menu.
 */
export  type ContextMenuItem = 'AutoFitAll' | 'AutoFit' | 'Group' | 'Ungroup' | 'Edit' | 'Delete' | 'Save' | 'Cancel' | 'Copy' | 'PdfExport' | 'ExcelExport' | 'CsvExport' | 'SortAscending' | 'SortDescending' | 'FirstPage' | 'PrevPage' | 'LastPage' | 'NextPage';
/**
 * Defines the default items of Column menu.
 */
export  type ColumnMenuItem = 'AutoFitAll' | 'AutoFit' | 'Group' | 'Ungroup' | 'SortAscending' | 'SortDescending' | 'ColumnChooser' | 'Filter';
/**
 * Defines Predefined toolbar items.
 * @hidden
 */
export  enum ToolbarItem {
    Add = 0,
    Edit = 1,
    Update = 2,
    Delete = 3,
    Cancel = 4,
    Print = 5,
    Search = 6,
    ColumnChooser = 7,
    PdfExport = 8,
    ExcelExport = 9,
    CsvExport = 10,
    WordExport = 11,
}
export  type PdfPageSize = 'Letter' | 'Note' | 'Legal' | 'A0' | 'A1' | 'A2' | 'A3' | 'A4' | 'A5' | 'A6' | 'A7' | 'A8' | 'A9' | 'B0' | 'B1' | 'B2' | 'B3' | 'B4' | 'B5' | 'Archa' | 'Archb' | 'Archc' | 'Archd' | 'Arche' | 'Flsa' | 'HalfLetter' | 'Letter11x17' | 'Ledger';
export  type PageOrientation = 'Landscape' | 'Portrait';
export  type ContentType = 'Image' | 'Line' | 'PageNumber' | 'Text';
export  type PdfPageNumberType = 'LowerLatin' | 'LowerRoman' | 'UpperLatin' | 'UpperRoman' | 'Numeric' | 'Arabic';
export  type PdfDashStyle = 'Solid' | 'Dash' | 'Dot' | 'DashDot' | 'DashDotDot';
/**
 * Defines PDF horizontal alignment.
 */
export  type PdfHAlign = 'Left' | 'Right' | 'Center' | 'Justify';
/**
 * Defines PDF vertical alignment.
 */
export  type PdfVAlign = 'Top' | 'Bottom' | 'Middle';
/**
 * Defines Export Type.
 */
export  type ExportType = 'CurrentPage' | 'AllPages';
/**
 * Defines Excel horizontal alignment.
 */
export  type ExcelHAlign = 'Left' | 'Right' | 'Center' | 'Fill';
/**
 * Defines Excel vertical alignment.
 */
export  type ExcelVAlign = 'Top' | 'Bottom' | 'Center' | 'Justify';
/**
 * Defines border line style.
 */
export  type BorderLineStyle = 'Thin' | 'Thick';
export  type CheckState = 'Check' | 'Uncheck' | 'Intermediate' | 'None';
/**
 * Defines mode of cell selection.
 * * Ascending
 * * Descending
 */
export  type CellSelectionMode = 'Flow' | 'Box';
/**
 * Defines modes of editing.
 * * Ascending
 * * Descending
 */
export  type EditMode = 'Normal' | 'Dialog' | 'Batch';
/**
 * Interface for a class SortDescriptor
 */
export interface SortDescriptorModel {
    /**
     * Defines the field name of sort column. 
     * @default ''
     */
    field?: string;
    /**
     * Defines the direction of sort column. 
     * @default ''
     */
    direction?: SortDirection;
}
/**
 * Interface for a class SortSettings
 */
export interface SortSettingsModel {
    /**
     * Specifies the columns to sort at initial rendering of Grid.
     * Also user can get current sorted columns. 
     * @default []
     */
    columns?: SortDescriptorModel[];
    /**
     * If `allowUnsort` set to false the user can not get the grid in unsorted state by clicking the sorted column header.
     * @default true
     */
    allowUnsort?: boolean;
}
/**
 * Interface for a class Predicate
 */
export interface PredicateModel {
    /**
     * Defines the field name of the filter column.  
     * @default ''
     */
    field?: string;
    /**
     * Defines the operator to filter records. The available operators and its supported data types are:
     * <table> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * Operator<br/></td><td colspan=1 rowspan=1> 
     * Description<br/></td><td colspan=1 rowspan=1> 
     * Supported Types<br/></td></tr> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * startswith<br/></td><td colspan=1 rowspan=1> 
     * Checks whether the value begins with the specified value.<br/></td><td colspan=1 rowspan=1> 
     * String<br/></td></tr> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * endswith<br/></td><td colspan=1 rowspan=1> 
     * Checks whether the value ends with the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
     * <br/>String<br/></td></tr> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * contains<br/></td><td colspan=1 rowspan=1> 
     * Checks whether the value contains the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
     * <br/>String<br/></td></tr> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * equal<br/></td><td colspan=1 rowspan=1> 
     * Checks whether the value is equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
     * <br/>String | Number | Boolean | Date<br/></td></tr> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * notequal<br/></td><td colspan=1 rowspan=1> 
     * Checks for values that are not equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
     * <br/>String | Number | Boolean | Date<br/></td></tr> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * greaterthan<br/></td><td colspan=1 rowspan=1> 
     * Checks whether the value is greater than the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
     * Number | Date<br/></td></tr> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * greaterthanorequal<br/></td><td colspan=1 rowspan=1> 
     * Checks whether the value is greater than or equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
     * <br/>Number | Date<br/></td></tr> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * lessthan<br/></td><td colspan=1 rowspan=1> 
     * Checks whether the value is less than the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
     * <br/>Number | Date<br/></td></tr> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * lessthanorequal<br/></td><td colspan=1 rowspan=1> 
     * Checks whether the value is less than or equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
     * <br/>Number | Date<br/></td></tr> 
     * </table> 
     * @default null
     */
    operator?: string;
    /**
     * Defines the value used to filter records. 
     * @default ''
     */
    value?: string | number | Date | boolean;
    /**
     * If match case set to true, then filter records with exact match or else  
     * filter records with case insensitive(uppercase and lowercase letters treated as same).  
     * @default null
     */
    matchCase?: boolean;
    /**
     * If ignoreAccent is set to true, then filter ignores the diacritic characters or accents while filtering.
     * @default false
     */
    ignoreAccent?: boolean;
    /**
     * Defines the relationship between one filter query and another by using AND or OR predicate.   
     * @default null
     */
    predicate?: string;
    /**
     * @hidden 
     * Defines the actual filter value for the filter column.  
     */
    actualFilterValue?: Object;
    /**
     * @hidden 
     * Defines the actual filter operator for the filter column.  
     */
    actualOperator?: Object;
    /**
     * @hidden 
     * Defines the type of the filter column.  
     */
    type?: string;
    /**
     * @hidden 
     * Defines the predicate of filter column.  
     */
    ejpredicate?: Object;
}
/**
 * Interface for a class FilterSettings
 */
export interface FilterSettingsModel {
    /**
     * Specifies the columns to be filtered at initial rendering of the Grid. You can also get the columns that were currently filtered.
     * @default []
     */
    columns?: PredicateModel[];
    /**
     * Defines options for filtering type. The available options are 
     * * `Menu` - Specifies the filter type as menu. 
     * * `CheckBox` - Specifies the filter type as checkbox.      
     * * `FilterBar` - Specifies the filter type as filterbar.  
     * * `Excel` - Specifies the filter type as checkbox.      
     * @default FilterBar 
     */
    type?: FilterType;
    /**
     * Defines the filter bar modes. The available options are,
     * * `OnEnter`: Initiates filter operation after Enter key is pressed. 
     * * `Immediate`: Initiates filter operation after a certain time interval. By default, time interval is 1500 ms. 
     * @default OnEnter
     */
    mode?: FilterBarMode;
    /**
     * Shows or hides the filtered status message on the pager.  
     * @default true
     */
    showFilterBarStatus?: boolean;
    /**
     * Defines the time delay (in milliseconds) in filtering records when the `Immediate` mode of filter bar is set. 
     * @default 1500 
     */
    immediateModeDelay?: number;
    /**
     * The `operators` is used to override the default operators in filter menu. This should be defined by type wise
     * (string, number, date and boolean). Based on the column type, this customize operator list will render in filter menu.
     * 
     * > Check the [`Filter Menu Operator`](./how-to.html#customizing-filter-menu-operators-list) customization.
     * @default null
     */
    operators?: ICustomOptr;
    /**
     * If ignoreAccent set to true, then filter ignores the diacritic characters or accents while filtering.
     * 
     * > Check the [`Diacritics`](./filtering.html/#diacritics) filtering.
     * @default false
     */
    ignoreAccent?: boolean;
}
/**
 * Interface for a class SelectionSettings
 */
export interface SelectionSettingsModel {
    /**
     * Grid supports row, cell, and both (row and cell) selection mode. 
     * @default Row
     */
    mode?: SelectionMode;
    /**
     * The cell selection modes are flow and box. It requires the selection 
     * [`mode`](./api-selectionSettings.html#mode-selectionmode) to be either cell or both.
     * * `Flow`: Selects the range of cells between start index and end index that also includes the other cells of the selected rows.
     * * `Box`: Selects the range of cells within the start and end column indexes that includes in between cells of rows within the range.
     * @default Flow
     */
    cellSelectionMode?: CellSelectionMode;
    /**
     * Defines options for selection type. They are 
     * * `Single`: Allows selection of only a row or a cell. 
     * * `Multiple`: Allows selection of multiple rows or cells. 
     * @default Single 
     */
    type?: SelectionType;
    /**
     * If 'checkboxOnly' set to true, then the Grid selection is allowed only through checkbox.
     * 
     * > To enable checkboxOnly selection, should specify the column type as`checkbox`.
     * @default false 
     */
    checkboxOnly?: boolean;
    /**
     * If 'persistSelection' set to true, then the Grid selection is persisted on all operations.
     * For persisting selection in the Grid, any one of the column should be enabled as a primary key.
     * @default false 
     */
    persistSelection?: boolean;
}
/**
 * Interface for a class SearchSettings
 */
export interface SearchSettingsModel {
    /**
     * Specifies the collection of fields included in search operation. By default, bounded columns of the Grid are included.  
     * @default []
     */
    fields?: string[];
    /**
     * Specifies the key value to search Grid records at initial rendering. 
     * You can also get the current search key.
     * @default ''
     */
    key?: string;
    /**
     * Defines the operator to search records. The available operators are:
     * <table> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * Operator<br/></td><td colspan=1 rowspan=1> 
     * Description<br/></td></tr> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * startswith<br/></td><td colspan=1 rowspan=1> 
     * Checks whether the string begins with the specified string.<br/></td></tr> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * endswith<br/></td><td colspan=1 rowspan=1> 
     * Checks whether the string ends with the specified string.<br/></td></tr> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * contains<br/></td><td colspan=1 rowspan=1> 
     * Checks whether the string contains the specified string. <br/></td></tr> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * equal<br/></td><td colspan=1 rowspan=1> 
     * Checks whether the string is equal to the specified string.<br/></td></tr> 
     * <tr> 
     * <td colspan=1 rowspan=1> 
     * notequal<br/></td><td colspan=1 rowspan=1> 
     * Checks for strings not equal to the specified string. <br/></td></tr> 
     * </table> 
     * @default contains 
     */
    operator?: string;
    /**
     * If `ignoreCase` is set to false, searches records that match exactly, else  
     * searches records that are case insensitive(uppercase and lowercase letters treated the same).  
     * @default true 
     */
    ignoreCase?: boolean;
}
/**
 * Interface for a class RowDropSettings
 */
export interface RowDropSettingsModel {
    /**
     * Defines the ID of droppable component on which row drop should occur.   
     * @default null
     */
    targetID?: string;
}
/**
 * Interface for a class TextWrapSettings
 */
export interface TextWrapSettingsModel {
    /**
     * Defines the `wrapMode` of the Grid. The available modes are: 
     * * `Both`: Wraps both the header and content. 
     * * `Content`: Wraps the header alone.
     * * `Header`: Wraps the content alone. 
     * @default Both
     */
    wrapMode?: WrapMode;
}
/**
 * Interface for a class GroupSettings
 */
export interface GroupSettingsModel {
    /**
     * If `showDropArea` is set to true, the group drop area element will be visible at the top of the Grid.     
     * @default true 
     */
    showDropArea?: boolean;
    /**
     * If `showToggleButton` set to true, then the toggle button will be showed in the column headers which can be used to group
     * or ungroup columns by clicking them.
     * @default false   
     */
    showToggleButton?: boolean;
    /**
     * If `showGroupedColumn` is set to false, it hides the grouped column after grouping.  
     * @default false  
     */
    showGroupedColumn?: boolean;
    /**
     * If `showUngroupButton` set to false, then ungroup button is hidden in dropped element.  
     * It can be used to ungroup the grouped column when click on ungroup button. 
     * @default true 
     */
    showUngroupButton?: boolean;
    /**
     * If `disablePageWiseAggregates` set to true, then the group aggregate value will
     * be calculated from the whole data instead of paged data and two requests will be made for each page
     * when Grid bound with remote service.
     * @default false
     */
    disablePageWiseAggregates?: boolean;
    /**
     * Specifies the column names to group at initial rendering of the Grid.  
     * You can also get the currently grouped columns.   
     * @default []  
     */
    columns?: string[];
    /**
     * The Caption Template allows user to display the string or HTML element in group caption.
     * > It accepts either the [template string](http://ej2.syncfusion.com/documentation/base/template-engine.html) or the HTML element ID.
     * @default ''
     */
    captionTemplate?: string;
}
/**
 * Interface for a class EditSettings
 */
export interface EditSettingsModel {
    /**
     * If `allowAdding` is set to true, new records can be added to the Grid.  
     * @default false 
     */
    allowAdding?: boolean;
    /**
     * If `allowEditing` is set to true, values can be updated in the existing record.  
     * @default false 
     */
    allowEditing?: boolean;
    /**
     * If `allowDeleting` is set to true, existing record can be deleted from the Grid.    
     * @default false 
     */
    allowDeleting?: boolean;
    /**
     * Defines the mode to edit. The available editing modes are:
     * * Normal
     * * Dialog
     * * Batch
     * @default Normal 
     */
    mode?: EditMode;
    /**
     * If `allowEditOnDblClick` is set to false, Grid will not allow editing of a record on double click. 
     * @default true 
     */
    allowEditOnDblClick?: boolean;
    /**
     * if `showConfirmDialog` is set to false, confirm dialog does not show when batch changes are saved or discarded.
     * @default true 
     */
    showConfirmDialog?: boolean;
    /**
     * If `showDeleteConfirmDialog` is set to true, confirm dialog will show delete action. You can also cancel delete command.
     * @default false 
     */
    showDeleteConfirmDialog?: boolean;
}
/**
 * Interface for a class Grid
 */
export interface GridModel extends base.ComponentModel{
    /**
     * Defines the schema of dataSource. 
     * If the `columns` declaration is empty or undefined then the `columns` are automatically generated from data source.     
     * @default []   
     */
    columns?: Column[] | string[] | ColumnModel[];
    /**
     * If `enableAltRow` is set to true, the grid will render with `e-altrow` CSS class to the alternative tr elements.    
     * > Check the [`AltRow`](./row.html#styling-alternate-rows) to customize the styles of alternative rows.
     * @default true 
     */
    enableAltRow?: boolean;
    /**
     * If `enableHover` is set to true, the row hover is enabled in the Grid.
     * @default true     
     */
    enableHover?: boolean;
    /**
     * Enables or disables the key board interaction of Grid.          
     * @hidden 
     * @default true     
     */
    allowKeyboard?: boolean;
    /**
     * If `allowTextWrap` set to true,  
     * then text content will wrap to the next line when its text content exceeds the width of the Column Cells. 
     * @default false     
     */
    allowTextWrap?: boolean;
    /**
     * Configures the text wrap in the Grid.  
     * @default {wrapMode:"Both"}     
     */
    textWrapSettings?: TextWrapSettingsModel;
    /**
     * If `allowPaging` is set to true, the pager renders at the footer of the Grid. It is used to handle page navigation in the Grid.
     * 
     * > Check the [`Paging`](./paging.html) to configure the grid pager.
     * @default false     
     */
    allowPaging?: boolean;
    /**
     * Configures the pager in the Grid.  
     * @default {currentPage: 1, pageSize: 12, pageCount: 8, enableQueryString: false, pageSizes: false, template: null}     
     */
    pageSettings?: PageSettingsModel;
    /**
     * If `enableVirtualization` set to true, then the Grid will render only the rows visible within the view-port
     * and load subsequent rows on vertical scrolling. This helps to load large dataset in Grid.
     * @default false
     */
    enableVirtualization?: boolean;
    /**
     * If `enableColumnVirtualization` set to true, then the Grid will render only the columns visible within the view-port
     * and load subsequent columns on horizontal scrolling. This helps to load large dataset of columns in Grid.
     * @default false
     */
    enableColumnVirtualization?: boolean;
    /**
     * Configures the search behavior in the Grid. 
     * @default { ignoreCase: true, fields: [], operator: 'contains', key: '' }    
     */
    searchSettings?: SearchSettingsModel;
    /**
     * If `allowSorting` is set to true, it allows sorting of grid records when column header is clicked.  
     * 
     * > Check the [`Sorting`](./sorting.html) to customize its default behavior.
     * @default false    
     */
    allowSorting?: boolean;
    /**
     * If `allowMultiSorting` set to true, then it will allow the user to sort multiple column in the grid.
     * > `allowSorting` should be true.
     * @default false
     */
    allowMultiSorting?: boolean;
    /**
     * If `allowExcelExport` set to true, then it will allow the user to export grid to Excel file.
     * 
     * > Check the [`ExcelExport`](./excel-exporting.html) to configure exporting document.
     * @default false    
     */
    allowExcelExport?: boolean;
    /**
     * If `allowPdfExport` set to true, then it will allow the user to export grid to Pdf file.
     * 
     * > Check the [`Pdfexport`](./pdf-exporting.html) to configure the exporting document.
     * @default false    
     */
    allowPdfExport?: boolean;
    /**
     * Configures the sort settings.  
     * @default {columns:[]}    
     */
    sortSettings?: SortSettingsModel;
    /**
     * If `allowSelection` is set to true, it allows selection of (highlight row) Grid records by clicking it.  
     * @default true        
     */
    allowSelection?: boolean;
    /**
     * The `selectedRowIndex` allows you to select a row at initial rendering. 
     * You can also get the currently selected row index.
     * @default -1        
     */
    selectedRowIndex?: number;
    /**
     * Configures the selection settings.  
     * @default {mode: 'Row', cellSelectionMode: 'Flow', type: 'Single'}    
     */
    selectionSettings?: SelectionSettingsModel;
    /**
     * If `allowFiltering` set to true the filter bar will be displayed. 
     * If set to false the filter bar will not be displayed. 
     * Filter bar allows the user to filter grid records with required criteria.   
     * 
     * > Check the [`Filtering`](./filtering.html) to customize its default behavior.     
     * @default false    
     */
    allowFiltering?: boolean;
    /**
     * If `allowReordering` is set to true, Grid columns can be reordered. 
     * Reordering can be done by drag and drop of a particular column from one index to another index.  
     * > If Grid is rendered with stacked headers, reordering is allowed only at the same level as the column headers.
     * @default false    
     */
    allowReordering?: boolean;
    /**
     * If `allowResizing` is set to true, Grid columns can be resized.      
     * @default false    
     */
    allowResizing?: boolean;
    /**
     * If `allowRowDragAndDrop` is set to true, you can drag and drop grid rows at another grid.    
     * @default false    
     */
    allowRowDragAndDrop?: boolean;
    /**
     * Configures the row drop settings.  
     * @default {targetID: ''}   
     */
    rowDropSettings?: RowDropSettingsModel;
    /**
     * Configures the filter settings of the Grid.  
     * @default {columns: [], type: 'FilterBar', mode: 'Immediate', showFilterBarStatus: true, immediateModeDelay: 1500 , operators: {}}    
     */
    filterSettings?: FilterSettingsModel;
    /**
     * If `allowGrouping` set to true, then it will allow the user to dynamically group or ungroup columns.  
     * Grouping can be done by drag and drop columns from column header to group drop area. 
     * 
     * > Check the [`Grouping`](./grouping.html) to customize its default behavior.
     * @default false    
     */
    allowGrouping?: boolean;
    /**
     * If `showColumnMenu` set to true, then it will enable the column menu options in each columns.
     * 
     * > Check the [`Column menu`](./columns.html#column-menu) for its configuration.
     * @default false    
     */
    showColumnMenu?: boolean;
    /**
     * Configures the group settings. 
     * @default {showDropArea: true, showToggleButton: false, showGroupedColumn: false, showUngroupButton: true, columns: []}    
     */
    groupSettings?: GroupSettingsModel;
    /**
     * Configures the edit settings. 
     * @default { allowAdding: false, allowEditing: false, allowDeleting: false, mode:'Normal',
     * allowEditOnDblClick: true, showConfirmDialog: true, showDeleteConfirmDialog: false }    
     */
    editSettings?: EditSettingsModel;
    /**
     * Configures the Grid aggregate rows.
     * > Check the [`Aggregates`](./aggregates.html) for its configuration.
     * @default []
     */
    aggregates?: AggregateRowModel[];
    /**
     * If `showColumnChooser` is set to true, it allows you to dynamically show or hide columns.  
     * 
     * > Check the [`ColumnChooser`](./columns.html#column-chooser) for its configuration.
     * @default false    
     */
    showColumnChooser?: boolean;
    /**
     * Defines the scrollable height of the grid content.    
     * @default auto    
     */
    height?: string | number;
    /**
     * Defines the Grid width.    
     * @default auto    
     */
    width?: string | number;
    /**
     * Defines the mode of grid lines. The available modes are, 
     * * `Both`: Displays both horizontal and vertical grid lines. 
     * * `None`: No grid lines are displayed.
     * * `Horizontal`: Displays the horizontal grid lines only. 
     * * `Vertical`: Displays the vertical grid lines only.
     * * `Default`: Displays grid lines based on the theme.
     * @default Default
     */
    gridLines?: GridLine;
    /**
     * The row template that renders customized rows from the given template. 
     * By default, Grid renders a table row for every data source item.
     * > * It accepts either [template string](../base/template-engine.html) or HTML element ID.   
     * > * The row template must be a table row.  
     * 
     * > Check the [`Row Template`](./row.html) customization.
     */
    rowTemplate?: string;
    /**
     * The detail template allows you to show or hide additional information about a particular row.
     *  
     * > It accepts either the [template string](../base/template-engine.html) or the HTML element ID.
     * 
     * {% codeBlock src="grid/detail-template-api/index.ts" %}{% endcodeBlock %}
     */
    detailTemplate?: string;
    /**
     * Defines Grid options to render child Grid. 
     * It requires the [`queryString`](./api-grid.html#querystring-string) for parent 
     * and child relationship. 
     * 
     * > Check the [`Child Grid`](./hierarchy-grid.html) for its configuration.
     */
    childGrid?: GridModel;
    /**
     * Defines the relationship between parent and child datasource. It acts as the foreign key for parent datasource.       
     */
    queryString?: string;
    /**
     * Defines the print modes. The available print modes are   
     * * `AllPages`: Prints all pages of the Grid. 
     * * `CurrentPage`: Prints the current page of the Grid.
     * @default AllPages
     */
    printMode?: PrintMode;
    /**
     * It is used to render grid table rows. 
     * If the `dataSource` is an array of JavaScript objects, 
     * then Grid will create instance of [`data.DataManager`](../data/api-dataManager.html) 
     * from this `dataSource`. 
     * If the `dataSource` is an existing [`data.DataManager`](../data/api-dataManager.html),
     *  the Grid will not initialize a new one. 
     * 
     * > Check the available [`Adaptors`](../data/adaptors.html) to customize the data operation.
     * @default []    
     */
    dataSource?: Object | data.DataManager | DataResult;
    /**
     * Defines the height of Grid rows.
     * @default null
     */
    rowHeight?: number;
    /**
     * Defines the external [`data.Query`](../data/api-query.html) 
     * that will be executed along with data processing.    
     * @default null    
     */
    query?: data.Query;
    /**
     * Defines the currencyCode format of the Grid columns
     * @private
     */
    currencyCode?: string;
    /**
     * `toolbar` defines the ToolBar items of the Grid. 
     * It contains built-in and custom toolbar items. 
     * If a string value is assigned to the `toolbar` option, it is considered as the template for the whole Grid ToolBar. 
     * If an array value is assigned, it is considered as the list of built-in and custom toolbar items in the Grid's Toolbar. 
     * <br><br>     
     * The available built-in ToolBar items are:
     * * Add: Adds a new record.
     * * Edit: Edits the selected record.
     * * Update: Updates the edited record.
     * * Delete: Deletes the selected record.
     * * Cancel: Cancels the edit state.
     * * Search: Searches records by the given key.
     * * Print: Prints the Grid.
     * * ExcelExport - Export the Grid to Excel(excelExport() method manually to make export.)
     * * PdfExport - Export the Grid to PDF(pdfExport() method manually to make export.)
     * * CsvExport - Export the Grid to CSV(csvExport() method manually to make export.)<br><br>
     * The following code example implements the custom toolbar items.
     * 
     *  > Check the [`Toolbar`](./toolbar.html#custom-toolbar-items) to customize its default items.
     * 
     * {% codeBlock src="grid/toolbar-api/index.ts" %}{% endcodeBlock %}
     * @default null
     */
    toolbar?: ToolbarItems[] | string[] | navigations.ItemModel[] | ToolbarItem[];
    /**
     * `contextMenuItems` defines both built-in and custom context menu items.
     * <br><br> 
     * The available built-in items are,  
     * * `AutoFitAll` - Auto fit the size of all columns. 
     * * `AutoFit` - Auto fit the current column.
     * * `Group` - Group by current column. 
     * * `Ungroup` - Ungroup by current column.
     * * `Edit` - Edit the current record.
     * * `Delete` - Delete the current record.
     * * `Save` - Save the edited record.
     * * `Cancel` - Cancel the edited state.
     * * `Copy` - Copy the selected records.
     * * `PdfExport` - Export the grid as Pdf format.
     * * `ExcelExport` - Export the grid as Excel format.
     * * `CsvExport` - Export the grid as CSV format.
     * * `SortAscending` - Sort the current column in ascending order.
     * * `SortDescending` - Sort the current column in descending order.
     * * `FirstPage` - Go to the first page.
     * * `PrevPage` - Go to the previous page.
     * * `LastPage` - Go to the last page.
     * * `NextPage` - Go to the next page.
     * 
     * @default null
     */
    contextMenuItems?: ContextMenuItem[] | ContextMenuItemModel[];
    /**
     * `columnMenuItems` defines both built-in and custom column menu items.
     * <br><br> 
     * The available built-in items are,
     * * `AutoFitAll` - Auto fit the size of all columns. 
     * * `AutoFit` - Auto fit the current column.
     * * `Group` - Group by current column. 
     * * `Ungroup` - Ungroup by current column.
     * * `SortAscending` - Sort the current column in ascending order.
     * * `SortDescending` - Sort the current column in descending order.
     * * `Filter` - Filter options will show based on filterSettings property like checkbox filter, excel filter, menu filter.
     * @default null
     */
    columnMenuItems?: ColumnMenuItem[] | ColumnMenuItemModel[];
    /**
     * @hidden
     * It used to render toolbar template
     * @default null
     */
    toolbarTemplate?: string;
    /**
     * @hidden
     * It used to render pager template
     * @default null
     */
    pagerTemplate?: string;
    /**
     * Gets or sets the number of frozen rows.
     * @default 0
     */
    frozenRows?: number;
    /**
     * Gets or sets the number of frozen columns.
     * @default 0
     */
    frozenColumns?: number;
    /**
     * Triggers when the component is created.
     * @event 
     */
    created?: base.EmitType<Object>;
    /**
     * Triggers when the component is destroyed. 
     * @event 
     */
    destroyed?: base.EmitType<Object>;
    /**
     * This event allows customization of Grid properties before rendering.
     * @event 
     */
    load?: base.EmitType<Object>;
    /**
     * Triggered every time a request is made to access row information, element, or data. 
     * This will be triggered before the row element is appended to the Grid element.
     * @event 
     */
    rowDataBound?: base.EmitType<RowDataBoundEventArgs>;
    /**
     * Triggered every time a request is made to access cell information, element, or data.
     * This will be triggered before the cell element is appended to the Grid element.
     * @event 
     */
    queryCellInfo?: base.EmitType<QueryCellInfoEventArgs>;
    /**
     * Triggers when Grid actions such as sorting, filtering, paging, grouping etc., starts. 
     * @event
     */
    actionBegin?: base.EmitType<PageEventArgs | GroupEventArgs | FilterEventArgs | SearchEventArgs | SortEventArgs | AddEventArgs | SaveEventArgs | EditEventArgs | DeleteEventArgs>;
    /**
     * Triggers when Grid actions such as sorting, filtering, paging, grouping etc. are completed. 
     * @event 
     */
    actionComplete?: base.EmitType<PageEventArgs | GroupEventArgs | FilterEventArgs | SearchEventArgs | SortEventArgs | AddEventArgs | SaveEventArgs | EditEventArgs | DeleteEventArgs>;
    /**
     * Triggers when any Grid action failed to achieve the desired results. 
     * @event 
     */
    actionFailure?: base.EmitType<FailureEventArgs>;
    /**
     * Triggers when data source is populated in the Grid.
     * @event 
     */
    dataBound?: base.EmitType<Object>;
    /**
     * Triggers when record is double clicked.
     * @event 
     */
    recordDoubleClick?: base.EmitType<RecordDoubleClickEventArgs>;
    /**
     * Triggers before row selection occurs.
     * @event 
     */
    rowSelecting?: base.EmitType<RowSelectingEventArgs>;
    /**
     * Triggers after a row is selected.
     * @event 
     */
    rowSelected?: base.EmitType<any>;
    /**
     * Triggers before deselecting the selected row.
     * @event 
     */
    rowDeselecting?: base.EmitType<any>;
    /**
     * Triggers when a selected row is deselected.
     * @event 
     */
    rowDeselected?: base.EmitType<any>;
    /**
     * Triggers before any cell selection occurs.
     * @event 
     */
    cellSelecting?: base.EmitType<CellSelectingEventArgs>;
    /**
     * Triggers after a cell is selected.
     * @event 
     */
    cellSelected?: base.EmitType<CellSelectEventArgs>;
    /**
     * Triggers before the selected cell is deselecting.
     * @event 
     */
    cellDeselecting?: base.EmitType<CellDeselectEventArgs>;
    /**
     * Triggers when a particular selected cell is deselected.
     * @event 
     */
    cellDeselected?: base.EmitType<CellDeselectEventArgs>;
    /**
     * Triggers when column header element drag (move) starts. 
     * @event  
     */
    columnDragStart?: base.EmitType<ColumnDragEventArgs>;
    /**
     * Triggers when column header element is dragged (moved) continuously. 
     * @event  
     */
    columnDrag?: base.EmitType<ColumnDragEventArgs>;
    /**
     * Triggers when a column header element is dropped on the target column. 
     * @event  
     */
    columnDrop?: base.EmitType<ColumnDragEventArgs>;
    /**
     * Triggers after print action is completed.  
     * @event 
     */
    printComplete?: base.EmitType<PrintEventArgs>;
    /**
     * Triggers before the print action starts.  
     * @event 
     */
    beforePrint?: base.EmitType<PrintEventArgs>;
    /**
     * Triggers before exporting each cell to PDF document. You can also customize the PDF cells.
     * @event 
     */
    pdfQueryCellInfo?: base.EmitType<PdfQueryCellInfoEventArgs>;
    /**
     * Triggers before exporting each cell to Excel file.
     * You can also customize the Excel cells.
     * @event
     */
    excelQueryCellInfo?: base.EmitType<ExcelQueryCellInfoEventArgs>;
    /**
     * Triggers before Grid data is exported to Excel file.
     * @event
     */
    beforeExcelExport?: base.EmitType<Object>;
    /**
     * Triggers after Grid data is exported to Excel file.
     * @event
     */
    excelExportComplete?: base.EmitType<ExcelExportCompleteArgs>;
    /**
     * Triggers before Grid data is exported to PDF document.
     * @event
     */
    beforePdfExport?: base.EmitType<Object>;
    /**
     * Triggers after Grid data is exported to PDF document.
     * @event
     */
    pdfExportComplete?: base.EmitType<PdfExportCompleteArgs>;
    /**
     * Triggers after detail row expands.
     * > This event triggers at initial expand.  
     * @event 
     */
    detailDataBound?: base.EmitType<DetailDataBoundEventArgs>;
    /**
     * Triggers when row element's drag(move) starts. 
     * @event  
     */
    rowDragStart?: base.EmitType<RowDragEventArgs>;
    /**
     * Triggers when row elements are dragged (moved) continuously. 
     * @event  
     */
    rowDrag?: base.EmitType<RowDragEventArgs>;
    /**
     * Triggers when row elements are dropped on the target row. 
     * @event  
     */
    rowDrop?: base.EmitType<RowDragEventArgs>;
    /**
     * Triggers when toolbar item is clicked.
     * @event
     */
    toolbarClick?: base.EmitType<navigations.ClickEventArgs>;
    /**
     * Triggers before the columnChooser open.
     * @event
     */
    beforeOpenColumnChooser?: base.EmitType<ColumnChooserEventArgs>;
    /**
     * Triggers when records are added in batch mode.   
     * @event
     */
    batchAdd?: base.EmitType<BatchAddArgs>;
    /**
     * Triggers when records are deleted in batch mode.
     * @event
     */
    batchDelete?: base.EmitType<BatchDeleteArgs>;
    /**
     * Triggers before records are added in batch mode.
     * @event
     */
    beforeBatchAdd?: base.EmitType<BeforeBatchAddArgs>;
    /**
     * Triggers before records are deleted in batch mode.
     * @event
     */
    beforeBatchDelete?: base.EmitType<BeforeBatchDeleteArgs>;
    /**
     * Triggers before records are saved in batch mode.
     * @event
     */
    beforeBatchSave?: base.EmitType<BeforeBatchSaveArgs>;
    /**
     * Triggers before the record is to be edit.
     * @event
     */
    beginEdit?: base.EmitType<BeginEditArgs>;
    /**
     * Triggers when the cell is being edited.
     * @event
     */
    cellEdit?: base.EmitType<CellEditArgs>;
    /**
     * Triggers when cell is saved.
     * @event
     */
    cellSave?: base.EmitType<CellSaveArgs>;
    /**
     * Triggers when column resize starts.
     * @event
     */
    resizeStart?: base.EmitType<any>;
    /**
     * Triggers on column resizing.
     * @event
     */
    resizing?: base.EmitType<any>;
    /**
     * Triggers when column resize ends.
     * @event
     */
    resizeStop?: base.EmitType<any>;
    /**
     * Triggers before data is bound to Grid.
     * @event
     */
    beforeDataBound?: base.EmitType<BeforeDataBoundArgs>;
    /**
     * Triggers before context menu opens.
     * @event
     */
    contextMenuOpen?: base.EmitType<navigations.BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers when click on context menu.
     * @event
     */
    contextMenuClick?: base.EmitType<navigations.MenuEventArgs>;
    /**
     * Triggers before column menu opens.
     * @event
     */
    columnMenuOpen?: base.EmitType<ColumnMenuOpenEventArgs>;
    /**
     * Triggers when click on column menu.
     * @event
     */
    columnMenuClick?: base.EmitType<navigations.MenuEventArgs>;
    /**
     * Triggers when the check box state change in checkbox column.
     * @event
     */
    checkBoxChange?: base.EmitType<CheckBoxChangeEventArgs>;
    /**
     * Triggers before Grid copy action.
     * @event
     */
    beforeCopy?: base.EmitType<BeforeCopyEventArgs>;
    /**
     * Triggers when the grid actions such as Sorting, Paging, Grouping etc., are done.
     * In this event,the current view data and total record count should be assigned to the `dataSource` based on the action performed.
     * @event
     */
    dataStateChange?: base.EmitType<DataStateChangeEventArgs>;
    /**
     * Triggers when the grid data is added, deleted and updated.
     * Invoke the done method from the argument to start render after edit operation.
     * @event
     */
    dataSourceChanged?: base.EmitType<DataSourceChangedEventArgs>;
}
/**
 * Represents the field name and direction of sort column.
 */
export  class SortDescriptor extends base.ChildProperty<SortDescriptor> {
    /**
     * Defines the field name of sort column.
     * @default ''
     */
    field: string;
    /**
     * Defines the direction of sort column.
     * @default ''
     */
    direction: SortDirection;
}
/**
 * Configures the sorting behavior of Grid.
 */
export  class SortSettings extends base.ChildProperty<SortSettings> {
    /**
     * Specifies the columns to sort at initial rendering of Grid.
     * Also user can get current sorted columns.
     * @default []
     */
    columns: SortDescriptorModel[];
    /**
     * If `allowUnsort` set to false the user can not get the grid in unsorted state by clicking the sorted column header.
     * @default true
     */
    allowUnsort: boolean;
}
/**
 * Represents the predicate for the filter column.
 */
export  class Predicate extends base.ChildProperty<Predicate> {
    /**
     * Defines the field name of the filter column.
     * @default ''
     */
    field: string;
    /**
     * Defines the operator to filter records. The available operators and its supported data types are:
     * <table>
     * <tr>
     * <td colspan=1 rowspan=1>
     * Operator<br/></td><td colspan=1 rowspan=1>
     * Description<br/></td><td colspan=1 rowspan=1>
     * Supported Types<br/></td></tr>
     * <tr>
     * <td colspan=1 rowspan=1>
     * startswith<br/></td><td colspan=1 rowspan=1>
     * Checks whether the value begins with the specified value.<br/></td><td colspan=1 rowspan=1>
     * String<br/></td></tr>
     * <tr>
     * <td colspan=1 rowspan=1>
     * endswith<br/></td><td colspan=1 rowspan=1>
     * Checks whether the value ends with the specified value.<br/><br/></td><td colspan=1 rowspan=1>
     * <br/>String<br/></td></tr>
     * <tr>
     * <td colspan=1 rowspan=1>
     * contains<br/></td><td colspan=1 rowspan=1>
     * Checks whether the value contains the specified value.<br/><br/></td><td colspan=1 rowspan=1>
     * <br/>String<br/></td></tr>
     * <tr>
     * <td colspan=1 rowspan=1>
     * equal<br/></td><td colspan=1 rowspan=1>
     * Checks whether the value is equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1>
     * <br/>String | Number | Boolean | Date<br/></td></tr>
     * <tr>
     * <td colspan=1 rowspan=1>
     * notequal<br/></td><td colspan=1 rowspan=1>
     * Checks for values that are not equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1>
     * <br/>String | Number | Boolean | Date<br/></td></tr>
     * <tr>
     * <td colspan=1 rowspan=1>
     * greaterthan<br/></td><td colspan=1 rowspan=1>
     * Checks whether the value is greater than the specified value.<br/><br/></td><td colspan=1 rowspan=1>
     * Number | Date<br/></td></tr>
     * <tr>
     * <td colspan=1 rowspan=1>
     * greaterthanorequal<br/></td><td colspan=1 rowspan=1>
     * Checks whether the value is greater than or equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1>
     * <br/>Number | Date<br/></td></tr>
     * <tr>
     * <td colspan=1 rowspan=1>
     * lessthan<br/></td><td colspan=1 rowspan=1>
     * Checks whether the value is less than the specified value.<br/><br/></td><td colspan=1 rowspan=1>
     * <br/>Number | Date<br/></td></tr>
     * <tr>
     * <td colspan=1 rowspan=1>
     * lessthanorequal<br/></td><td colspan=1 rowspan=1>
     * Checks whether the value is less than or equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1>
     * <br/>Number | Date<br/></td></tr>
     * </table>
     * @default null
     */
    operator: string;
    /**
     * Defines the value used to filter records.
     * @default ''
     */
    value: string | number | Date | boolean;
    /**
     * If match case set to true, then filter records with exact match or else
     * filter records with case insensitive(uppercase and lowercase letters treated as same).
     * @default null
     */
    matchCase: boolean;
    /**
     * If ignoreAccent is set to true, then filter ignores the diacritic characters or accents while filtering.
     * @default false
     */
    ignoreAccent: boolean;
    /**
     * Defines the relationship between one filter query and another by using AND or OR predicate.
     * @default null
     */
    predicate: string;
    /**
     * @hidden
     * Defines the actual filter value for the filter column.
     */
    actualFilterValue: Object;
    /**
     * @hidden
     * Defines the actual filter operator for the filter column.
     */
    actualOperator: Object;
    /**
     * @hidden
     * Defines the type of the filter column.
     */
    type: string;
    /**
     * @hidden
     * Defines the predicate of filter column.
     */
    ejpredicate: Object;
}
/**
 * Configures the filtering behavior of the Grid.
 */
export  class FilterSettings extends base.ChildProperty<FilterSettings> {
    /**
     * Specifies the columns to be filtered at initial rendering of the Grid. You can also get the columns that were currently filtered.
     * @default []
     */
    columns: PredicateModel[];
    /**
     * Defines options for filtering type. The available options are
     * * `Menu` - Specifies the filter type as menu.
     * * `CheckBox` - Specifies the filter type as checkbox.
     * * `FilterBar` - Specifies the filter type as filterbar.
     * * `Excel` - Specifies the filter type as checkbox.
     * @default FilterBar
     */
    type: FilterType;
    /**
     * Defines the filter bar modes. The available options are,
     * * `OnEnter`: Initiates filter operation after Enter key is pressed.
     * * `Immediate`: Initiates filter operation after a certain time interval. By default, time interval is 1500 ms.
     * @default OnEnter
     */
    mode: FilterBarMode;
    /**
     * Shows or hides the filtered status message on the pager.
     * @default true
     */
    showFilterBarStatus: boolean;
    /**
     * Defines the time delay (in milliseconds) in filtering records when the `Immediate` mode of filter bar is set.
     * @default 1500
     */
    immediateModeDelay: number;
    /**
     * The `operators` is used to override the default operators in filter menu. This should be defined by type wise
     * (string, number, date and boolean). Based on the column type, this customize operator list will render in filter menu.
     *
     * > Check the [`Filter Menu Operator`](./how-to.html#customizing-filter-menu-operators-list) customization.
     * @default null
     */
    operators: ICustomOptr;
    /**
     * If ignoreAccent set to true, then filter ignores the diacritic characters or accents while filtering.
     *
     * > Check the [`Diacritics`](./filtering.html/#diacritics) filtering.
     * @default false
     */
    ignoreAccent: boolean;
}
/**
 * Configures the selection behavior of the Grid.
 */
export  class SelectionSettings extends base.ChildProperty<SelectionSettings> {
    /**
     * Grid supports row, cell, and both (row and cell) selection mode.
     * @default Row
     */
    mode: SelectionMode;
    /**
     * The cell selection modes are flow and box. It requires the selection
     * [`mode`](./api-selectionSettings.html#mode-selectionmode) to be either cell or both.
     * * `Flow`: Selects the range of cells between start index and end index that also includes the other cells of the selected rows.
     * * `Box`: Selects the range of cells within the start and end column indexes that includes in between cells of rows within the range.
     * @default Flow
     */
    cellSelectionMode: CellSelectionMode;
    /**
     * Defines options for selection type. They are
     * * `Single`: Allows selection of only a row or a cell.
     * * `Multiple`: Allows selection of multiple rows or cells.
     * @default Single
     */
    type: SelectionType;
    /**
     * If 'checkboxOnly' set to true, then the Grid selection is allowed only through checkbox.
     *
     * > To enable checkboxOnly selection, should specify the column type as`checkbox`.
     * @default false
     */
    checkboxOnly: boolean;
    /**
     * If 'persistSelection' set to true, then the Grid selection is persisted on all operations.
     * For persisting selection in the Grid, any one of the column should be enabled as a primary key.
     * @default false
     */
    persistSelection: boolean;
}
/**
 * Configures the search behavior of the Grid.
 */
export  class SearchSettings extends base.ChildProperty<SearchSettings> {
    /**
     * Specifies the collection of fields included in search operation. By default, bounded columns of the Grid are included.
     * @default []
     */
    fields: string[];
    /**
     * Specifies the key value to search Grid records at initial rendering.
     * You can also get the current search key.
     * @default ''
     */
    key: string;
    /**
     * Defines the operator to search records. The available operators are:
     * <table>
     * <tr>
     * <td colspan=1 rowspan=1>
     * Operator<br/></td><td colspan=1 rowspan=1>
     * Description<br/></td></tr>
     * <tr>
     * <td colspan=1 rowspan=1>
     * startswith<br/></td><td colspan=1 rowspan=1>
     * Checks whether the string begins with the specified string.<br/></td></tr>
     * <tr>
     * <td colspan=1 rowspan=1>
     * endswith<br/></td><td colspan=1 rowspan=1>
     * Checks whether the string ends with the specified string.<br/></td></tr>
     * <tr>
     * <td colspan=1 rowspan=1>
     * contains<br/></td><td colspan=1 rowspan=1>
     * Checks whether the string contains the specified string. <br/></td></tr>
     * <tr>
     * <td colspan=1 rowspan=1>
     * equal<br/></td><td colspan=1 rowspan=1>
     * Checks whether the string is equal to the specified string.<br/></td></tr>
     * <tr>
     * <td colspan=1 rowspan=1>
     * notequal<br/></td><td colspan=1 rowspan=1>
     * Checks for strings not equal to the specified string. <br/></td></tr>
     * </table>
     * @default contains
     */
    operator: string;
    /**
     * If `ignoreCase` is set to false, searches records that match exactly, else
     * searches records that are case insensitive(uppercase and lowercase letters treated the same).
     * @default true
     */
    ignoreCase: boolean;
}
/**
 * Configures the row drop settings of the Grid.
 */
export  class RowDropSettings extends base.ChildProperty<RowDropSettings> {
    /**
     * Defines the ID of droppable component on which row drop should occur.
     * @default null
     */
    targetID: string;
}
/**
 * Configures the text wrap settings of the Grid.
 */
export  class TextWrapSettings extends base.ChildProperty<TextWrapSettings> {
    /**
     * Defines the `wrapMode` of the Grid. The available modes are:
     * * `Both`: Wraps both the header and content.
     * * `Content`: Wraps the header alone.
     * * `Header`: Wraps the content alone.
     * @default Both
     */
    wrapMode: WrapMode;
}
/**
 * Configures the group behavior of the Grid.
 */
export  class GroupSettings extends base.ChildProperty<GroupSettings> {
    /**
     * If `showDropArea` is set to true, the group drop area element will be visible at the top of the Grid.
     * @default true
     */
    showDropArea: boolean;
    /**
     * If `showToggleButton` set to true, then the toggle button will be showed in the column headers which can be used to group
     * or ungroup columns by clicking them.
     * @default false
     */
    showToggleButton: boolean;
    /**
     * If `showGroupedColumn` is set to false, it hides the grouped column after grouping.
     * @default false
     */
    showGroupedColumn: boolean;
    /**
     * If `showUngroupButton` set to false, then ungroup button is hidden in dropped element.
     * It can be used to ungroup the grouped column when click on ungroup button.
     * @default true
     */
    showUngroupButton: boolean;
    /**
     * If `disablePageWiseAggregates` set to true, then the group aggregate value will
     * be calculated from the whole data instead of paged data and two requests will be made for each page
     * when Grid bound with remote service.
     * @default false
     */
    disablePageWiseAggregates: boolean;
    /**
     * Specifies the column names to group at initial rendering of the Grid.
     * You can also get the currently grouped columns.
     * @default []
     */
    columns: string[];
    /**
     * The Caption Template allows user to display the string or HTML element in group caption.
     * > It accepts either the [template string](http://ej2.syncfusion.com/documentation/base/template-engine.html) or the HTML element ID.
     * @default ''
     */
    captionTemplate: string;
}
/**
 * Configures the edit behavior of the Grid.
 */
export  class EditSettings extends base.ChildProperty<EditSettings> {
    /**
     * If `allowAdding` is set to true, new records can be added to the Grid.
     * @default false
     */
    allowAdding: boolean;
    /**
     * If `allowEditing` is set to true, values can be updated in the existing record.
     * @default false
     */
    allowEditing: boolean;
    /**
     * If `allowDeleting` is set to true, existing record can be deleted from the Grid.
     * @default false
     */
    allowDeleting: boolean;
    /**
     * Defines the mode to edit. The available editing modes are:
     * * Normal
     * * Dialog
     * * Batch
     * @default Normal
     */
    mode: EditMode;
    /**
     * If `allowEditOnDblClick` is set to false, Grid will not allow editing of a record on double click.
     * @default true
     */
    allowEditOnDblClick: boolean;
    /**
     * if `showConfirmDialog` is set to false, confirm dialog does not show when batch changes are saved or discarded.
     * @default true
     */
    showConfirmDialog: boolean;
    /**
     * If `showDeleteConfirmDialog` is set to true, confirm dialog will show delete action. You can also cancel delete command.
     * @default false
     */
    showDeleteConfirmDialog: boolean;
}
/**
 * Represents the Grid component.
 * ```html
 * <div id="grid"></div>
 * <script>
 *  var gridObj = new Grid({ allowPaging: true });
 *  gridObj.appendTo("#grid");
 * </script>
 * ```
 */
export  class Grid extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    private gridPager;
    private isInitial;
    private columnModel;
    private rowTemplateFn;
    private detailTemplateFn;
    private sortedColumns;
    private footerElement;
    private inViewIndexes;
    private mediaCol;
    private getShowHideService;
    private mediaColumn;
    private isMediaQuery;
    private isInitialLoad;
    private dataBoundFunction;
    private freezeRefresh;
    /** @hidden */
    recordsCount: number;
    /**
     * @hidden
     */
    mergeCells: {
        [key: string]: number;
    };
    /**
     * @hidden
     */
    checkAllRows: CheckState;
    /**
     * @hidden
     */
    isCheckBoxSelection: boolean;
    /**
     * @hidden
     */
    isPersistSelection: boolean;
    /**
     * Gets the currently visible records of the Grid.
     */
    currentViewData: Object[];
    /** @hidden */
    parentDetails: ParentDetails;
    /** @hidden */
    currentAction: Action;
    /** @hidden */
    isEdit: boolean;
    /** @hidden */
    filterOperators: IFilterOperator;
    /** @hidden */
    localeObj: base.L10n;
    private defaultLocale;
    private keyConfigs;
    /**
     * @hidden
     */
    renderModule: Render;
    /**
     * @hidden
     */
    headerModule: IRenderer;
    /**
     * @hidden
     */
    contentModule: IRenderer;
    /**
     * @hidden
     */
    valueFormatterService: IValueFormatter;
    /**
     * @hidden
     */
    serviceLocator: ServiceLocator;
    /**
     * @hidden
     */
    ariaService: AriaService;
    /**
     * The `keyboardModule` is used to manipulate keyboard interactions in the Grid.
     */
    keyboardModule: base.KeyboardEvents;
    /**
     * @hidden
     */
    widthService: ColumnWidthService;
    /**
     * The `rowDragAndDropModule` is used to manipulate row reordering in the Grid.
     */
    rowDragAndDropModule: RowDD;
    /**
     * The `pagerModule` is used to manipulate paging in the Grid.
     */
    pagerModule: Page;
    /**
     * The `sortModule` is used to manipulate sorting in the Grid.
     */
    sortModule: Sort;
    /**
     * The `filterModule` is used to manipulate filtering in the Grid.
     */
    filterModule: Filter;
    /**
     * The `selectionModule` is used to manipulate selection behavior in the Grid.
     */
    selectionModule: Selection;
    /**
     * The `showHider` is used to manipulate column's show/hide operation in the Grid.
     */
    showHider: ShowHide;
    /**
     * The `searchModule` is used to manipulate searching in the Grid.
     */
    searchModule: Search;
    /**
     * The `scrollModule` is used to manipulate scrolling in the Grid.
     */
    scrollModule: Scroll;
    /**
     * The `reorderModule` is used to manipulate reordering in the Grid.
     */
    reorderModule: Reorder;
    /**
     * `resizeModule` is used to manipulate resizing in the Grid.
     * @hidden
     */
    resizeModule: Resize;
    /**
     * The `groupModule` is used to manipulate grouping behavior in the Grid.
     */
    groupModule: Group;
    /**
     * The `printModule` is used to handle the printing feature of the Grid.
     */
    printModule: Print;
    /**
     * The `excelExportModule` is used to handle Excel exporting feature in the Grid.
     */
    excelExportModule: ExcelExport;
    /**
     * The `pdfExportModule` is used to handle PDF exporting feature in the Grid.
     */
    pdfExportModule: PdfExport;
    /**
     * `detailRowModule` is used to handle detail rows rendering in the Grid.
     * @hidden
     */
    detailRowModule: DetailRow;
    /**
     * The `toolbarModule` is used to manipulate ToolBar items and its action in the Grid.
     */
    toolbarModule: Toolbar;
    /**
     * The `contextMenuModule` is used to handle context menu items and its action in the Grid.
     */
    contextMenuModule: ContextMenu;
    /**
     * The `columnMenuModule` is used to manipulate column menu items and its action in the Grid.
     */
    columnMenuModule: ColumnMenu;
    /**
     * The `editModule` is used to handle Grid content manipulation.
     */
    editModule: Edit;
    /**
     * `clipboardModule` is used to handle Grid copy action.
     */
    clipboardModule: Clipboard;
    /**
     * `columnchooserModule` is used to dynamically show or hide the Grid columns.
     * @hidden
     */
    columnChooserModule: ColumnChooser;
    private commandColumnModule;
    private focusModule;
    protected needsID: boolean;
    /**
     * Defines the schema of dataSource.
     * If the `columns` declaration is empty or undefined then the `columns` are automatically generated from data source.
     * @default []
     */
    columns: Column[] | string[] | ColumnModel[];
    /**
     * If `enableAltRow` is set to true, the grid will render with `e-altrow` CSS class to the alternative tr elements.
     * > Check the [`AltRow`](./row.html#styling-alternate-rows) to customize the styles of alternative rows.
     * @default true
     */
    enableAltRow: boolean;
    /**
     * If `enableHover` is set to true, the row hover is enabled in the Grid.
     * @default true
     */
    enableHover: boolean;
    /**
     * Enables or disables the key board interaction of Grid.
     * @hidden
     * @default true
     */
    allowKeyboard: boolean;
    /**
     * If `allowTextWrap` set to true,
     * then text content will wrap to the next line when its text content exceeds the width of the Column Cells.
     * @default false
     */
    allowTextWrap: boolean;
    /**
     * Configures the text wrap in the Grid.
     * @default {wrapMode:"Both"}
     */
    textWrapSettings: TextWrapSettingsModel;
    /**
     * If `allowPaging` is set to true, the pager renders at the footer of the Grid. It is used to handle page navigation in the Grid.
     *
     * > Check the [`Paging`](./paging.html) to configure the grid pager.
     * @default false
     */
    allowPaging: boolean;
    /**
     * Configures the pager in the Grid.
     * @default {currentPage: 1, pageSize: 12, pageCount: 8, enableQueryString: false, pageSizes: false, template: null}
     */
    pageSettings: PageSettingsModel;
    /**
     * If `enableVirtualization` set to true, then the Grid will render only the rows visible within the view-port
     * and load subsequent rows on vertical scrolling. This helps to load large dataset in Grid.
     * @default false
     */
    enableVirtualization: boolean;
    /**
     * If `enableColumnVirtualization` set to true, then the Grid will render only the columns visible within the view-port
     * and load subsequent columns on horizontal scrolling. This helps to load large dataset of columns in Grid.
     * @default false
     */
    enableColumnVirtualization: boolean;
    /**
     * Configures the search behavior in the Grid.
     * @default { ignoreCase: true, fields: [], operator: 'contains', key: '' }
     */
    searchSettings: SearchSettingsModel;
    /**
     * If `allowSorting` is set to true, it allows sorting of grid records when column header is clicked.
     *
     * > Check the [`Sorting`](./sorting.html) to customize its default behavior.
     * @default false
     */
    allowSorting: boolean;
    /**
     * If `allowMultiSorting` set to true, then it will allow the user to sort multiple column in the grid.
     * > `allowSorting` should be true.
     * @default false
     */
    allowMultiSorting: boolean;
    /**
     * If `allowExcelExport` set to true, then it will allow the user to export grid to Excel file.
     *
     * > Check the [`ExcelExport`](./excel-exporting.html) to configure exporting document.
     * @default false
     */
    allowExcelExport: boolean;
    /**
     * If `allowPdfExport` set to true, then it will allow the user to export grid to Pdf file.
     *
     * > Check the [`Pdfexport`](./pdf-exporting.html) to configure the exporting document.
     * @default false
     */
    allowPdfExport: boolean;
    /**
     * Configures the sort settings.
     * @default {columns:[]}
     */
    sortSettings: SortSettingsModel;
    /**
     * If `allowSelection` is set to true, it allows selection of (highlight row) Grid records by clicking it.
     * @default true
     */
    allowSelection: boolean;
    /**
     * The `selectedRowIndex` allows you to select a row at initial rendering.
     * You can also get the currently selected row index.
     * @default -1
     */
    selectedRowIndex: number;
    /**
     * Configures the selection settings.
     * @default {mode: 'Row', cellSelectionMode: 'Flow', type: 'Single'}
     */
    selectionSettings: SelectionSettingsModel;
    /**
     * If `allowFiltering` set to true the filter bar will be displayed.
     * If set to false the filter bar will not be displayed.
     * Filter bar allows the user to filter grid records with required criteria.
     *
     * > Check the [`Filtering`](./filtering.html) to customize its default behavior.
     * @default false
     */
    allowFiltering: boolean;
    /**
     * If `allowReordering` is set to true, Grid columns can be reordered.
     * Reordering can be done by drag and drop of a particular column from one index to another index.
     * > If Grid is rendered with stacked headers, reordering is allowed only at the same level as the column headers.
     * @default false
     */
    allowReordering: boolean;
    /**
     * If `allowResizing` is set to true, Grid columns can be resized.
     * @default false
     */
    allowResizing: boolean;
    /**
     * If `allowRowDragAndDrop` is set to true, you can drag and drop grid rows at another grid.
     * @default false
     */
    allowRowDragAndDrop: boolean;
    /**
     * Configures the row drop settings.
     * @default {targetID: ''}
     */
    rowDropSettings: RowDropSettingsModel;
    /**
     * Configures the filter settings of the Grid.
     * @default {columns: [], type: 'FilterBar', mode: 'Immediate', showFilterBarStatus: true, immediateModeDelay: 1500 , operators: {}}
     */
    filterSettings: FilterSettingsModel;
    /**
     * If `allowGrouping` set to true, then it will allow the user to dynamically group or ungroup columns.
     * Grouping can be done by drag and drop columns from column header to group drop area.
     *
     * > Check the [`Grouping`](./grouping.html) to customize its default behavior.
     * @default false
     */
    allowGrouping: boolean;
    /**
     * If `showColumnMenu` set to true, then it will enable the column menu options in each columns.
     *
     * > Check the [`Column menu`](./columns.html#column-menu) for its configuration.
     * @default false
     */
    showColumnMenu: boolean;
    /**
     * Configures the group settings.
     * @default {showDropArea: true, showToggleButton: false, showGroupedColumn: false, showUngroupButton: true, columns: []}
     */
    groupSettings: GroupSettingsModel;
    /**
     * Configures the edit settings.
     * @default { allowAdding: false, allowEditing: false, allowDeleting: false, mode:'Normal',
     * allowEditOnDblClick: true, showConfirmDialog: true, showDeleteConfirmDialog: false }
     */
    editSettings: EditSettingsModel;
    /**
     * Configures the Grid aggregate rows.
     * > Check the [`Aggregates`](./aggregates.html) for its configuration.
     * @default []
     */
    aggregates: AggregateRowModel[];
    /**
     * If `showColumnChooser` is set to true, it allows you to dynamically show or hide columns.
     *
     * > Check the [`ColumnChooser`](./columns.html#column-chooser) for its configuration.
     * @default false
     */
    showColumnChooser: boolean;
    /**
     * Defines the scrollable height of the grid content.
     * @default auto
     */
    height: string | number;
    /**
     * Defines the Grid width.
     * @default auto
     */
    width: string | number;
    /**
     * Defines the mode of grid lines. The available modes are,
     * * `Both`: Displays both horizontal and vertical grid lines.
     * * `None`: No grid lines are displayed.
     * * `Horizontal`: Displays the horizontal grid lines only.
     * * `Vertical`: Displays the vertical grid lines only.
     * * `Default`: Displays grid lines based on the theme.
     * @default Default
     */
    gridLines: GridLine;
    /**
     * The row template that renders customized rows from the given template.
     * By default, Grid renders a table row for every data source item.
     * > * It accepts either [template string](../base/template-engine.html) or HTML element ID.
     * > * The row template must be a table row.
     *
     * > Check the [`Row Template`](./row.html) customization.
     */
    rowTemplate: string;
    /**
     * The detail template allows you to show or hide additional information about a particular row.
     *
     * > It accepts either the [template string](../base/template-engine.html) or the HTML element ID.
     *
     * {% codeBlock src="grid/detail-template-api/index.ts" %}{% endcodeBlock %}
     */
    detailTemplate: string;
    /**
     * Defines Grid options to render child Grid.
     * It requires the [`queryString`](./api-grid.html#querystring-string) for parent
     * and child relationship.
     *
     * > Check the [`Child Grid`](./hierarchy-grid.html) for its configuration.
     */
    childGrid: GridModel;
    /**
     * Defines the relationship between parent and child datasource. It acts as the foreign key for parent datasource.
     */
    queryString: string;
    /**
     * Defines the print modes. The available print modes are
     * * `AllPages`: Prints all pages of the Grid.
     * * `CurrentPage`: Prints the current page of the Grid.
     * @default AllPages
     */
    printMode: PrintMode;
    /**
     * It is used to render grid table rows.
     * If the `dataSource` is an array of JavaScript objects,
     * then Grid will create instance of [`data.DataManager`](../data/api-dataManager.html)
     * from this `dataSource`.
     * If the `dataSource` is an existing [`data.DataManager`](../data/api-dataManager.html),
     *  the Grid will not initialize a new one.
     *
     * > Check the available [`Adaptors`](../data/adaptors.html) to customize the data operation.
     * @default []
     */
    dataSource: Object | data.DataManager | DataResult;
    /**
     * Defines the height of Grid rows.
     * @default null
     */
    rowHeight: number;
    /**
     * Defines the external [`data.Query`](../data/api-query.html)
     * that will be executed along with data processing.
     * @default null
     */
    query: data.Query;
    /**
     * Defines the currencyCode format of the Grid columns
     * @private
     */
    private currencyCode;
    /**
     * `toolbar` defines the ToolBar items of the Grid.
     * It contains built-in and custom toolbar items.
     * If a string value is assigned to the `toolbar` option, it is considered as the template for the whole Grid ToolBar.
     * If an array value is assigned, it is considered as the list of built-in and custom toolbar items in the Grid's Toolbar.
     * <br><br>
     * The available built-in ToolBar items are:
     * * Add: Adds a new record.
     * * Edit: Edits the selected record.
     * * Update: Updates the edited record.
     * * Delete: Deletes the selected record.
     * * Cancel: Cancels the edit state.
     * * Search: Searches records by the given key.
     * * Print: Prints the Grid.
     * * ExcelExport - Export the Grid to Excel(excelExport() method manually to make export.)
     * * PdfExport - Export the Grid to PDF(pdfExport() method manually to make export.)
     * * CsvExport - Export the Grid to CSV(csvExport() method manually to make export.)<br><br>
     * The following code example implements the custom toolbar items.
     *
     *  > Check the [`Toolbar`](./toolbar.html#custom-toolbar-items) to customize its default items.
     *
     * {% codeBlock src="grid/toolbar-api/index.ts" %}{% endcodeBlock %}
     * @default null
     */
    toolbar: ToolbarItems[] | string[] | navigations.ItemModel[] | ToolbarItem[];
    /**
     * `contextMenuItems` defines both built-in and custom context menu items.
     * <br><br>
     * The available built-in items are,
     * * `AutoFitAll` - Auto fit the size of all columns.
     * * `AutoFit` - Auto fit the current column.
     * * `Group` - Group by current column.
     * * `Ungroup` - Ungroup by current column.
     * * `Edit` - Edit the current record.
     * * `Delete` - Delete the current record.
     * * `Save` - Save the edited record.
     * * `Cancel` - Cancel the edited state.
     * * `Copy` - Copy the selected records.
     * * `PdfExport` - Export the grid as Pdf format.
     * * `ExcelExport` - Export the grid as Excel format.
     * * `CsvExport` - Export the grid as CSV format.
     * * `SortAscending` - Sort the current column in ascending order.
     * * `SortDescending` - Sort the current column in descending order.
     * * `FirstPage` - Go to the first page.
     * * `PrevPage` - Go to the previous page.
     * * `LastPage` - Go to the last page.
     * * `NextPage` - Go to the next page.
     *
     * @default null
     */
    contextMenuItems: ContextMenuItem[] | ContextMenuItemModel[];
    /**
     * `columnMenuItems` defines both built-in and custom column menu items.
     * <br><br>
     * The available built-in items are,
     * * `AutoFitAll` - Auto fit the size of all columns.
     * * `AutoFit` - Auto fit the current column.
     * * `Group` - Group by current column.
     * * `Ungroup` - Ungroup by current column.
     * * `SortAscending` - Sort the current column in ascending order.
     * * `SortDescending` - Sort the current column in descending order.
     * * `Filter` - Filter options will show based on filterSettings property like checkbox filter, excel filter, menu filter.
     * @default null
     */
    columnMenuItems: ColumnMenuItem[] | ColumnMenuItemModel[];
    /**
     * @hidden
     * It used to render toolbar template
     * @default null
     */
    toolbarTemplate: string;
    /**
     * @hidden
     * It used to render pager template
     * @default null
     */
    pagerTemplate: string;
    /**
     * Gets or sets the number of frozen rows.
     * @default 0
     */
    frozenRows: number;
    /**
     * Gets or sets the number of frozen columns.
     * @default 0
     */
    frozenColumns: number;
    /**
     * Triggers when the component is created.
     * @event
     */
    created: base.EmitType<Object>;
    /**
     * Triggers when the component is destroyed.
     * @event
     */
    destroyed: base.EmitType<Object>;
    /**
     * This event allows customization of Grid properties before rendering.
     * @event
     */
    load: base.EmitType<Object>;
    /**
     * Triggered every time a request is made to access row information, element, or data.
     * This will be triggered before the row element is appended to the Grid element.
     * @event
     */
    rowDataBound: base.EmitType<RowDataBoundEventArgs>;
    /**
     * Triggered every time a request is made to access cell information, element, or data.
     * This will be triggered before the cell element is appended to the Grid element.
     * @event
     */
    queryCellInfo: base.EmitType<QueryCellInfoEventArgs>;
    /**
     * Triggers when Grid actions such as sorting, filtering, paging, grouping etc., starts.
     * @event
     */
    actionBegin: base.EmitType<PageEventArgs | GroupEventArgs | FilterEventArgs | SearchEventArgs | SortEventArgs | AddEventArgs | SaveEventArgs | EditEventArgs | DeleteEventArgs>;
    /**
     * Triggers when Grid actions such as sorting, filtering, paging, grouping etc. are completed.
     * @event
     */
    actionComplete: base.EmitType<PageEventArgs | GroupEventArgs | FilterEventArgs | SearchEventArgs | SortEventArgs | AddEventArgs | SaveEventArgs | EditEventArgs | DeleteEventArgs>;
    /**
     * Triggers when any Grid action failed to achieve the desired results.
     * @event
     */
    actionFailure: base.EmitType<FailureEventArgs>;
    /**
     * Triggers when data source is populated in the Grid.
     * @event
     */
    dataBound: base.EmitType<Object>;
    /**
     * Triggers when record is double clicked.
     * @event
     */
    recordDoubleClick: base.EmitType<RecordDoubleClickEventArgs>;
    /**
     * Triggers before row selection occurs.
     * @event
     */
    rowSelecting: base.EmitType<RowSelectingEventArgs>;
    /**
     * Triggers after a row is selected.
     * @event
     */
    rowSelected: base.EmitType<any>;
    /**
     * Triggers before deselecting the selected row.
     * @event
     */
    rowDeselecting: base.EmitType<any>;
    /**
     * Triggers when a selected row is deselected.
     * @event
     */
    rowDeselected: base.EmitType<any>;
    /**
     * Triggers before any cell selection occurs.
     * @event
     */
    cellSelecting: base.EmitType<CellSelectingEventArgs>;
    /**
     * Triggers after a cell is selected.
     * @event
     */
    cellSelected: base.EmitType<CellSelectEventArgs>;
    /**
     * Triggers before the selected cell is deselecting.
     * @event
     */
    cellDeselecting: base.EmitType<CellDeselectEventArgs>;
    /**
     * Triggers when a particular selected cell is deselected.
     * @event
     */
    cellDeselected: base.EmitType<CellDeselectEventArgs>;
    /**
     * Triggers when column header element drag (move) starts.
     * @event
     */
    columnDragStart: base.EmitType<ColumnDragEventArgs>;
    /**
     * Triggers when column header element is dragged (moved) continuously.
     * @event
     */
    columnDrag: base.EmitType<ColumnDragEventArgs>;
    /**
     * Triggers when a column header element is dropped on the target column.
     * @event
     */
    columnDrop: base.EmitType<ColumnDragEventArgs>;
    /**
     * Triggers after print action is completed.
     * @event
     */
    printComplete: base.EmitType<PrintEventArgs>;
    /**
     * Triggers before the print action starts.
     * @event
     */
    beforePrint: base.EmitType<PrintEventArgs>;
    /**
     * Triggers before exporting each cell to PDF document. You can also customize the PDF cells.
     * @event
     */
    pdfQueryCellInfo: base.EmitType<PdfQueryCellInfoEventArgs>;
    /**
     * Triggers before exporting each cell to Excel file.
     * You can also customize the Excel cells.
     * @event
     */
    excelQueryCellInfo: base.EmitType<ExcelQueryCellInfoEventArgs>;
    /**
     * Triggers before Grid data is exported to Excel file.
     * @event
     */
    beforeExcelExport: base.EmitType<Object>;
    /**
     * Triggers after Grid data is exported to Excel file.
     * @event
     */
    excelExportComplete: base.EmitType<ExcelExportCompleteArgs>;
    /**
     * Triggers before Grid data is exported to PDF document.
     * @event
     */
    beforePdfExport: base.EmitType<Object>;
    /**
     * Triggers after Grid data is exported to PDF document.
     * @event
     */
    pdfExportComplete: base.EmitType<PdfExportCompleteArgs>;
    /**
     * Triggers after detail row expands.
     * > This event triggers at initial expand.
     * @event
     */
    detailDataBound: base.EmitType<DetailDataBoundEventArgs>;
    /**
     * Triggers when row element's drag(move) starts.
     * @event
     */
    rowDragStart: base.EmitType<RowDragEventArgs>;
    /**
     * Triggers when row elements are dragged (moved) continuously.
     * @event
     */
    rowDrag: base.EmitType<RowDragEventArgs>;
    /**
     * Triggers when row elements are dropped on the target row.
     * @event
     */
    rowDrop: base.EmitType<RowDragEventArgs>;
    /**
     * Triggers when toolbar item is clicked.
     * @event
     */
    toolbarClick: base.EmitType<navigations.ClickEventArgs>;
    /**
     * Triggers before the columnChooser open.
     * @event
     */
    beforeOpenColumnChooser: base.EmitType<ColumnChooserEventArgs>;
    /**
     * Triggers when records are added in batch mode.
     * @event
     */
    batchAdd: base.EmitType<BatchAddArgs>;
    /**
     * Triggers when records are deleted in batch mode.
     * @event
     */
    batchDelete: base.EmitType<BatchDeleteArgs>;
    /**
     * Triggers before records are added in batch mode.
     * @event
     */
    beforeBatchAdd: base.EmitType<BeforeBatchAddArgs>;
    /**
     * Triggers before records are deleted in batch mode.
     * @event
     */
    beforeBatchDelete: base.EmitType<BeforeBatchDeleteArgs>;
    /**
     * Triggers before records are saved in batch mode.
     * @event
     */
    beforeBatchSave: base.EmitType<BeforeBatchSaveArgs>;
    /**
     * Triggers before the record is to be edit.
     * @event
     */
    beginEdit: base.EmitType<BeginEditArgs>;
    /**
     * Triggers when the cell is being edited.
     * @event
     */
    cellEdit: base.EmitType<CellEditArgs>;
    /**
     * Triggers when cell is saved.
     * @event
     */
    cellSave: base.EmitType<CellSaveArgs>;
    /**
     * Triggers when column resize starts.
     * @event
     */
    resizeStart: base.EmitType<ResizeArgs>;
    /**
     * Triggers on column resizing.
     * @event
     */
    resizing: base.EmitType<ResizeArgs>;
    /**
     * Triggers when column resize ends.
     * @event
     */
    resizeStop: base.EmitType<ResizeArgs>;
    /**
     * Triggers before data is bound to Grid.
     * @event
     */
    beforeDataBound: base.EmitType<BeforeDataBoundArgs>;
    /**
     * Triggers before context menu opens.
     * @event
     */
    contextMenuOpen: base.EmitType<navigations.BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers when click on context menu.
     * @event
     */
    contextMenuClick: base.EmitType<navigations.MenuEventArgs>;
    /**
     * Triggers before column menu opens.
     * @event
     */
    columnMenuOpen: base.EmitType<ColumnMenuOpenEventArgs>;
    /**
     * Triggers when click on column menu.
     * @event
     */
    columnMenuClick: base.EmitType<navigations.MenuEventArgs>;
    /**
     * Triggers when the check box state change in checkbox column.
     * @event
     */
    checkBoxChange: base.EmitType<CheckBoxChangeEventArgs>;
    /**
     * Triggers before Grid copy action.
     * @event
     */
    beforeCopy: base.EmitType<BeforeCopyEventArgs>;
    /**
     * Triggers when the grid actions such as Sorting, Paging, Grouping etc., are done.
     * In this event,the current view data and total record count should be assigned to the `dataSource` based on the action performed.
     * @event
     */
    dataStateChange: base.EmitType<DataStateChangeEventArgs>;
    /**
     * Triggers when the grid data is added, deleted and updated.
     * Invoke the done method from the argument to start render after edit operation.
     * @event
     */
    dataSourceChanged: base.EmitType<DataSourceChangedEventArgs>;
    /**
     * Constructor for creating the component
     * @hidden
     */
    constructor(options?: GridModel, element?: string | HTMLElement);
    /**
     * Get the properties to be maintained in the persisted state.
     * @return {string}
     * @hidden
     */
    getPersistData(): string;
    private ignoreInArrays(ignoreOnColumn, columns);
    private ignoreInColumn(ignoreOnColumn, column);
    /**
     * To provide the array of modules needed for component rendering
     * @return {base.ModuleDeclaration[]}
     * @hidden
     */
    requiredModules(): base.ModuleDeclaration[];
    extendRequiredModules(modules: base.ModuleDeclaration[]): void;
    /**
     * For internal use only - Initialize the event handler;
     * @private
     */
    protected preRender(): void;
    private initProperties();
    /**
     * For internal use only - To Initialize the component rendering.
     * @private
     */
    protected render(): void;
    /**
     * By default, grid shows the spinner for all its actions. You can use this method to show spinner at your needed time.
     */
    showSpinner(): void;
    /**
     * Manually showed spinner needs to hide by `hideSpinnner`.
     */
    hideSpinner(): void;
    private updateStackedFilter();
    private getMediaColumns();
    /**
     * @hidden
     */
    mediaQueryUpdate(columnIndex: number, e?: MediaQueryList): void;
    private refreshMediaCol();
    /**
     * For internal use only - Initialize the event handler
     * @private
     */
    protected eventInitializer(): void;
    /**
     * Destroys the component (detaches/removes all event handlers, attributes, classes, and empties the component element).
     * @method destroy
     * @return {void}
     */
    destroy(): void;
    private destroyDependentModules();
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    /**
     * Called internally if any of the property value changed.
     * @hidden
     */
    onPropertyChanged(newProp: GridModel, oldProp: GridModel): void;
    private extendedPropertyChange(prop, newProp);
    private updateDefaultCursor();
    private updateColumnModel(columns);
    private updateFrozenColumns();
    /**
     * Gets the columns from the Grid.
     * @return {Column[]}
     */
    getColumns(isRefresh?: boolean): Column[];
    /**
     * @private
     */
    getColumnIndexesInView(): number[];
    /**
     * @private
     */
    getLocaleConstants(): Object;
    /**
     * @private
     */
    setColumnIndexesInView(indexes: number[]): void;
    /**
     * Gets the visible columns from the Grid.
     * @return {Column[]}
     */
    getVisibleColumns(): Column[];
    /**
     * Gets the header div of the Grid.
     * @return {Element}
     */
    getHeaderContent(): Element;
    /**
     * Sets the header div of the Grid to replace the old header.
     * @param  {Element} element - Specifies the Grid header.
     * @return {void}
     */
    setGridHeaderContent(element: Element): void;
    /**
     * Gets the content table of the Grid.
     * @return {Element}
     */
    getContentTable(): Element;
    /**
     * Sets the content table of the Grid to replace the old content table.
     * @param  {Element} element - Specifies the Grid content table.
     * @return {void}
     */
    setGridContentTable(element: Element): void;
    /**
     * Gets the content div of the Grid.
     * @return {Element}
     */
    getContent(): Element;
    /**
     * Sets the content div of the Grid to replace the old Grid content.
     * @param  {Element} element - Specifies the Grid content.
     * @return {void}
     */
    setGridContent(element: Element): void;
    /**
     * Gets the header table element of the Grid.
     * @return {Element}
     */
    getHeaderTable(): Element;
    /**
     * Sets the header table of the Grid to replace the old one.
     * @param  {Element} element - Specifies the Grid header table.
     * @return {void}
     */
    setGridHeaderTable(element: Element): void;
    /**
     * Gets the footer div of the Grid.
     * @return {Element}
     */
    getFooterContent(): Element;
    /**
     * Gets the footer table element of the Grid.
     * @return {Element}
     */
    getFooterContentTable(): Element;
    /**
     * Gets the pager of the Grid.
     * @return {Element}
     */
    getPager(): Element;
    /**
     * Sets the pager of the Grid to replace the old pager.
     * @param  {Element} element - Specifies the Grid pager.
     * @return {void}
     */
    setGridPager(element: Element): void;
    /**
     * Gets a row by index.
     * @param  {number} index - Specifies the row index.
     * @return {Element}
     */
    getRowByIndex(index: number): Element;
    /**
     * Gets a movable tables row by index.
     * @param  {number} index - Specifies the row index.
     * @return {Element}
     */
    getMovableRowByIndex(index: number): Element;
    /**
     * Gets all the data rows of the Grid.
     * @return {Element[]}
     */
    getRows(): Element[];
    /**
     * Get a row information based on cell
     * @param {Element}
     * @return RowInfo
     */
    getRowInfo(target: Element | EventTarget): RowInfo;
    /**
     * Gets the Grid's movable content rows from frozen grid.
     * @return {Element[]}
     */
    getMovableRows(): Element[];
    /**
     * Gets all the Grid's data rows.
     * @return {Element[]}
     */
    getDataRows(): Element[];
    /**
     * @hidden
     */
    addMovableRows(fRows: HTMLElement[], mrows: HTMLElement[]): HTMLElement[];
    private generateDataRows(rows);
    /**
     * Gets all the Grid's movable table data rows.
     * @return {Element[]}
     */
    getMovableDataRows(): Element[];
    /**
     * Updates particular cell value based on the given primary key value.
     * > Primary key column must be specified using `columns.isPrimaryKey` property.
     * @param {string| number} key - Specifies the PrimaryKey value of dataSource.
     * @param {string } field - Specifies the field name which you want to update.
     * @param {string | number | boolean | Date} value - To update new value for the particular cell.
     */
    setCellValue(key: string | number, field: string, value: string | number | boolean | Date): void;
    /**
     * Updates and refresh the particular row values based on the given primary key value.
     * > Primary key column must be specified using `columns.isPrimaryKey` property.
     *  @param {string| number} key - Specifies the PrimaryKey value of dataSource.
     *  @param {Object} rowData - To update new data for the particular row.
     */
    setRowData(key: string | number, rowData?: Object): void;
    /**
     * Gets a cell by row and column index.
     * @param  {number} rowIndex - Specifies the row index.
     * @param  {number} columnIndex - Specifies the column index.
     * @return {Element}
     */
    getCellFromIndex(rowIndex: number, columnIndex: number): Element;
    /**
     * Gets a movable table cell by row and column index.
     * @param  {number} rowIndex - Specifies the row index.
     * @param  {number} columnIndex - Specifies the column index.
     * @return {Element}
     */
    getMovableCellFromIndex(rowIndex: number, columnIndex: number): Element;
    /**
     * Gets a column header by column index.
     * @param  {number} index - Specifies the column index.
     * @return {Element}
     */
    getColumnHeaderByIndex(index: number): Element;
    /**
     * @hidden
     */
    getRowObjectFromUID(uid: string): Row<Column>;
    private rowObject(rows, uid);
    /**
     * @hidden
     */
    getRowsObject(): Row<Column>[];
    /**
     * @hidden
     */
    getMovableRowsObject(): Row<Column>[];
    /**
     * Gets a column header by column name.
     * @param  {string} field - Specifies the column name.
     * @return {Element}
     */
    getColumnHeaderByField(field: string): Element;
    /**
     * Gets a column header by UID.
     * @param  {string} field - Specifies the column uid.
     * @return {Element}
     */
    getColumnHeaderByUid(uid: string): Element;
    /**
     * Gets a Column by column name.
     * @param  {string} field - Specifies the column name.
     * @return {Column}
     */
    getColumnByField(field: string): Column;
    /**
     * Gets a column index by column name.
     * @param  {string} field - Specifies the column name.
     * @return {number}
     */
    getColumnIndexByField(field: string): number;
    /**
     * Gets a column by UID.
     * @param  {string} uid - Specifies the column UID.
     * @return {Column}
     */
    getColumnByUid(uid: string): Column;
    /**
     * Gets a column index by UID.
     * @param  {string} uid - Specifies the column UID.
     * @return {number}
     */
    getColumnIndexByUid(uid: string): number;
    /**
     * Gets UID by column name.
     * @param  {string} field - Specifies the column name.
     * @return {string}
     */
    getUidByColumnField(field: string): string;
    /**
     * Gets TH index by column uid value.
     * @private
     * @param  {string} uid - Specifies the column uid.
     * @return {number}
     */
    getNormalizedColumnIndex(uid: string): number;
    /**
     * Gets the collection of column fields.
     * @return {string[]}
     */
    getColumnFieldNames(): string[];
    /**
     * Gets a compiled row template.
     * @return {Function}
     * @private
     */
    getRowTemplate(): Function;
    /**
     * Gets a compiled detail row template.
     * @private
     * @return {Function}
     */
    getDetailTemplate(): Function;
    /**
     * Get the names of the primary key columns of the Grid.
     * @return {string[]}
     */
    getPrimaryKeyFieldNames(): string[];
    /**
     * Refreshes the Grid header and content.
     */
    refresh(): void;
    /**
     * Refreshes the Grid header.
     */
    refreshHeader(): void;
    /**
     * Gets the collection of selected rows.
     * @return {Element[]}
     */
    getSelectedRows(): Element[];
    /**
     * Gets the collection of selected row indexes.
     * @return {number[]}
     */
    getSelectedRowIndexes(): number[];
    /**
     * Gets the collection of selected row and cell indexes.
     * @return {number[]}
     */
    getSelectedRowCellIndexes(): ISelectedCell[];
    /**
     * Gets the collection of selected records.
     * @return {Object[]}
     */
    getSelectedRecords(): Object[];
    /**
     * Gets the data module.
     * @return {Data}
     */
    getDataModule(): Data;
    /**
     * Shows a column by its column name.
     * @param  {string|string[]} keys - Defines a single or collection of column names.
     * @param  {string} showBy - Defines the column key either as field name or header text.
     * @return {void}
     */
    showColumns(keys: string | string[], showBy?: string): void;
    /**
     * Hides a column by column name.
     * @param  {string|string[]} keys - Defines a single or collection of column names.
     * @param  {string} hideBy - Defines the column key either as field name or header text.
     * @return {void}
     */
    hideColumns(keys: string | string[], hideBy?: string): void;
    /**
     * @hidden
     */
    getFrozenColumns(): number;
    private getFrozenCount(cols, cnt);
    /**
     * Navigates to the specified target page.
     * @param  {number} pageNo - Defines the page number to navigate.
     * @return {void}
     */
    goToPage(pageNo: number): void;
    /**
     * Defines the text of external message.
     * @param  {string} message - Defines the message to update.
     * @return {void}
     */
    updateExternalMessage(message: string): void;
    /**
     * Sorts a column with the given options.
     * @param {string} columnName - Defines the column name to be sorted.
     * @param {SortDirection} direction - Defines the direction of sorting field.
     * @param {boolean} isMultiSort - Specifies whether the previous sorted columns are to be maintained.
     * @return {void}
     */
    sortColumn(columnName: string, direction: SortDirection, isMultiSort?: boolean): void;
    /**
     * Clears all the sorted columns of the Grid.
     * @return {void}
     */
    clearSorting(): void;
    /**
     * Remove sorted column by field name.
     * @param {string} field - Defines the column field name to remove sort.
     * @return {void}
     * @hidden
     */
    removeSortColumn(field: string): void;
    /**
     * Filters grid row by column name with the given options.
     * @param  {string} fieldName - Defines the field name of the column.
     * @param  {string} filterOperator - Defines the operator to filter records.
     * @param  {string | number | Date | boolean} filterValue - Defines the value used to filter records.
     * @param  {string} predicate - Defines the relationship between one filter query and another by using AND or OR predicate.
     * @param  {boolean} matchCase - If match case is set to true, the grid filters the records with exact match. if false, it filters case
     * insensitive records (uppercase and lowercase letters treated the same).
     * @param  {boolean} ignoreAccent - If ignoreAccent set to true,
     * then filter ignores the diacritic characters or accents while filtering.
     * @param  {string} actualFilterValue - Defines the actual filter value for the filter column.
     * @param  {string} actualOperator - Defines the actual filter operator for the filter column.
     * @return {void}
     */
    filterByColumn(fieldName: string, filterOperator: string, filterValue: string | number | Date | boolean, predicate?: string, matchCase?: boolean, ignoreAccent?: boolean, actualFilterValue?: string, actualOperator?: string): void;
    /**
     * Clears all the filtered rows of the Grid.
     * @return {void}
     */
    clearFiltering(): void;
    /**
     * Removes filtered column by field name.
     * @param  {string} field - Defines column field name to remove filter.
     * @param  {boolean} isClearFilterBar -  Specifies whether the filter bar value needs to be cleared.
     * @return {void}
     * @hidden
     */
    removeFilteredColsByField(field: string, isClearFilterBar?: boolean): void;
    /**
     * Selects a row by given index.
     * @param  {number} index - Defines the row index.
     * @param  {boolean} isToggle - If set to true, then it toggles the selection.
     * @return {void}
     */
    selectRow(index: number, isToggle?: boolean): void;
    /**
     * Selects a collection of rows by indexes.
     * @param  {number[]} rowIndexes - Specifies the row indexes.
     * @return {void}
     */
    selectRows(rowIndexes: number[]): void;
    /**
     * Deselects the current selected rows and cells.
     * @return {void}
     */
    clearSelection(): void;
    /**
     * Selects a cell by the given index.
     * @param  {IIndex} cellIndex - Defines the row and column indexes.
     * @param  {boolean} isToggle - If set to true, then it toggles the selection.
     * @return {void}
     */
    selectCell(cellIndex: IIndex, isToggle?: boolean): void;
    /**
     * Searches Grid records using the given key.
     * You can customize the default search option by using the
     * [`searchSettings`](./api-searchSettings.html).
     * @param  {string} searchString - Defines the key.
     * @return {void}
     */
    search(searchString: string): void;
    /**
     * By default, prints all the pages of the Grid and hides the pager.
     * > You can customize print options using the
     * [`printMode`](./api-grid.html#printmode-string).
     * @return {void}
     */
    print(): void;
    /**
     * Delete a record with Given options. If fieldname and data is not given then grid will delete the selected record.
     * > `editSettings.allowDeleting` should be true.
     * @param {string} fieldname - Defines the primary key field, 'Name of the column'.
     * @param {Object} data - Defines the JSON data of the record to be deleted.
     */
    deleteRecord(fieldname?: string, data?: Object): void;
    /**
     * To edit any particular row by TR element.
     * @param {HTMLTableRowElement} tr - Defines the table row to be edited.
     */
    startEdit(): void;
    /**
     * If Grid is in editable state, you can save a record by invoking endEdit.
     */
    endEdit(): void;
    /**
     * Cancels edited state.
     */
    closeEdit(): void;
    /**
     * Adds a new record to the Grid. Without passing parameters, it adds empty rows.
     * > `editSettings.allowEditing` should be true.
     * @param {Object} data - Defines the new add record data.
     * @param {number} index - Defines the row index to be added
     */
    addRecord(data?: Object, index?: number): void;
    /**
     * Delete any visible row by TR element.
     * @param {HTMLTableRowElement} tr - Defines the table row element.
     */
    deleteRow(tr: HTMLTableRowElement): void;
    /**
     * Copy the selected rows or cells data into clipboard.
     * @param {boolean} withHeader - Specifies whether the column header text needs to be copied along with rows or cells.
     */
    copy(withHeader?: boolean): void;
    /**
     * @hidden
     */
    recalcIndentWidth(): void;
    /**
     * Changes the Grid column positions by field names.
     * @param  {string} fromFName - Defines the origin field name.
     * @param  {string} toFName - Defines the destination field name.
     * @return {void}
     */
    reorderColumns(fromFName: string, toFName: string): void;
    /**
     * Changes the column width to automatically fit its content to ensure that the width shows the content without wrapping/hiding.
     * > * This method ignores the hidden columns.
     * > * Uses the `autoFitColumns` method in the `dataBound` event to resize at initial rendering.
     * @param  {string |string[]} fieldNames - Defines the column names.
     * @return {void}
     *
     *
     * ```typescript
     * <div id="Grid"></div>
     * <script>
     * let gridObj: Grid = new Grid({
     *     dataSource: employeeData,
     *     columns: [
     *         { field: 'OrderID', headerText: 'Order ID', width:100 },
     *         { field: 'EmployeeID', headerText: 'Employee ID' }],
     *     dataBound: () => gridObj.autoFitColumns('EmployeeID')
     * });
     * gridObj.appendTo('#Grid');
     * </script>
     * ```
     *
     */
    autoFitColumns(fieldNames: string | string[]): void;
    /**
     * @hidden
     */
    createColumnchooser(x: number, y: number, target: Element): void;
    private initializeServices();
    private processModel();
    private initForeignColumn();
    private gridRender();
    private dataReady();
    private updateRTL();
    private createGridPopUpElement();
    private updateGridLines();
    private updateResizeLines();
    /**
     * The function is used to apply text wrap
     * @return {void}
     * @hidden
     */
    applyTextWrap(): void;
    /**
     * The function is used to remove text wrap
     * @return {void}
     * @hidden
     */
    removeTextWrap(): void;
    /**
     * The function is used to add Tooltip to the grid cell that has ellipsiswithtooltip clip mode.
     * @return {void}
     * @hidden
     */
    refreshTooltip(): void;
    /**
     * To create table for ellipsiswithtooltip
     * @hidden
     */
    protected createTable(table: Element, tag: string, type: string): HTMLDivElement;
    /**
     * Binding events to the element while component creation.
     * @hidden
     */
    wireEvents(): void;
    /**
     * Unbinding events from the element while component destroy.
     * @hidden
     */
    unwireEvents(): void;
    /**
     * @hidden
     */
    addListener(): void;
    /**
     * @hidden
     */
    removeListener(): void;
    /**
     * Get current visible data of grid.
     * @return {Object[]}
     * @hidden
     */
    getCurrentViewRecords(): Object[];
    private mouseClickHandler(e);
    private checkEdit(e);
    private dblClickHandler(e);
    private focusOutHandler(e);
    private isChildGrid(e);
    private mergePersistGridData();
    private isDetail();
    private isCommandColumn(columns);
    private isForeignKeyEnabled(columns);
    private keyActionHandler(e);
    /**
     * @hidden
     */
    setInjectedModules(modules: Function[]): void;
    private updateColumnObject();
    /**
     * Gets the foreign columns from Grid.
     * @return {Column[]}
     */
    getForeignKeyColumns(): Column[];
    /**
     * Refreshes the Grid column changes.
     */
    refreshColumns(): void;
    /**
     * Export Grid data to Excel file(.xlsx).
     * @param  {ExcelExportProperties} excelExportProperties - Defines the export properties of the Grid.
     * @param  {boolean} isMultipleExport - Define to enable multiple export.
     * @param  {workbook} workbook - Defines the Workbook if multiple export is enabled.
     * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.
     * @return {Promise<any>}
     */
    excelExport(excelExportProperties?: ExcelExportProperties, isMultipleExport?: boolean, workbook?: any, isBlob?: boolean): Promise<any>;
    /**
     * Export Grid data to CSV file.
     * @param  {ExcelExportProperties} excelExportProperties - Defines the export properties of the Grid.
     * @param  {boolean} isMultipleExport - Define to enable multiple export.
     * @param  {workbook} workbook - Defines the Workbook if multiple export is enabled.
     * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.
     * @return {Promise<any>}
     *
     */
    csvExport(excelExportProperties?: ExcelExportProperties, isMultipleExport?: boolean, workbook?: any, isBlob?: boolean): Promise<any>;
    /**
     * Export Grid data to PDF document.
     * @param  {pdfExportProperties} PdfExportProperties - Defines the export properties of the Grid.
     * @param  {isMultipleExport} isMultipleExport - Define to enable multiple export.
     * @param  {pdfDoc} pdfDoc - Defined the Pdf Document if multiple export is enabled.
     * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.
     * @return {Promise<any>}
     *
     */
    pdfExport(pdfExportProperties?: PdfExportProperties, isMultipleExport?: boolean, pdfDoc?: Object, isBlob?: boolean): Promise<Object>;
    /**
     * Groups a column by column name.
     * @param  {string} columnName - Defines the column name to group.
     * @return {void}
     */
    groupColumn(columnName: string): void;
    /**
     * Ungroups a column by column name.
     * @param  {string} columnName - Defines the column name to ungroup.
     * @return {void}
     */
    ungroupColumn(columnName: string): void;
    /**
     * @hidden
     */
    isContextMenuOpen(): boolean;
    /**
     * @hidden
     */
    ensureModuleInjected(module: Function): boolean;
    /**
     * Destroys the given template reference.
     * @param {string[]} propertyNames - Defines the collection of template name.
     */
    destroyTemplate(propertyNames?: string[]): void;
}
/**
 * Specifies grid interfaces.
 * @hidden
 */
export interface IGrid extends base.Component<HTMLElement> {
    currentViewData?: Object[];
    /**
     * Specifies the columns for Grid.
     * @default []
     */
    columns?: Column[] | string[] | ColumnModel[];
    /**
     * Specifies whether the enableAltRow is enable or not.
     * @default null
     */
    enableAltRow?: boolean;
    /**
     * Specifies whether the enable row hover is enable or not.
     * @default null
     */
    enableHover?: boolean;
    /**
     * Specifies the allowKeyboard Navigation for the Grid.
     * @default null
     */
    allowKeyboard?: boolean;
    /**
     * Specifies whether the allowTextWrap is enabled or not.
     * @default null
     */
    allowTextWrap?: boolean;
    /**
     * Specifies the 'textWrapSettings' for Grid.
     * @default []
     */
    textWrapSettings?: TextWrapSettingsModel;
    /**
     * Specifies whether the paging is enable or not.
     * @default null
     */
    allowPaging?: boolean;
    /**
     * Specifies the pageSettings for Grid.
     * @default PageSettings
     */
    pageSettings?: PageSettingsModel;
    enableVirtualization: boolean;
    enableColumnVirtualization: boolean;
    /**
     * Specifies whether the sorting is enable or not.
     * @default null
     */
    allowSorting?: boolean;
    /**
     * Specifies whether the multi-sorting is enable or not.
     * @default null
     */
    allowMultiSorting?: boolean;
    /**
     * Specifies the sortSettings for Grid.
     * @default []
     */
    sortSettings?: SortSettingsModel;
    /**
     * Specifies whether the Excel exporting is enable or not.
     * @default null
     */
    allowExcelExport?: boolean;
    /**
     * Specifies whether the Pdf exporting is enable or not.
     * @default null
     */
    allowPdfExport?: boolean;
    /**
     * Specifies whether the selection is enable or not.
     * @default null
     */
    allowSelection?: boolean;
    /**
     * It is used to select the row while initializing the grid.
     * @default -1
     */
    selectedRowIndex?: number;
    /**
     * Specifies the selectionSettings for Grid.
     * @default []
     */
    selectionSettings?: SelectionSettingsModel;
    /**
     * Specifies whether the reordering is enable or not.
     * @default null
     */
    allowReordering?: boolean;
    /**
     * If `allowResizing` set to true, then the Grid columns can be resized.
     * @default false
     */
    allowResizing?: boolean;
    /**
     * Specifies whether the filtering is enable or not.
     * @default null
     */
    allowFiltering?: boolean;
    /**
     * Specifies the filterSettings for Grid.
     * @default []
     */
    filterSettings?: FilterSettingsModel;
    /**
     * Specifies whether the grouping is enable or not.
     * @default null
     */
    allowGrouping?: boolean;
    /**
     * Specifies whether the column menu is show or not.
     * @default null
     */
    showColumnMenu?: boolean;
    /**
     * Specifies the groupSettings for Grid.
     * @default []
     */
    groupSettings?: GroupSettingsModel;
    /**
     * if showColumnChooser is true, then column chooser will be enabled in Grid.
     * @default false
     */
    showColumnChooser?: boolean;
    /**
     * Specifies the editSettings for Grid.
     * @default []
     */
    editSettings?: EditSettingsModel;
    /**
     * Specifies the summaryRows for Grid.
     * @default []
     */
    aggregates?: AggregateRowModel[];
    /**
     * Specifies scrollable height of the grid content.
     * @default auto
     */
    height?: string | number;
    /**
     * Specifies scrollable width of the grid content.
     * @default auto
     */
    width?: string | number;
    /**
     * Specifies the searchSettings for Grid.
     * @default []
     */
    searchSettings?: SearchSettingsModel;
    /**
     * Specifies the rowDropSettings for Grid.
     * @default []
     */
    rowDropSettings?: RowDropSettingsModel;
    /**
     * Specifies whether the allowRowDragAndDrop is enable or not.
     * @default false
     */
    allowRowDragAndDrop?: boolean;
    /**
     * Specifies whether the gridLines mode
     * @default null
     */
    gridLines?: GridLine;
    /**
     * Specifies rowTemplate
     */
    rowTemplate?: string;
    /**
     * Specifies detailTemplate
     */
    detailTemplate?: string;
    /**
     * Defines the child Grid to add inside the data rows of the parent Grid with expand/collapse options.
     */
    childGrid?: GridModel;
    /**
     * Defines the relation between parent and child grid.
     */
    queryString?: string;
    /**
     * Specifies the printMode
     */
    printMode?: PrintMode;
    /**
     * Specifies the dataSource for Grid.
     * @default []
     */
    dataSource?: Object | data.DataManager;
    /**
     * Defines the row height for Grid rows.
     * @default null
     */
    rowHeight?: number;
    /**
     * Specifies the query for Grid.
     * @default []
     */
    query?: data.Query;
    /**
     * @hidden
     * Specifies the toolbar for Grid.
     * @default null
     */
    toolbar?: ToolbarItems[] | string[] | navigations.ItemModel[] | ToolbarItem[];
    /**
     * Specifies the context menu items for Grid.
     * @default null
     */
    contextMenuItems?: ContextMenuItem[] | ContextMenuItemModel[];
    /**
     * Specifies the column menu items for Grid.
     * @default null
     */
    columnMenuItems?: string[] | ContextMenuItemModel[];
    /**
     * @hidden
     * It used to render toolbar template
     * @default null
     */
    toolbarTemplate?: string;
    /**
     * @hidden
     * It used to render pager template
     * @default null
     */
    pagerTemplate?: string;
    /**
     * Defines the frozen rows for the grid content
     * @default 0
     */
    frozenRows?: number;
    /**
     * Defines the frozen columns for the grid content
     * @default 0
     */
    frozenColumns?: number;
    isEdit?: boolean;
    editModule?: Edit;
    mergeCells?: {
        [key: string]: number;
    };
    checkAllRows?: CheckState;
    isCheckBoxSelection?: boolean;
    isPersistSelection?: boolean;
    getHeaderContent?(): Element;
    setGridHeaderContent?(value: Element): void;
    getContentTable?(): Element;
    setGridContentTable?(value: Element): void;
    getContent?(): Element;
    setGridContent?(value: Element): void;
    getHeaderTable?(): Element;
    setGridHeaderTable?(value: Element): void;
    getFooterContent?(): Element;
    getFooterContentTable?(): Element;
    getPager?(): Element;
    setGridPager?(value: Element): void;
    getRowByIndex?(index: number): Element;
    getMovableRowByIndex?(index: number): Element;
    getRowInfo?(target: Element): RowInfo;
    selectRow?(index: number, isToggle?: boolean): void;
    getColumnHeaderByIndex?(index: number): Element;
    getColumnByField?(field: string): Column;
    getColumnIndexByField?(field: string): number;
    getColumnByUid?(uid: string): Column;
    getColumnIndexByUid?(uid: string): number;
    getUidByColumnField?(field: string): string;
    getNormalizedColumnIndex?(uid: string): number;
    getColumnIndexesInView(): number[];
    setColumnIndexesInView(indexes?: number[]): void;
    getRows?(): Element[];
    getMovableRows?(): Element[];
    getCellFromIndex?(rowIndex: number, columnIndex: number): Element;
    getMovableCellFromIndex?(rowIndex: number, columnIndex: number): Element;
    getColumnFieldNames?(): string[];
    getSelectedRows?(): Element[];
    getSelectedRecords?(): Object[];
    getSelectedRowIndexes?(): number[];
    getSelectedRowCellIndexes(): ISelectedCell[];
    getCurrentViewRecords(): Object[];
    selectRows?(indexes: number[]): void;
    clearSelection?(): void;
    updateExternalMessage?(message: string): void;
    getColumns?(isRefresh?: boolean): Column[];
    getRowTemplate?(): Function;
    getDetailTemplate?(): Function;
    sortColumn?(columnName: string, sortDirection: SortDirection, isMultiSort?: boolean): void;
    removeSortColumn?(field: string): void;
    getColumnHeaderByUid?(uid: string): Element;
    getColumnHeaderByField?(field: string): Element;
    showColumns?(keys: string | string[], showBy?: string): void;
    hideColumns?(keys: string | string[], hideBy?: string): void;
    showSpinner?(): void;
    hideSpinner?(): void;
    getVisibleColumns?(): Column[];
    refreshHeader?(): void;
    getDataRows?(): Element[];
    getMovableDataRows?(): Element[];
    addMovableRows?(fRows: HTMLElement[], mrows: HTMLElement[]): HTMLElement[];
    getPrimaryKeyFieldNames?(): string[];
    autoFitColumns(fieldNames: string | string[]): void;
    groupColumn(columnName: string): void;
    ungroupColumn(columnName: string): void;
    ensureModuleInjected(module: Function): Boolean;
    isContextMenuOpen(): Boolean;
    goToPage(pageNo: number): void;
    getFrozenColumns(): number;
    print(): void;
    excelExport(exportProperties?: any, isMultipleExport?: boolean, workbook?: any): Promise<any>;
    csvExport(exportProperties?: any, isMultipleExport?: boolean, workbook?: any): Promise<any>;
    pdfExport(exportProperties?: any, isMultipleExport?: boolean, pdfDoc?: Object): Promise<Object>;
    search(searchString: string): void;
    deleteRecord?(fieldname?: string, data?: Object): void;
    startEdit?(): void;
    endEdit?(): void;
    closeEdit?(): void;
    addRecord?(data?: Object): void;
    deleteRow?(tr: HTMLTableRowElement): void;
    getRowObjectFromUID?(uid: string): Row<Column>;
    addFreezeRows?(fRows: Row<Column>[], mRows?: Row<Column>[]): Row<Column>[];
    getRowsObject?(): Row<Column>[];
    getMovableRowsObject?(): Row<Column>[];
    createColumnchooser(x: number, y: number, target: Element): void;
    getDataModule?(): Data;
    refreshTooltip?(): void;
    copy?(withHeader?: boolean): void;
    getLocaleConstants?(): Object;
    getForeignKeyColumns?(): Column[];
    setCellValue(key: string | number, field: string, value: string | number | boolean | Date): void;
    setRowData(key: string | number, rowData?: Object): void;
    getState?(): Object;
}
/** @hidden */
export interface IRenderer {
    renderPanel(): void;
    renderTable(): void;
    setPanel(panel: Element): void;
    setTable(table: Element): void;
    getPanel(): Element;
    getTable(): Element;
    getRows?(): Row<{}>[] | HTMLCollectionOf<HTMLTableRowElement>;
    getMovableRows?(): Row<{}>[] | HTMLCollectionOf<HTMLTableRowElement>;
    refreshUI?(): void;
    setVisible?(column?: Column[]): void;
    addEventListener?(): void;
    removeEventListener?(): void;
    getRowElements?(): Element[];
    getMovableRowElements?(): Element[];
    setSelection?(uid: string, set: boolean, clearAll: boolean): void;
    getRowByIndex?(index: number): Element;
    getVirtualRowIndex?(index: number): number;
    getMovableRowByIndex?(index: number): Element;
    getRowInfo?(target: Element): RowInfo;
    getState?(): Object;
}
/**
 * IAction interface
 * @hidden
 */
export interface IAction {
    updateModel?(): void;
    onActionBegin?(args?: Object, type?: string): void;
    onActionComplete?(args?: Object, type?: string): void;
    addEventListener?(): void;
    removeEventListener?(): void;
}
/**
 * @hidden
 */
export interface IDataProcessor {
    generateQuery(): data.Query;
    getData(args: Object, query: data.Query): Promise<Object>;
    processData?(): void;
}
/**
 * @hidden
 */
export interface IValueFormatter {
    fromView(value: string, format: Function, target?: string): string | number | Date;
    toView(value: number | Date, format: Function): string | Object;
    setCulture?(cultureName: string): void;
    getFormatFunction?(format: base.NumberFormatOptions | base.DateFormatOptions): Function;
    getParserFunction?(format: base.NumberFormatOptions | base.DateFormatOptions): Function;
}
/**
 * @hidden
 */
export interface ITemplateRender {
    compiled: {
        [x: string]: Function;
    };
    compile(key: string, template: string): Function;
    render(key: string, data: Object, params?: {
        [p: string]: Object;
    }): string;
}
/**
 * @hidden
 */
export interface IEditCell {
    create?: Element | Function;
    read?: Object | Function;
    write?: void | Function;
    params?: calendars.DatePickerModel | inputs.NumericTextBoxModel | dropdowns.DropDownListModel;
    destroy?: Function;
}
/**
 * @hidden
 */
export interface IFilterUI {
    create?: Element | Function;
    read?: Object | Function;
    write?: void | Function;
}
/**
 * @hidden
 */
export interface IFilterMUI {
    create?: void | Function;
    read?: Object | Function;
    write?: void | Function;
}
/**
 * @hidden
 */
export interface ICustomOptr {
    stringOperator?: {
        [key: string]: Object;
    }[];
    numberOperator?: {
        [key: string]: Object;
    }[];
    dateOperator?: {
        [key: string]: Object;
    }[];
    booleanOperator?: {
        [key: string]: Object;
    }[];
}
/**
 * @hidden
 */
export interface ICellRenderer<T> {
    element?: Element;
    getGui?(): string | Element;
    format?(column: T, value: Object, data: Object): string;
    evaluate?(node: Element, column: Cell<T>, data: Object, attributes?: Object): boolean;
    setStyleAndAttributes?(node: Element, attributes: {
        [key: string]: Object;
    }): void;
    render(cell: Cell<T>, data: Object, attributes?: {
        [x: string]: string;
    }): Element;
    appendHtml?(node: Element, innerHtml: string | Element): Element;
    refresh?(cell: Cell<T>, node: Element): Element;
}
/**
 * @hidden
 */
export interface IRowRenderer<T> {
    element?: Element;
    render(row: Row<T>, column: Column[], attributes?: {
        [x: string]: string;
    }, rowTemplate?: string): Element;
}
export interface ICellFormatter {
    getValue(column: Column, data: Object): Object;
}
/**
 * @hidden
 */
export interface IIndex {
    rowIndex?: number;
    cellIndex?: number;
}
/**
 * @hidden
 */
export interface ISelectedCell {
    rowIndex: number;
    cellIndexes: number[];
}
/**
 * @hidden
 */
export interface IFilterOperator {
    contains: string;
    endsWith: string;
    equal: string;
    greaterThan: string;
    greaterThanOrEqual: string;
    lessThan: string;
    lessThanOrEqual: string;
    notEqual: string;
    startsWith: string;
}
export interface NotifyArgs {
    records?: Object[];
    count?: number;
    requestType?: Action;
    module?: string;
    enable?: boolean;
    properties?: Object;
    virtualInfo?: VirtualInfo;
    cancel?: boolean;
    rows?: Row<Column>[];
    isFrozen?: boolean;
    args?: NotifyArgs;
}
/**
 * @hidden
 */
export interface ICell<T> {
    colSpan?: number;
    rowSpan?: number;
    cellType?: CellType;
    visible?: boolean;
    isTemplate?: boolean;
    isDataCell?: boolean;
    column?: T;
    rowID?: string;
    index?: number;
    colIndex?: number;
    className?: string;
    commands?: CommandModel[];
    isForeignKey?: boolean;
    foreignKeyData?: Object;
}
/**
 * @hidden
 */
export interface IRow<T> {
    uid?: string;
    data?: Object;
    isSelected?: boolean;
    isReadOnly?: boolean;
    isAltRow?: boolean;
    isDataRow?: boolean;
    isExpand?: boolean;
    rowSpan?: number;
    cells?: Cell<T>[];
    index?: number;
    indent?: number;
    subRowDetails?: Object;
    height?: string;
    cssClass?: string;
    foreignKeyData?: Object;
}
/**
 * @hidden
 */
export interface IModelGenerator<T> {
    generateRows(data: Object, args?: Object): Row<T>[];
    refreshRows?(input?: Row<T>[]): Row<T>[];
}
export interface RowInfo {
    /** returns particular cell element */
    cell?: Element;
    /** returns particular cell index */
    cellIndex?: number;
    /** returns particular row element */
    row?: Element;
    /** returns particular rowIndex */
    rowIndex?: number;
    /** returns particular row data */
    rowData?: Object;
    /** return particular column information  */
    column?: Object;
}
export interface ActionEventArgs {
    /** Defines the current action. */
    requestType?: Action;
    /** Defines the type of event. */
    type?: string;
}
export interface FailureEventArgs {
    /** Defines the error information. */
    error?: Error;
}
export interface FilterEventArgs extends ActionEventArgs {
    /** Defines the object that is currently filtered. */
    currentFilterObject?: PredicateModel;
    /** Defines the column name that is currently filtered. */
    currentFilteringColumn?: string;
    /** Defines the collection of filtered columns. */
    columns?: PredicateModel[];
}
export interface GroupEventArgs extends ActionEventArgs {
    /** Defines the field name of the currently grouped columns. */
    columnName?: string;
}
export interface PageEventArgs extends ActionEventArgs {
    /** Defines the previous page number. */
    previousPage?: string;
    /** Defines the current page number. */
    currentPage?: string;
}
export interface SortEventArgs extends ActionEventArgs {
    /** Defines the field name of currently sorted column. */
    columnName?: string;
    /** Defines the direction of sort column. */
    direction?: SortDirection;
}
export interface SearchEventArgs extends ActionEventArgs {
    /** Defines the string value to search. */
    searchString?: string;
}
export interface PrintEventArgs extends ActionEventArgs {
    /** Defines the Grid element. */
    element?: Element;
    /** Defines the currently selected rows. */
    selectedRows?: NodeListOf<Element>;
    /** Cancel the print action */
    cancel?: boolean;
}
export interface DetailDataBoundEventArgs {
    /** Defines the details row element. */
    detailElement?: Element;
    /** Defines the selected row data. */
    data?: Object;
}
export interface ColumnChooserEventArgs {
    /** Defines the parent element. */
    element?: Element;
    /** Defines the display columns of column chooser. */
    columns?: Column[];
    /** Specifies the instance of column chooser dialog. */
    dialogInstance?: Object;
}
export interface RowDeselectEventArgs {
    /** Defines the current selected/deselected row data. */
    data?: Object;
    /** Defines the selected/deselected row index. */
    rowIndex?: number;
    /** Defines the selected/deselected row. */
    row?: Element;
    /** Define the foreignKey row data associated with this column */
    foreignKeyData?: Object;
}
export interface RowSelectEventArgs extends RowDeselectEventArgs {
    /** Defines the previously selected row index. */
    previousRowIndex?: number;
    /** Defines the previously selected row. */
    previousRow?: Element;
    /** Defines the target element for selection. */
    target?: Element;
    /** Define the foreignKey row data associated with this column */
    foreignKeyData?: Object;
}
export interface RecordDoubleClickEventArgs {
    /** Defines the target element. */
    target?: Element;
    /** Defines the cell element. */
    cell?: Element;
    /** Defines the cell index. */
    cellIndex?: number;
    /** Defines the column object. */
    column?: Column;
    /** Defines the name of the event. */
    name?: string;
    /** Defines the row element. */
    row?: Element;
    /** Defines the current row data. */
    rowData?: Object;
    /** Defines the row index. */
    rowIndex?: number;
    /** Define the foreignKey row data associated with this column */
    foreignKeyData?: Object;
}
export interface RowSelectingEventArgs extends RowSelectEventArgs {
    /** Defines whether CTRL key is pressed. */
    isCtrlPressed?: boolean;
    /** Defines whether SHIFT key is pressed. */
    isShiftPressed?: boolean;
}
export interface CellDeselectEventArgs {
    /** Defines the currently selected/deselected row data. */
    data?: Object;
    /** Defines the indexes of the current selected/deselected cells. */
    cellIndexes?: ISelectedCell[];
    /** Defines the currently selected/deselected cells. */
    cells?: Element[];
}
export interface CellSelectEventArgs extends CellDeselectEventArgs {
    /** Defines the index of the current selected cell. */
    cellIndex?: IIndex;
    /** Defines the previously selected cell index. */
    previousRowCellIndex?: number;
    /** Defines the element. */
    currentCell: Element;
    /** Defines the previously selected cell element. */
    previousRowCell?: Element;
}
export interface CellSelectingEventArgs extends CellSelectEventArgs {
    /** Defines whether the CTRL key is pressed or not. */
    isCtrlPressed?: boolean;
    /** Defines whether the SHIFT key is pressed or not. */
    isShiftPressed?: boolean;
}
export interface ColumnDragEventArgs {
    /** Defines the target element from which the drag starts. */
    target?: Element;
    /** Defines the type of the element dragged. */
    draggableType?: string;
    /** Defines the column object that is dragged. */
    column?: Column;
}
export interface RowDataBoundEventArgs {
    /** Defines the current row data. */
    data?: Object;
    /** Defines the row element. */
    row?: Element;
    /** Defines the row height */
    rowHeight?: number;
}
export interface QueryCellInfoEventArgs {
    /** Defines the row data associated with this cell. */
    data?: Object;
    /** Defines the cell element. */
    cell?: Element;
    /** Defines the column object associated with this cell. */
    column?: Column;
    /** Defines the no. of columns to be spanned */
    colSpan?: number;
    /** Define the foreignKey row data associated with this column */
    foreignKeyData?: Object;
}
export interface PdfQueryCellInfoEventArgs {
    /** Defines the column of the current cell. */
    column?: Column;
    /** Defines the style of the current cell. */
    style?: PdfStyle;
    /** Defines the value of the current cell. */
    value?: Date | string | number | boolean;
    /** Defines the no. of columns to be spanned */
    colSpan?: number;
}
export interface ExcelQueryCellInfoEventArgs {
    /** Defines the row data associated with this cell. */
    data?: Object;
    /** Defines the column of the current cell. */
    column: Column;
    /** Defines the value of the current cell. */
    value?: Date | string | number | boolean;
    /** Defines the style of the current cell. */
    style?: ExcelStyle;
    /** Defines the number of columns to be spanned */
    colSpan?: number;
}
export interface MultipleExport {
    /** Indicates whether to append the multiple grid in same sheet or different sheet */
    type?: MultipleExportType;
    /**  Defines the number of blank rows between the multiple grid data */
    blankRows?: number;
}
export interface ExcelRow {
    /**  Defines the index for cells */
    index?: number;
    /**  Defines the cells in a row */
    cells?: ExcelCell[];
}
export interface Border {
    /**  Defines the color of border */
    color?: string;
    /**  Defines the line style of border */
    lineStyle?: BorderLineStyle;
}
export interface ExcelStyle {
    /** Defines the color of font */
    fontColor?: string;
    /** Defines the name of font */
    fontName?: string;
    /** Defines the size of font */
    fontSize?: number;
    /** Defines the horizontal alignment for cell style */
    hAlign?: ExcelHAlign;
    /** Defines the vertical alignment for cell style */
    vAlign?: ExcelVAlign;
    /** Defines the bold style for fonts  */
    bold?: boolean;
    /** Defines the italic style for fonts */
    italic?: boolean;
    /** Defines the underline style for fonts */
    underline?: boolean;
    /** Defines the background color for cell style */
    backColor?: string;
    /** Defines the wrapText for cell style */
    wrapText?: boolean;
    /** Defines the borders for cell style */
    borders?: Border;
}
export interface PdfStyle {
    /** Defines the horizontal alignment */
    textAlignment?: PdfHAlign;
    /** Defines the brush color of font */
    textBrushColor?: string;
    /** Defines the pen color of font */
    textPenColor?: string;
    /** Defines the font family */
    fontFamily?: string;
    /** Defines the font size */
    fontSize?: number;
    /** Defines the font bold */
    bold?: boolean;
    /** Defines the italic font */
    italic?: boolean;
    /** Defines the underlined font */
    underline?: boolean;
    /** Defines the strike-out font */
    strikeout?: boolean;
    /** Defines the horizontal alignment */
    verticalAlignment?: PdfVAlign;
    /** Defines the background color */
    backgroundColor?: string;
    /** Defines the grid border */
    border?: PdfBorder;
}
export interface PdfBorder {
    /** Defines the border color */
    color?: string;
    /** Defines the border width */
    width?: number;
    /** Defines the border dash style */
    dashStyle?: PdfDashStyle;
}
export interface ExcelCell {
    /** Defines the index for the cell */
    index?: number;
    /** Defines the column span for the cell  */
    colSpan?: number;
    /** Defines the value of the cell */
    value?: string | boolean | number | Date;
    /** Defines the hyperlink of the cell */
    hyperlink?: Hyperlink;
    /** Defines the style of the cell */
    style?: ExcelStyle;
}
export interface Hyperlink {
    /** Defines the Url for hyperlink */
    target?: string;
    /** Defines the display text for hyperlink */
    displayText?: string;
}
export interface ExcelHeader {
    /** Defines the number of rows between the header and grid data */
    headerRows?: number;
    /** Defines the rows in header content */
    rows?: ExcelRow[];
}
export interface ExcelFooter {
    /** Defines the number of rows between the grid data and footer */
    footerRows?: number;
    /** Defines the rows in footer content */
    rows?: ExcelRow[];
}
export interface ExcelExportProperties {
    /** Defines the data source dynamically before exporting */
    dataSource?: Object | data.DataManager;
    /** Exports multiple grid into the excel document */
    multipleExport?: MultipleExport;
    /** Defines the header content for exported document  */
    header?: ExcelHeader;
    /** Defines the footer content for exported document */
    footer?: ExcelFooter;
    /** Indicates to export current page or all page */
    exportType?: ExportType;
    /** Indicates whether to show the hidden columns in exported excel */
    includeHiddenColumn?: boolean;
    /** Defines the theme for exported data  */
    theme?: Theme;
}
export interface RowDragEventArgs {
    /** Defines the selected row's element. */
    rows?: Element;
    /** Defines the target element from which drag starts. */
    target?: Element;
    /** Defines the type of the element to be dragged.
     * @hidden
     */
    draggableType?: string;
    /** Defines the selected row data. */
    data?: Object[];
}
/**
 * @hidden
 */
export interface EJ2Intance extends HTMLElement {
    ej2_instances: Object | Object[];
}
/**
 * @hidden
 */
export interface IPosition {
    x: number;
    y: number;
}
/**
 * @hidden
 */
export interface ParentDetails {
    parentID?: string;
    parentPrimaryKeys?: string[];
    parentKeyField?: string;
    parentKeyFieldValue?: string;
    parentRowData?: Object;
}
/**
 * @hidden
 */
export interface VirtualInfo {
    data?: boolean;
    event?: string;
    block?: number;
    page?: number;
    currentPage?: number;
    direction?: string;
    blockIndexes?: number[];
    columnIndexes?: number[];
    columnBlocks?: number[];
    loadSelf?: boolean;
    loadNext?: boolean;
    nextInfo?: {
        page?: number;
    };
    sentinelInfo?: SentinelType;
    offsets?: Offsets;
}
/**
 * @hidden
 */
export interface InterSection {
    container?: HTMLElement;
    pageHeight?: number;
    debounceEvent?: boolean;
    axes?: string[];
}
/**
 * @hidden
 */
export interface ICancel {
    /** Defines the cancel option value. */
    cancel?: boolean;
}
/**
 * @hidden
 */
export interface IPrimaryKey {
    /** Defines the primaryKey. */
    primaryKey?: string[];
}
/**
 * @hidden
 */
export interface BeforeBatchAddArgs extends ICancel, IPrimaryKey {
    /** Defines the default data object. */
    defaultData?: Object;
}
/**
 * @hidden
 */
export interface BatchDeleteArgs extends IPrimaryKey {
    /** Defines the deleted data. */
    rowData?: Object;
    /** Defines the row index. */
    rowIndex?: number;
}
/**
 * @hidden
 */
export interface BeforeBatchDeleteArgs extends BatchDeleteArgs, ICancel {
    /** Defines the row element. */
    row?: Element;
}
/**
 * @hidden
 */
export interface BeforeBatchSaveArgs extends ICancel {
    /** Defines the changed record object. */
    batchChanges?: Object;
}
/**
 * @hidden
 */
export interface ResizeArgs extends ICancel {
    /** Event argument of point or touch action. */
    e?: MouseEvent | TouchEvent;
    /** Defines the resizing column details */
    column?: Column;
}
/**
 * @hidden
 */
export interface BatchAddArgs extends ICancel, IPrimaryKey {
    /** Defines the added data. */
    defaultData?: Object;
    /** Defines the column index. */
    columnIndex?: number;
    /** Defines the row element. */
    row?: Element;
    /** Defines the cell element. */
    cell?: Element;
    /** Defines the column object. */
    columnObject?: Column;
}
/**
 * @hidden
 */
export interface BeginEditArgs extends ICancel, IPrimaryKey {
    /** Defines the edited data. */
    rowData?: Object;
    /** Defines the edited row index. */
    rowIndex?: number;
    /** Defines the current edited row. */
    row?: Element;
    /** Defines the name of the event. */
    type?: string;
    /** Defines the primary key value. */
    primaryKeyValue?: string[];
}
export interface DeleteEventArgs {
    /** Defines the cancel option value. */
    cancel?: boolean;
    /** Defines the request type. */
    requestType?: string;
    /** Defines the foreign key record object (JSON). @hidden */
    foreignKeyData?: Object;
    /** Defines the record objects. */
    data?: Object[];
    /** Defines the selected rows for delete. */
    tr?: Element[];
    /** Defines the name of the event. */
    type?: string;
}
export interface AddEventArgs {
    /** If `cancel` is set to true, then the current action will stopped. */
    cancel?: boolean;
    /** Defines the request type. */
    requestType?: string;
    /** Defines the foreign key record object.
     * @hidden
     */
    foreignKeyData?: Object;
    /** Defines the record objects. */
    data?: Object;
    /** Defines the event name. */
    type?: string;
    /** Defines the previous data. */
    previousData?: Object;
    /** Defines the added row. */
    row?: Object;
    /** Added row index */
    index?: number;
}
export interface SaveEventArgs extends AddEventArgs {
    /** Defines the previous data. */
    previousData?: Object;
    /** Defines the selected row index. */
    selectedRow?: number;
    /** Defines the current action. */
    action?: string;
    /** Added row index */
    index?: number;
}
export interface EditEventArgs extends BeginEditArgs {
    /** Defines the request type. */
    requestType?: string;
    /** Defines foreign data object. */
    foreignKeyData?: Object;
    addRecord?(data?: Object, index?: number): void;
}
/**
 * @hidden
 */
export interface CellEditSameArgs extends ICancel {
    /** Defines the row data object. */
    rowData?: Object;
    /** Defines the column name. */
    columnName?: string;
    /** Defines the cell object. */
    cell?: Element;
    /** Defines the column object. */
    columnObject?: Column;
    /** Defines the cell value. */
    value?: string;
    /** Defines isForeignKey option value. */
    isForeignKey?: boolean;
}
/**
 * @hidden
 */
export interface CellEditArgs extends CellEditSameArgs, IPrimaryKey {
    /** Defines the current row. */
    row?: Element;
    /** Defines the validation rules. */
    validationRules?: Object;
    /** Defines the name of the event. */
    type?: string;
    /** Defines foreign data object */
    foreignKeyData?: Object;
}
export interface IFilterCreate {
    column?: Column;
    target?: HTMLElement;
    getOptrInstance?: FlMenuOptrUI;
    localizeText?: base.L10n;
    dialogObj?: popups.Dialog;
}
/**
 * @hidden
 */
export interface CellSaveArgs extends CellEditSameArgs {
    /** Defines the previous value of the cell. */
    previousValue?: string;
}
/**
 * @hidden
 */
export interface BeforeDataBoundArgs {
    /** Defines the data. */
    result?: Object[];
    /** Defines the data count. */
    count?: number;
}
/**
 * @hidden
 */
export interface IEdit {
    formObj?: inputs.FormValidator;
    destroy?: Function;
    closeEdit?(): void;
    deleteRecord?(fieldname?: string, data?: Object): void;
    startEdit?(tr?: Element): void;
    endEdit?(): void;
    closeEdit?(): void;
    addRecord?(data?: Object, index?: number): void;
    deleteRow?(tr: HTMLTableRowElement): void;
    endEdit?(data?: Object): void;
    batchSave?(): void;
    getBatchChanges?(): Object;
    removeRowObjectFromUID?(uid: string): void;
    addRowObject?(row: Row<Column>): void;
    editCell?(index: number, field: string, isAdd?: boolean): void;
    updateCell?(rowIndex: number, field: string, value: string | number | boolean | Date): void;
    updateRow?(index: number, data: Object): void;
    saveCell?(isForceSave?: boolean): void;
}
/**
 * @hidden
 */
export interface CheckBoxChangeEventArgs extends ICancel {
    /** Defines the checked state. */
    checked?: boolean;
    /** Defines the selected row indexes. */
    selectedRowIndexes?: number[];
    /** Defines the target element for selection. */
    target?: Element;
}
/**
 * @hidden
 */
export interface BeforeCopyEventArgs extends ICancel {
    /** Defines the grid copied data. */
    data?: string;
}
/**
 * Defines options for custom command buttons.
 */
export interface CommandButtonOptions extends buttons.ButtonModel {
    /**
     * Defines handler for the click event.
     */
    click?: base.EmitType<Event>;
}
/**
 * Define options for custom command buttons.
 */
export interface CommandModel {
    /**
     * Define the command Button type
     */
    type?: CommandButtonType;
    /**
     * Define the button model
     */
    buttonOption?: CommandButtonOptions;
}
/**
 * Defines the pending state for Custom Service Data
 */
export interface PendingState {
    /**
     * The function which resolves the current action's promise.
     */
    resolver?: Function;
    /**
     * Defines the current state of the action.
     */
    isPending?: Boolean;
    /**
     * Grouping property for Custom data service
     */
    group?: string[];
}
/**
 * Sorting property for Custom data Service
 */
export interface Sorts {
    /** Defines the field to be sorted */
    name?: string;
    /** Defines the direction of sorting */
    direction?: string;
}
/** Custom data service event types */
export interface DataStateChangeEventArgs {
    /** Defines the skip count in datasource record */
    skip?: number;
    /** Defines the page size */
    take?: number;
    /** Defines the filter criteria  */
    where?: PredicateModel[];
    /** Defines the sorted field and direction */
    sorted?: Sorts[];
    /** Defines the grouped field names */
    group?: string[];
    /** Defines the search criteria */
    search?: PredicateModel[];
    /** Defines the grid action details performed by paging, grouping, filtering, searching, sorting */
    action?: PageEventArgs | GroupEventArgs | FilterEventArgs | SearchEventArgs | SortEventArgs;
    /** Defines the remote table name */
    table?: string;
    /** Defines the selected field names */
    select?: string[];
    /** If `count` is set true, then the remote service needs to return records and count */
    count?: boolean;
}
export interface DataSourceChangedEventArgs {
    /** Defines the current action type. */
    requestType?: string;
    /** Defines the current action. */
    action?: string;
    /** Defines the primary column field */
    key?: string | string[];
    /** Defines the state of the performed action */
    state?: DataStateChangeEventArgs;
    /** Defines the selected row data. */
    data?: Object | Object[];
    /** Defines the primary key value */
    primaryKeyValues?: Object[];
    /** Defines the index value */
    index?: number;
    /** Defines the end of editing function. */
    endEdit?: Function;
    /** Defines the changes made in batch editing */
    changes?: Object;
    /** Defines the query */
    query?: data.Query;
}
/**
 * @hidden
 */
export interface CheckBoxChangeEventArgs extends ICancel {
    /** Defines the checked state. */
    checked?: boolean;
    /** Defines the selected row indexes. */
    selectedRowIndexes?: number[];
    /** Defines the target element for selection. */
    target?: Element;
}
/**
 * @hidden
 */
export interface BeforeCopyEventArgs extends ICancel {
    /** Defines the grid copied data. */
    data?: string;
}
/**
 * @hidden
 */
export interface IFocus {
    matrix: Matrix;
    onKeyPress?: Function;
    onClick?: Function;
    onFocus?: Function;
    jump?: (action: string, current: number[]) => SwapInfo;
    getFocusInfo?: () => FocusInfo;
    getFocusable?: (element: HTMLElement) => HTMLElement;
    selector?: (row: Row<Column>, cell: Cell<Column>) => boolean;
    generateRows?: (rows: Row<Column>[], optionals?: Object) => void;
    getInfo?: (e?: base.KeyboardEventArgs) => FocusedContainer;
    validator?: () => Function;
    getNextCurrent?: (previous: number[], swap?: SwapInfo, active?: IFocus, action?: string) => number[];
    preventDefault?: (e: base.KeyboardEventArgs, info: FocusInfo) => void;
}
/**
 * @hidden
 */
export interface FocusInfo {
    element?: HTMLElement;
    elementToFocus?: HTMLElement;
    outline?: boolean;
    class?: string;
    skipAction?: boolean;
}
/**
 * @hidden
 */
export interface CellFocusArgs {
    element?: HTMLElement;
    parent?: HTMLElement;
    indexes?: number[];
    byKey?: boolean;
    byClick?: boolean;
    keyArgs?: base.KeyboardEventArgs;
    clickArgs?: Event;
    isJump?: boolean;
    container?: FocusedContainer;
    outline?: boolean;
    cancel?: boolean;
}
/**
 * @hidden
 */
export interface FocusedContainer {
    isContent?: boolean;
    isHeader?: boolean;
    isDataCell?: boolean;
    isFrozen?: boolean;
    isStacked?: boolean;
    isSelectable?: boolean;
    indexes?: number[];
}
/**
 * @hidden
 */
export interface SwapInfo {
    swap?: boolean;
    toHeader?: boolean;
    toFrozen?: boolean;
    current?: number[];
}
/**
 * @hidden
 */
export interface SwapInfo {
    swap?: boolean;
    toHeader?: boolean;
    toFrozen?: boolean;
    current?: number[];
}
export interface ContextMenuItemModel extends navigations.MenuItemModel {
    target?: string;
}
/**
 * @hidden
 */
export interface IFilter {
    type?: string;
    dataSource?: Object[] | data.DataManager;
    hideSearchbox?: boolean;
    itemTemplate?: string;
    ui?: IFilterMUI;
}
/**
 * @hidden
 */
export interface IFilterArgs {
    type?: string;
    field?: string;
    displayName?: string;
    query?: data.Query;
    dataSource?: Object[] | data.DataManager;
    format?: string;
    filteredColumns?: Object[];
    sortedColumns?: string[];
    localizedStrings?: Object;
    position?: {
        X: number;
        Y: number;
    };
    formatFn?: Function;
    parserFn?: Function;
    hideSearchbox?: boolean;
    allowCaseSensitive?: boolean;
    handler?: Function;
    template?: Function;
    target?: Element;
    foreignKeyValue?: string;
    column?: Column;
    actualPredicate?: {
        [key: string]: PredicateModel[];
    };
}
export interface PdfExportProperties {
    /** Defines the Pdf orientation. */
    pageOrientation?: PageOrientation;
    /** Defines the Pdf page size. */
    pageSize?: PdfPageSize;
    /** Defines the Pdf header. */
    header?: PdfHeader;
    /** Defines the Pdf footer. */
    footer?: PdfFooter;
    /** Indicates whether to show the hidden columns in exported Pdf */
    includeHiddenColumn?: boolean;
    /** Defines the data source dynamically before exporting */
    dataSource?: Object | data.DataManager;
    /** Indicates to export current page or all page */
    exportType?: ExportType;
    /** Defines the theme for exported data  */
    theme?: Theme;
}
export interface Theme {
    /** Defines the style of header content. */
    header?: ThemeStyle;
    /** Defines the theme style of record content. */
    record?: ThemeStyle;
    /** Defines the theme style of caption content. */
    caption?: ThemeStyle;
}
export interface ThemeStyle {
    /** Defines the font color of theme style. */
    fontColor?: string;
    /** Defines the font name of theme style. */
    fontName?: string;
    /** Defines the font size of theme style. */
    fontSize?: number;
    /** Defines the bold of theme style. */
    bold?: boolean;
    /** Defines the borders of theme style. */
    borders?: Border;
}
export interface PdfHeader {
    /** Defines the header content distance from top. */
    fromTop?: number;
    /** Defines the height of header content. */
    height?: number;
    /** Defines the header contents. */
    contents?: PdfHeaderFooterContent[];
}
export interface PdfFooter {
    /** Defines the footer content distance from bottom. */
    fromBottom?: number;
    /** Defines the height of footer content. */
    height?: number;
    /** Defines the footer contents */
    contents?: PdfHeaderFooterContent[];
}
export interface PdfHeaderFooterContent {
    /** Defines the content type */
    type: ContentType;
    /** Defines the page number type */
    pageNumberType?: PdfPageNumberType;
    /** Defines the style of content */
    style?: PdfContentStyle;
    /** Defines the pdf points for drawing line */
    points?: PdfPoints;
    /** Defines the format for customizing page number */
    format?: string;
    /** Defines the position of the content */
    position?: PdfPosition;
    /** Defines the size of content */
    size?: PdfSize;
    /** Defines the base64 string for image content type */
    src?: string;
    /** Defines the value for content */
    value?: any;
}
export interface PdfPosition {
    /** Defines the x position */
    x: number;
    /** Defines the y position */
    y: number;
}
export interface PdfSize {
    /** Defines the height */
    height: number;
    /** Defines the width */
    width: number;
}
export interface PdfPoints {
    /** Defines the x1 position */
    x1: number;
    /** Defines the y1 position */
    y1: number;
    /** Defines the x2 position */
    x2: number;
    /** Defines the y2 position */
    y2: number;
}
export interface PdfContentStyle {
    /** Defines the pen color. */
    penColor?: string;
    /** Defines the pen size. */
    penSize?: number;
    /** Defines the dash style. */
    dashStyle?: PdfDashStyle;
    /** Defines the text brush color. */
    textBrushColor?: string;
    /** Defines the text pen color. */
    textPenColor?: string;
    /** Defines the font size. */
    fontSize?: number;
    /** Defines the horizontal alignment. */
    hAlign?: PdfHAlign;
    /** Defines the vertical alignment. */
    vAlign?: PdfVAlign;
}
/**
 * Defines the context menu item model.
 */
export interface ContextMenuItemModel extends navigations.MenuItemModel {
    /**
     * Define the target to show the menu item.
     */
    target?: string;
}
export interface ColumnMenuItemModel extends navigations.MenuItemModel {
    hide?: boolean;
}
export interface ColumnMenuOpenEventArgs extends navigations.BeforeOpenCloseMenuEventArgs {
    column?: Column;
}
export interface ColumnMenuClickEventArgs extends navigations.MenuEventArgs {
    column?: Column;
}
export interface ContextMenuClickEventArgs extends navigations.MenuEventArgs {
    column?: Column;
}
export interface ContextMenuOpenEventArgs extends navigations.BeforeOpenCloseMenuEventArgs {
    column?: Column;
}
export interface ExcelExportCompleteArgs {
    /** Defines the promise object for blob data. */
    promise?: Promise<{
        blobData: Blob;
    }>;
}
export interface PdfExportCompleteArgs {
    /** Defines the promise object for blob data. */
    promise?: Promise<{
        blobData: Blob;
    }>;
}
export interface SelectionNotifyArgs extends NotifyArgs {
    row?: HTMLElement;
    CheckState?: boolean;
}
export interface DataResult {
    result: Object[] | data.Group[];
    count: number;
}
/**
 * Exports types used by Grid.
 */
export  type ValueType = number | string | Date | boolean;
export  type ValueAccessor = (field: string, data: Object, column: ColumnModel) => Object;
export  type SortComparer = (x: ValueType, y: ValueType) => number;
export  type CustomSummaryType = (data: Object[] | Object, column: AggregateColumnModel) => Object;
export  type ReturnType = {
    result: Object[];
    count: number;
    aggregates?: Object;
};
export  type SentinelType = {
    check?: (rect: ClientRect, info: SentinelType) => boolean;
    top?: number;
    entered?: boolean;
    axis?: string;
};
export  type SentinelInfo = {
    up?: SentinelType;
    down?: SentinelType;
    right?: SentinelType;
    left?: SentinelType;
};
export  type Offsets = {
    top?: number;
    left?: number;
};
/**
 * Function to check whether target object implement specific interface
 * @param  {Object} target
 * @param  {string} checkFor
 * @returns no
 * @hidden
 */
export  function doesImplementInterface(target: Object, checkFor: string): boolean;
/**
 * Function to get value from provided data
 * @param  {string} field
 * @param  {Object} data
 * @param  {IColumn} column
 * @hidden
 */
export  function valueAccessor(field: string, data: Object, column: ColumnModel): Object;
/**
 * The function used to update Dom using requestAnimationFrame.
 * @param  {Function} fn - Function that contains the actual action
 * @return {Promise<T>}
 * @hidden
 */
export  function getUpdateUsingRaf<T>(updateFunction: Function, callBack: Function): void;
/**
 * @hidden
 */
export  function iterateArrayOrObject<T, U>(collection: U[], predicate: (item: Object, index: number) => T): T[];
/** @hidden */
export  function templateCompiler(template: string): Function;
/** @hidden */
export  function setStyleAndAttributes(node: Element, customAttributes: {
    [x: string]: Object;
}): void;
/** @hidden */
export  function extend(copied: Object, first: Object, second?: Object, exclude?: string[]): Object;
/** @hidden */
export  function prepareColumns(columns: Column[] | string[] | ColumnModel[], autoWidth?: boolean): Column[];
/** @hidden */
export  function setCssInGridPopUp(popUp: HTMLElement, e: MouseEvent | TouchEvent, className: string): void;
/** @hidden */
export  function getActualProperties<T>(obj: T): T;
/** @hidden */
export  function parentsUntil(elem: Element, selector: string, isID?: boolean): Element;
/** @hidden */
export  function getElementIndex(element: Element, elements: Element[]): number;
/** @hidden */
export  function inArray(value: Object, collection: Object[]): number;
/** @hidden */
export  function getActualPropFromColl(collection: Object[]): Object[];
/** @hidden */
export  function removeElement(target: Element, selector: string): void;
/** @hidden */
export  function getPosition(e: MouseEvent | TouchEvent): IPosition;
/** @hidden */
export  function getUid(prefix: string): string;
/** @hidden */
export  function appendChildren(elem: Element, children: Element[]): Element;
/** @hidden */
export  function parents(elem: Element, selector: string, isID?: boolean): Element[];
/** @hidden */
export  function calculateAggregate(type: AggregateType | string, data: Object, column?: AggregateColumnModel, context?: Object): Object;
/** @hidden */
export  function getScrollBarWidth(): number;
/** @hidden */
export  function getRowHeight(element?: HTMLElement): number;
/** @hidden */
export  function isEditable(col: Column, type: string, elem: Element): boolean;
/** @hidden */
export  function isActionPrevent(inst: IGrid): boolean;
/** @hidden */
export  function wrap(elem: any, action: boolean): void;
export  function changeButtonType(target: Element): void;
/** @hidden */
export  function setFormatter(serviceLocator?: ServiceLocator, column?: Column): void;
/** @hidden */
export  function addRemoveActiveClasses(cells: Element[], add: boolean, ...args: string[]): void;
/** @hidden */
export  function distinctStringValues(result: string[]): string[];
/** @hidden */
export  function getFilterMenuPostion(target: Element, dialogObj: popups.Dialog, grid: IGrid): void;
/** @hidden */
export  function getZIndexCalcualtion(args: {
    popup: popups.Popup;
}, dialogObj: popups.Dialog): void;
/** @hidden */
export  function toogleCheckbox(elem: Element): void;
/** @hidden */
export  function createCboxWithWrap(uid: string, elem: Element, className?: string): Element;
/** @hidden */
export  function removeAddCboxClasses(elem: Element, checked: boolean): void;
/**
 * Refresh the Row model's foreign data.
 * @param row - Grid Row model object.
 * @param columns - Foreign columns array.
 * @param data - Updated Row data.
 * @hidden
 */
export  function refreshForeignData(row: IRow<Column>, columns: Column[], data: Object): void;
/**
 * Get the foreign data for the corresponding cell value.
 * @param column - Foreign Key column
 * @param data - Row data.
 * @param lValue - cell value.
 * @param foreignData - foreign data source.
 * @hidden
 */
export  function getForeignData(column: Column, data?: Object, lValue?: string | number, foreignKeyData?: Object[]): Object[];
/**
 * To use to get the column's object by the foreign key value.
 * @param foreignKeyValue - Defines ForeignKeyValue.
 * @param columns - Array of column object.
 * @hidden
 */
export  function getColumnByForeignKeyValue(foreignKeyValue: string, columns: Column[]): Column;
/**
 * @hidden
 * @param filterObject - Defines predicate model object
 */
export  function getDatePredicate(filterObject: PredicateModel): data.Predicate;
/**
 * @hidden
 */
export  function renderMovable(ele: Element, frzCols: number): Element;
/**
 * Base export
 */
/**
 * Grid component exported items
 */
/**
 * Models
 */
/**
 * Interface for a class AggregateColumn
 */
export interface AggregateColumnModel {
    /**
     * Defines the aggregate type of a particular column.
     * To use multiple aggregates for single column, specify the `type` as array.
     * Types of aggregate are,
     * * sum
     * * average
     * * max
     * * min
     * * count
     * * truecount
     * * falsecount
     * * custom
     * > Specify the `type` value as `custom` to use custom aggregation.
     * 
     * @default null
     */
    type?: AggregateType | AggregateType[] | string;
    /**
     * Defines the column name to perform aggregation.
     * @default null
     */
    field?: string;
    /**
     * Defines the column name to display the aggregate value. If `columnName` is not defined,
     * then `field` name value will be assigned to the `columnName` property.
     * @default null
     */
    columnName?: string;
    /**
     * Format is applied to a calculated value before it is displayed.
     * Gets the format from the user, which can be standard or custom
     * [`number`](../base/intl.html#number-formatter-and-parser)
     * and [`date`](../base/intl.html#date-formatter-and-parser) formats.
     * @default null    
     */
    format?: string | base.NumberFormatOptions | base.DateFormatOptions;
    /**
     * Defines the footer cell template as a string for the aggregate column.
     * The `type` name should be used to access aggregate values inside the template.
     * 
     * {% codeBlock src="grid/footer-template-api/index.ts" %}{% endcodeBlock %}
     * @default null
     */
    footerTemplate?: string;
    /**
     * Defines the group footer cell template as a string for the aggregate column. 
     * The `type` name should be used to access aggregate values inside the template.
     * Additionally, the following fields can be accessed in the template.
     * * **field**: The current grouped field.
     * * **key**: The current grouped value.
     * 
     * {% codeBlock src="grid/group-footer-api/index.ts" %}{% endcodeBlock %}
     * @default null
     */
    groupFooterTemplate?: string;
    /**
     * Defines the group caption cell template as a string for the aggregate column.
     * The `type` name should be used to access aggregate values inside the template.
     * Additionally, the following fields can be accessed in the template.
     * * **field**: The current grouped field name.
     * * **key**: The current grouped field value.
     * 
     * {% codeBlock src="grid/group-caption-api/index.ts" %}{% endcodeBlock %}
     * @default null
     */
    groupCaptionTemplate?: string;
    /**
     * Defines a function to calculate custom aggregate value. The `type` value should be set to `custom`.
     * To use custom aggregate value in the template, use the key as `${custom}`.
     * **Total aggregation**: The custom function will be called with the whole data and the current `AggregateColumn` object.
     * **Group aggregation**: This will be called with the current group details and the `AggregateColumn` object.
     * 
     * @default null
     */
    customAggregate?: CustomSummaryType;
}
/**
 * Interface for a class AggregateRow
 */
export interface AggregateRowModel {
    /**
     * Configures the aggregate columns. 
     * @default []
     */
    columns?: AggregateColumnModel[];
}
/**
 * Configures the Grid's aggregate column.
 */
export  class AggregateColumn extends base.ChildProperty<AggregateColumn> {
    private formatFn;
    private templateFn;
    /**
     * Defines the aggregate type of a particular column.
     * To use multiple aggregates for single column, specify the `type` as array.
     * Types of aggregate are,
     * * sum
     * * average
     * * max
     * * min
     * * count
     * * truecount
     * * falsecount
     * * custom
     * > Specify the `type` value as `custom` to use custom aggregation.
     *
     * @default null
     */
    type: AggregateType | AggregateType[] | string;
    /**
     * Defines the column name to perform aggregation.
     * @default null
     */
    field: string;
    /**
     * Defines the column name to display the aggregate value. If `columnName` is not defined,
     * then `field` name value will be assigned to the `columnName` property.
     * @default null
     */
    columnName: string;
    /**
     * Format is applied to a calculated value before it is displayed.
     * Gets the format from the user, which can be standard or custom
     * [`number`](../base/intl.html#number-formatter-and-parser)
     * and [`date`](../base/intl.html#date-formatter-and-parser) formats.
     * @default null
     */
    format: string | base.NumberFormatOptions | base.DateFormatOptions;
    /**
     * Defines the footer cell template as a string for the aggregate column.
     * The `type` name should be used to access aggregate values inside the template.
     *
     * {% codeBlock src="grid/footer-template-api/index.ts" %}{% endcodeBlock %}
     * @default null
     */
    footerTemplate: string;
    /**
     * Defines the group footer cell template as a string for the aggregate column.
     * The `type` name should be used to access aggregate values inside the template.
     * Additionally, the following fields can be accessed in the template.
     * * **field**: The current grouped field.
     * * **key**: The current grouped value.
     *
     * {% codeBlock src="grid/group-footer-api/index.ts" %}{% endcodeBlock %}
     * @default null
     */
    groupFooterTemplate: string;
    /**
     * Defines the group caption cell template as a string for the aggregate column.
     * The `type` name should be used to access aggregate values inside the template.
     * Additionally, the following fields can be accessed in the template.
     * * **field**: The current grouped field name.
     * * **key**: The current grouped field value.
     *
     * {% codeBlock src="grid/group-caption-api/index.ts" %}{% endcodeBlock %}
     * @default null
     */
    groupCaptionTemplate: string;
    /**
     * Defines a function to calculate custom aggregate value. The `type` value should be set to `custom`.
     * To use custom aggregate value in the template, use the key as `${custom}`.
     * **Total aggregation**: The custom function will be called with the whole data and the current `AggregateColumn` object.
     * **Group aggregation**: This will be called with the current group details and the `AggregateColumn` object.
     *
     * @default null
     */
    customAggregate: CustomSummaryType;
    /**
     * @hidden
     */
    setFormatter(): void;
    /**
     * @hidden
     */
    getFormatter(): Function;
    /**
     * @hidden
     */
    setTemplate(helper?: Object): void;
    /**
     * @hidden
     */
    getTemplate(type: CellType): {
        fn: Function;
        property: string;
    };
    /**
     * @hidden
     */
    setPropertiesSilent(prop: Object): void;
}
/**
 * Configures the aggregate rows.
 */
export  class AggregateRow extends base.ChildProperty<AggregateRow> {
    /**
     * Configures the aggregate columns.
     * @default []
     */
    columns: AggregateColumnModel[];
}
/**
 * Cell
 * @hidden
 */
export  class Cell<T> {
    colSpan: number;
    rowSpan: number;
    cellType: CellType;
    visible: boolean;
    isTemplate: boolean;
    isDataCell: boolean;
    isSelected: boolean;
    column: T;
    rowID: string;
    index: number;
    colIndex: number;
    className: string;
    attributes: {
        [a: string]: Object;
    };
    isSpanned: boolean;
    cellSpan: number;
    spanText: string | number | boolean | Date;
    commands: CommandModel[];
    isForeignKey: boolean;
    foreignKeyData: Object;
    constructor(options: {
        [x: string]: Object;
    });
    clone(): Cell<T>;
}
/**
 * Represents Grid `Column` model class.
 */
export  class Column {
    /**
     * Defines the field name of column which is mapped with mapping name of DataSource.
     * The bounded columns can be sort, filter and group etc.,
     * The `field` name must be a valid JavaScript identifier,
     * the first character must be an alphabet and should not contain spaces and special characters.
     * @default undefined
     */
    field: string;
    /**
     * Gets the unique identifier value of the column. It is used to get the column object.
     * @default undefined
     */
    uid: string;
    /**
     * Defines the header text of column which is used to display in column header.
     * If `headerText` is not defined, then field name value will be assigned to header text.
     * @default undefined
     */
    headerText: string;
    /**
     * Defines the width of the column in pixels or percentage.
     * @default undefined
     */
    width: string | number;
    /**
     * Defines the minimum Width of the column in pixels or percentage.
     * @default undefined
     */
    minWidth: string | number;
    /**
     * Defines the maximum width of the column in pixel or percentage, which will restrict resizing beyond this pixel or percentage.
     * @default undefined
     */
    maxWidth: string | number;
    /**
     * Defines the alignment of the column in both header and content cells.
     * @default Left
     */
    textAlign: TextAlign;
    /**
     * Defines the cell content's overflow mode. The available modes are
     * * `Clip` -  Truncates the cell content when it overflows its area.
     * * `Ellipsis` -  Displays ellipsis when the cell content overflows its area.
     * * `EllipsisWithTooltip` - Displays ellipsis when the cell content overflows its area
     * also it will display tooltip while hover on ellipsis applied cell.
     * @default Ellipsis
     */
    clipMode: ClipMode;
    /**
     * Define the alignment of column header which is used to align the text of column header.
     * @default Left
     */
    headerTextAlign: TextAlign;
    /**
     * If `disableHtmlEncode` is set to true, it encodes the HTML of the header and content cells.
     * @default false
     */
    disableHtmlEncode: boolean;
    /**
     * Defines the data type of the column.
     * @default null
     */
    type: string;
    /**
     * It is used to change display value with the given format and does not affect the original data.
     * Gets the format from the user which can be standard or custom
     * [`number`](../base/intl.html#number-formatter-and-parser)
     * and [`date`](../base/intl.html#date-formatter-and-parser) formats.
     * @default null
     */
    format: string | base.NumberFormatOptions | base.DateFormatOptions;
    /**
     * If `visible` is set to false, hides the particular column. By default, columns are displayed.
     * @default true
     */
    visible: boolean;
    /**
     * Defines the column template that renders customized element in each cell of the column.
     * It accepts either [template string](../base/template-engine.html) or HTML element ID.
     * @default null
     */
    template: string;
    /**
     * Defines the header template as string or HTML element ID which is used to add customized element in the column header.
     * @default null
     */
    headerTemplate: string;
    /**
     * You can use this property to freeze selected columns in grid
     * @default false
     */
    isFrozen: boolean;
    /**
     * If `allowSorting` set to false, then it disables sorting option of a particular column.
     * By default all columns are sortable.
     * @default true
     */
    allowSorting: boolean;
    /**
     * If `allowResizing` is set to false, it disables resize option of a particular column.
     * By default all the columns can be resized.
     * @default true
     */
    allowResizing: boolean;
    /**
     * If `allowFiltering` set to false, then it disables filtering option and filter bar element of a particular column.
     * By default all columns are filterable.
     * @default true
     */
    allowFiltering: boolean;
    /**
     * If `allowGrouping` set to false, then it disables grouping of a particular column.
     * By default all columns are groupable.
     * @default true
     */
    allowGrouping: boolean;
    /**
     * If `showColumnMenu` set to false, then it disable the column menu of a particular column.
     * By default column menu will show for all columns
     * @default true
     */
    showColumnMenu: boolean;
    /**
     * If `enableGroupByFormat` set to true, then it groups the particular column by formatted values.
     * @default true
     */
    enableGroupByFormat: boolean;
    /**
     * If `allowEditing` set to false, then it disables editing of a particular column.
     * By default all columns are editable.
     * @default true
     */
    allowEditing: boolean;
    /**
     * The CSS styles and attributes of the content cells of a particular column can be customized.
     *
     * {% codeBlock src="grid/custom-attribute-api/index.ts" %}{% endcodeBlock %}
     * @default null
     */
    customAttributes: {
        [x: string]: Object;
    };
    /**
     * If `displayAsCheckBox` is set to true, it displays the column value as a check box instead of Boolean value.
     * @default false
     */
    displayAsCheckBox: boolean;
    /**
     * Defines the column data source which will act as foreign data source.
     * @default null
     */
    dataSource: Object[] | data.DataManager;
    /**
     * Defines the method which is used to achieve custom formatting from an external function.
     * This function triggers before rendering of each cell.
     * {% codeBlock src="grid/formatter-api/index.ts" %}{% endcodeBlock %}
     * @default null
     */
    formatter: {
        new (): ICellFormatter;
    } | ICellFormatter | Function;
    /**
     * Defines the method used to apply custom cell values from external function and display this on each cell rendered.
     *
     * {% codeBlock src="grid/value-accessor-api/index.ts" %}{% endcodeBlock %}
     *
     * @default null
     */
    valueAccessor: ValueAccessor;
    /**
     * The `filterBarTemplate` is used to add a custom component instead of default input component for filter bar.
     * It have create and read functions.
     * * create: It is used for creating custom components.
     * * read: It is used to perform custom filter action.
     *
     * {% codeBlock src="grid/filter-template-api/index.ts" %}{% endcodeBlock %}
     * @default null
     */
    filterBarTemplate: IFilterUI;
    /**
     *  It is used to customize the default filter options for a specific columns.
     * * type -  Specifies the filter type as menu or checkbox.
     * * ui - to render custom component for specific column it has following functions.
     * * ui.create – It is used for creating custom components.
     * * ui.read -  It is used for read the value from the component.
     * * ui.write - It is used to apply component model as dynamically.
     * {% codeBlock src="grid/filter-menu-api/index.ts" %}{% endcodeBlock %}
     *
     * > Check the [`Filter UI`](./filtering.html#custom-component-in-filter-menu) for its customization.
     *  @default null
     */
    filter: IFilter;
    /**
     * Used to render multiple header rows(stacked headers) on the Grid header.
     * @default null
     */
    columns: Column[] | string[] | ColumnModel[];
    /**
     * Defines the tool tip text for stacked headers.
     * @default null
     * @hidden
     */
    toolTip: string;
    /**
     * If `isPrimaryKey` is set to true, considers this column as the primary key constraint.
     * @default false
     */
    isPrimaryKey: boolean;
    /**
     * Column visibility can change based on [`Media Queries`](http://cssmediaqueries.com/what-are-css-media-queries.html).
     * `hideAtMedia` accepts only valid Media Queries.
     * @default undefined
     */
    hideAtMedia?: string;
    /**
     * If `showInColumnChooser` set to false, then hide the particular column in column chooser.
     *  By default all columns are displayed in column Chooser.
     * @default true
     */
    showInColumnChooser?: boolean;
    /**
     * Defines the type of component for editable.
     * @default stringedit
     */
    editType: string;
    /**
     * Defines rules to validate data before creating and updating.
     * @default null
     */
    validationRules: Object;
    /**
     * Defines default values for the component when adding a new record to the Grid.
     * @default null
     */
    defaultValue: string;
    /**
     * Defines the `IEditCell` object to customize default edit cell.
     * @default {}
     */
    edit: IEditCell;
    /**
     * If `isIdentity` is set to true, then this column is considered as identity column.
     * @default false
     */
    isIdentity: boolean;
    /**
     * Defines the display column name from the foreign data source which will be obtained from comparing local and foreign data.
     * @default null
     */
    foreignKeyValue: string;
    /**
     * Defines the mapping column name of the foreign data source.
     * If it is not defined then the `columns.field` will be considered as mapping column name
     * @default null
     */
    foreignKeyField: string;
    /**
     * @hidden
     * Defines the commands column template as string or HTML element ID which is used to add
     * customized command buttons in each cells of the column.
     */
    commandsTemplate: string;
    /**
     * `commands` provides an option to display command buttons in every cell.
     * The available built-in command buttons are
     * * Edit - Edit the record.
     * * Delete - Delete the record.
     * * Save - Save the record.
     * * Cancel - Cancel the edit state.
     * {% codeBlock src="grid/command-column-api/index.ts" %}{% endcodeBlock %}
     * @default null
     */
    commands: CommandModel[];
    /**
     * @hidden
     * Gets the current view foreign key data.
     * @default []
     */
    columnData: Object[];
    constructor(options: ColumnModel);
    private formatFn;
    private parserFn;
    private templateFn;
    private fltrTemplateFn;
    private headerTemplateFn;
    private sortDirection;
    /** @hidden */
    getSortDirection(): string;
    /** @hidden */
    setSortDirection(direction: string): void;
    /** @hidden */
    setProperties(column: Column): void;
    /**
     * Defines the custom sort comparer function.
     * The sort comparer function has the same functionality like
     * [`Array.sort`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) sort comparer.
     * {% codeBlock src="grid/sort-comparer-api/index.ts" %}{% endcodeBlock %}
     */
    sortComparer: (x: number | string, y: number | string) => number;
    /**
     * @hidden
     * It defines the column is foreign key column or not.
     */
    isForeignColumn(): boolean;
    /** @hidden */
    getFormatter(): Function;
    /** @hidden */
    setFormatter(value: Function): void;
    /** @hidden */
    getParser(): Function;
    /** @hidden */
    setParser(value: Function): void;
    /** @hidden */
    getColumnTemplate(): Function;
    /** @hidden */
    getHeaderTemplate(): Function;
    /** @hidden */
    getFilterItemTemplate(): Function;
    /** @hidden */
    getDomSetter(): string;
}
/**
 * Interface for a class Column
 */
export interface ColumnModel {
    /**
     * Defines the field name of column which is mapped with mapping name of DataSource.
     * The bounded columns can be sort, filter and group etc.,
     * If the `field` name contains “dot”, then it is considered as complex binding.
     * The `field` name must be a valid JavaScript identifier,
     * the first character must be an alphabet and should not contain spaces and special characters.
     * @default undefined
     */
    field?: string;
    /**
     * Gets the unique identifier value of the column. It is used to get the object.
     * @default undefined
     */
    uid?: string;
    /**
     * Defines the header text of column which is used to display in column header.
     * If `headerText` is not defined, then field name value will be assigned to header text.
     * @default undefined
     */
    headerText?: string;
    /**
     * Defines the width of the column in pixels or percentage.
     * @default undefined
     */
    width?: string | number;
    /**
     * Defines the minimum width of the column in pixels or percentage.
     * @default undefined
     */
    minWidth?: string | number;
    /**
     * Defines the maximum width of the column in pixel or percentage, which will restrict resizing beyond this pixel or percentage.
     * @default undefined
     */
    maxWidth?: string | number;
    /**
     * Defines the alignment of the column in both header and content cells.
     * @default Left
     */
    textAlign?: TextAlign;
    /**
     * Defines the cell content's overflow mode. The available modes are
     * * `Clip` -  Truncates the cell content when it overflows its area.
     * * `Ellipsis` -  Displays ellipsis when the cell content overflows its area.
     * * `EllipsisWithTooltip` - Displays ellipsis when the cell content overflows its area
     * also it will display tooltip while hover on ellipsis applied cell.
     * @default Ellipsis
     */
    clipMode?: ClipMode;
    /**
     * Define the alignment of column header which is used to align the text of column header.
     * @default Left
     * @hidden
     */
    headerTextAlign?: TextAlign;
    /**
     * If `disableHtmlEncode` is set to true, it encodes the HTML of the header and content cells.
     * @default false
     */
    disableHtmlEncode?: boolean;
    /**
     * Defines the data type of the column.
     * @default null
     */
    type?: string;
    /**
     * It is used to change display value with the given format and does not affect the original data.
     * Gets the format from the user which can be standard or custom
     * [`number`](../base/intl.html#number-formatter-and-parser)
     * and [`date`](../base/intl.html#date-formatter-and-parser) formats.
     * @default null
     */
    format?: string | base.NumberFormatOptions | base.DateFormatOptions;
    /**
     * If `visible` is set to false, hides the particular column. By default, all columns are displayed.
     * @default true
     */
    visible?: boolean;
    /**
     * Defines the column template that renders customized element in each cell of the column.
     * It accepts either [template string](../base/template-engine.html) or HTML element ID.
     * @default null
     */
    template?: string;
    /**
     * Defines the column template as string or HTML element ID which is used to add customized element in the column header.
     * @default null
     */
    headerTemplate?: string;
    /**
     * You can use this property to freeze selected columns in grid.
     * @default false
     */
    isFrozen?: boolean;
    /**
     * If `allowSorting` set to false, then it disables sorting option of a particular column.
     * By default all columns are sortable.
     * @default true
     */
    allowSorting?: boolean;
    /**
     * If `allowResizing` set to false, it disables resize option of a particular column.
     * @default true
     */
    allowResizing?: boolean;
    /**
     * If `showColumnMenu` set to false, then it disable the column menu of a particular column.
     * By default column menu will show for all columns
     * @default true
     */
    showColumnMenu?: boolean;
    /**
     * If `allowFiltering` set to false, then it disables filtering option and filter bar element of a particular column.
     * By default all columns are filterable.
     * @default true
     */
    allowFiltering?: boolean;
    /**
     * If `allowGrouping` set to false, then it disables grouping of a particular column.
     * By default all columns are groupable.
     * @default true
     */
    allowGrouping?: boolean;
    /**
     * If `enableGroupByFormat` set to true, then it groups the particular column by formatted values.
     * By default no columns are group by format.
     * @default true
     */
    enableGroupByFormat?: boolean;
    /**
     * If `allowEditing` set to false, then it disables editing of a particular column.
     * By default all columns are editable.
     * @default true
     */
    allowEditing?: boolean;
    /**
     * The CSS styles and attributes of the content cells of a particular column can be customized.
     *
     * ```html
     * <div id="Grid"></div>
     * ```
     * ```typescript
     * let gridObj: Grid = new Grid({
     * dataSource: filterData,
     * columns: [
     *    { field: 'OrderID', headerText: 'Order ID' },
     *    {
     *        field: 'EmployeeID', headerText: 'Employee ID', customAttributes: {
     *           class: 'employeeid',
     *           type: 'employee-id-cell'
     *      }
     *   }]
     * });
     * gridObj.appendTo('#Grid');
     * ```
     *
     * @default null
     */
    customAttributes?: {
        [x: string]: Object;
    };
    /**
     * If `displayAsCheckBox` is set to true, it displays the column value as a check box instead of Boolean value.
     * @default false
     */
    displayAsCheckBox?: boolean;
    /**
     * Defines the column data source  which will act as foreign data source.
     * @default null
     */
    dataSource?: Object[] | data.DataManager;
    /**
     * Defines the method which is used to achieve custom formatting from an external function.
     * This function triggers before rendering of each cell.
     *
     * ```html
     * <div id="Grid"></div>
     * ```
     * ```typescript
     * class ExtendedFormatter implements ICellFormatter {
     * public getValue(column: Column, data: Object): Object {
     *   return '<span style="color:' + (data['Verified'] ? 'green' : 'red') + '"><i>' + data['Verified'] + '</i><span>';
     * }
     * }
     * let gridObj: Grid = new Grid({
     *     dataSource: filterData,
     *     columns: [
     *         { field: 'ShipName', headerText: 'Ship Name' },
     *         { field: 'Verified', headerText: 'Verified Status', formatter: ExtendedFormatter }]
     * });
     * gridObj.appendTo('#Grid');
     * ```
     *
     * @default null
     */
    formatter?: {
        new (): ICellFormatter;
    } | ICellFormatter | Function;
    /**
     * Defines the method used to apply custom cell values from external function and display this on each cell rendered.
     *
     * ```html
     * <div id="Grid"></div>
     * ```
     * ```typescript
     * let gridObj: Grid = new Grid({
     * dataSource: [{ EmployeeID: 1, EmployeeName: ['John', 'M'] }, { EmployeeID: 2, EmployeeName: ['Peter', 'A'] }],
     * columns: [
     *     { field: 'EmployeeID', headerText: 'Employee ID' },
     *     { field: 'EmployeeName', headerText: 'Employee First Name',
     *       valueAccessor: (field: string, data: Object, column: Column) => {
     *             return data['EmployeeName'][0];
     *         },
     *     }]
     * });
     * ```
     *
     * @default null
     */
    valueAccessor?: ValueAccessor;
    /**
     * The `filterBarTemplate` is used to add a custom component instead of default input component for filter bar.
     * It have create and read functions.
     * * create: It is used for creating custom components.
     * * read: It is used to perform custom filter action.
     *
     * ```html
     * <div id="Grid"></div>
     * ```
     * ```typescript
     * let gridObj: Grid = new Grid({
     * dataSource: filterData,
     * columns: [
     *   { field: 'OrderID', headerText: 'Order ID' },
     *   {
     *      field: 'EmployeeID', filterBarTemplate: {
     *         create: (args: { element: Element, column: Column }) => {
     *              let input: HTMLInputElement = document.createElement('input');
     *              input.id = 'EmployeeID';
     *              input.type = 'text';
     *              return input;
     *         },
     *         write: (args: { element: Element, column: Column }) => {
     *             args.element.addEventListener('input', args.column.filterBarTemplate.read as EventListener);
     *         },
     *         read: (args: { element: HTMLInputElement, columnIndex: number, column: Column }) => {
     *             gridObj.filterByColumn(args.element.id, 'equal', args.element.value);
     *        }
     *     }
     *  }],
     *   allowFiltering: true
     * });
     * gridObj.appendTo('#Grid');
     * ```
     *
     * @default null
     */
    filterBarTemplate?: IFilterUI;
    /**
     *  Defines the filter options to customize filtering for the particular column.
     *  @default null
     */
    filter?: IFilter;
    /**
     * Used to render multiple header rows(stacked headers) on the Grid header.
     * @default null
     */
    columns?: Column[] | string[] | ColumnModel[];
    /**
     * Defines the tool tip text for stacked headers.
     * @hidden
     * @default null
     */
    toolTip?: string;
    /**
     * If `isPrimaryKey` is set to true, considers this column as the primary key constraint.
     * @default false
     */
    isPrimaryKey?: boolean;
    /**
     * Defines the type of component for editing.
     * @default stringedit
     */
    editType?: string;
    /**
     * Defines rules to validate data before creating and updating.
     * @default null
     */
    validationRules?: Object;
    /**
     * Defines default values for the component when adding a new record to the Grid.
     * @default null
     */
    defaultValue?: string;
    /**
     * Defines the `IEditCell` object to customize default edit cell.
     * @default {}
     */
    edit?: IEditCell;
    /**
     * If `isIdentity` is set to true, then this column is considered as identity column.
     * @default false
     */
    isIdentity?: boolean;
    /**
     * Defines the mapping column name of the foreign data source.
     * If it is not defined then the `columns.field` will be considered as mapping column name
     * @default null
     */
    foreignKeyField?: string;
    /**
     * Defines the display column name from the foreign data source which will be obtained from comparing local and foreign data
     * @default null
     */
    foreignKeyValue?: string;
    /**
     * column visibility can change based on its [`Media Queries`](http://cssmediaqueries.com/what-are-css-media-queries.html).
     * `hideAtMedia` accepts only valid Media Queries.
     * @default undefined
     */
    hideAtMedia?: string;
    /**
     * If `showInColumnChooser` set to false, then hides the particular column in column chooser.
     * By default all columns are displayed in column Chooser.
     * @default true
     */
    showInColumnChooser?: boolean;
    /**
     * @hidden
     * Defines the commands column template as string or HTML element ID which is used to add
     * customized command buttons in each cells of the column.
     */
    commandsTemplate?: string;
    /**
     * `commands` provides an option to display command buttons in every cell.
     * The available built-in command buttons are
     * * Edit - Edit the record.
     * * Delete - Delete the record.
     * * Save - Save the record.
     * * Cancel - Cancel the edit state.
     *
     * The following code example implements the custom command column.
     * ```html
     * <style type="text/css" class="cssStyles">
     * .details-icon:before
     * {
     *    content:"\e74d";
     * }
     * </style>
     * <div id="Grid"></div>
     * ```
     * ```typescript
     * var gridObj = new Grid({
     * datasource: window.gridData,
     * columns : [
     *  { field: 'CustomerID', headerText: 'Customer ID' },
     *  { field: 'CustomerName', headerText: 'Customer Name' },
     *  {commands: [{buttonOption:{content: 'Details', click: onClick, cssClass: details-icon}}], headerText: 'Customer Details'}
     * ]
     * gridObj.appendTo("#Grid");
     * ```
     * @default null
     */
    commands?: CommandModel[];
    /**
     * It defines the custom sort comparer function.
     */
    sortComparer?: (x: number | string, y: number | string) => number;
    /**
     * @hidden
     * It defines the column is foreign key column or not.
     */
    isForeignColumn?: () => boolean;
}
/**
 * Interface for a class PageSettings
 */
export interface PageSettingsModel {
    /**
     * Defines the number of records to be displayed per page.
     * @default 12
     */
    pageSize?: number;
    /**
     * Defines the number of pages to be displayed in the pager container.  
     * @default 8 
     */
    pageCount?: number;
    /**
     * Defines the current page number of the pager.
     * @default 1
     */
    currentPage?: number;
    /**
     * @hidden
     * Gets the total records count of the Grid. 
     */
    totalRecordsCount?: number;
    /**
     * If `enableQueryString` set to true,   
     * then it pass current page information as a query string along with the URL while navigating to other page.  
     * @default false  
     */
    enableQueryString?: boolean;
    /**
     * If `pageSizes` set to true or Array of values,
     * It renders DropDownList in the pager which allow us to select pageSize from DropDownList.      
     * @default false    
     */
    pageSizes?: boolean | number[];
    /**
     * Defines the template which renders customized elements in pager instead of default elements.     
     * It accepts either [template string](../base/template-engine.html) or HTML element ID.   
     * @default null    
     */
    template?: string;
}
/**
 * Configures the paging behavior of the Grid.
 */
export  class PageSettings extends base.ChildProperty<PageSettings> {
    /**
     * Defines the number of records to be displayed per page.
     * @default 12
     */
    pageSize: number;
    /**
     * Defines the number of pages to be displayed in the pager container.
     * @default 8
     */
    pageCount: number;
    /**
     * Defines the current page number of the pager.
     * @default 1
     */
    currentPage: number;
    /**
     * @hidden
     * Gets the total records count of the Grid.
     */
    totalRecordsCount: number;
    /**
     * If `enableQueryString` set to true,
     * then it pass current page information as a query string along with the URL while navigating to other page.
     * @default false
     */
    enableQueryString: boolean;
    /**
     * If `pageSizes` set to true or Array of values,
     * It renders DropDownList in the pager which allow us to select pageSize from DropDownList.
     * @default false
     */
    pageSizes: boolean | number[];
    /**
     * Defines the template which renders customized elements in pager instead of default elements.
     * It accepts either [template string](../base/template-engine.html) or HTML element ID.
     * @default null
     */
    template: string;
}
/**
 * Row
 * @hidden
 */
export  class Row<T> {
    uid: string;
    data: Object;
    changes: Object;
    isDirty: boolean;
    edit: string;
    isSelected: boolean;
    isReadOnly: boolean;
    isAltRow: boolean;
    isDataRow: boolean;
    isExpand: boolean;
    rowSpan: number;
    cells: Cell<T>[];
    index: number;
    indent: number;
    subRowDetails: Object;
    height: string;
    visible: boolean;
    attributes: {
        [x: string]: Object;
    };
    cssClass: string;
    foreignKeyData: Object;
    constructor(options: {
        [x: string]: Object;
    });
    clone(): Row<T>;
}
/**
 * Models
 */
/**
 * Edit render module is used to render grid edit row.
 * @hidden
 */
export  class BatchEditRender {
    private parent;
    /**
     * Constructor for render module
     */
    constructor(parent?: IGrid);
    update(elements: Element[], args: {
        columnObject?: Column;
        cell?: Element;
        row?: Element;
    }): void;
    private getEditElement(elements, args);
    removeEventListener(): void;
}
/**
 * `BooleanEditCell` is used to handle boolean cell type editing.
 * @hidden
 */
export  class BooleanEditCell implements IEditCell {
    private parent;
    private obj;
    private editRow;
    private editType;
    private activeClasses;
    constructor(parent?: IGrid);
    create(args: {
        column: Column;
        value: string;
        type: string;
    }): Element;
    read(element: Element): boolean;
    write(args: {
        rowData: Object;
        element: Element;
        column: Column;
        requestType: string;
        row: Element;
    }): void;
    private checkBoxChange(args);
    destroy(): void;
}
/**
 * `boolfilterui` render boolean column.
 * @hidden
 */
export  class BooleanFilterUI implements IFilterMUI {
    private parent;
    protected serviceLocator: ServiceLocator;
    private elem;
    private value;
    private filterSettings;
    private dropInstance;
    private dialogObj;
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator, filterSettings?: FilterSettings);
    create(args: {
        column: Column;
        target: HTMLElement;
        getOptrInstance: FlMenuOptrUI;
        localizeText: base.L10n;
        dialogObj: popups.Dialog;
    }): void;
    write(args: {
        column: Column;
        target: Element;
        parent: IGrid;
        filteredValue: number | string | Date | boolean;
    }): void;
    read(element: Element, column: Column, filterOptr: string, filterObj: Filter): void;
    private ddActionComplete(e);
    private openPopup(args);
}
/**
 * GroupCaptionCellRenderer class which responsible for building group caption cell.
 * @hidden
 */
export  class GroupCaptionCellRenderer extends CellRenderer implements ICellRenderer<Column> {
    element: HTMLElement;
    /**
     * Function to render the cell content based on Column object.
     * @param  {Cell} cell
     * @param  {Object} data
     */
    render(cell: Cell<Column>, data: GroupedData): Element;
}
/**
 * GroupCaptionEmptyCellRenderer class which responsible for building group caption empty cell.
 * @hidden
 */
export  class GroupCaptionEmptyCellRenderer extends CellRenderer implements ICellRenderer<Column> {
    element: HTMLElement;
    /**
     * Function to render the cell content based on Column object.
     * @param  {Cell} cell
     * @param  {Object} data
     */
    render(cell: Cell<Column>, data: {
        field: string;
        key: string;
        count: number;
    }): Element;
}
/**
 * `CellMergeRender` module.
 * @hidden
 */
export  class CellMergeRender<T> {
    private serviceLocator;
    protected parent: IGrid;
    constructor(serviceLocator?: ServiceLocator, parent?: IGrid);
    render(cellArgs: QueryCellInfoEventArgs, row: Row<T>, i: number, td: Element): Element;
    private backupMergeCells(fName, data, span);
    private generteKey(fname, data);
    private splitKey(key);
    private containsKey(fname, data);
    private getMergeCells();
    private setMergeCells(key, span);
    updateVirtualCells(rows: Row<Column>[]): Row<Column>[];
    private getIndexFromAllColumns(field);
}
/**
 * CellRenderer class which responsible for building cell content.
 * @hidden
 */
export  class CellRenderer implements ICellRenderer<Column> {
    element: HTMLElement;
    private rowChkBox;
    protected localizer: base.L10n;
    protected formatter: IValueFormatter;
    protected parent: IGrid;
    constructor(parent: IGrid, locator?: ServiceLocator);
    /**
     * Function to return the wrapper for the TD content
     * @returns string
     */
    getGui(): string | Element;
    /**
     * Function to format the cell value.
     * @param  {Column} column
     * @param  {Object} value
     * @param  {Object} data
     */
    format(column: Column, value: Object, data?: Object): string;
    evaluate(node: Element, cell: Cell<Column>, data: Object, attributes?: Object, fData?: Object): boolean;
    /**
     * Function to invoke the custom formatter available in the column object.
     * @param  {Column} column
     * @param  {Object} value
     * @param  {Object} data
     */
    invokeFormatter(column: Column, value: Object, data: Object): Object;
    /**
     * Function to render the cell content based on Column object.
     * @param  {Column} column
     * @param  {Object} data
     * @param  {{[x:string]:Object}} attributes?
     * @param  {Element}
     */
    render(cell: Cell<Column>, data: Object, attributes?: {
        [x: string]: Object;
    }): Element;
    /**
     * Function to refresh the cell content based on Column object.
     * @param  {Column} column
     * @param  {Object} data
     * @param  {{[x:string]:Object}} attributes?
     * @param  {Element}
     */
    refreshTD(td: Element, cell: Cell<Column>, data: Object, attributes?: {
        [x: string]: Object;
    }): void;
    private refreshCell(cell, data, attributes?);
    /**
     * Function to specifies how the result content to be placed in the cell.
     * @param  {Element} node
     * @param  {string|Element} innerHtml
     * @returns Element
     */
    appendHtml(node: Element, innerHtml: string | Element, property?: string): Element;
    /**
     * @hidden
     */
    setAttributes(node: HTMLElement, cell: Cell<Column>, attributes?: {
        [x: string]: Object;
    }): void;
    buildAttributeFromCell<Column>(node: HTMLElement, cell: Cell<Column>, isCheckBoxType?: boolean): void;
    getValue(field: string, data: Object, column: Column): Object;
}
/**
 * `CommandColumn` used to render command column in grid
 * @hidden
 */
export  class CommandColumnRenderer extends CellRenderer implements ICellRenderer<Column> {
    private buttonElement;
    private unbounDiv;
    element: HTMLElement;
    constructor(parent: IGrid, locator?: ServiceLocator);
    /**
     * Function to render the cell content based on Column object.
     * @param  {Column} column
     * @param  {Object} data
     * @param  {{[x:string]:Object}} attributes?
     * @param  {Element}
     */
    render(cell: Cell<Column>, data: Object, attributes?: {
        [x: string]: Object;
    }): Element;
    private renderButton(node, buttonOption, index);
}
/**
 * Content module is used to render grid content
 * @hidden
 */
export  class ContentRender implements IRenderer {
    private contentTable;
    private contentPanel;
    private rows;
    private freezeRows;
    private movableRows;
    private rowElements;
    private freezeRowElements;
    colgroup: Element;
    private isLoaded;
    private tbody;
    private drop;
    private args;
    private rafCallback;
    protected parent: IGrid;
    private serviceLocator;
    private ariaService;
    protected generator: IModelGenerator<Column>;
    /**
     * Constructor for content renderer module
     */
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
    /**
     * The function is used to render grid content div
     */
    renderPanel(): void;
    /**
     * The function is used to render grid content table
     */
    renderTable(): void;
    /**
     * The function is used to create content table elements
     * @return {Element}
     * @hidden
     */
    createContentTable(id: String): Element;
    private splitRows(idx);
    /**
     * Refresh the content of the Grid.
     * @return {void}
     */
    refreshContentRows(args?: NotifyArgs): void;
    appendContent(tbody: Element, frag: DocumentFragment, args: NotifyArgs): void;
    /**
     * Get the content div element of grid
     * @return {Element}
     */
    getPanel(): Element;
    /**
     * Set the content div element of grid
     * @param  {Element} panel
     */
    setPanel(panel: Element): void;
    /**
     * Get the content table element of grid
     * @return {Element}
     */
    getTable(): Element;
    /**
     * Set the content table element of grid
     * @param  {Element} table
     */
    setTable(table: Element): void;
    /**
     * Get the Row collection in the Grid.
     * @returns {Row[] | HTMLCollectionOf<HTMLTableRowElement>}
     */
    getRows(): Row<Column>[] | HTMLCollectionOf<HTMLTableRowElement>;
    /**
     * Get the Movable Row collection in the Freeze pane Grid.
     * @returns {Row[] | HTMLCollectionOf<HTMLTableRowElement>}
     */
    getMovableRows(): Row<Column>[] | HTMLCollectionOf<HTMLTableRowElement>;
    /**
     * Get the content table data row elements
     * @return {Element}
     */
    getRowElements(): Element[];
    /**
     * Get the Freeze pane movable content table data row elements
     * @return {Element}
     */
    getMovableRowElements(): Element[];
    /**
     * Get the content table data row elements
     * @return {Element}
     */
    setRowElements(elements: Element[]): void;
    /**
     * Get the header colgroup element
     * @returns {Element}
     */
    getColGroup(): Element;
    /**
     * Set the header colgroup element
     * @param {Element} colgroup
     * @returns {Element}
     */
    setColGroup(colGroup: Element): Element;
    /**
     * Function to hide content table column based on visible property
     * @param  {Column[]} columns?
     */
    setVisible(columns?: Column[]): void;
    private colGroupRefresh();
    private initializeContentDrop();
    private canSkip(column, row, index);
    getModelGenerator(): IModelGenerator<Column>;
    renderEmpty(tbody: HTMLElement): void;
    setSelection(uid: string, set: boolean, clearAll?: boolean): void;
    getRowByIndex(index: number): Element;
    getVirtualRowIndex(index: number): number;
    getMovableRowByIndex(index: number): Element;
    private enableAfterRender(e);
}
/**
 * `datefilterui` render date column.
 * @hidden
 */
export  class DateFilterUI implements IFilterMUI {
    private parent;
    protected locator: ServiceLocator;
    private inputElem;
    private value;
    private datePickerObj;
    private fltrSettings;
    private dialogObj;
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator, filterSettings?: FilterSettings);
    create(args: IFilterCreate): void;
    write(args: {
        column: Column;
        target: Element;
        parent: IGrid;
        filteredValue: number | string | Date | boolean;
    }): void;
    read(element: Element, column: Column, filterOptr: string, filterObj: Filter): void;
    private openPopup(args);
}
/**
 * `DatePickerEditCell` is used to handle datepicker cell type editing.
 * @hidden
 */
export  class DatePickerEditCell implements IEditCell {
    private parent;
    private obj;
    constructor(parent?: IGrid);
    create(args: {
        column: Column;
        value: string;
        type: string;
    }): Element;
    read(element: Element): string | Date;
    write(args: {
        rowData: Object;
        element: Element;
        column: Column;
        type: string;
    }): void;
    destroy(): void;
}
/**
 * `DefaultEditCell` is used to handle default cell type editing.
 * @hidden
 */
export  class DefaultEditCell implements IEditCell {
    private parent;
    constructor(parent?: IGrid);
    create(args: {
        column: Column;
        value: string;
        requestType: string;
    }): Element;
    read(element: Element): string;
    write(args: {
        rowData: Object;
        element: Element;
        column: Column;
        requestType: string;
    }): void;
}
/**
 * ExpandCellRenderer class which responsible for building group expand cell.
 * @hidden
 */
export  class DetailExpandCellRenderer extends CellRenderer implements ICellRenderer<Column> {
    element: HTMLElement;
    /**
     * Function to render the detail expand cell
     */
    render(cell: Cell<Column>, data: Object, attributes: Object): Element;
}
/**
 * DetailHeaderIndentCellRenderer class which responsible for building detail header indent cell.
 * @hidden
 */
export  class DetailHeaderIndentCellRenderer extends CellRenderer implements ICellRenderer<Column> {
    element: HTMLElement;
    /**
     * Function to render the detail indent cell
     * @param  {Cell} cell
     * @param  {Object} data
     */
    render(cell: Cell<Column>, data: Object): Element;
}
/**
 * Edit render module is used to render grid edit row.
 * @hidden
 */
export  class DialogEditRender {
    private parent;
    private l10n;
    private isEdit;
    private serviceLocator;
    private dialog;
    private dialogObj;
    /**
     * Constructor for render module
     */
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
    private setLocaleObj();
    addNew(elements: Element[], args: {
        primaryKeyValue?: string[];
    }): void;
    update(elements: Element[], args: {
        primaryKeyValue?: string[];
    }): void;
    private createDialog(elements, args);
    private btnClick(e);
    private dialogClose();
    private destroy(args?);
    private getEditElement(elements);
    removeEventListener(): void;
}
/**
 * `DropDownEditCell` is used to handle dropdown cell type editing.
 * @hidden
 */
export  class DropDownEditCell implements IEditCell {
    private parent;
    private obj;
    private column;
    constructor(parent?: IGrid);
    create(args: {
        column: Column;
        value: string;
    }): Element;
    write(args: {
        rowData: Object;
        element: Element;
        column: Column;
        requestType: string;
    }): void;
    read(element: Element): string;
    private ddActionComplete(e);
    private dropDownOpen(args);
    destroy(): void;
}
/**
 * Edit render module is used to render grid edit row.
 * @hidden
 */
export  class EditRender {
    private editType;
    protected parent: IGrid;
    private renderer;
    protected serviceLocator: ServiceLocator;
    private focus;
    /**
     * Constructor for render module
     */
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
    addNew(args: {
        rowData?: Object;
        columnName?: string;
        columnObject?: Column;
        requestType?: string;
        cell?: Element;
        row?: Element;
        primaryKeyValue?: string[];
    }): void;
    update(args: {
        rowData?: Object;
        columnName?: string;
        columnObject?: Column;
        requestType?: string;
        cell?: Element;
        row?: Element;
        primaryKeyValue?: string[];
    }): void;
    private convertWidget(args);
    private focusElement(elem, type?);
    private getEditElements(args);
    destroy(): void;
}
/**
 * ExpandCellRenderer class which responsible for building group expand cell.
 * @hidden
 */
export  class ExpandCellRenderer extends IndentCellRenderer implements ICellRenderer<Column> {
    /**
     * Function to render the expand cell
     * @param  {Cell} cell
     * @param  {Object} data
     */
    render(cell: Cell<Column>, data: {
        field: string;
        key: string;
    }): Element;
}
/**
 * FilterCellRenderer class which responsible for building filter cell.
 * @hidden
 */
export  class FilterCellRenderer extends CellRenderer implements ICellRenderer<Column> {
    element: HTMLElement;
    /**
     * Function to return the wrapper for the TH content.
     * @returns string
     */
    getGui(): string | Element;
    /**
     * Function to render the cell content based on Column object.
     * @param  {Cell} cell
     * @param  {Object} data
     */
    render(cell: Cell<Column>, data: Object): Element;
    /**
     * Function to specifies how the result content to be placed in the cell.
     * @param  {Element} node
     * @param  {string|Element} innerHTML
     * @returns Element
     */
    appendHtml(node: Element, innerHtml: string | Element): Element;
}
/**
 * `filter operators` render boolean column.
 * @hidden
 */
export  class FlMenuOptrUI {
    private parent;
    private customFilterOperators;
    private serviceLocator;
    private filterSettings;
    private dropOptr;
    private customOptr;
    private optrData;
    private dialogObj;
    constructor(parent?: IGrid, customFltrOperators?: Object, serviceLocator?: ServiceLocator, filterSettings?: FilterSettings);
    /**
     * @hidden
     */
    renderOperatorUI(dlgConetntEle: Element, target: Element, column: Column, dlgObj: popups.Dialog): void;
    private dropDownOpen(args);
    private dropSelectedVal(col, optr);
    /**
     * @hidden
     */
    getFlOperator(): string;
}
/**
 * `filter menu` render boolean column.
 * @hidden
 */
export  class FilterMenuRenderer {
    private parent;
    private filterObj;
    private serviceLocator;
    private dlgDiv;
    private l10n;
    dlgObj: popups.Dialog;
    private valueFormatter;
    private filterSettings;
    private customFilterOperators;
    private dropOptr;
    private flMuiObj;
    private col;
    private isDialogOpen;
    private colTypes;
    constructor(parent?: IGrid, filterSettings?: FilterSettings, serviceLocator?: ServiceLocator, customFltrOperators?: Object, fltrObj?: Filter);
    private openDialog(args);
    private closeDialog();
    private renderDlgContent(target, column);
    private dialogCreated(target, column);
    private renderFilterUI(target, col);
    private renderOperatorUI(dlgConetntEle, target, column);
    private renderFlValueUI(dlgConetntEle, target, column);
    private writeMethod(col, dlgContentEle);
    private filterBtnClick(col);
    private clearBtnClick(column);
    destroy(): void;
}
/**
 * Footer module is used to render grid content
 * @hidden
 */
export  class FooterRenderer extends ContentRender implements IRenderer {
    private locator;
    protected modelGenerator: SummaryModelGenerator;
    private aggregates;
    private freezeTable;
    private frozenContent;
    private movableContent;
    constructor(gridModule?: IGrid, serviceLocator?: ServiceLocator);
    /**
     * The function is used to render grid footer div
     */
    renderPanel(): void;
    /**
     * The function is used to render grid footer table
     */
    renderTable(): void;
    private renderSummaryContent(e?, table?, cStart?, cEnd?);
    refresh(e?: {
        aggregates?: Object;
    }): void;
    refreshCol(): void;
    private onWidthChange(args);
    private onScroll(e?);
    getColFromIndex(index?: number): HTMLElement;
    private columnVisibilityChanged();
    addEventListener(): void;
    removeEventListener(): void;
    private updateFooterTableWidth(tFoot);
}
/**
 * Freeze module is used to render grid content with frozen rows and columns
 * @hidden
 */
export  class FreezeContentRender extends ContentRender implements IRenderer {
    private frozenContent;
    private movableContent;
    constructor(parent?: IGrid, locator?: ServiceLocator);
    renderPanel(): void;
    renderEmpty(tbody: HTMLElement): void;
    private setFrozenContent(ele);
    private setMovableContent(ele);
    getFrozenContent(): Element;
    getMovableContent(): Element;
    getModelGenerator(): IModelGenerator<Column>;
    renderTable(): void;
}
export  class FreezeRender extends HeaderRender implements IRenderer {
    private frozenHeader;
    private movableHeader;
    constructor(parent?: IGrid, locator?: ServiceLocator);
    addEventListener(): void;
    renderTable(): void;
    renderPanel(): void;
    refreshUI(): void;
    private rfshMovable();
    private refreshFreeze(obj);
    private updateResizeHandler();
    private setWrapHeight(fRows, mRows, isModeChg, isContReset?, isStackedHdr?);
    private refreshStackedHdrHgt();
    private getRowSpan(row);
    private updateStackedHdrRowHgt(idx, maxRowSpan, row, rows);
    private setFrozenHeader(ele);
    private setMovableHeader(ele);
    getFrozenHeader(): Element;
    getMovableHeader(): Element;
    private updateColgroup();
}
/**
 * HeaderCellRenderer class which responsible for building header cell content.
 * @hidden
 */
export  class HeaderCellRenderer extends CellRenderer implements ICellRenderer<Column> {
    element: HTMLElement;
    private ariaService;
    private hTxtEle;
    private sortEle;
    private gui;
    private chkAllBox;
    /**
     * Function to return the wrapper for the TH content.
     * @returns string
     */
    getGui(): string | Element;
    /**
     * Function to render the cell content based on Column object.
     * @param  {Column} column
     * @param  {Object} data
     * @param  {Element}
     */
    render(cell: Cell<Column>, data: Object, attributes?: {
        [x: string]: Object;
    }): Element;
    /**
     * Function to refresh the cell content based on Column object.
     * @param  {Cell} cell
     * @param  {Element} node
     */
    refresh(cell: Cell<Column>, node: Element): Element;
    private clean(node);
    private prepareHeader(cell, node, fltrMenuEle);
    private extendPrepareHeader(column, node);
    /**
     * Function to specifies how the result content to be placed in the cell.
     * @param  {Element} node
     * @param  {string|Element} innerHtml
     * @returns Element
     */
    appendHtml(node: Element, innerHtml: string | Element): Element;
}
/**
 * HeaderIndentCellRenderer class which responsible for building header indent cell.
 * @hidden
 */
export  class HeaderIndentCellRenderer extends CellRenderer implements ICellRenderer<Column> {
    element: HTMLElement;
    /**
     * Function to render the indent cell
     * @param  {Cell} cell
     * @param  {Object} data
     */
    render(cell: Cell<Column>, data: Object): Element;
}
/**
 * Content module is used to render grid content
 * @hidden
 */
export  class HeaderRender implements IRenderer {
    private headerTable;
    private headerPanel;
    private colgroup;
    private caption;
    protected colDepth: number;
    private column;
    protected rows: Row<Column>[];
    private frzIdx;
    private helper;
    private dragStart;
    private drag;
    private dragStop;
    private drop;
    protected parent: IGrid;
    protected serviceLocator: ServiceLocator;
    protected widthService: ColumnWidthService;
    protected ariaService: AriaService;
    /**
     * Constructor for header renderer module
     */
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
    /**
     * The function is used to render grid header div
     */
    renderPanel(): void;
    /**
     * The function is used to render grid header table
     */
    renderTable(): void;
    /**
     * Get the header content div element of grid
     * @return {Element}
     */
    getPanel(): Element;
    /**
     * Set the header content div element of grid
     * @param  {Element} panel
     */
    setPanel(panel: Element): void;
    /**
     * Get the header table element of grid
     * @return {Element}
     */
    getTable(): Element;
    /**
     * Set the header table element of grid
     * @param  {Element} table
     */
    setTable(table: Element): void;
    /**
     * Get the header colgroup element
     * @returns {Element}
     */
    getColGroup(): Element;
    /**
     * Set the header colgroup element
     * @param {Element} colgroup
     * @returns {Element}
     */
    setColGroup(colGroup: Element): Element;
    /**
     * Get the header row element collection.
     * @return {Element[]}
     */
    getRows(): Row<Column>[] | HTMLCollectionOf<HTMLTableRowElement>;
    /**
     * The function is used to create header table elements
     * @return {Element}
     * @hidden
     */
    private createHeaderTable();
    /**
     * @hidden
     */
    createTable(): Element;
    private createHeaderContent();
    private updateColGroup(colGroup);
    private ensureColumns(rows);
    private getHeaderCells(rows);
    private appendCells(cols, rows, index, isFirstObj, isFirstCol, isLastCol, isMovable);
    private refreshFrozenHdr(cols, frzObj);
    private getColSpan(colSpan, isMovable, frozenCnt);
    private generateRow(index);
    private generateCell(column, cellType?, rowSpan?, className?, rowIndex?, colIndex?);
    /**
     * Function to hide header table column based on visible property
     * @param  {Column[]} columns?
     */
    setVisible(columns?: Column[]): void;
    private colPosRefresh();
    /**
     * Refresh the header of the Grid.
     * @returns {void}
     */
    refreshUI(): void;
    appendContent(table?: Element): void;
    private getObjDepth();
    private checkDepth(col, index);
    private getCellCnt(col, cnt);
    protected initializeHeaderDrag(): void;
    protected initializeHeaderDrop(): void;
}
/**
 * IndentCellRenderer class which responsible for building group indent cell.
 * @hidden
 */
export  class IndentCellRenderer extends CellRenderer implements ICellRenderer<Column> {
    element: HTMLElement;
    /**
     * Function to render the indent cell
     * @param  {Cell} cell
     * @param  {Object} data
     */
    render(cell: Cell<Column>, data: Object): Element;
}
/**
 * Edit render module is used to render grid edit row.
 * @hidden
 */
export  class InlineEditRender {
    private parent;
    /**
     * Constructor for render module
     */
    constructor(parent?: IGrid);
    addNew(elements: Object, args: {
        row?: Element;
    }): void;
    private renderMovableform(ele);
    private updateFreezeEdit(row, td);
    update(elements: Object, args: {
        row?: Element;
    }): void;
    private refreshFreezeEdit(row);
    private updateFrozenCont(row, ele, mEle);
    private renderMovable(ele, mEle);
    private getEditElement(elements?, isEdit?, tdElement?);
    removeEventListener(): void;
}
/**
 * `numberfilterui` render number column.
 * @hidden
 */
export  class NumberFilterUI implements IFilterMUI {
    private parent;
    protected serviceLocator: ServiceLocator;
    private instance;
    private value;
    private numericTxtObj;
    private filterSettings;
    private filter;
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator, filterSettings?: FilterSettings);
    create(args: IFilterCreate): void;
    write(args: {
        column: Column;
        target: Element;
        parent: IGrid;
        filteredValue: number | string | Date | boolean;
    }): void;
    read(element: Element, column: Column, filterOptr: string, filterObj: Filter): void;
}
/**
 * `NumericEditCell` is used to handle numeric cell type editing.
 * @hidden
 */
export  class NumericEditCell implements IEditCell {
    private parent;
    private obj;
    constructor(parent?: IGrid);
    create(args: {
        column: Column;
        value: string;
    }): Element;
    read(element: Element): number;
    write(args: {
        rowData: Object;
        element: Element;
        column: Column;
        requestType: string;
    }): void;
    destroy(): void;
}
/**
 * Content module is used to render grid content
 * @hidden
 */
export  class Render {
    private isColTypeDef;
    private parent;
    private locator;
    private headerRenderer;
    private contentRenderer;
    private l10n;
    data: Data;
    private ariaService;
    private renderer;
    private emptyGrid;
    /**
     * Constructor for render module
     */
    constructor(parent?: IGrid, locator?: ServiceLocator);
    /**
     * To initialize grid header, content and footer rendering
     */
    render(): void;
    /**
     * Refresh the entire Grid.
     * @return {void}
     */
    refresh(e?: NotifyArgs): void;
    private refreshComplete(e?);
    /**
     * The function is used to refresh the dataManager
     * @return {void}
     */
    private refreshDataManager(args?);
    private getFData(deferred);
    private isNeedForeignAction();
    private foreignKey(columns);
    private sendBulkRequest(args?);
    private dmSuccess(e, args);
    private dmFailure(e);
    /**
     * Render empty row to Grid which is used at the time to represent to no records.
     * @return {void}
     * @hidden
     */
    renderEmptyRow(): void;
    private emptyRow(isTrigger?);
    private updateColumnType(record);
    private dataManagerSuccess(e, args?);
    private dataManagerFailure(e);
    private updatesOnInitialRender(e);
    private buildColumns(record);
    private instantiateRenderer();
    private addEventListener();
    /** @hidden */
    validateGroupRecords(e: ReturnType): Promise<Object>;
    private getPredicate(key, operator, value);
    private updateGroupInfo(current, untouched);
}
/**
 * RowRenderer class which responsible for building row content.
 * @hidden
 */
export  class RowRenderer<T> implements IRowRenderer<T> {
    element: Element;
    private cellRenderer;
    private serviceLocator;
    private cellType;
    protected parent: IGrid;
    constructor(serviceLocator?: ServiceLocator, cellType?: CellType, parent?: IGrid);
    /**
     * Function to render the row content based on Column[] and data.
     * @param  {Column[]} columns
     * @param  {Object} data?
     * @param  {{[x:string]:Object}} attributes?
     * @param  {string} rowTemplate?
     */
    render(row: Row<T>, columns: Column[], attributes?: {
        [x: string]: Object;
    }, rowTemplate?: string, cloneNode?: Element): Element;
    /**
     * Function to refresh the row content based on Column[] and data.
     * @param  {Column[]} columns
     * @param  {Object} data?
     * @param  {{[x:string]:Object}} attributes?
     * @param  {string} rowTemplate?
     */
    refresh(row: Row<T>, columns: Column[], isChanged: boolean, attributes?: {
        [x: string]: Object;
    }, rowTemplate?: string): void;
    private refreshRow(row, columns, attributes?, rowTemplate?, cloneNode?);
    private refreshMergeCells(row);
    /**
     * Function to check and add alternative row css class.
     * @param  {Element} tr
     * @param  {{[x:string]:Object}} attr
     */
    buildAttributeFromRow(tr: Element, row: Row<T>): void;
}
/**
 * StackedHeaderCellRenderer class which responsible for building stacked header cell content.
 * @hidden
 */
export  class StackedHeaderCellRenderer extends CellRenderer implements ICellRenderer<Column> {
    element: HTMLElement;
    /**
     * Function to render the cell content based on Column object.
     * @param  {Column} column
     * @param  {Object} data
     * @param  {Element}
     */
    render(cell: Cell<Column>, data: Object, attributes?: {
        [x: string]: Object;
    }): Element;
}
/**
 * `string filterui` render string column.
 * @hidden
 */
export  class StringFilterUI implements IFilterMUI {
    private parent;
    protected serLocator: ServiceLocator;
    private instance;
    private value;
    actObj: dropdowns.AutoComplete;
    private filterSettings;
    private filter;
    private dialogObj;
    constructor(parent?: IGrid, serviceLocator?: ServiceLocator, filterSettings?: FilterSettings);
    create(args: IFilterCreate): void;
    private getAutoCompleteOptions(args);
    write(args: {
        column: Column;
        target: Element;
        parent: IGrid;
        filteredValue: number | string | Date | boolean;
    }): void;
    read(element: Element, column: Column, filterOptr: string, filterObj: Filter): void;
    private openPopup(args);
}
/**
 * SummaryCellRenderer class which responsible for building summary cell content.
 * @hidden
 */
export  class SummaryCellRenderer extends CellRenderer implements ICellRenderer<AggregateColumnModel> {
    element: HTMLElement;
    getValue(field: string, data: Object, column: AggregateColumnModel): Object;
    evaluate(node: Element, cell: Cell<AggregateColumnModel>, data: Object, attributes?: Object): boolean;
}
/**
 * VirtualContentRenderer
 * @hidden
 */
export  class VirtualContentRenderer extends ContentRender implements IRenderer {
    private count;
    private maxPage;
    private maxBlock;
    private prevHeight;
    private observer;
    private prevInfo;
    private vgenerator;
    private header;
    private locator;
    private preventEvent;
    private actions;
    private content;
    private offsets;
    private tmpOffsets;
    private virtualEle;
    private offsetKeys;
    private isFocused;
    constructor(parent: IGrid, locator?: ServiceLocator);
    renderTable(): void;
    renderEmpty(tbody: HTMLElement): void;
    private scrollListener(scrollArgs);
    private block(blk);
    private getInfoFromView(direction, info, e);
    ensureBlocks(info: VirtualInfo): number[];
    appendContent(target: HTMLElement, newChild: DocumentFragment, e: NotifyArgs): void;
    private onDataReady(e?);
    private setVirtualHeight();
    private getPageFromTop(sTop, info);
    private getTranslateY(sTop, cHeight, info?);
    getOffset(block: number): number;
    private onEntered();
    eventListener(action: string): void;
    getBlockSize(): number;
    getBlockHeight(): number;
    isEndBlock(index: number): boolean;
    private getRowHeight();
    getTotalBlocks(): number;
    getColumnOffset(block: number): number;
    getModelGenerator(): IModelGenerator<Column>;
    private resetScrollPosition(action);
    private onActionBegin(e);
    getRows(): Row<Column>[];
    getRowByIndex(index: number): Element;
    getVirtualRowIndex(index: number): number;
    private refreshOffsets();
    refreshVirtualElement(): void;
}
/**
 * @hidden
 */
export  class VirtualHeaderRenderer extends HeaderRender implements IRenderer {
    virtualEle: VirtualElementHandler;
    private gen;
    constructor(parent: IGrid, locator: ServiceLocator);
    renderTable(): void;
    appendContent(table: Element): void;
    refreshUI(): void;
}
/**
 * @hidden
 */
export  class VirtualElementHandler {
    wrapper: HTMLElement;
    placeholder: HTMLElement;
    content: HTMLElement;
    table: HTMLElement;
    renderWrapper(): void;
    renderPlaceHolder(position?: string): void;
    adjustTable(xValue: number, yValue: number): void;
    setWrapperWidth(width: string, full?: boolean): void;
    setVirtualHeight(height?: number, width?: string): void;
}
/**
 * Services
 */
/**
 * AriaService
 * @hidden
 */
export  class AriaService {
    setOptions(target: HTMLElement, options: IAriaOptions<boolean>): void;
    setExpand(target: HTMLElement, expand: boolean): void;
    setSort(target: HTMLElement, direction?: SortDirection | 'none' | boolean): void;
    setBusy(target: HTMLElement, isBusy: boolean): void;
    setGrabbed(target: HTMLElement, isGrabbed: boolean, remove?: boolean): void;
    setDropTarget(target: HTMLElement, isTarget: boolean): void;
}
/**
 * @hidden
 */
export interface IAriaOptions<T> {
    role?: string;
    expand?: T;
    collapse?: T;
    selected?: T;
    multiselectable?: T;
    sort?: T | 'none';
    busy?: T;
    invalid?: T;
    grabbed?: T;
    dropeffect?: T;
    haspopup?: T;
    level?: T;
    colcount?: string;
}
/**
 * CellRendererFactory
 * @hidden
 */
export  class CellRendererFactory {
    cellRenderMap: {
        [c: string]: ICellRenderer<{}>;
    };
    addCellRenderer(name: string | CellType, type: ICellRenderer<{}>): void;
    getCellRenderer(name: string | CellType): ICellRenderer<{}>;
}
/**
 * FocusStrategy class
 * @hidden
 */
export  class FocusStrategy {
    parent: IGrid;
    currentInfo: FocusInfo;
    oneTime: boolean;
    swap: SwapInfo;
    content: IFocus;
    header: IFocus;
    active: IFocus;
    fContent: IFocus;
    fHeader: IFocus;
    private forget;
    private skipFocus;
    private focusByClick;
    private passiveHandler;
    private prevIndexes;
    constructor(parent: IGrid);
    protected focusCheck(e: Event): void;
    protected onFocus(): void;
    protected passiveFocus(e: FocusEvent): void;
    protected onBlur(e?: FocusEvent): void;
    onClick(e: Event | {
        target: Element;
    }, force?: boolean): void;
    protected onKeyPress(e: base.KeyboardEventArgs): void;
    private skipOn(e);
    getFocusedElement(): HTMLElement;
    getContent(): IFocus;
    setActive(content: boolean, isFrozen?: boolean): void;
    setFocusedElement(element: HTMLElement): void;
    focus(e?: base.KeyboardEventArgs): void;
    protected removeFocus(e?: FocusEvent): void;
    protected addFocus(info: FocusInfo, e?: base.KeyboardEventArgs): void;
    protected refreshMatrix(content?: boolean): Function;
    addEventListener(): void;
    removeEventListener(): void;
    destroy(): void;
    restoreFocus(): void;
    clearOutline(): void;
    clearIndicator(): void;
    getPrevIndexes(): IIndex;
    forgetPrevious(): void;
    setActiveByKey(action: string, active: IFocus): void;
    internalCellFocus(e: CellFocusArgs): void;
}
/**
 * Create matrix from row collection which act as mental model for cell navigation
 * @hidden
 */
export  class Matrix {
    matrix: number[][];
    current: number[];
    columns: number;
    rows: number;
    set(rowIndex: number, columnIndex: number, allow?: boolean): void;
    get(rowIndex: number, columnIndex: number, navigator: number[], action?: string, validator?: Function): number[];
    first(vector: number[], index: number, navigator: number[], moveTo?: boolean, action?: string): number;
    select(rowIndex: number, columnIndex: number): void;
    generate(rows: Row<Column>[], selector: Function): number[][];
    inValid(value: number): boolean;
}
/**
 * @hidden
 */
export  class ContentFocus implements IFocus {
    matrix: Matrix;
    parent: IGrid;
    keyActions: {
        [x: string]: number[];
    };
    indexesByKey: (action: string) => number[];
    constructor(parent: IGrid);
    getTable(): HTMLTableElement;
    onKeyPress(e: base.KeyboardEventArgs): void | boolean;
    getCurrentFromAction(action: string, navigator?: number[], isPresent?: boolean, e?: base.KeyboardEventArgs): number[];
    onClick(e: Event, force?: boolean): void | boolean;
    getFocusInfo(): FocusInfo;
    getFocusable(element: HTMLElement): HTMLElement;
    selector(row: Row<Column>, cell: Cell<Column>): boolean;
    jump(action: string, current: number[]): SwapInfo;
    getNextCurrent(previous?: number[], swap?: SwapInfo, active?: IFocus, action?: string): number[];
    generateRows(rows?: Row<Column>[], optionals?: Object): void;
    getInfo(e?: base.KeyboardEventArgs): FocusedContainer;
    validator(): Function;
    protected shouldFocusChange(e: base.KeyboardEventArgs): boolean;
}
/**
 * @hidden
 */
export  class HeaderFocus extends ContentFocus implements IFocus {
    constructor(parent: IGrid);
    getTable(): HTMLTableElement;
    onClick(e: Event): void | boolean;
    getFocusInfo(): FocusInfo;
    selector(row: Row<Column>, cell: Cell<Column>): boolean;
    jump(action: string, current: number[]): SwapInfo;
    getNextCurrent(previous?: number[], swap?: SwapInfo, active?: IFocus, action?: string): number[];
    generateRows(rows?: Row<Column>[]): void;
    getInfo(e?: base.KeyboardEventArgs): FocusedContainer;
    validator(): Function;
    protected shouldFocusChange(e: base.KeyboardEventArgs): boolean;
}
export  class FixedContentFocus extends ContentFocus {
    getTable(): HTMLTableElement;
    jump(action: string, current: number[]): SwapInfo;
    getNextCurrent(previous?: number[], swap?: SwapInfo, active?: IFocus, action?: string): number[];
}
export  class FixedHeaderFocus extends HeaderFocus {
    jump(action: string, current: number[]): SwapInfo;
    getTable(): HTMLTableElement;
    getNextCurrent(previous?: number[], swap?: SwapInfo, active?: IFocus, action?: string): number[];
}
/** @hidden */
export  class SearchBox {
    searchBox: HTMLElement;
    constructor(searchBox: HTMLElement);
    protected searchFocus(args: Event): void;
    protected searchBlur(args: Event): void;
    wireEvent(): void;
    unWireEvent(): void;
}
/**
 * FreezeRowModelGenerator is used to generate grid data rows with freeze row and column.
 * @hidden
 */
export  class FreezeRowModelGenerator implements IModelGenerator<Column> {
    private rowModelGenerator;
    private parent;
    private isFrzLoad;
    constructor(parent: IGrid);
    generateRows(data: Object, notifyArgs?: NotifyArgs): Row<Column>[];
}
/**
 * GroupModelGenerator is used to generate group caption rows and data rows.
 * @hidden
 */
export  class GroupModelGenerator extends RowModelGenerator implements IModelGenerator<Column> {
    private rows;
    private index;
    private summaryModelGen;
    private captionModelGen;
    constructor(parent?: IGrid);
    generateRows(data: {
        length: number;
    }, args?: Object): Row<Column>[];
    private getGroupedRecords(index, data, raw?);
    private getCaptionRowCells(field, indent, data);
    private generateCaptionRow(data, indent);
    private getForeignKeyData(row);
    private generateDataRows(data, indent);
    private generateIndentCell();
    refreshRows(input?: Row<Column>[]): Row<Column>[];
}
export interface GroupedData {
    GroupGuid?: string;
    items?: GroupedData;
    field?: string;
    isDataRow?: boolean;
    level?: number;
    key?: string;
    foreignKey?: string;
    count?: number;
}
export  type ScrollDirection = 'up' | 'down' | 'right' | 'left';
/**
 * InterSectionObserver - class watch whether it enters the viewport.
 * @hidden
 */
export  class InterSectionObserver {
    private containerRect;
    private element;
    private fromWheel;
    private touchMove;
    private options;
    private sentinelInfo;
    constructor(element: HTMLElement, options: InterSection);
    observe(callback: Function, onEnterCallback: Function): void;
    check(direction: ScrollDirection): boolean;
    private virtualScrollHandler(callback, onEnterCallback);
    setPageHeight(value: number): void;
}
/**
 * RendererFactory
 * @hidden
 */
export  class RendererFactory {
    rendererMap: {
        [c: string]: IRenderer;
    };
    addRenderer(name: RenderType, type: IRenderer): void;
    getRenderer(name: RenderType): IRenderer;
}
/**
 * RowModelGenerator is used to generate grid data rows.
 * @hidden
 */
export  class RowModelGenerator implements IModelGenerator<Column> {
    protected parent: IGrid;
    /**
     * Constructor for header renderer module
     */
    constructor(parent?: IGrid);
    generateRows(data: Object, args?: {
        startIndex?: number;
    }): Row<Column>[];
    protected ensureColumns(): Cell<Column>[];
    protected generateRow(data: Object, index: number, cssClass?: string, indent?: number): Row<Column>;
    protected refreshForeignKeyRow(options: IRow<Column>): void;
    protected generateCells(options: IRow<Column>): Cell<Column>[];
    protected generateCell(column: Column, rowId?: string, cellType?: CellType, colSpan?: number, oIndex?: number, foreignKeyData?: Object): Cell<Column>;
    refreshRows(input?: Row<Column>[]): Row<Column>[];
}
/**
 * ServiceLocator
 * @hidden
 */
export  class ServiceLocator {
    private services;
    register<T>(name: string, type: T): void;
    getService<T>(name: string): T;
}
/**
 * Summary row model generator
 * @hidden
 */
export  class SummaryModelGenerator implements IModelGenerator<AggregateColumnModel> {
    protected parent: IGrid;
    /**
     * Constructor for Summary row model generator
     */
    constructor(parent?: IGrid);
    getData(): Object;
    columnSelector(column: AggregateColumnModel): boolean;
    getColumns(start?: number, end?: number): Column[];
    generateRows(input: Object[] | data.Group, args?: Object, start?: number, end?: number): Row<AggregateColumnModel>[];
    getGeneratedRow(summaryRow: AggregateRowModel, data: Object, raw: number, start: number, end: number): Row<AggregateColumnModel>;
    getGeneratedCell(column: Column, summaryRow: AggregateRowModel, cellType?: CellType, indent?: string): Cell<AggregateColumnModel>;
    private buildSummaryData(data, args?);
    protected getIndentByLevel(data?: number): string[];
    protected setTemplate(column: AggregateColumn, data: Object[], single: Object | data.Group): Object;
    protected getCellType(): CellType;
}
export  class GroupSummaryModelGenerator extends SummaryModelGenerator implements IModelGenerator<AggregateColumnModel> {
    columnSelector(column: AggregateColumnModel): boolean;
    protected getIndentByLevel(level?: number): string[];
    protected getCellType(): CellType;
}
export  class CaptionSummaryModelGenerator extends SummaryModelGenerator implements IModelGenerator<AggregateColumnModel> {
    columnSelector(column: AggregateColumnModel): boolean;
    getData(): Object;
    isEmpty(): boolean;
    protected getCellType(): CellType;
}
/**
 * ValueFormatter class to globalize the value.
 * @hidden
 */
export  class ValueFormatter implements IValueFormatter {
    private intl;
    constructor(cultureName?: string);
    getFormatFunction(format: base.NumberFormatOptions | base.DateFormatOptions): Function;
    getParserFunction(format: base.NumberFormatOptions | base.DateFormatOptions): Function;
    fromView(value: string, format: Function, type?: string): string | number | Date;
    toView(value: number | Date, format: Function): string | Object;
    setCulture(cultureName: string): void;
}
/**
 * Content module is used to render grid content
 */
export  class VirtualRowModelGenerator implements IModelGenerator<Column> {
    private model;
    rowModelGenerator: IModelGenerator<Column>;
    parent: IGrid;
    cOffsets: {
        [x: number]: number;
    };
    cache: {
        [x: number]: Row<Column>[];
    };
    data: {
        [x: number]: Object[];
    };
    groups: {
        [x: number]: Object;
    };
    constructor(parent: IGrid);
    generateRows(data: Object[], notifyArgs?: NotifyArgs): Row<Column>[];
    getBlockIndexes(page: number): number[];
    getPage(block: number): number;
    isBlockAvailable(value: number): boolean;
    getData(): VirtualInfo;
    private getStartIndex(blk, data, full?);
    getColumnIndexes(content?: HTMLElement): number[];
    checkAndResetCache(action: string): boolean;
    refreshColOffsets(): void;
    updateGroupRow(current: Row<Column>[], block: number): Row<Column>[];
    private iterateGroup(current, rows);
    getRows(): Row<Column>[];
}
/**
 * ColumnWidthService
 * @hidden
 */
export  class ColumnWidthService {
    private parent;
    constructor(parent: IGrid);
    setWidthToColumns(): void;
    setColumnWidth(column: Column, index?: number, module?: string): void;
    private setWidth(width, index);
    getSiblingsHeight(element: HTMLElement): number;
    private getHeightFromDirection(element, direction);
    getWidth(column: Column): string | number;
    getTableWidth(columns: Column[]): number;
    private setWidthToFrozenTable();
    private setWidthToMovableTable();
    setWidthToTable(): void;
}
/**
 * Export Grid components
 */
/**
 * `ExternalMessage` module is used to display user provided message.
 */
export  class ExternalMessage implements IRender {
    private element;
    private pagerModule;
    /**
     * Constructor for externalMessage module
     * @param  {Pager} pagerModule?
     * @returns defaultType
     * @hidden
     */
    constructor(pagerModule?: Pager);
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    /**
     * The function is used to render pager externalMessage
     * @hidden
     */
    render(): void;
    /**
     * Refreshes the external message of Pager.
     */
    refresh(): void;
    /**
     * Hides the external message of Pager.
     */
    hideMessage(): void;
    /**
     * Shows the external message of the Pager.
     */
    showMessage(): void;
    /**
     * To destroy the PagerMessage
     * @method destroy
     * @return {void}
     * @hidden
     */
    destroy(): void;
}
/**
 * Pager component exported items
 */
/**
 * `NumericContainer` module handles rendering and refreshing numeric container.
 */
export  class NumericContainer implements IRender {
    private element;
    private first;
    private prev;
    private PP;
    private NP;
    private next;
    private last;
    private links;
    private pagerElement;
    private pagerModule;
    /**
     * Constructor for numericContainer module
     * @hidden
     */
    constructor(pagerModule?: Pager);
    /**
     * The function is used to render numericContainer
     * @hidden
     */
    render(): void;
    /**
     * Refreshes the numeric container of Pager.
     */
    refresh(): void;
    /**
     * The function is used to refresh refreshNumericLinks
     * @hidden
     */
    refreshNumericLinks(): void;
    /**
     * Binding events to the element while component creation
     * @hidden
     */
    wireEvents(): void;
    /**
     * Unbinding events from the element while component destroy
     * @hidden
     */
    unwireEvents(): void;
    /**
     * To destroy the PagerMessage
     * @method destroy
     * @return {void}
     * @hidden
     */
    destroy(): void;
    private renderNumericContainer();
    private renderFirstNPrev(pagerContainer);
    private renderPrevPagerSet(pagerContainer);
    private renderNextPagerSet(pagerContainer);
    private renderNextNLast(pagerContainer);
    private clickHandler(e);
    private updateLinksHtml();
    private updateStyles();
    private updateFirstNPrevStyles();
    private updatePrevPagerSetStyles();
    private updateNextPagerSetStyles();
    private updateNextNLastStyles();
}
/**
 * `PagerDropDown` module handles selected pageSize from DropDownList.
 */
export  class PagerDropDown {
    private pagerCons;
    private dropDownListObject;
    private pagerDropDownDiv;
    private pagerModule;
    /**
     * Constructor for pager module
     * @hidden
     */
    constructor(pagerModule?: Pager);
    /**
     * For internal use only - Get the module name.
     * @private
     * @hidden
     */
    protected getModuleName(): string;
    /**
     * The function is used to render pager dropdown
     * @hidden
     */
    render(): void;
    /**
     * For internal use only - Get the pagesize.
     * @private
     * @hidden
     */
    private onChange(e);
    /**
     * To destroy the Pagerdropdown
     * @method destroy
     * @return {void}
     * @hidden
     */
    destroy(args?: {
        requestType: string;
    }): void;
}
/**
 * `PagerMessage` module is used to display pager information.
 */
export  class PagerMessage implements IRender {
    private pageNoMsgElem;
    private pageCountMsgElem;
    private pagerModule;
    /**
     * Constructor for externalMessage module
     * @hidden
     */
    constructor(pagerModule?: Pager);
    /**
     * The function is used to render pager message
     * @hidden
     */
    render(): void;
    /**
     * Refreshes the pager information.
     */
    refresh(): void;
    /**
     * Hides the Pager information.
     */
    hideMessage(): void;
    /**
     * Shows the Pager information.
     */
    showMessage(): void;
    /**
     * To destroy the PagerMessage
     * @method destroy
     * @return {void}
     * @hidden
     */
    destroy(): void;
    private format(str, args);
}
/**
 * Interface for a class Pager
 */
export interface PagerModel extends base.ComponentModel{
    /**
     * If `enableQueryString` set to true,   
     * then it pass current page information as a query string along with the URL while navigating to other page.  
     * @default false  
     */
    enableQueryString?: boolean;
    /**
     * If `enableExternalMessage` set to true, then it adds the message to Pager.  
     * @default false  
     */
    enableExternalMessage?: boolean;
    /**
     * If `enablePagerMessage` set to true, then it adds the pager information.  
     * @default true  
     */
    enablePagerMessage?: boolean;
    /**
     * Defines the records count of visible page.  
     * @default 12  
     */
    pageSize?: number;
    /**
     * Defines the number of pages to display in pager container.   
     * @default 10  
     */
    pageCount?: number;
    /**
     * Defines the current page number of pager.   
     * @default 1  
     */
    currentPage?: number;
    /**
     * Gets or Sets the total records count which is used to render numeric container.   
     * @default null  
     */
    totalRecordsCount?: number;
    /**
     * Defines the external message of Pager.  
     * @default null  
     */
    externalMessage?: string;
    /**
     * If `pageSizes` set to true or Array of values,
     * It renders DropDownList in the pager which allow us to select pageSize from DropDownList.    
     * @default false    
     */
    pageSizes?: boolean | number[];
    /**
     *  Defines the template as string or HTML element ID which renders customized elements in pager instead of default elements.    
     * @default null    
     */
    template?: string;
    /**
     * Defines the customized text to append with numeric items.  
     * @default null  
     */
    customText?: string;
    /**
     * Triggers when click on the numeric items.   
     * @default null  
     */
    click?: base.EmitType<Object>;
    /**
     * Triggers after pageSize is selected in DropDownList.   
     * @default null  
     */
    dropDownChanged?: base.EmitType<Object>;
    /**
     * Triggers when Pager is created.   
     * @default null  
     */
    created?: base.EmitType<Object>;
}
/** @hidden */
export interface IRender {
    render(): void;
    refresh(): void;
}
/**
 * Represents the `Pager` component.
 * ```html
 * <div id="pager"/>
 * ```
 * ```typescript
 * <script>
 *   var pagerObj = new Pager({ totalRecordsCount: 50, pageSize:10 });
 *   pagerObj.appendTo("#pager");
 * </script>
 * ```
 */
export  class Pager extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /*** @hidden */
    totalPages: number;
    private templateFn;
    /*** @hidden */
    previousPageNo: number;
    private defaultConstants;
    /*** @hidden */
    localeObj: base.L10n;
    /**
     * `containerModule` is used to manipulate numeric container behavior of Pager.
     */
    containerModule: NumericContainer;
    /**
     * `pagerMessageModule` is used to manipulate pager message of Pager.
     */
    pagerMessageModule: PagerMessage;
    /**
     * `externalMessageModule` is used to manipulate external message of Pager.
     */
    externalMessageModule: ExternalMessage;
    /**
     * `pagerdropdownModule` is used to manipulate pageSizes of Pager.
     *  @hidden
     */
    pagerdropdownModule: PagerDropDown;
    /**
     * If `enableQueryString` set to true,
     * then it pass current page information as a query string along with the URL while navigating to other page.
     * @default false
     */
    enableQueryString: boolean;
    /**
     * If `enableExternalMessage` set to true, then it adds the message to Pager.
     * @default false
     */
    enableExternalMessage: boolean;
    /**
     * If `enablePagerMessage` set to true, then it adds the pager information.
     * @default true
     */
    enablePagerMessage: boolean;
    /**
     * Defines the records count of visible page.
     * @default 12
     */
    pageSize: number;
    /**
     * Defines the number of pages to display in pager container.
     * @default 10
     */
    pageCount: number;
    /**
     * Defines the current page number of pager.
     * @default 1
     */
    currentPage: number;
    /**
     * Gets or Sets the total records count which is used to render numeric container.
     * @default null
     */
    totalRecordsCount: number;
    /**
     * Defines the external message of Pager.
     * @default null
     */
    externalMessage: string;
    /**
     * If `pageSizes` set to true or Array of values,
     * It renders DropDownList in the pager which allow us to select pageSize from DropDownList.
     * @default false
     */
    pageSizes: boolean | number[];
    /**
     *  Defines the template as string or HTML element ID which renders customized elements in pager instead of default elements.
     * @default null
     */
    template: string;
    /**
     * Defines the customized text to append with numeric items.
     * @default null
     */
    customText: string;
    /**
     * Triggers when click on the numeric items.
     * @default null
     */
    click: base.EmitType<Object>;
    /**
     * Triggers after pageSize is selected in DropDownList.
     * @default null
     */
    dropDownChanged: base.EmitType<Object>;
    /**
     * Triggers when Pager is created.
     * @default null
     */
    created: base.EmitType<Object>;
    /**
     * Constructor for creating the component.
     * @hidden
     */
    constructor(options?: PagerModel, element?: string | HTMLElement);
    /**
     * To provide the array of modules needed for component rendering
     * @hidden
     */
    protected requiredModules(): base.ModuleDeclaration[];
    /**
     * Initialize the event handler
     * @hidden
     */
    protected preRender(): void;
    /**
     * To Initialize the component rendering
     */
    protected render(): void;
    /**
     * Get the properties to be maintained in the persisted state.
     * @hidden
     */
    getPersistData(): string;
    /**
     * To destroy the Pager component.
     * @method destroy
     * @return {void}
     */
    destroy(): void;
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    /**
     * Called internally if any of the property value changed.
     * @hidden
     */
    onPropertyChanged(newProp: PagerModel, oldProp: PagerModel): void;
    /**
     * Gets the localized label by locale keyword.
     * @param  {string} key
     * @return {string}
     */
    getLocalizedLabel(key: string): string;
    /**
     * Navigate to target page by given number.
     * @param  {number} pageNo - Defines page number.
     * @return {void}
     */
    goToPage(pageNo: number): void;
    private checkpagesizes();
    private checkGoToPage(newPageNo, oldPageNo?);
    private currentPageChanged();
    private pagerTemplate();
    /** @hidden */
    updateTotalPages(): void;
    /** @hidden */
    getPagerTemplate(): Function;
    private compile(template);
    /**
     * Refreshes page count, pager information and external message.
     * @return {void}
     */
    refresh(): void;
    private updateRTL();
    private initLocalization();
    private updateQueryString(value);
    private getUpdatedURL(uri, key, value);
    private renderFirstPrevDivForDevice();
    private renderNextLastDivForDevice();
    private addAriaLabel();
}
 }
export namespace heatmap { 

/**
 * Export heat map
 */
/**
 * HeatMap Axis-Helper file
 */
export  class AxisHelper {
    private heatMap;
    private initialClipRect;
    private htmlObject;
    private element;
    private padding;
    private drawSvgCanvas;
    constructor(heatMap?: HeatMap);
    renderAxes(): void;
    private drawXAxisLine(parent, axis);
    private drawYAxisLine(parent, axis);
    private drawXAxisTitle(axis, parent, rect);
    private drawYAxisTitle(axis, parent, rect);
    /**
     * Get the visible labels for both x and y axis
     * @private
     */
    calculateVisibleLabels(): void;
    /**
     * Measure the title and labels rendering position for both X and Y axis.
     * @param rect
     */
    measureAxis(rect: Rect): void;
    /**
     * Calculate the X and Y axis line position
     * @param rect
     * @private
     */
    calculateAxisSize(rect: Rect): void;
    private drawXAxisLabels(axis, parent, rect);
    private drawYAxisLabels(axis, parent, rect);
}
/**
 * Interface for a class Axis
 */
export interface AxisModel {
    /**
     * base.Title of heat map axis
     * @default ''
     */
    title?: TitleModel;
    /**
     * If set to true, the axis will render at the opposite side of its default position.
     * @default false
     */
    opposedPosition?: boolean;
    /**
     * Options for label assignment.
     */
    labels?: string[];
    /**
     * Options for customizing the label text.
     */
    textStyle?: FontModel;
    /**
     * The angle to rotate the axis label
     * @default 0
     */
    labelRotation?: number;
    /**
     * It specifies whether the axis to be rendered in inversed manner or not.
     * @default false
     */
    isInversed?: boolean;
    /**
     * Specifies the type of data the axis is handling.
     * * Numeric:  Renders a numeric axis.
     * * DateTime: Renders a dateTime axis.
     * * Category: Renders a category axis.
     * @default 'Category'
     */
    valueType?: ValueType;
    /**
     * Specifies the minimum range of an axis.
     * @default null
     */
    minimum?: Object;
    /**
     * Specifies the maximum range of an axis.
     * @default null
     */
    maximum?: Object;
    /**
     * Specifies the interval for an axis.
     * @default null
     */
    interval?: number;
    /**
     * Used to format the axis label that accepts any global string format like 'C', 'n1', 'P' etc.
     * It also accepts placeholder like '{value}°C' in which value represent the axis label, e.g, 20°C.
     * @default ''
     */
    labelFormat?: string;
    /**
     * Specifies the types like `Years`, `Months`, `Days`, `Hours`, `Minutes` in date time axis.They are,
     * * Years: Defines the interval of the axis in years.
     * * Months: Defines the interval of the axis in months.
     * * Days: Defines the interval of the axis in days.
     * * Hours: Defines the interval of the axis in hours.
     * * Minutes: Defines the interval of the axis in minutes.
     * @default 'Days'
     */
    intervalType?: IntervalType;
    /**
     * Specifies the actions like `Rotate45`, `None` and `Trim` when the axis labels intersect with each other.They are,
     * * None: Shows all the labels.
     * * Rotate45: Rotates the label to 45 degree when it intersects.
     * * Trim : Trim the label when label text width exceed the label width
     * @default Trim
     */
    labelIntersectAction?: LabelIntersectAction;
}
/**
 * HeatMap Axis file
 */
export  class Axis extends base.ChildProperty<Axis> {
    /**
     * Title of heat map axis
     * @default ''
     */
    title: TitleModel;
    /**
     * If set to true, the axis will render at the opposite side of its default position.
     * @default false
     */
    opposedPosition: boolean;
    /**
     * Options for label assignment.
     */
    labels: string[];
    /**
     * Options for customizing the label text.
     */
    textStyle: FontModel;
    /**
     * The angle to rotate the axis label
     * @default 0
     */
    labelRotation: number;
    /**
     * It specifies whether the axis to be rendered in inversed manner or not.
     * @default false
     */
    isInversed: boolean;
    /**
     * Specifies the type of data the axis is handling.
     * * Numeric:  Renders a numeric axis.
     * * DateTime: Renders a dateTime axis.
     * * Category: Renders a category axis.
     * @default 'Category'
     */
    valueType: ValueType;
    /**
     * Specifies the minimum range of an axis.
     * @default null
     */
    minimum: Object;
    /**
     * Specifies the maximum range of an axis.
     * @default null
     */
    maximum: Object;
    /**
     * Specifies the interval for an axis.
     * @default null
     */
    interval: number;
    /**
     * Used to format the axis label that accepts any global string format like 'C', 'n1', 'P' etc.
     * It also accepts placeholder like '{value}°C' in which value represent the axis label, e.g, 20°C.
     * @default ''
     */
    labelFormat: string;
    /**
     * Specifies the types like `Years`, `Months`, `Days`, `Hours`, `Minutes` in date time axis.They are,
     * * Years: Defines the interval of the axis in years.
     * * Months: Defines the interval of the axis in months.
     * * Days: Defines the interval of the axis in days.
     * * Hours: Defines the interval of the axis in hours.
     * * Minutes: Defines the interval of the axis in minutes.
     * @default 'Days'
     */
    intervalType: IntervalType;
    /**
     * Specifies the actions like `Rotate45`, `None` and `Trim` when the axis labels intersect with each other.They are,
     * * None: Shows all the labels.
     * * Rotate45: Rotates the label to 45 degree when it intersects.
     * * Trim : Trim the label when label text width exceed the label width
     * @default Trim
     */
    labelIntersectAction: LabelIntersectAction;
    /** @private */
    orientation: Orientation;
    /** @private */
    rect: Rect;
    /** @private */
    nearSizes: number[];
    /** @private */
    farSizes: number[];
    /** @private */
    maxLabelSize: Size;
    /** @private */
    titleSize: Size;
    /** @private */
    axisLabels: string[];
    /** @private */
    tooltipLabels: string[];
    /** @private */
    labelValue: (string | number | Date)[];
    /** @private */
    axisLabelSize: number;
    /** @private */
    axisLabelInterval: number;
    /** @private */
    maxLength: number;
    /** @private */
    min: number;
    /** @private */
    max: number;
    /** @private */
    format: Function;
    /** @private */
    angle: number;
    /**
     * measure the axis title and label size
     * @param axis
     * @param heatmap
     * @private
     */
    computeSize(axis: Axis, heatmap: HeatMap): void;
    private getTitleSize(axis, innerPadding);
    private getMaxLabelSize(axis, heatmap);
    /**
     * Generate the axis lables for numeric axis
     * @param heatmap
     * @private
     */
    calculateNumericAxisLabels(heatmap: HeatMap): void;
    /**
     * Generate the axis lables for category axis
     * @private
     */
    calculateCategoryAxisLabels(): void;
    /**
     * Generate the axis labels for date time axis.
     * @param heatmap
     * @private
     */
    calculateDateTimeAxisLabel(heatmap: HeatMap): void;
    getSkeleton(): string;
    /**
     * Formatted the axis label.
     * @private
     */
    protected formatValue(isCustom: boolean, format: string, tempInterval: number): string;
    /** @private */
    getTotalLabelLength(min: number, max: number): number;
}
/**
 * Interface for a class Data
 */
export interface DataModel {
    /**
     * Property to provide Datasource.
     * @default null
     */
    data?: Object;
    /**
     * Specifies the provided datasource is an JSON data. 
     * @default false
     */
    isJsonData?: boolean;
    /**
     * specifies Adaptor type
     * @default cell
     */
    adaptorType?: AdaptorType;
    /**
     * Specifies xAxis mapping. 
     * @default ''
     */
    xDataMapping?: string;
    /**
     * Specifies yAxis mapping. 
     * @default ''
     */
    yDataMapping?: string;
    /**
     * Specifies value mapping. 
     * @default ''
     */
    valueMapping?: string;
}
/**
 * Interface for a class AdaptiveMinMax
 */
export interface AdaptiveMinMaxModel {
}
/**
 * Interface for a class Adaptor
 */
export interface AdaptorModel {
}
/**
 * HeatMap Adaptor file
 */
/**
 * Configures the Adaptor Property in the Heatmap.
 */
export  class Data extends base.ChildProperty<Data> {
    /**
     * Property to provide Datasource.
     * @default null
     */
    data: Object;
    /**
     * Specifies the provided datasource is an JSON data.
     * @default false
     */
    isJsonData: boolean;
    /**
     * specifies Adaptor type
     * @default cell
     */
    adaptorType: AdaptorType;
    /**
     * Specifies xAxis mapping.
     * @default ''
     */
    xDataMapping: string;
    /**
     * Specifies yAxis mapping.
     * @default ''
     */
    yDataMapping: string;
    /**
     * Specifies value mapping.
     * @default ''
     */
    valueMapping: string;
}
export  class AdaptiveMinMax {
    min: Object;
    max: Object;
}
export  class Adaptor {
    private heatMap;
    reconstructData: Object[][];
    reconstructedXAxis: string[];
    reconstructedYAxis: string[];
    adaptiveXMinMax: AdaptiveMinMax;
    adaptiveYMinMax: AdaptiveMinMax;
    constructor(heatMap?: HeatMap);
    /**
     * Method to construct Two Dimentional Datasource.
     * @return {void}
     * @private
     */
    constructDatasource(adaptData: DataModel): void;
    /**
     * Method to construct Axis Collection.
     * @return {void}
     * @private
     */
    private constructAdaptiveAxis();
    /**
     * Method to calculate Numeric Axis Collection.
     * @return {string[]}
     * @private
     */
    private getNumericAxisCollection(min, max);
    /**
     * Method to calculate DateTime Axis Collection.
     * @return {string[]}
     * @private
     */
    private getDateAxisCollection(min, max, intervalType);
    /**
     * Method to calculate Maximum and Minimum Value from datasource.
     * @return {void}
     * @private
     */
    private getMinMaxValue(data, xAxis, yAxis);
    /**
     * Method to process Cell datasource.
     * @return {Object}
     * @private
     */
    private processCellData(adaptordata);
    /**
     * Method to process JSON Cell datasource.
     * @return {Object}
     * @private
     */
    private processJsonCellData(adaptordata);
    /**
     * Method to process JSON Table datasource.
     * @return {Object}
     * @private
     */
    private processJsonTableData(adaptordata);
    /**
     * To destroy the Adaptor.
     * @return {void}
     * @private
     */
    destroy(heatMap: HeatMap): void;
    /**
     * To get Module name
     *  @private
     */
    getModuleName(): string;
}
/**
 * HeatMap TwoDimensional file
 */
export  class TwoDimensional {
    private heatMap;
    private completeDataSource;
    constructor(heatMap?: HeatMap);
    /**
     * To reconstruct proper two dimensional dataSource depends on min and max values.
     *  @private
     */
    processDataSource(dataSource: Object): void;
    /**
     * To get minimum value
     *  @private
     */
    private checkmin(val);
}
/**
 * Interface for a class HeatMap
 */
export interface HeatMapModel extends base.ComponentModel{
    /**
     * The width of the heatmap as a string accepts input as both like '100px' or '100%'.
     * If specified as '100%, heatmap renders to the full width of its parent element.
     * @default null
     */
    width?: string;
    /**
     * The height of the heatmap as a string accepts input as both like '100px' or '100%'.
     * If specified as '100%, heatmap renders to the full height of its parent element.
     * @default null
     */
    height?: string;
    /**
     * Enable or disable the tool tip for heatmap
     * @default true
     */
    showTooltip?: boolean;
    /**
     * Triggers when click the heat map cell.
     * @event
     */
    tooltipRender?: base.EmitType<ITooltipEventArgs>;
    /**
     * Specifies the rendering mode of heat map.
     * @default SVG
     */
    renderingMode?: DrawType;
    /**
     * Specifies the datasource for the heat map.
     * @default null
     */
    dataSource?: Object | DataModel;
    /**
     *  Specifies the theme for heatmap.
     * @default 'Material'
     */
    theme?: HeatMapTheme;
    /**
     * Options to customize left, right, top and bottom margins of the heat map.
     */
    margin?: MarginModel;
    /**
     * base.Title of heat map
     * @default ''
     */
    titleSettings?: TitleModel;
    /**
     * Options to configure the horizontal axis.
     */
    xAxis?: AxisModel;
    /**
     * Options for customizing the legend of the heat map
     * @default ''
     */
    legendSettings?: LegendSettingsModel;
    /**
     * Options for customizing the cell color of the heat map
     */
    paletteSettings?: PaletteSettingsModel;
    /**
     * Options to configure the vertical axis.
     */
    yAxis?: AxisModel;
    /**
     * Options to customize the heat map cell
     */
    cellSettings?: CellSettingsModel;
    /**
     * Triggers after heat map rendered.
     * @event
     */
    created?: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers before heat map load.
     * @event
     */
    load?: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers when click the heat map cell.
     * @event
     */
    cellClick?: base.EmitType<ICellClickEventArgs>;
}
/**
 * Heat Map base.Component
 */
export  class HeatMap extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /**
     * The width of the heatmap as a string accepts input as both like '100px' or '100%'.
     * If specified as '100%, heatmap renders to the full width of its parent element.
     * @default null
     */
    width: string;
    /**
     * The height of the heatmap as a string accepts input as both like '100px' or '100%'.
     * If specified as '100%, heatmap renders to the full height of its parent element.
     * @default null
     */
    height: string;
    /**
     * Enable or disable the tool tip for heatmap
     * @default true
     */
    showTooltip: boolean;
    /**
     * Triggers when click the heat map cell.
     * @event
     */
    tooltipRender: base.EmitType<ITooltipEventArgs>;
    /**
     * Specifies the rendering mode of heat map.
     * @default SVG
     */
    renderingMode: DrawType;
    /**
     * Specifies the datasource for the heat map.
     * @default null
     */
    dataSource: Object | DataModel;
    /**
     *  Specifies the theme for heatmap.
     * @default 'Material'
     */
    theme: HeatMapTheme;
    /**
     * Options to customize left, right, top and bottom margins of the heat map.
     */
    margin: MarginModel;
    /**
     * Title of heat map
     * @default ''
     */
    titleSettings: TitleModel;
    /**
     * Options to configure the horizontal axis.
     */
    xAxis: AxisModel;
    /**
     * Options for customizing the legend of the heat map
     * @default ''
     */
    legendSettings: LegendSettingsModel;
    /**
     * Options for customizing the cell color of the heat map
     */
    paletteSettings: PaletteSettingsModel;
    /**
     * Options to configure the vertical axis.
     */
    yAxis: AxisModel;
    /**
     * Options to customize the heat map cell
     */
    cellSettings: CellSettingsModel;
    /**
     * Triggers after heat map rendered.
     * @event
     */
    created: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers before heat map load.
     * @event
     */
    load: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers when click the heat map cell.
     * @event
     */
    cellClick: base.EmitType<ICellClickEventArgs>;
    /** @private */
    enableCanvasRendering: boolean;
    /** @private */
    renderer: base.SvgRenderer;
    /** @private */
    canvasRenderer: base.CanvasRenderer;
    /** @private */
    svgObject: Element;
    /** @private */
    availableSize: Size;
    /** @private */
    private elementSize;
    /** @private */
    themeStyle: IThemeStyle;
    /** @private */
    initialClipRect: Rect;
    heatMapAxis: AxisHelper;
    heatMapSeries: Series;
    private drawSvgCanvas;
    private twoDimensional;
    private cellColor;
    /** @private */
    colorCollection: ColorCollection[];
    /** @private */
    legendColorCollection: LegendColorCollection[];
    /** @private */
    tempRectHoverClass: string;
    /** @private */
    tempTooltipRectId: string;
    /** @private */
    clonedDataSource: any[];
    /** @private */
    completeAdaptDataSource: Object;
    /** @private */
    xLength: number;
    /** @private */
    yLength: number;
    /** @private */
    dataSourceMinValue: number;
    /** @private */
    dataSourceMaxValue: number;
    /** @private */
    tooltipTimer: number;
    /** @private */
    gradientTimer: number;
    /** @private */
    resizeTimer: number;
    /** @private */
    emptyPointColor: string;
    /** @private */
    horizontalGradient: boolean;
    /**
     * @private
     */
    tooltipCollection: CanvasTooltip[];
    /**
     * @private
     */
    isTouch: boolean;
    /**
     * @private
     */
    private border;
    /**
     * Gets the axis of the HeatMap.
     * @hidden
     */
    axisCollections: Axis[];
    /**
     * @private
     */
    intl: base.Internationalization;
    /**
     * @private
     */
    isCellData: boolean;
    private titleCollection;
    /**
     * @private
     */
    mouseX: number;
    /**
     * @private
     */
    mouseY: number;
    /**
     * The `legendModule` is used to display the legend.
     */
    legendModule: Legend;
    /**
     * The `tooltipModule` is used to manipulate Tooltip item from base of heatmap.
     */
    tooltipModule: Tooltip;
    /**
     * The `adaptorModule` is used to manipulate Adaptor item from base of heatmap.
     */
    adaptorModule: Adaptor;
    protected preRender(): void;
    private initPrivateVariable();
    /**
     * Method to set culture for heatmap
     */
    private setCulture();
    protected render(): void;
    /**
     * To re-calculate the datasource while changing datasource property dynamically.
     * @private
     */
    private reRenderDatasource();
    /**
     * To process datasource property.
     * @private
     */
    private processInitData();
    /**
     * To set render mode of heatmap as SVG or Canvas.
     * @private
     */
    private setRenderMode();
    private renderElements();
    /**
     * Get component name
     */
    getModuleName(): string;
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    getPersistData(): string;
    onPropertyChanged(newProp: HeatMapModel, oldProp: HeatMapModel): void;
    private createSvg();
    /**
     *  To Remove the SVG.
     */
    removeSvg(): void;
    private renderSecondaryElement();
    /**
     * To provide the array of modules needed for control rendering
     * @return{base.ModuleDeclaration[]}
     * @private
     */
    requiredModules(): base.ModuleDeclaration[];
    /**
     * To destroy the widget
     * @method destroy
     * @return {void}.
     * @member of Heatmap
     */
    destroy(): void;
    private renderBorder();
    private calculateSize();
    private renderTitle();
    private titleTooltip(event, x, y, isTouch?);
    private axisTooltip(event, x, y, isTouch?);
    private isHeatmapRect(x, y);
    private setTheme();
    private calculateBounds();
    private refreshBound();
    private initAxis();
    /**
     * Method to bind events for HeatMap
     */
    private wireEvents();
    /**
     * Applying styles for heatmap element
     */
    private setStyle(element);
    /**
     * Method to unbind events for HeatMap
     */
    private unWireEvents();
    /**
     * Handles the heatmap resize.
     * @return {boolean}
     * @private
     */
    heatMapResize(e: Event): boolean;
    /**
     * Get the maximum length of data source for both horizontal and vertical
     * @private
     */
    private calculateMaxLength();
    /**
     * To find mouse x, y for aligned heatmap element svg position
     */
    private setMouseXY(pageX, pageY);
    heatMapMouseClick(e: PointerEvent): boolean;
    /**
     * Handles the mouse Move.
     * @return {boolean}
     * @private
     */
    heatMapMouseMove(e: PointerEvent): boolean;
    /**
     * Handles the mouse end.
     * @return {boolean}
     * @private
     */
    heatMapMouseLeave(e: PointerEvent): boolean;
}
/**
 * Heatmap component exported items
 */
/**
 * Interface for a class LegendSettings
 */
export interface LegendSettingsModel {
    /**
     * Specifies the height of Legend.
     * @default ''
     */
    height?: string;
    /**
     * Specifies the width of Legend.
     * @default ''
     */
    width?: string;
    /**
     * Specifies the position of Legend to render.
     * @default 'Right'
     */
    position?: LegendPosition;
    /**
     * Specifies whether the Legend should be visible or not.
     * @default true
     */
    visible?: boolean;
    /**
     * Specifies the alignment of the legend
     * @default 'Center'
     */
    alignment?: Alignment;
    /**
     * Specifies whether the label should be visible or not.
     * @default true
     */
    showLabel?: boolean;
    /**
     * Specifies whether the gradient pointer should be visible or not.
     * @default true
     */
    showGradientPointer?: boolean;
    /**
     * Specifies the legend label style. 
     * @default ''
     */
    textStyle?: FontModel;
}
/**
 * Interface for a class Legend
 */
export interface LegendModel {
}
/**
 * Configures the Legend
 */
export  class LegendSettings extends base.ChildProperty<LegendSettings> {
    /**
     * Specifies the height of Legend.
     * @default ''
     */
    height: string;
    /**
     * Specifies the width of Legend.
     * @default ''
     */
    width: string;
    /**
     * Specifies the position of Legend to render.
     * @default 'Right'
     */
    position: LegendPosition;
    /**
     * Specifies whether the Legend should be visible or not.
     * @default true
     */
    visible: boolean;
    /**
     * Specifies the alignment of the legend
     * @default 'Center'
     */
    alignment: Alignment;
    /**
     * Specifies whether the label should be visible or not.
     * @default true
     */
    showLabel: boolean;
    /**
     * Specifies whether the gradient pointer should be visible or not.
     * @default true
     */
    showGradientPointer: boolean;
    /**
     * Specifies the legend label style.
     * @default ''
     */
    textStyle: FontModel;
}
export  class Legend {
    private heatMap;
    private drawSvgCanvas;
    private legend;
    private legendGroup;
    legendRectScale: Rect;
    maxLegendLabelSize: Size;
    gradientPointer: HTMLElement;
    private legendHeight;
    private legendWidth;
    private height;
    private width;
    private legendRectPadding;
    private gradientScaleSize;
    private positionCollections;
    labelCollections: string[];
    private legendMinValue;
    private legendMaxValue;
    private legendSize;
    previousOptions: GradientPointer;
    listPerPage: number;
    private numberOfPages;
    private listHeight;
    private listWidth;
    private legendScale;
    fillRect: Rect;
    private legendRect;
    currentPage: number;
    private lastList;
    navigationCollections: Rect[];
    private pagingRect;
    private labelPadding;
    private paginggroup;
    private translategroup;
    private listInterval;
    legendLabelTooltip: CanvasTooltip[];
    private numberOfRows;
    private labelXCollections;
    private labelYCollections;
    private legendXCollections;
    private legendYCollections;
    constructor(heatMap?: HeatMap);
    /**
     * Get component name
     */
    private getModuleName();
    /**
     * To destroy the Legend.
     * @return {void}
     * @private
     */
    destroy(heatMap: HeatMap): void;
    /**
     * @private
     */
    renderLegendItems(heatMap: HeatMap): void;
    private renderLegendLabel(heatMap, rect);
    /**
     * @private
     */
    renderGradientPointer(e: PointerEvent, pageX: number, pageY: number): void;
    /**
     * @private
     */
    removeGradientPointer(heatMap: HeatMap): void;
    /**
     * @private
     */
    calculateLegendBounds(rect: Rect): void;
    private calculateListLegendBounds(rect);
    private getMaxLabelSize(heatMap);
    /**
     * @private
     */
    calculateLegendSize(rect: Rect, legendTop: number): void;
    private measureListLegendBound(rect);
    private renderPagingElements(heatMap);
    private calculateGradientScale(scale);
    private calculateColorAxisGrid(legendRect);
    private renderColorAxisGrid(legendRect);
    /**
     * @private
     */
    renderLegendLabelTooltip(e: PointerEvent): void;
    private calculateListPerPage(rect, heatMap);
    private renderListLegendMode(rect);
    /**
     * @private
     */
    translatePage(heatMap: HeatMap, page: number, isNext: boolean): void;
}
/**
 * Interface for a class Font
 */
export interface FontModel {
    /**
     * Font size for the text.
     * @default '16px'
     */
    size?: string;
    /**
     * Color for the text.
     * @default ''
     */
    color?: string;
    /**
     * FontFamily for the text.
     */
    fontFamily?: string;
    /**
     * FontWeight for the text.
     * @default 'Normal'
     */
    fontWeight?: string;
    /**
     * FontStyle for the text.
     * @default 'Normal'
     */
    fontStyle?: string;
    /**
     * text alignment
     * @default 'Center'
     */
    textAlignment?: Alignment;
    /**
     * Specifies the heat map text overflow
     * @default 'Trim'
     */
    textOverflow?: TextOverflow;
}
/**
 * Interface for a class Margin
 */
export interface MarginModel {
    /**
     * Left margin in pixels.
     * @default 10
     */
    left?: number;
    /**
     * Right margin in pixels.
     * @default 10
     */
    right?: number;
    /**
     * Top margin in pixels.
     * @default 10
     */
    top?: number;
    /**
     * Bottom margin in pixels.
     * @default 10
     */
    bottom?: number;
}
/**
 * Interface for a class Border
 */
export interface BorderModel {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default ''
     */
    color?: string;
    /**
     * The width of the border in pixels.
     * @default 1
     */
    width?: number;
    /**
     * The radius of the border in pixels.
     * @default ''
     */
    radius?: number;
}
/**
 * Interface for a class Title
 */
export interface TitleModel {
    /**
     * Title text
     * @default ''
     */
    text?: string;
    /**
     * Options for customizing the title.
     */
    textStyle?: FontModel;
}
/**
 * Interface for a class PaletteCollection
 */
export interface PaletteCollectionModel {
    /**
     * Palette color value
     * @default null
     */
    value?: number;
    /**
     * Palette color text
     * @default ''
     */
    color?: string;
    /**
     * Palette color label
     * @default ''
     */
    label?: string;
}
/**
 * Interface for a class ColorCollection
 */
export interface ColorCollectionModel {
}
/**
 * Interface for a class LegendColorCollection
 */
export interface LegendColorCollectionModel {
}
/**
 * Configures the fonts in heat map.
 */
export  class Font extends base.ChildProperty<Font> {
    /**
     * Font size for the text.
     * @default '16px'
     */
    size: string;
    /**
     * Color for the text.
     * @default ''
     */
    color: string;
    /**
     * FontFamily for the text.
     */
    fontFamily: string;
    /**
     * FontWeight for the text.
     * @default 'Normal'
     */
    fontWeight: string;
    /**
     * FontStyle for the text.
     * @default 'Normal'
     */
    fontStyle: string;
    /**
     * text alignment
     * @default 'Center'
     */
    textAlignment: Alignment;
    /**
     * Specifies the heat map text overflow
     * @default 'Trim'
     */
    textOverflow: TextOverflow;
}
/**
 * Configures the heat map margins.
 */
export  class Margin extends base.ChildProperty<Margin> {
    /**
     * Left margin in pixels.
     * @default 10
     */
    left: number;
    /**
     * Right margin in pixels.
     * @default 10
     */
    right: number;
    /**
     * Top margin in pixels.
     * @default 10
     */
    top: number;
    /**
     * Bottom margin in pixels.
     * @default 10
     */
    bottom: number;
}
/**
 * Configures the borders in the heat map.
 */
export  class Border extends base.ChildProperty<Border> {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default ''
     */
    color: string;
    /**
     * The width of the border in pixels.
     * @default 1
     */
    width: number;
    /**
     * The radius of the border in pixels.
     * @default ''
     */
    radius: number;
}
/**
 * class used to maintain Title styles.
 */
export  class Title extends base.ChildProperty<Title> {
    /**
     * Title text
     * @default ''
     */
    text: string;
    /**
     * Options for customizing the title.
     */
    textStyle: FontModel;
}
/**
 * class used to maintain palette information.
 */
export  class PaletteCollection extends base.ChildProperty<PaletteCollection> {
    /**
     * Palette color value
     * @default null
     */
    value: number;
    /**
     * Palette color text
     * @default ''
     */
    color: string;
    /**
     * Palette color label
     * @default ''
     */
    label: string;
}
/**
 * Internal class used to maintain colorcollection.
 */
export  class ColorCollection {
    value: number;
    color: string;
    constructor(value: number, color: string);
}
/**
 * Internal class used to maintain legend colorcollection.
 */
export  class LegendColorCollection {
    value: number;
    color: string;
    label: string;
    isHidden: boolean;
    constructor(value: number, color: string, label: string, isHidden: boolean);
}
/** @private */
export interface IFontMapping {
    size?: string;
    color?: string;
    fontWeight?: string;
    fontStyle?: string;
    fontFamily?: string;
    textOverflow?: TextOverflow;
}
/**
 * Specifies the Theme style for heat map
 */
export interface IThemeStyle {
    heatMapTitle: string;
    axisTitle: string;
    axisLabel: string;
    legendLabel: string;
    background: string;
    cellBorder: string;
    cellTextColor: string;
    emptyCellColor: string;
    palette: PaletteCollectionModel[];
}
export interface ILoadedEventArgs extends IHeatMapEventArgs {
    /** Defines the current heatmap instance */
    heatmap: HeatMap;
}
export interface IHeatMapEventArgs {
    /** Defines the name of the event */
    name: string;
    /** Defines the event cancel status */
    cancel: boolean;
}
export interface ICellClickEventArgs extends IHeatMapEventArgs {
    /** Defines the current HeatMap instance */
    heatmap: HeatMap;
    /** Defines current clicked cell element */
    cellElement: Element;
    /** Defines current clicked cell value */
    value: number;
    /** Defines x-axis label for current clicked cell */
    xLabel: string;
    /** Defines y-axis label for current clicked cell */
    yLabel: string;
    /** Defines x-axis value for current clicked cell */
    xValue: string | number | Date;
    /** Defines y-axis value for current clicked cell */
    yValue: string | number | Date;
}
export interface ITooltipEventArgs extends IHeatMapEventArgs {
    /** Defines the current HeatMap instance */
    heatmap: HeatMap;
    /** Defines current hover cell value */
    value: number;
    /** Defines x-axis label for current hover cell */
    xLabel: string;
    /** Defines y-axis label for current hover cell */
    yLabel: string;
    /** Defines x-axis value for current hover cell */
    xValue: string | number | Date;
    /** Defines y-axis value for current hover cell */
    yValue: string | number | Date;
    /** Defines tooltip text value */
    content: string[];
}
/**
 * Specifies HeatMaps Themes
 */
export  namespace Theme {
    /** @private */
    let heatMapTitleFont: IFontMapping;
    /** @private */
    let axisTitleFont: IFontMapping;
    /** @private */
    let axisLabelFont: IFontMapping;
    /** @private */
    let legendLabelFont: IFontMapping;
    /** @private */
    let rectLabelFont: IFontMapping;
}
/** @private */
export  function getThemeColor(theme: HeatMapTheme): IThemeStyle;
/**
 * Interface for a class CellSettings
 */
export interface CellSettingsModel {
    /**
     * Toggles the visibility of data label over the heatmap cells.
     * @default true
     */
    showLabel?: boolean;
    /**
     * Specifies the formatting options for the data label. 
     * @default ''
     */
    format?: string;
    /**
     * Enables or disables the cell highlighting on mouse hover
     * @default true
     */
    enableCellHighlighting?: Boolean;
    /**
     * Specifies the cell border style. 
     * @default ''
     */
    border?: BorderModel;
    /**
     * Specifies the cell label style. 
     * @default ''
     */
    textStyle?: FontModel;
}
/**
 * Interface for a class Series
 */
export interface SeriesModel {
}
/**
 * Configures the CellSettings property in the Heatmap.
 */
export  class CellSettings extends base.ChildProperty<CellSettings> {
    /**
     * Toggles the visibility of data label over the heatmap cells.
     * @default true
     */
    showLabel: boolean;
    /**
     * Specifies the formatting options for the data label.
     * @default ''
     */
    format: string;
    /**
     * Enables or disables the cell highlighting on mouse hover
     * @default true
     */
    enableCellHighlighting: Boolean;
    /**
     * Specifies the cell border style.
     * @default ''
     */
    border: BorderModel;
    /**
     * Specifies the cell label style.
     * @default ''
     */
    textStyle: FontModel;
}

export class Series {
    private heatMap;
    private drawSvgCanvas;
    private cellColor;
    hoverXAxisLabel: string | number;
    hoverYAxisLabel: string | number;
    hoverXAxisValue: string | number | Date;
    hoverYAxisValue: string | number | Date;
    constructor(heatMap?: HeatMap);
    /** @private */
    private containerRectObject;
    /** @private */
    private containerTextObject;
    /** @private */
    format: Function;
    checkLabelYDisplay: boolean;
    checkLabelXDisplay: boolean;
    rectPositionCollection: CurrentRect[][];
    /**
     * To render rect series.
     * @return {void}
     * @private
     */
    renderRectSeries(): void;
    /**
     * To find saturated color for datalabel.
     * @return {string}
     * @private
     */
    private getSaturatedColor(color);
    /**
     * To highlight the mouse hovered rect cell.
     * @return {void}
     * @private
     */
    highlightSvgRect(tempID: string): void;
    /**
     * To get the value depends to format.
     * @return {string}
     * @private
     */
    getFormatedText(val: number, getFormat: string): string;
    /**
     * To get mouse hovered cell details.
     * @return {CurrentRect}
     * @private
     */
    getCurrentRect(x: number, y: number): CurrentRect;
    /**
     * Format the cell label.
     * @private
     */
    private formatValue(isCustom, format, tempInterval);
}
/**
 * Interface for a class PaletteSettings
 */
export interface PaletteSettingsModel {
    /**
     * Specifies the color collection for heat map cell. 
     * @default ''
     */
    palette?: PaletteCollectionModel[];
    /**
     * Specifies the color style
     * @default 'Gradient'
     */
    type?: PaletteType;
    /**
     * Specifies the color for empty points in Heatmap.
     * @default ''
     */
    emptyPointColor?: string;
}
/**
 * Interface for a class RgbColor
 */
export interface RgbColorModel {
}
/**
 * Interface for a class CellColor
 */
export interface CellColorModel {
}
/**
 * Configures the color property in Heatmap.
 */
export  class PaletteSettings extends base.ChildProperty<PaletteSettings> {
    /**
     * Specifies the color collection for heat map cell.
     * @default ''
     */
    palette: PaletteCollectionModel[];
    /**
     * Specifies the color style
     * @default 'Gradient'
     */
    type: PaletteType;
    /**
     * Specifies the color for empty points in Heatmap.
     * @default ''
     */
    emptyPointColor: string;
}
/**
 * Helper class for colormapping
 */
export  class RgbColor {
    R: number;
    G: number;
    B: number;
    constructor(r: number, g: number, b: number);
}
export  class CellColor {
    heatMap: HeatMap;
    constructor(heatMap?: HeatMap);
    /**
     * To convert hexa color to RGB.
     * @return {RGB}
     * @private
     */
    convertToRGB(value: number, colorMapping: ColorCollection[]): RgbColor;
    /**
     * To convert RGB to HEX.
     * @return {string}
     * @private
     */
    rgbToHex(r: number, g: number, b: number): string;
    /**
     * To convert Component to HEX.
     * @return {string}
     * @private
     */
    protected componentToHex(c: number): string;
    /**
     * To get similar color.
     * @return {string}
     * @private
     */
    protected getEqualColor(list: ColorCollection[], offset: number): string;
    /**
     * To convert RGB to HEX.
     * @return {string}
     * @private
     */
    protected convertToHex(color: string): string;
    /**
     * To get RGB for percentage value.
     * @return {RGB}
     * @private
     */
    protected getPercentageColor(percent: number, previous: string, next: string): RgbColor;
    /**
     * To convert numbet to percentage.
     * @return {RGB}
     * @private
     */
    protected getPercentage(percent: number, previous: number, next: number): number;
    /**
     * To get complete color Collection.
     * @private
     */
    getColorCollection(): void;
    /**
     * To update legend color Collection.
     * @private
     */
    private updateLegendColorCollection();
    /**
     * To get ordered palette color collection.
     * @private
     */
    private orderbyOffset(offsets);
    /**
     * To get color depends to value.
     * @private
     */
    getColorByValue(text: number): string;
}
/**
 * Defines the Alignment. They are
 * * near - Align the element to the left.
 * * center - Align the element to the center.
 * * far - Align the element to the right.
 * *
 */
export  type Alignment = 'Near' | 'Center' | 'Far';
/**
 * Defines Theme of the heatmap.
 */
export  type HeatMapTheme = 'Material' | 'Fabric' | 'Bootstrap' | 'Highcontrast';
export  type Orientation = 'Horizontal' | 'Vertical';
/**
 * Defines the type of axis. They are
 * * double -  Renders a numeric axis.
 * * dateTime - Renders a dateTime axis.
 * * category - Renders a category axis.
 */
export  type ValueType = 'Numeric' | 'DateTime' | 'Category';
/**
 * Defines Color for cell.
 */
export  type PaletteType = 'Gradient' | 'Fixed';
/**
 * Defines the interval type of datetime axis. They are
 * * years - Define the interval of the axis in years.
 * * months - Define the interval of the axis in months.
 * * days - Define the interval of the axis in days.
 * * hours - Define the interval of the axis in hours.
 * * minutes - Define the interval of the axis in minutes.
 */
export  type IntervalType = 'Years' | 'Months' | 'Days' | 'Hours' | 'Minutes';
/**
 * Defines the Legend position
 * Left - Legend in the left position
 * Right - Legend in the left right  position
 * Up - Legend in the left up  position
 * Down -Legend in the left down position
 */
export  type LegendPosition = 'Left' | 'Right' | 'Top' | 'Bottom';
export  type TextOverflow = 'None' | 'Wrap' | 'Trim';
/**
 * specify the adapter type
 */
export  type AdaptorType = 'Cell' | 'Table' | 'Pivot';
/**
 * specify the rendering mode
 */
export  type DrawType = 'SVG' | 'Canvas' | 'Auto';
export  type LabelIntersectAction = 'None' | 'Trim' | 'Rotate45';
/**
 * Helper method for heatmap
 */
/** @private */
export  function stringToNumber(value: string, containerSize: number): number;
/**
 * Function to measure the height and width of the text.
 * @private
 */
export  function measureText(text: string, font: FontModel): Size;
/** @private */
export  class TextElement {
    ['font-size']: string;
    ['font-style']: string;
    ['font-family']: string;
    ['font-weight']: string;
    fill: string;
    constructor(fontModel: FontModel, fontColor?: string);
}
export  function titlePositionX(width: number, leftPadding: number, rightPadding: number, titleStyle: FontModel): number;
/**
 * Internal class size for height and width
 */
export  class Size {
    /**
     * height of the size
     */
    height: number;
    /**
     * width of the size
     */
    width: number;
    constructor(width: number, height: number);
}
/** @private */
export  class CustomizeOption {
    id: string;
    constructor(id?: string);
}
/** @private */
export  class PathOption extends CustomizeOption {
    opacity: number;
    fill: string;
    stroke: string;
    ['stroke-width']: number;
    ['stroke-dasharray']: string;
    d: string;
    constructor(id: string, fill: string, width: number, color?: string, opacity?: number, dashArray?: string, d?: string);
}
/**
 * Class to define currentRect private property.
 * @private
 */
export  class CurrentRect {
    x: number;
    y: number;
    width: number;
    height: number;
    value: number;
    id: string;
    constructor(x: number, y: number, width: number, height: number, value: number, id: string);
}
/**
 * Class to define property to draw rectangle.
 * @private
 */
export  class RectOption extends PathOption {
    x: number;
    y: number;
    height: number;
    width: number;
    rx: number;
    ry: number;
    transform: string;
    constructor(id: string, fill: string, border: BorderModel, opacity: number, rect: Rect, borderColor?: string, rx?: number, ry?: number, transform?: string, dashArray?: string);
}
/**
 * Helper Class to define property to draw rectangle.
 * @private
 */
export  class Rect {
    x: number;
    y: number;
    height: number;
    width: number;
    constructor(x: number, y: number, width: number, height: number);
}
/**
 * Class to define property to draw text.
 * @private
 */
export  class TextOption extends TextElement {
    id: string;
    ['text-anchor']: string;
    text: string | string[];
    transform: string;
    x: number;
    y: number;
    ['dominant-baseline']: string;
    labelRotation: number;
    baseline: string;
    constructor(id: string, basic: TextBasic, element: FontModel, fontColor?: string);
}
/**
 * Helper Class to define property to draw text.
 * @private
 */
export  class TextBasic {
    ['text-anchor']: string;
    text: string | string[];
    transform: string;
    x: number;
    y: number;
    ['dominant-baseline']: string;
    labelRotation: number;
    baseline: string;
    constructor(x?: number, y?: number, anchor?: string, text?: string | string[], labelRotation?: number, transform?: string, baseLine?: string);
}
/**
 * Class to define property to draw line.
 * @private
 */
export  class Line {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
    constructor(x1: number, y1: number, x2: number, y2: number);
}
/**
 * Class to define property to draw line.
 * @private
 */
export  class LineOption extends PathOption {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
    constructor(id: string, line: Line, stroke: string, strokewidth: number, opacity?: number, dasharray?: string);
}
/** @private */
export  function sum(values: number[]): number;
export  function titlePositionY(heatmapSize: Size, topPadding: number, bottomPadding: number, titleStyle: FontModel): number;
/** @private */
export  function rotateTextSize(font: FontModel, text: string, angle: number): Size;
/**
 * Class to draw SVG and Canvas Rectangle & Text.
 * @private
 */
export  class DrawSvgCanvas {
    private heatMap;
    constructor(heatmap?: HeatMap);
    drawRectangle(properties: RectOption, parentElement: Element): void;
    createText(properties: TextOption, parentElement: Element, text: string): void;
    createWrapText(options: TextOption, font: FontModel, parentElement: Element): void;
    drawLine(properties: LineOption, parentElement: Element): void;
    canvasDrawText(options: TextOption, label: string, translateX?: number, translateY?: number): void;
    private getOptionValue<T>(options, key);
    private setAttributes(canvas, options);
    drawCanvasRectangle(canvas: base.CanvasRenderer, options: RectOption): void;
    private drawCornerRadius(canvas, options);
}
export  function getTitle(title: string, style: FontModel, width: number): string[];
export  function textWrap(currentLabel: string, maximumWidth: number, font: FontModel): string[];
/** @private */
export  function textTrim(maxWidth: number, text: string, font: FontModel): string;
/** @private */
export  function textNone(maxWidth: number, text: string, font: FontModel): string;
/** @private */
export  class Gradient {
    id: string;
    x1: string;
    x2: string;
    y1: string;
    y2: string;
    constructor(x: string, x1: string, x2: string, y1: string, y2: string);
}
export  class GradientColor {
    color: string;
    colorStop: string;
    constructor(color: string, colorStop: string);
}
/** @private */
export  function showTooltip(text: string, x: number, y: number, areaWidth: number, id: string, element: Element, isTouch?: boolean): void;
/** @private */
export  function removeElement(id: string): void;
/** @private */
export  function getElement(id: string): Element;
/** @private */
export  function increaseDateTimeInterval(value: number, interval: number, intervalType: string): Date;
export  class CanvasTooltip {
    text: string;
    region: Rect;
    constructor(text: string, rect: Rect);
}
export  function getTooltipText(tooltipCollection: CanvasTooltip[], xPosition: number, yPosition: number): string;
/**
 * @private
 */
export  class PaletterColor {
    isCompact: boolean;
    offsets: PaletteCollectionModel[];
}
/**
 * @private
 */
export  class GradientPointer {
    pathX1: number;
    pathY1: number;
    pathX2: number;
    pathY2: number;
    pathX3: number;
    pathY3: number;
    constructor(pathX1: number, pathY1: number, pathX2: number, pathY2: number, pathX3: number, pathY3: number);
}
/** @private */
export  function colorNameToHex(color: string): string;
/** @private */
export  function convertToHexCode(value: RgbColor): string;
/** @private */
export  function componentToHex(value: number): string;
/** @private */
export  function convertHexToColor(hex: string): RgbColor;
export  class Tooltip {
    private heatMap;
    private isFirst;
    isFadeout: boolean;
    tooltipObject: svgbase.Tooltip;
    constructor(heatMap?: HeatMap);
    /**
     * Get component name
     */
    getModuleName(): string;
    /**
     * To show/hide Tooltip.
     * @private
     */
    showHideTooltip(isShow: boolean, isFadeout?: boolean): void;
    /**
     * To destroy the Tooltip.
     * @return {void}
     * @private
     */
    destroy(heatMap: HeatMap): void;
    /**
     * To add Tooltip to the rect cell.
     * @return {void}
     * @private
     */
    private createTooltip(x, y, tempTooltipText?);
    /**
     * To create div container for tooltip.
     * @return {void}
     * @private
     */
    createTooltipDiv(heatMap: HeatMap): void;
    /**
     * To render tooltip.
     * @private
     */
    renderTooltip(currentRect: CurrentRect): void;
}
/**
 * HeatMap index file
 */
 }

export namespace lineargauge { 

/**
 * LinearGauge component exported.
 */
/**
 * Represent the annotation rendering for gauge
 */
export  class Annotations {
    private gauge;
    constructor(gauge: LinearGauge);
    /**
     * To render annotation elements
     */
    renderAnnotationElements(): void;
    /**
     * To create annotation elements
     */
    createAnnotationTemplate(element: HTMLElement, annotationIndex: number): void;
    protected getModuleName(): string;
    /**
     * To destroy the annotation.
     * @return {void}
     * @private
     */
    destroy(gauge: LinearGauge): void;
}
/**
 * @private
 * To handle the animation for gauge
 */
export  class Animations {
    gauge: LinearGauge;
    constructor(gauge: LinearGauge);
    /**
     * To do the marker pointer animation.
     * @return {void}
     * @private
     */
    performMarkerAnimation(element: Element, axis: Axis, pointer: Pointer): void;
    /**
     * Perform the bar pointer animation
     * @param element
     * @param axis
     * @param pointer
     */
    performBarAnimation(element: Element, axis: Axis, pointer: Pointer): void;
}
/**
 * Interface for a class Line
 */
export interface LineModel {
    /**
     * The dash array of the axis line.
     */
    dashArray?: string;
    /**
     * Height of the axis line.
     */
    height?: number;
    /**
     * Width of the axis line.
     * @default 2
     */
    width?: number;
    /**
     * Color of the axis line.
     */
    color?: string;
    /**
     * Specifies to move the axis line.
     */
    offset?: number;
}
/**
 * Interface for a class Label
 */
export interface LabelModel {
    /**
     * The font of the axis labels.
     */
    font?: FontModel;
    /**
     * The color of the label, based on range color.
     * @default false
     */
    useRangeColor?: boolean;
    /**
     * To format the axis label, which accepts any global format string like 'C', 'n1', 'P' etc.
     * Also accepts placeholder like '{value}°C' in which value represent the axis label e.g. 20°C.
     */
    format?: string;
    /**
     * To move the axis labels.
     * @default 0
     */
    offset?: number;
}
/**
 * Interface for a class Range
 */
export interface RangeModel {
    /**
     * Start of the axis range.
     */
    start?: number;
    /**
     * End of the axis range.
     */
    end?: number;
    /**
     * Specifies to position the axis range.
     * @default 'Outside'
     */
    position?: base.Position;
    /**
     * Color of the axis range.
     */
    color?: string;
    /**
     * Starting width of axis range.
     * @default 10
     */
    startWidth?: number;
    /**
     * Ending width of axis range.
     * @default 10
     */
    endWidth?: number;
    /**
     * Specifies to move the axis range.
     * @default 0
     */
    offset?: number;
    /**
     * Specifies the border of axis range.
     */
    border?: BorderModel;
}
/**
 * Interface for a class Tick
 */
export interface TickModel {
    /**
     * Height of the tick line.
     */
    height?: number;
    /**
     * Width of the tick line. 
     * @default 2
     */
    width?: number;
    /**
     * Specifies the interval for ticks.
     */
    interval?: number;
    /**
     * The color of the major or minor tick line, which accepts value in hex, rgba as a valid CSS color string.
     */
    color?: string;
    /**
     * Specifies to move the axis ticks.
     */
    offset?: number;
}
/**
 * Interface for a class Pointer
 */
export interface PointerModel {
    /**
     * Specifies the type of pointer.
     * @default 'Marker'
     */
    type?: Point;
    /**
     * Specifies value of the pointer.
     * @default null
     */
    value?: number;
    /**
     * Specifies the marker shape in pointer.
     * @default InvertedTriangle
     */
    markerType?: MarkerType;
    /**
     * Specifies the path of image.
     * @default null
     */
    imageUrl?: string;
    /**
     * Specifies the border of pointer.
     */
    border?: BorderModel;
    /**
     * Specifies the corner radius for rounded rectangle.
     * @default 10
     */
    roundedCornerRadius?: number;
    /**
     * Specifies the place of the pointer.
     * @default 'Far'
     */
    placement?: Placement;
    /**
     * Specifies the height of pointer.
     * @default 20
     */
    height?: number;
    /**
     * Specifies the width of pointer.
     * @default 20
     */
    width?: number;
    /**
     * Specifies the color of the pointer.
     */
    color?: string;
    /**
     * Specifies the opacity for pointer.
     * @default 1
     */
    opacity?: number;
    /**
     * Specifies the animating duration of pointer in milliseconds.
     * @default 0
     */
    animationDuration?: number;
    /**
     * Specifies the enable or disable the pointer drag.
     * @default false
     */
    enableDrag?: boolean;
    /**
     * Specifies to move the pointer.
     * @default 0
     */
    offset?: number;
    /**
     * Description of the pointer.
     * @default null
     */
    description?: string;
}
/**
 * Interface for a class Axis
 * @private
 */
export interface AxisModel {
    /**
     * Specifies the minimum value of an axis.
     * @default 0
     */
    minimum?: number;
    /**
     * Specifies the maximum value of an axis.
     * @default 100
     */
    maximum?: number;
    /**
     * Specifies the axis rendering direction.
     */
    isInversed?: boolean;
    /**
     * Specifies the axis rendering position.
     */
    opposedPosition?: boolean;
    /**
     * Options for customizing the axis line.
     */
    line?: LineModel;
    /**
     * Options for customizing the ranges of an axis
     */
    ranges?: RangeModel[];
    /**
     * Options for customizing the pointers of an axis
     */
    pointers?: PointerModel[];
    /**
     * Options for customizing the major tick lines.
     */
    majorTicks?: TickModel;
    /**
     * Options for customizing the minor tick lines.
     */
    minorTicks?: TickModel;
    /**
     * Options for customizing the axis label appearance.
     */
    labelStyle?: LabelModel;
}
/**
 * @private
 * To calculate the overall axis bounds for gauge.
 */
export  class AxisLayoutPanel {
    private gauge;
    private htmlObject;
    constructor(gauge: LinearGauge);
    /**
     * To calculate the axis bounds
     */
    calculateAxesBounds(): void;
    /**
     * Calculate axis line bounds
     * @param axis
     * @param axisIndex
     */
    calculateLineBounds(axis: Axis, axisIndex: number): void;
    /**
     * Calculate axis tick bounds
     * @param axis
     * @param axisIndex
     */
    calculateTickBounds(axis: Axis, axisIndex: number): void;
    /**
     * To Calculate axis label bounds
     * @param axis
     * @param axisIndex
     */
    calculateLabelBounds(axis: Axis, axisIndex: number): void;
    /**
     * Calculate pointer bounds
     * @param axis
     * @param axisIndex
     */
    calculatePointerBounds(axis: Axis, axisIndex: number): void;
    /**
     * Calculate marker pointer bounds
     * @param axisIndex
     * @param axis
     * @param pointerIndex
     * @param pointer
     */
    calculateMarkerBounds(axisIndex: number, axis: Axis, pointerIndex: number, pointer: Pointer): void;
    /**
     * Calculate bar pointer bounds
     * @param axisIndex
     * @param axis
     * @param pointerIndex
     * @param pointer
     */
    calculateBarBounds(axisIndex: number, axis: Axis, pointerIndex: number, pointer: Pointer): void;
    /**
     * Calculate ranges bounds
     * @param axis
     * @param axisIndex
     */
    calculateRangesBounds(axis: Axis, axisIndex: number): void;
    private checkPreviousAxes(currentAxis, axisIndex);
    /**
     *
     * @param axis To calculate the visible labels
     */
    calculateVisibleLabels(axis: Axis): void;
    /**
     * Calculate maximum label width for the axis.
     * @return {void}
     * @private
     */
    private getMaxLabelWidth(gauge, axis);
    private checkThermometer();
}
/**
 * @private
 * To render the axis elements
 */
export  class AxisRenderer extends Animations {
    private htmlObject;
    private axisObject;
    private axisElements;
    constructor(gauge: LinearGauge);
    renderAxes(): void;
    axisAlign(axes: AxisModel[]): void;
    drawAxisLine(axis: Axis, axisObject: Element, axisIndex: number): void;
    drawTicks(axis: Axis, ticks: Tick, axisObject: Element, tickID: string, tickBounds: Rect): void;
    drawAxisLabels(axis: Axis, axisObject: Element): void;
    drawPointers(axis: Axis, axisObject: Element, axisIndex: number): void;
    drawMarkerPointer(axis: Axis, axisIndex: number, pointer: Pointer, pointerIndex: number, parentElement: Element): void;
    drawBarPointer(axis: Axis, axisIndex: number, pointer: Pointer, pointerIndex: number, parentElement: Element): void;
    drawRanges(axis: Axis, axisObject: Element, axisIndex: number): void;
}
/** Options for customizing the axis line. */
export  class Line extends base.ChildProperty<Line> {
    /**
     * The dash array of the axis line.
     */
    dashArray: string;
    /**
     * Height of the axis line.
     */
    height: number;
    /**
     * Width of the axis line.
     * @default 2
     */
    width: number;
    /**
     * Color of the axis line.
     */
    color: string;
    /**
     * Specifies to move the axis line.
     */
    offset: number;
}
/**
 * Options for customizing the axis labels appearance.
 */
export  class Label extends base.ChildProperty<Label> {
    /**
     * The font of the axis labels.
     */
    font: FontModel;
    /**
     * The color of the label, based on range color.
     * @default false
     */
    useRangeColor: boolean;
    /**
     * To format the axis label, which accepts any global format string like 'C', 'n1', 'P' etc.
     * Also accepts placeholder like '{value}°C' in which value represent the axis label e.g. 20°C.
     */
    format: string;
    /**
     * To move the axis labels.
     * @default 0
     */
    offset: number;
}
/**
 * Options for customizing the ranges of an axis.
 */
export  class Range extends base.ChildProperty<Range> {
    /**
     * Start of the axis range.
     */
    start: number;
    /**
     * End of the axis range.
     */
    end: number;
    /**
     * Specifies to position the axis range.
     * @default 'Outside'
     */
    position: Position;
    /**
     * Color of the axis range.
     */
    color: string;
    /**
     * Starting width of axis range.
     * @default 10
     */
    startWidth: number;
    /**
     * Ending width of axis range.
     * @default 10
     */
    endWidth: number;
    /**
     * Specifies to move the axis range.
     * @default 0
     */
    offset: number;
    /**
     * Specifies the border of axis range.
     */
    border: BorderModel;
    /** @private */
    bounds: Rect;
    /** @private */
    path: string;
    /** @private */
    interior: string;
}
/**
 * Options for customizing the minor tick lines.
 */
export  class Tick extends base.ChildProperty<Tick> {
    /**
     * Height of the tick line.
     */
    height: number;
    /**
     * Width of the tick line.
     * @default 2
     */
    width: number;
    /**
     * Specifies the interval for ticks.
     */
    interval: number;
    /**
     * The color of the major or minor tick line, which accepts value in hex, rgba as a valid CSS color string.
     */
    color: string;
    /**
     * Specifies to move the axis ticks.
     */
    offset: number;
}
/**
 * Options for customizing the pointers of an axis.
 */
export  class Pointer extends base.ChildProperty<Pointer> {
    /**
     * Specifies the type of pointer.
     * @default 'Marker'
     */
    type: Point;
    /**
     * Specifies value of the pointer.
     * @default null
     */
    value: number;
    /**
     * Specifies the marker shape in pointer.
     * @default InvertedTriangle
     */
    markerType: MarkerType;
    /**
     * Specifies the path of image.
     * @default null
     */
    imageUrl: string;
    /**
     * Specifies the border of pointer.
     */
    border: BorderModel;
    /**
     * Specifies the corner radius for rounded rectangle.
     * @default 10
     */
    roundedCornerRadius: number;
    /**
     * Specifies the place of the pointer.
     * @default 'Far'
     */
    placement: Placement;
    /**
     * Specifies the height of pointer.
     * @default 20
     */
    height: number;
    /**
     * Specifies the width of pointer.
     * @default 20
     */
    width: number;
    /**
     * Specifies the color of the pointer.
     */
    color: string;
    /**
     * Specifies the opacity for pointer.
     * @default 1
     */
    opacity: number;
    /**
     * Specifies the animating duration of pointer in milliseconds.
     * @default 0
     */
    animationDuration: number;
    /**
     * Specifies the enable or disable the pointer drag.
     * @default false
     */
    enableDrag: boolean;
    /**
     * Specifies to move the pointer.
     * @default 0
     */
    offset: number;
    /**
     * Description of the pointer.
     * @default null
     */
    description: string;
    /** @private */
    bounds: Rect;
    /** @private */
    startValue: number;
    /** @private */
    animationComplete: boolean;
    /** @private */
    currentValue: number;
}
export  class Axis extends base.ChildProperty<Axis> {
    /**
     * Specifies the minimum value of an axis.
     * @default 0
     */
    minimum: number;
    /**
     * Specifies the maximum value of an axis.
     * @default 100
     */
    maximum: number;
    /**
     * Specifies the axis rendering direction.
     */
    isInversed: boolean;
    /**
     * Specifies the axis rendering position.
     */
    opposedPosition: boolean;
    /**
     * Options for customizing the axis line.
     */
    line: LineModel;
    /**
     * Options for customizing the ranges of an axis
     */
    ranges: RangeModel[];
    /**
     * Options for customizing the pointers of an axis
     */
    pointers: PointerModel[];
    /**
     * Options for customizing the major tick lines.
     */
    majorTicks: TickModel;
    /**
     * Options for customizing the minor tick lines.
     */
    minorTicks: TickModel;
    /**
     * Options for customizing the axis label appearance.
     */
    labelStyle: LabelModel;
    /** @private */
    visibleLabels: VisibleLabels[];
    /** @private */
    maxLabelSize: Size;
    /** @private */
    visibleRange: VisibleRange;
    /** @private */
    lineBounds: Rect;
    /** @private */
    majorTickBounds: Rect;
    /** @private */
    minorTickBounds: Rect;
    /** @private */
    labelBounds: Rect;
    /** @private */
    pointerBounds: Rect;
    /** @private */
    bounds: Rect;
    /** @private */
    maxTickLength: number;
    /** @private */
    checkAlign: Align;
    /** @private */
    majorInterval: number;
    /** @private */
    minorInterval: number;
}
/**
 * Linear gauge component exported items
 */
/**
 * Interface for a class LinearGauge
 */
export interface LinearGaugeModel extends base.ComponentModel{
    /**
     * The width of the Linear gauge as a string in order to provide input as both like '100px' or '100%'.
     * If specified as '100%, gauge will render to the full width of its parent element.
     * @default null
     */
    width?: string;
    /**
     * The height of the Linear gauge as a string in order to provide input as both like '100px' or '100%'.
     * If specified as '100%, gauge will render to the full height of its parent element.
     * @default null
     */
    height?: string;
    /**
     * Specifies the gauge will rendered either horizontal or vertical orientation.
     */
    orientation?: Orientation;
    /**
     *  Options to customize the left, right, top and bottom margins of the gauge.
     */
    margin?: MarginModel;
    /**
     * Options for customizing the color and width of the gauge border.
     */
    border?: BorderModel;
    /**
     * The background color of the gauge, which accepts value in hex, rgba as a valid CSS color string.
     * @default 'transparent'
     */
    background?: string;
    /**
     * Specifies the title for linear gauge.
     */
    title?: string;
    /**
     * Options for customizing the title appearance of linear gauge.
     */
    titleStyle?: FontModel;
    /**
     * Options for customizing the container linear gauge.
     */
    container?: ContainerModel;
    /**
     *  Options for customizing the axes of linear gauge.
     */
    axes?: AxisModel[];
    /**
     * Options for customizing the tooltip in linear gauge.
     */
    tooltip?: TooltipSettingsModel;
    /**
     *  Options for customizing the annotation of linear gauge.
     */
    annotations?: AnnotationModel[];
    /**
     * Specifies color palette for axis ranges.
     * @default []
     */
    rangePalettes?: string[];
    /**
     * Specifies whether a grouping separator should be used for a number.
     * @default false
     */
    useGroupingSeparator?: boolean;
    /**
     * Specifies the description for linear gauge.
     * @default null
     */
    description?: string;
    /**
     * TabIndex value for the gauge.
     * @default 1
     */
    tabIndex?: number;
    /**
     * Specifies the theme for the maps.
     */
    theme?: LinearGaugeTheme;
    /**
     * Triggers after gauge base.loaded.
     * @event
     */
    loaded?: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers before gauge base.load.
     * @event
     */
    load?: base.EmitType<ILoadEventArgs>;
    /**
     * Triggers after complete the animation for pointer.
     * @event
     */
    animationComplete?: base.EmitType<IAnimationCompleteEventArgs>;
    /**
     * Triggers before each axis label gets rendered.
     * @event
     */
    axisLabelRender?: base.EmitType<IAxisLabelRenderEventArgs>;
    /**
     * Triggers before each annotation gets rendered.
     * @event
     */
    annotationRender?: base.EmitType<IAnnotationRenderEventArgs>;
    /**
     * Triggers before the tooltip get rendered.
     * @event
     */
    tooltipRender?: base.EmitType<ITooltipRenderEventArgs>;
    /**
     * Triggers when mouse move on gauge area.
     * @event
     */
    gaugeMouseMove?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers when mouse leave from the gauge area .
     * @event
     */
    gaugeMouseLeave?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers when mouse down on gauge area.
     * @event
     */
    gaugeMouseDown?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers when mouse up on gauge area.
     * @event
     */
    gaugeMouseUp?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers while drag the pointer.
     * @event
     */
    valueChange?: base.EmitType<IValueChangeEventArgs>;
    /**
     * Triggers after window resize.
     * @event
     */
    resized?: base.EmitType<IResizeEventArgs>;
}
/**
 * Represents the EJ2 Linear gauge control.
 * ```html
 * <div id="container"/>
 * <script>
 *   var gaugeObj = new LinearGauge({ });
 *   gaugeObj.appendTo("#container");
 * </script>
 * ```
 */
export  class LinearGauge extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /**
     *  annotationModule is used to place the any text or images into the gauge.
     */
    annotationsModule: Annotations;
    /**
     * tooltipModule is used to display the pointer value.
     */
    tooltipModule: GaugeTooltip;
    /**
     * The width of the Linear gauge as a string in order to provide input as both like '100px' or '100%'.
     * If specified as '100%, gauge will render to the full width of its parent element.
     * @default null
     */
    width: string;
    /**
     * The height of the Linear gauge as a string in order to provide input as both like '100px' or '100%'.
     * If specified as '100%, gauge will render to the full height of its parent element.
     * @default null
     */
    height: string;
    /**
     * Specifies the gauge will rendered either horizontal or vertical orientation.
     */
    orientation: Orientation;
    /**
     *  Options to customize the left, right, top and bottom margins of the gauge.
     */
    margin: MarginModel;
    /**
     * Options for customizing the color and width of the gauge border.
     */
    border: BorderModel;
    /**
     * The background color of the gauge, which accepts value in hex, rgba as a valid CSS color string.
     * @default 'transparent'
     */
    background: string;
    /**
     * Specifies the title for linear gauge.
     */
    title: string;
    /**
     * Options for customizing the title appearance of linear gauge.
     */
    titleStyle: FontModel;
    /**
     * Options for customizing the container linear gauge.
     */
    container: ContainerModel;
    /**
     *  Options for customizing the axes of linear gauge.
     */
    axes: AxisModel[];
    /**
     * Options for customizing the tooltip in linear gauge.
     */
    tooltip: TooltipSettingsModel;
    /**
     *  Options for customizing the annotation of linear gauge.
     */
    annotations: AnnotationModel[];
    /**
     * Specifies color palette for axis ranges.
     * @default []
     */
    rangePalettes: string[];
    /**
     * Specifies whether a grouping separator should be used for a number.
     * @default false
     */
    useGroupingSeparator: boolean;
    /**
     * Specifies the description for linear gauge.
     * @default null
     */
    description: string;
    /**
     * TabIndex value for the gauge.
     * @default 1
     */
    tabIndex: number;
    /**
     * Specifies the theme for the maps.
     */
    theme: LinearGaugeTheme;
    /**
     * Triggers after gauge loaded.
     * @event
     */
    loaded: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers before gauge load.
     * @event
     */
    load: base.EmitType<ILoadEventArgs>;
    /**
     * Triggers after complete the animation for pointer.
     * @event
     */
    animationComplete: base.EmitType<IAnimationCompleteEventArgs>;
    /**
     * Triggers before each axis label gets rendered.
     * @event
     */
    axisLabelRender: base.EmitType<IAxisLabelRenderEventArgs>;
    /**
     * Triggers before each annotation gets rendered.
     * @event
     */
    annotationRender: base.EmitType<IAnnotationRenderEventArgs>;
    /**
     * Triggers before the tooltip get rendered.
     * @event
     */
    tooltipRender: base.EmitType<ITooltipRenderEventArgs>;
    /**
     * Triggers when mouse move on gauge area.
     * @event
     */
    gaugeMouseMove: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers when mouse leave from the gauge area .
     * @event
     */
    gaugeMouseLeave: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers when mouse down on gauge area.
     * @event
     */
    gaugeMouseDown: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers when mouse up on gauge area.
     * @event
     */
    gaugeMouseUp: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers while drag the pointer.
     * @event
     */
    valueChange: base.EmitType<IValueChangeEventArgs>;
    /**
     * Triggers after window resize.
     * @event
     */
    resized: base.EmitType<IResizeEventArgs>;
    /** @private */
    renderer: base.SvgRenderer;
    /** @private */
    svgObject: Element;
    /** @private */
    availableSize: Size;
    /** @private */
    actualRect: Rect;
    /** @private */
    intl: base.Internationalization;
    /** @private* */
    containerBounds: Rect;
    /**
     * @private
     * Calculate the axes bounds for gauge.
     * @hidden
     */
    gaugeAxisLayoutPanel: AxisLayoutPanel;
    /**
     * @private
     * Render the axis elements for gauge.
     * @hidden
     */
    axisRenderer: AxisRenderer;
    /** @private */
    private resizeTo;
    /** @private */
    containerObject: Element;
    /** @private */
    pointerDrag: boolean;
    /** @private */
    mouseX: number;
    /** @private */
    mouseY: number;
    /** @private */
    mouseElement: Element;
    /** @private */
    gaugeResized: boolean;
    /** @private */
    nearSizes: number[];
    /** @private */
    farSizes: number[];
    /**
     * @private
     * Constructor for creating the widget
     * @hidden
     */
    constructor(options?: LinearGaugeModel, element?: string | HTMLElement);
    /**
     * Initialize the preRender method.
     */
    protected preRender(): void;
    private themeEffect();
    private setThemeColors(labelcolor, others);
    private initPrivateVariable();
    /**
     * Method to set culture for chart
     */
    private setCulture();
    /**
     * Methods to create svg element
     */
    private createSvg();
    /**
     * To Remove the SVG.
     * @return {boolean}
     * @private
     */
    removeSvg(): void;
    /**
     * Method to calculate the size of the gauge
     */
    private calculateSize();
    /**
     * To Initialize the control rendering
     */
    protected render(): void;
    /**
     * @private
     * To render the gauge elements
     */
    renderGaugeElements(): void;
    private appendSecondaryElement();
    /**
     * @private
     * To calculate axes bounds
     */
    calculateBounds(): void;
    /**
     * @private
     * To render axis elements
     */
    renderAxisElements(): void;
    private renderBorder();
    private renderTitle();
    private unWireEvents();
    private wireEvents();
    private setStyle(element);
    /**
     * Handles the gauge resize.
     * @return {boolean}
     * @private
     */
    gaugeResize(e: Event): boolean;
    /**
     * To destroy the gauge element from the DOM.
     */
    destroy(): void;
    /**
     * @private
     * To render the gauge container
     */
    renderContainer(): void;
    /**
     * Handles the mouse down on gauge.
     * @return {boolean}
     * @private
     */
    gaugeOnMouseDown(e: PointerEvent): boolean;
    /**
     * Handles the mouse move.
     * @return {boolean}
     * @private
     */
    mouseMove(e: PointerEvent): boolean;
    /**
     * To find the mouse move on pointer.
     * @param element
     */
    private moveOnPointer(element);
    /**
     * @private
     * Handle the right click
     * @param event
     */
    gaugeRightClick(event: MouseEvent | PointerEvent): boolean;
    /**
     * Handles the mouse leave.
     * @return {boolean}
     * @private
     */
    mouseLeave(e: PointerEvent): boolean;
    /**
     * Handles the mouse move on gauge.
     * @return {boolean}
     * @private
     */
    gaugeOnMouseMove(e: PointerEvent | TouchEvent): boolean;
    /**
     * Handles the mouse up.
     * @return {boolean}
     * @private
     */
    mouseEnd(e: PointerEvent): boolean;
    /**
     * Handles the mouse event arguments.
     * @return {IMouseEventArgs}
     * @private
     */
    private getMouseArgs(e, type, name);
    /**
     * @private
     * @param axis
     * @param pointer
     */
    markerDrag(axis: Axis, pointer: Pointer): void;
    /**
     * @private
     * @param axis
     * @param pointer
     */
    barDrag(axis: Axis, pointer: Pointer): void;
    /**
     * Triggers when drag the pointer
     * @param activeElement
     */
    private triggerDragEvent(activeElement);
    /**
     * To set the pointer value using this method
     * @param axisIndex
     * @param pointerIndex
     * @param value
     */
    setPointerValue(axisIndex: number, pointerIndex: number, value: number): void;
    /**
     * To set the annotation value using this method.
     * @param annotationIndex
     * @param content
     */
    setAnnotationValue(annotationIndex: number, content: string): void;
    /**
     * To provide the array of modules needed for control rendering
     * @return {base.ModuleDeclaration[]}
     * @private
     */
    requiredModules(): base.ModuleDeclaration[];
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    getPersistData(): string;
    /**
     * Get component name
     */
    getModuleName(): string;
    /**
     * Called internally if any of the property value changed.
     * @private
     */
    onPropertyChanged(newProp: LinearGaugeModel, oldProp: LinearGaugeModel): void;
}
/**
 * Interface for a class Font
 */
export interface FontModel {
    /**
     * Font size for text.
     */
    size?: string;
    /**
     * Color for text.
     */
    color?: string;
    /**
     * FontFamily for text.
     */
    fontFamily?: string;
    /**
     * FontWeight for text.
     */
    fontWeight?: string;
    /**
     * FontStyle for text.
     */
    fontStyle?: string;
    /**
     * Opacity for text.
     */
    opacity?: number;
}
/**
 * Interface for a class Margin
 */
export interface MarginModel {
    /**
     * Left margin in pixels.
     * @default 10
     */
    left?: number;
    /**
     * Right margin in pixels.
     * @default 10
     */
    right?: number;
    /**
     * Top margin in pixels.
     * @default 10
     */
    top?: number;
    /**
     * Bottom margin in pixels.
     * @default 10
     */
    bottom?: number;
}
/**
 * Interface for a class Border
 */
export interface BorderModel {
    /**
     * The color of the border, which accepts value in hex, rgba as a valid CSS color string.
     */
    color?: string;
    /**
     * The width of the border in pixels.
     * @default '0'
     */
    width?: number;
}
/**
 * Interface for a class Annotation
 */
export interface AnnotationModel {
    /**
     * Specifies the id of html element.
     */
    content?: string;
    /**
     * Specifies the position of x.
     */
    x?: number;
    /**
     * Specifies the position of y.
     */
    y?: number;
    /**
     * Specifies the vertical alignment of annotation.
     */
    verticalAlignment?: Placement;
    /**
     * Specifies the horizontal alignment of annotation.
     */
    horizontalAlignment?: Placement;
    /**
     * Specifies the zIndex of the annotation.
     * @default '-1'
     */
    zIndex?: string;
    /**
     * The font of the axis labels.
     */
    font?: FontModel;
    /**
     * Specifies the index of axis.
     */
    axisIndex?: number;
    /**
     * Specifies the value of axis.
     */
    axisValue?: number;
}
/**
 * Interface for a class Container
 */
export interface ContainerModel {
    /**
     * Specifies the type of container.
     * @default 'Normal'
     */
    type?: ContainerType;
    /**
     * Specifies the height of the container.
     * @default 0
     */
    height?: number;
    /**
     * Specifies the width of the container.
     * @default 0
     */
    width?: number;
    /**
     * Specifies the corner radius for rounded rectangle.
     * @default 10
     */
    roundedCornerRadius?: number;
    /**
     * Specifies the background of the color.
     */
    backgroundColor?: string;
    /**
     * Specifies the border of container.
     */
    border?: BorderModel;
    /**
     * Specifies to move the container.
     */
    offset?: number;
}
/**
 * Interface for a class TooltipSettings
 */
export interface TooltipSettingsModel {
    /**
     * Enable / Disable the visibility of tooltip.
     * @default false
     */
    enable?: boolean;
    /**
     * The fill color of the tooltip, which accepts value in hex, rgba as a valid CSS color string. 
     */
    fill?: string;
    /**
     * Options to customize the tooltip text.
     */
    textStyle?: FontModel;
    /**
     * Format of the tooltip content.
     * @default null
     */
    format?: string;
    /**
     * Custom template to format the tooltip content. Use ${x} and ${y} as a placeholder text to display the corresponding data point.
     * @default null
     */
    template?: string;
    /**
     * If set true, tooltip will animate, while moving from one point to another.
     * @default true
     */
    enableAnimation?: boolean;
    /**
     * Options to customize the border for tooltip.
     */
    border?: BorderModel;
}
/**
 * Options for customizing the fonts.
 */
export  class Font extends base.ChildProperty<Font> {
    /**
     * Font size for text.
     */
    size: string;
    /**
     * Color for text.
     */
    color: string;
    /**
     * FontFamily for text.
     */
    fontFamily: string;
    /**
     * FontWeight for text.
     */
    fontWeight: string;
    /**
     * FontStyle for text.
     */
    fontStyle: string;
    /**
     * Opacity for text.
     */
    opacity: number;
}
/**
 * Configures the margin of linear gauge.
 */
export  class Margin extends base.ChildProperty<Margin> {
    /**
     * Left margin in pixels.
     * @default 10
     */
    left: number;
    /**
     * Right margin in pixels.
     * @default 10
     */
    right: number;
    /**
     * Top margin in pixels.
     * @default 10
     */
    top: number;
    /**
     * Bottom margin in pixels.
     * @default 10
     */
    bottom: number;
}
/**
 * Configures the border in linear gauge.
 */
export  class Border extends base.ChildProperty<Border> {
    /**
     * The color of the border, which accepts value in hex, rgba as a valid CSS color string.
     */
    color: string;
    /**
     * The width of the border in pixels.
     * @default '0'
     */
    width: number;
}
/**
 * Options for customizing the annotation.
 */
export  class Annotation extends base.ChildProperty<Annotation> {
    /**
     * Specifies the id of html element.
     */
    content: string;
    /**
     * Specifies the position of x.
     */
    x: number;
    /**
     * Specifies the position of y.
     */
    y: number;
    /**
     * Specifies the vertical alignment of annotation.
     */
    verticalAlignment: Placement;
    /**
     * Specifies the horizontal alignment of annotation.
     */
    horizontalAlignment: Placement;
    /**
     * Specifies the zIndex of the annotation.
     * @default '-1'
     */
    zIndex: string;
    /**
     * The font of the axis labels.
     */
    font: FontModel;
    /**
     * Specifies the index of axis.
     */
    axisIndex: number;
    /**
     * Specifies the value of axis.
     */
    axisValue: number;
}
/**
 * Options for customizing the container of linear gauge.
 */
export  class Container extends base.ChildProperty<Container> {
    /**
     * Specifies the type of container.
     * @default 'Normal'
     */
    type: ContainerType;
    /**
     * Specifies the height of the container.
     * @default 0
     */
    height: number;
    /**
     * Specifies the width of the container.
     * @default 0
     */
    width: number;
    /**
     * Specifies the corner radius for rounded rectangle.
     * @default 10
     */
    roundedCornerRadius: number;
    /**
     * Specifies the background of the color.
     */
    backgroundColor: string;
    /**
     * Specifies the border of container.
     */
    border: BorderModel;
    /**
     * Specifies to move the container.
     */
    offset: number;
}
/**
 * Options for customizing the tooltip in linear gauge.
 */
export  class TooltipSettings extends base.ChildProperty<TooltipSettings> {
    /**
     * Enable / Disable the visibility of tooltip.
     * @default false
     */
    enable: boolean;
    /**
     * The fill color of the tooltip, which accepts value in hex, rgba as a valid CSS color string.
     */
    fill: string;
    /**
     * Options to customize the tooltip text.
     */
    textStyle: FontModel;
    /**
     * Format of the tooltip content.
     * @default null
     */
    format: string;
    /**
     * Custom template to format the tooltip content. Use ${x} and ${y} as a placeholder text to display the corresponding data point.
     * @default null
     */
    template: string;
    /**
     * If set true, tooltip will animate, while moving from one point to another.
     * @default true
     */
    enableAnimation: boolean;
    /**
     * Options to customize the border for tooltip.
     */
    border: BorderModel;
}
/**
 * Specifies the linear gauge constant value
 */
/** @private */
export  const loaded: string;
/** @private */
export  const load: string;
/** @private */
export  const animationComplete: string;
/** @private */
export  const axisLabelRender: string;
/** @private */
export  const tooltipRender: string;
/** @private */
export  const annotationRender: string;
/** @private */
export  const gaugeMouseMove: string;
/** @private */
export  const gaugeMouseLeave: string;
/** @private */
export  const gaugeMouseDown: string;
/** @private */
export  const gaugeMouseUp: string;
/** @private */
export  const valueChange: string;
/** @private */
export  const resized: string;
/**
 * @private
 * Specifies LienarGauge Events
 */
/** @private */
export interface ILinearGaugeEventArgs {
    name: string;
    cancel: boolean;
}
/**
 * Gauge Loaded event arguments
 */
export interface ILoadedEventArgs extends ILinearGaugeEventArgs {
    /**
     * event argument gauge
     */
    gauge: LinearGauge;
}
/**
 * Gauge Load event arguments
 */
export interface ILoadEventArgs extends ILinearGaugeEventArgs {
    /**
     * event argument gauge
     */
    gauge: LinearGauge;
}
/**
 * Gauge animation completed event arguments
 */
export interface IAnimationCompleteEventArgs extends ILinearGaugeEventArgs {
    /**
     * event argument axis
     */
    axis: Axis;
    /**
     * event argument pointer
     */
    pointer: Pointer;
}
/**
 * Gauge axis label rendering event arguments
 */
export interface IAxisLabelRenderEventArgs extends ILinearGaugeEventArgs {
    /**
     * event argument axis
     */
    axis: Axis;
    /**
     * event argument text
     */
    text: string;
    /**
     * event argument value
     */
    value: number;
}
/**
 * Gauge tooltip event arguments
 */
export interface ITooltipRenderEventArgs extends ILinearGaugeEventArgs {
    /**
     * event argument tooltip content
     */
    content?: string | HTMLElement;
    /**
     * event argument border
     */
    border?: BorderModel;
    /**
     * event argument text style
     */
    textStyle?: FontModel;
    /**
     * event argument axis
     */
    axis: Axis;
    /**
     * event argument pointer
     */
    pointer: Pointer;
}
/**
 * Gauge annotation render event arguments
 */
export interface IAnnotationRenderEventArgs extends ILinearGaugeEventArgs {
    /**
     * event argument content
     */
    content?: string;
    /**
     * event argument text style
     */
    textStyle?: FontModel;
    /**
     * event argument annotation
     */
    annotation: Annotation;
}
/**
 * Gauge mouse events args
 */
export interface IMouseEventArgs extends ILinearGaugeEventArgs {
    /**
     * event argument linear gauge model
     */
    model: LinearGauge;
    /**
     * event argument target
     */
    target: Element;
    /**
     * event argument x position
     */
    x: number;
    /**
     * event argument y position
     */
    y: number;
}
/**
 * Gauge resize event arguments
 */
export interface IResizeEventArgs {
    /**
     * event name
     */
    name: string;
    /**
     * event argument previous size
     */
    previousSize: Size;
    /**
     * event argument current size
     */
    currentSize: Size;
    /**
     * event argument gauge
     */
    gauge: LinearGauge;
}
/**
 * Gauge value change event arguments
 */
export interface IValueChangeEventArgs {
    /**
     * event name
     */
    name: string;
    /**
     * event argument gauge
     */
    gauge: LinearGauge;
    /**
     * event argument element
     */
    element: Element;
    /**
     * event argument axis index
     */
    axisIndex: number;
    /**
     * event argument axis
     */
    axis: Axis;
    /**
     * event argument pointer index
     */
    pointerIndex: number;
    /**
     * event argument pointer
     */
    pointer: Pointer;
    /**
     * event argument value
     */
    value: number;
}
/** @private */
export interface IVisiblePointer {
    axis?: Axis;
    axisIndex?: number;
    pointer?: Pointer;
    pointerIndex?: number;
}
/** @private */
export interface IMoveCursor {
    pointer?: boolean;
    style?: string;
}
/**
 * Represent the tooltip rendering for gauge
 */
export  class GaugeTooltip {
    private gauge;
    private element;
    private currentAxis;
    private axisIndex;
    private currentPointer;
    /**
     * EJ2 tooltip instance
     */
    ejTooltip: popups.Tooltip;
    private textStyle;
    private borderStyle;
    private pointerElement;
    private tooltip;
    constructor(gauge: LinearGauge);
    /**
     * Internal use for tooltip rendering
     * @param pointerElement
     */
    renderTooltip(pointerElement: Element): void;
    private appendTargetElement();
    private getTooltipPosition();
    private getTooltipLocation();
    private onBeforeRender(args);
    private tooltipCustomization(args);
    protected getModuleName(): string;
    /**
     * To destroy the tooltip.
     * @return {void}
     * @private
     */
    destroy(gauge: LinearGauge): void;
}
/**
 * Defines Position of axis. They are
 * * Inside
 * * Outside
 * @private
 */
export  type Position = 'Inside' | 'Outside';
/**
 * Defines type of pointer. They are
 * * Marker
 * * Bar
 * @private
 */
export  type Point = 'Marker' | 'Bar';
/**
 * Defines Theme of the gauge. They are
 * * Material
 * * Fabric
 * @private
 */
export  type LinearGaugeTheme = 'Material' | 'Bootstrap' | 'Highcontrast' | 'Fabric';
/**
 * Defines the type of marker. They are
 * Traingle
 * Diamond
 * Rectangle
 * Circle
 * Image
 * @private
 */
export  type MarkerType = 'Triangle' | 'InvertedTriangle' | 'Diamond' | 'Rectangle' | 'Circle' | 'Arrow' | 'InvertedArrow' | 'Image';
/**
 * Defines the place of the pointer. They are
 * None
 * Near
 * Center
 * Far
 * @private
 */
export  type Placement = 'Near' | 'Center' | 'Far' | 'None';
/**
 * Defines the type of gauge orientation. They are
 * Horizontal
 * Vertical
 * @private
 */
export  type Orientation = 'Horizontal' | 'Vertical';
/**
 * Defines the container type. They are
 * Normal
 * Thermometer
 * Rounded Rectangle
 */
export  type ContainerType = 'Normal' | 'Thermometer' | 'RoundedRectangle';
/**
 * Specifies Linear-Gauge Helper methods
 */
/** @private */
export  function stringToNumber(value: string, containerSize: number): number;
/**
 * Function to measure the height and width of the text.
 * @param  {string} text
 * @param  {FontModel} font
 * @param  {string} id
 * @returns no
 * @private
 */
export  function measureText(text: string, font: FontModel): Size;
/** @private */
export  function withInRange(value: number, start: number, end: number, max: number, min: number, type: string): boolean;
export  function convertPixelToValue(parentElement: HTMLElement, pointerElement: Element, orientation: Orientation, axis: Axis, type: string, location: GaugeLocation): number;
export  function getPathToRect(path: SVGPathElement, size: Size, parentElement: HTMLElement): Rect;
/** @private */
export  function getElement(id: string): HTMLElement;
/** @private */
export  function removeElement(id: string): void;
/** @private */
export  function isPointerDrag(axes: AxisModel[]): boolean;
/** @private */
export  function valueToCoefficient(value: number, axis: Axis, orientation: Orientation, range: VisibleRange): number;
export  function getFontStyle(font: FontModel): string;
/** @private */
export  function getLabelFormat(format: string): string;
/** @private */
export  function getTemplateFunction(template: string): Function;
/** @private */
export  function getElementOffset(childElement: HTMLElement, parentElement: HTMLElement): Size;
/** @private */
export  class VisibleRange {
    min?: number;
    max?: number;
    interval?: number;
    delta?: number;
    constructor(min: number, max: number, interval: number, delta: number);
}
/** @private */
export  class GaugeLocation {
    x: number;
    y: number;
    constructor(x: number, y: number);
}
/**
 * Internal class size for height and width
 */
export  class Size {
    /**
     * height of the size
     */
    height: number;
    /**
     * width of the size
     */
    width: number;
    constructor(width: number, height: number);
}
/** @private */
export  class Rect {
    x: number;
    y: number;
    height: number;
    width: number;
    constructor(x: number, y: number, width: number, height: number);
}
/** @private */
export  class CustomizeOption {
    id: string;
    constructor(id?: string);
}
/** @private */
export  class PathOption extends CustomizeOption {
    opacity: number;
    fill: string;
    stroke: string;
    ['stroke-width']: number;
    ['stroke-dasharray']: string;
    d: string;
    transform: string;
    constructor(id: string, fill: string, width: number, color: string, opacity?: number, dashArray?: string, d?: string, transform?: string);
}
/** @private */
export  class RectOption {
    x: number;
    y: number;
    id: string;
    height: number;
    width: number;
    rx: number;
    ry: number;
    opacity: number;
    transform: string;
    stroke: string;
    fill: string;
    ['stroke-width']: number;
    constructor(id: string, fill: string, border: BorderModel, opacity: number, rect: Rect, transform?: string, dashArray?: string);
}
/** @private */
export  class TextOption extends CustomizeOption {
    anchor: string;
    text: string;
    transform: string;
    x: number;
    y: number;
    baseLine: string;
    constructor(id?: string, x?: number, y?: number, anchor?: string, text?: string, transform?: string, baseLine?: string);
}
/** @private */
export  class VisibleLabels {
    text: string;
    value: number;
    size: Size;
    angle: number;
    constructor(text: string, value: number, size: Size);
}
/** @private */
export  class Align {
    axisIndex: number;
    align: string;
    constructor(axisIndex: number, align: string);
}
/** @private */
export  function textElement(options: TextOption, font: FontModel, color: string, parent: HTMLElement | Element): Element;
export  function calculateNiceInterval(min: number, max: number, size: number, orientation: Orientation): number;
export  function getActualDesiredIntervalsCount(size: number, orientation: Orientation): number;
/** @private */
export  function getPointer(target: HTMLElement, gauge: LinearGauge): IVisiblePointer;
/** @private */
export  function getRangeColor(value: number, ranges: Range[]): string;
/** @private */
export  function getRangePalette(): string[];
/** @private */
export  function calculateShapes(location: Rect, shape: MarkerType, size: Size, url: string, options: PathOption, orientation: Orientation, axis: Axis, pointer: Pointer): PathOption;
/** @private */
export  function getBox(location: Rect, boxName: string, orientation: Orientation, size: Size, type: string, containerWidth: number, axis: Axis, cornerRadius: number): string;
 }
export namespace lists { 

/**
 * Listview Component
 */
export  let cssClass: ClassList;
export interface ClassList {
    li: string;
    ul: string;
    group: string;
    icon: string;
    text: string;
    check: string;
    checked: string;
    selected: string;
    expanded: string;
    textContent: string;
    hasChild: string;
    level: string;
    url: string;
    collapsible: string;
    disabled: string;
    image: string;
    iconWrapper: string;
}
/**
 * Sorting Order
 */
export  type SortOrder = 'None' | 'Ascending' | 'Descending';
/**
 * Base List Generator
 */
export  namespace ListBase {
    /**
     * Default mapped fields.
     */
    let defaultMappedFields: FieldsMapping;
    /**
     * Function helps to created and return the UL Li element based on your data.
     * @param  {{[key:string]:Object}[]|string[]} dataSource - Specifies an array of JSON or String data.
     * @param  {ListBaseOptions} options? - Specifies the list options that need to provide.
     */
    function createList(dataSource: {
        [key: string]: Object;
    }[] | string[], options?: ListBaseOptions, isSingleLevel?: boolean): HTMLElement;
    /**
     * Function helps to created an element list based on string array input .
     * @param  {string[]} dataSource - Specifies an array of string data
     */
    function createListFromArray(dataSource: string[], isSingleLevel?: boolean, options?: ListBaseOptions): HTMLElement;
    /**
     * Function helps to created an element list based on string array input .
     * @param  {string[]} dataSource - Specifies an array of string data
     */
    function createListItemFromArray(dataSource: string[], isSingleLevel?: boolean, options?: ListBaseOptions): HTMLElement[];
    /**
     * Function helps to created an element list based on array of JSON input .
     * @param  {{[key:string]:Object}[]} dataSource - Specifies an array of JSON data.
     * @param  {ListBaseOptions} options? - Specifies the list options that need to provide.
     */
    function createListItemFromJson(dataSource: {
        [key: string]: Object;
    }[], options?: ListBaseOptions, level?: number, isSingleLevel?: boolean): HTMLElement[];
    /**
     * Function helps to created an element list based on array of JSON input .
     * @param  {{[key:string]:Object}[]} dataSource - Specifies an array of JSON data.
     * @param  {ListBaseOptions} options? - Specifies the list options that need to provide.
     */
    function createListFromJson(dataSource: {
        [key: string]: Object;
    }[], options?: ListBaseOptions, level?: number, isSingleLevel?: boolean): HTMLElement;
    /**
     * Return the next or previous visible element.
     * @param  {Element[]|NodeList} elementArray - An element array to find next or previous element.
     * @param  {Element} li - An element to find next or previous after this element.
     * @param  {boolean} isPrevious? - Specify when the need get previous element from array.
     */
    function getSiblingLI(elementArray: Element[] | NodeList, element: Element, isPrevious?: boolean): Element;
    /**
     * Return the index of the li element
     * @param  {Element} item - An element to find next or previous after this element.
     * @param  {Element[]|NodeList} elementArray - An element array to find index of given li.
     */
    function indexOf(item: Element, elementArray: Element[] | NodeList): number;
    /**
     * Returns the grouped data from given dataSource.
     * @param  {{[key:string]:Object}[]} dataSource - The JSON data which is necessary to process.
     * @param  {FieldsMapping} fields - Fields that are mapped from the data source.
     * @param  {SortOrder='None'} sortOrder- Specifies final result sort order.
     */
    function groupDataSource(dataSource: {
        [key: string]: Object;
    }[], fields: FieldsMapping, sortOrder?: SortOrder): {
        [key: string]: Object;
    }[];
    /**
     * Returns a sorted query object.
     * @param  {SortOrder} sortOrder - Specifies that sort order.
     * @param  {string} sortBy - Specifies sortBy fields.
     * @param  {data.Query=new data.Query()} query - Pass if any existing query.
     */
    function addSorting(sortOrder: SortOrder, sortBy: string, query?: data.Query): data.Query;
    /**
     * Return an array of JSON Data that processed based on queries.
     * @param  {{[key:string]:Object}[]} dataSource - Specifies local JSON data source.
     * @param  {data.Query} query - Specifies query that need to process.
     */
    function getDataSource(dataSource: {
        [key: string]: Object;
    }[], query: data.Query): {
        [key: string]: Object;
    }[];
    /**
     * Created JSON data based the UL and LI element
     * @param  {HTMLElement|Element} element - UL element that need to convert as a JSON
     * @param  {ListBaseOptions} options? - Specifies listbase option for fields.
     */
    function createJsonFromElement(element: HTMLElement | Element, options?: ListBaseOptions): {
        [key: string]: Object;
    }[];
    /**
     * Created UL element from content template.
     * @param  {string} template - that need to convert and generate li element.
     * @param  {{[key:string]:Object}[]} dataSource - Specifies local JSON data source.
     * @param  {ListBaseOptions} options? - Specifies listbase option for fields.
     */
    function renderContentTemplate(template: string, dataSource: {
        [key: string]: Object;
    }[], fields?: FieldsMapping, options?: ListBaseOptions): HTMLElement;
    /**
     * Created header items from group template.
     * @param  {string} template - that need to convert and generate li element.
     * @param  {{[key:string]:Object}[]} dataSource - Specifies local JSON data source.
     * @param  {FieldsMapping} fields - Specifies fields for mapping the dataSource.
     * @param  {Element[]} headerItems? - Specifies listbase header items.
     */
    function renderGroupTemplate(groupTemplate: string, groupDataSource: {
        [key: string]: Object;
    }[], fields: FieldsMapping, headerItems: Element[]): Element[];
    /**
     * Returns UL element based on the given LI element.
     * @param  {HTMLElement[]} liElement - Specifies array of LI element.
     * @param  {string} className? - Specifies class name that need to be added in UL element.
     * @param  {ListBaseOptions} options? - Specifies ListBase options.
     */
    function generateUL(liElement: HTMLElement[], className?: string, options?: ListBaseOptions): HTMLElement;
    /**
     * Returns LI element with additional DIV tag based on the given LI element.
     * @param  {liElement} liElement - Specifies LI element.
     * @param  {string} className? - Specifies class name that need to be added in created DIV element.
     * @param  {ListBaseOptions} options? - Specifies ListBase options.
     */
    function generateIcon(liElement: HTMLElement, className?: string, options?: ListBaseOptions): HTMLElement;
}
export interface FieldsMapping {
    id?: string;
    text?: string;
    value?: string;
    isChecked?: string;
    isVisible?: string;
    url?: string;
    enabled?: string;
    groupBy?: string;
    expanded?: string;
    selected?: string;
    iconCss?: string;
    child?: string;
    tooltip?: string;
    hasChildren?: string;
    htmlAttributes?: string;
    urlAttributes?: string;
    imageUrl?: string;
    imageAttributes?: string;
}
export  type Position = 'Right' | 'Left';
export interface AriaAttributesMapping {
    level?: number;
    listRole?: string;
    itemRole?: string;
    groupItemRole?: string;
    itemText?: string;
    wrapperRole?: string;
}
/**
 * Basic ListBase Options
 */
export interface ListBaseOptions {
    /**
     * Specifies that fields that mapped in dataSource
     */
    fields?: FieldsMapping;
    /**
     * Specifies the aria attributes
     */
    ariaAttributes?: AriaAttributesMapping;
    /**
     * Specifies to show checkBox
     */
    showCheckBox?: boolean;
    /**
     * Specifies to show icon
     */
    showIcon?: boolean;
    /**
     * Specifies to show collapsible icon
     */
    expandCollapse?: boolean;
    /**
     * Specifies when need to add additional UL list class
     */
    listClass?: string;
    /**
     * Specifies when need to add additional LI item class
     */
    itemClass?: string;
    /**
     * Enables when need process depth child processing.
     */
    processSubChild?: boolean;
    /**
     * Specifies the sort order
     */
    sortOrder?: SortOrder;
    /**
     * Specifies the item template
     */
    template?: string;
    /**
     * Specifies the group header template
     */
    groupTemplate?: string;
    /**
     * Specifies the callback function that triggered before each list creation
     */
    itemCreating?: Function;
    /**
     * Specifies the callback function that triggered after each list creation
     */
    itemCreated?: Function;
    /**
     * Specifies the customizable expand icon class
     */
    expandIconClass?: string;
    /**
     * Specifies the customized class name based on their module name
     */
    moduleName?: string;
    /**
     * Specifies the expand/collapse icon position
     */
    expandIconPosition?: Position;
}
/**
 * Used to get dataSource item from complex data using fields.
 * @param {{[key:string]:Object}|string[]|string} dataSource - Specifies an  JSON or String data.
 * @param {FieldsMapping} fields - Fields that are mapped from the dataSource.
 */
export  function getFieldValues(dataItem: {
    [key: string]: Object;
} | string | string[], fields: FieldsMapping): {
    [key: string]: Object;
} | string | string[];
/**
 * List Components
 */
/**
 * Listview Component
 */
/**
 * Interface for a class FieldSettings
 */
export interface FieldSettingsModel {
    /**
     * ID attribute of specific list-item.
     */
    id?: string;
    /**
     * It is used to map the text value of list item from the dataSource.
     */
    text?: string;
    /**
     * This property used to check whether the list item is in checked state or not.
     */
    isChecked?: string;
    /**
     * To check whether the visibility state of list item.
     */
    isVisible?: string;
    /**
     * It is used to enable the list item
     */
    enabled?: string;
    /**
     * It is used to customize the icon to the list items dynamically.
     *  We can add specific image to the icons using iconCss property.
     */
    iconCss?: string;
    /**
     * This property used for nested navigation of list-items.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/list-view/nested-list.html?lang=typescript here}
     *  to know more about this property with demo.
     */
    child?: string;
    /**
     * It is used to display `tooltip content of text` while hovering on list items.
     */
    tooltip?: string;
    /**
     * It wraps the list view element into a group based on the value of groupBy property.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/list-view/grouping.html?lang=typescript here}
     *  to know more about this property with demo.
     */
    groupBy?: string;
    /**
     * It is used to enable the sorting of list items to be ascending or descending.
     */
    sortBy?: string;
    /**
     * Defines the HTML base.attributes such as id, class, etc,. for the specific list item.
     */
    htmlAttributes?: string;
    /**
     * It is used to fetch a specified named table data while using serviceUrl of data.DataManager
     *  in dataSource property.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/data/getting-started.html?lang=typescript here}
     *  to know more about this property with demo.
     */
    tableName?: string;
}
/**
 * Interface for a class ListView
 */
export interface ListViewModel extends base.ComponentModel{
    /**
     * This cssClass property helps to use custom skinning option for ListView component,
     *  by adding the mentioned class name into root element of ListView.
     * @default ''
     */
    cssClass?: string;
    /**
     * Defines the HTML base.attributes such as id, class, etc., for the ListView.
     * @default {}
     */
    htmlAttributes?: { [key: string]: string; };
    /**
     * It specifies enabled state of ListView component.
     * @default true
     */
    enable?: boolean;
    /**
     * It provides the data to render the ListView component which is mapped
     *  with the fields of ListView.
     * @default []
     */
    dataSource?: { [key: string]: Object }[] | string[] | data.DataManager;
    /**
     * It is used to fetch the specific data from dataSource by using where, select key words.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/list-view/data-binding.html?lang=typescript#bind-to-remote-data here}
     *  to know more about this property with demo.
     * @default null
     */
    query?: data.Query;
    /**
     * It is used to map keys from the dataSource which extracts the appropriate data from the dataSource
     *  with specified mapped with the column fields to render the ListView.
     * @default base.ListBase.defaultMappedFields
     */
    fields?: FieldSettingsModel;
    /**
     * It is used to apply the animation to sub list navigation of list items.
     * @default { effect: 'SlideLeft', duration: 400, easing: 'ease' }
     */
    animation?: AnimationSettings;
    /**
     * It is used to enable the sorting of list items to be ascending or descending.
     * @default 'None'
     */
    sortOrder?: SortOrder;
    /**
     * Using this property, we can show or hide the icon of list item.
     * @default false
     */
    showIcon?: boolean;
    /**
     * Using this property, we can show or hide the `checkbox`.
     * @default false
     */
    showCheckBox?: boolean;
    /**
     * It is used to set the position of check box in an item.
     * @default 'Left'
     */
    checkBoxPosition?: checkBoxPosition;
    /**
     * It is used to set the title of ListView component.
     * @default ""
     */
    headerTitle?: string;
    /**
     * Using this property, we can show or hide the header of ListView component.
     * @default false
     */
    showHeader?: boolean;
    /**
     * It is used to set the height of the ListView component.
     * @default ''
     */
    height?: number | string;
    /**
     * It sets the width to the ListView component.
     * @default ''
     */
    width?: number | string;
    /**
     * The ListView supports to customize the content of each list items with the help of template property.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/list-view/customizing-templates.html?lang=typescript here}
     *  to know more about this property with demo.
     * @default null
     */
    template?: string;
    /**
     * The ListView has an option to custom design the group header title with the help of groupTemplate property.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/15.4.23/documentation/list-view/customizing-templates.html?lang=typescript#group-template here}
     *  to know more about this property with demo.
     * @default null
     */
    groupTemplate?: string;
    /**
     * We can trigger the `select` event when we select the list item in the component.
     * @event
     */
    select?: base.EmitType<SelectEventArgs>;
    /**
     * We can trigger `actionBegin` event before every ListView action starts.
     * @event
     */
    actionBegin?: base.EmitType<Object>;
    /**
     * We can trigger `actionComplete` event for every ListView action success event
     *  with the dataSource parameter.
     * @event
     */
    actionComplete?: base.EmitType<Object>;
    /**
     * We can trigger `actionFailure` event for every ListView action failure event
     *  with the dataSource parameter.
     * @event
     */
    actionFailure?: base.EmitType<Object>;
}
export interface Fields {
    /**
     * ID attribute of specific list-item.
     */
    id?: string;
    /**
     * It is used to map the text value of list item from the dataSource.
     */
    text?: string;
}
export  class FieldSettings extends base.ChildProperty<FieldSettings> {
    /**
     * ID attribute of specific list-item.
     */
    id: string;
    /**
     * It is used to map the text value of list item from the dataSource.
     */
    text: string;
    /**
     * This property used to check whether the list item is in checked state or not.
     */
    isChecked: string;
    /**
     * To check whether the visibility state of list item.
     */
    isVisible: string;
    /**
     * It is used to enable the list item
     */
    enabled: string;
    /**
     * It is used to customize the icon to the list items dynamically.
     *  We can add specific image to the icons using iconCss property.
     */
    iconCss: string;
    /**
     * This property used for nested navigation of list-items.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/list-view/nested-list.html?lang=typescript here}
     *  to know more about this property with demo.
     */
    child: string;
    /**
     * It is used to display `tooltip content of text` while hovering on list items.
     */
    tooltip: string;
    /**
     * It wraps the list view element into a group based on the value of groupBy property.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/list-view/grouping.html?lang=typescript here}
     *  to know more about this property with demo.
     */
    groupBy: string;
    /**
     * It is used to enable the sorting of list items to be ascending or descending.
     */
    sortBy: string;
    /**
     * Defines the HTML attributes such as id, class, etc,. for the specific list item.
     */
    htmlAttributes: string;
    /**
     * It is used to fetch a specified named table data while using serviceUrl of data.DataManager
     *  in dataSource property.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/data/getting-started.html?lang=typescript here}
     *  to know more about this property with demo.
     */
    tableName: string;
}
/**
 * Animation configuration settings.
 */
export interface AnimationSettings {
    /**
     * It is used to specify the effect which is shown in sub list transform.
     */
    effect?: ListViewEffect;
    /**
     * It is used to specify the time duration of transform object.
     */
    duration?: number;
    /**
     * It is used to specify the easing effect applied while transform
     */
    easing?: string;
}
/**
 * ListView animation effects
 */
export  type ListViewEffect = 'None' | 'SlideLeft' | 'SlideDown' | 'Zoom' | 'Fade';
/**
 * ListView check box positions
 */
export  type checkBoxPosition = 'Left' | 'Right';
/**
 * Represents the EJ2 ListView control.
 * ```html
 * <div id="listview">
 * <ul>
 * <li>Favourite</li>
 * <li>Documents</li>
 * <li>Downloads</li>
 * </ul>
 * </div>
 * ```
 * ```typescript
 *   var lvObj = new ListView({});
 *   lvObj.appendTo("#listview");
 * ```
 */
export  class ListView extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    private ulElement;
    private selectedLI;
    private curUL;
    private curDSLevel;
    private curViewDS;
    private curDSJSON;
    localData: {
        [key: string]: Object;
    }[];
    private liCollection;
    private headerEle;
    private contentContainer;
    private keyboardModule;
    private touchModule;
    private keyConfigs;
    private listBaseOption;
    private animateOptions;
    private rippleFn;
    private isNestedList;
    private currentLiElements;
    private resetList;
    private selectedData;
    private selectedId;
    private aniObj;
    /**
     * This cssClass property helps to use custom skinning option for ListView component,
     *  by adding the mentioned class name into root element of ListView.
     * @default ''
     */
    cssClass: string;
    /**
     * Defines the HTML attributes such as id, class, etc., for the ListView.
     * @default {}
     */
    htmlAttributes: {
        [key: string]: string;
    };
    /**
     * It specifies enabled state of ListView component.
     * @default true
     */
    enable: boolean;
    /**
     * It provides the data to render the ListView component which is mapped
     *  with the fields of ListView.
     * @default []
     */
    dataSource: {
        [key: string]: Object;
    }[] | string[] | data.DataManager;
    /**
     * It is used to fetch the specific data from dataSource by using where, select key words.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/list-view/data-binding.html?lang=typescript#bind-to-remote-data here}
     *  to know more about this property with demo.
     * @default null
     */
    query: data.Query;
    /**
     * It is used to map keys from the dataSource which extracts the appropriate data from the dataSource
     *  with specified mapped with the column fields to render the ListView.
     * @default ListBase.defaultMappedFields
     */
    fields: FieldSettingsModel;
    /**
     * It is used to apply the animation to sub list navigation of list items.
     * @default { effect: 'SlideLeft', duration: 400, easing: 'ease' }
     */
    animation: AnimationSettings;
    /**
     * It is used to enable the sorting of list items to be ascending or descending.
     * @default 'None'
     */
    sortOrder: SortOrder;
    /**
     * Using this property, we can show or hide the icon of list item.
     * @default false
     */
    showIcon: boolean;
    /**
     * Using this property, we can show or hide the `checkbox`.
     * @default false
     */
    showCheckBox: boolean;
    /**
     * It is used to set the position of check box in an item.
     * @default 'Left'
     */
    checkBoxPosition: checkBoxPosition;
    /**
     * It is used to set the title of ListView component.
     * @default ""
     */
    headerTitle: string;
    /**
     * Using this property, we can show or hide the header of ListView component.
     * @default false
     */
    showHeader: boolean;
    /**
     * It is used to set the height of the ListView component.
     * @default ''
     */
    height: number | string;
    /**
     * It sets the width to the ListView component.
     * @default ''
     */
    width: number | string;
    /**
     * The ListView supports to customize the content of each list items with the help of template property.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/list-view/customizing-templates.html?lang=typescript here}
     *  to know more about this property with demo.
     * @default null
     */
    template: string;
    /**
     * The ListView has an option to custom design the group header title with the help of groupTemplate property.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/15.4.23/documentation/list-view/customizing-templates.html?lang=typescript#group-template here}
     *  to know more about this property with demo.
     * @default null
     */
    groupTemplate: string;
    /**
     * We can trigger the `select` event when we select the list item in the component.
     * @event
     */
    select: base.EmitType<SelectEventArgs>;
    /**
     * We can trigger `actionBegin` event before every ListView action starts.
     * @event
     */
    actionBegin: base.EmitType<Object>;
    /**
     * We can trigger `actionComplete` event for every ListView action success event
     *  with the dataSource parameter.
     * @event
     */
    actionComplete: base.EmitType<Object>;
    /**
     * We can trigger `actionFailure` event for every ListView action failure event
     *  with the dataSource parameter.
     * @event
     */
    actionFailure: base.EmitType<Object>;
    /**
     * Constructor for creating the widget
     */
    constructor(options?: ListViewModel, element?: string | HTMLElement);
    onPropertyChanged(newProp: ListViewModel, oldProp: ListViewModel): void;
    private setHTMLAttribute();
    private setCSSClass(oldCSSClass?);
    private setSize();
    private setEnable();
    private setEnableRTL();
    private enableElement(element, isEnabled?);
    private header(text?, showBack?);
    private switchView(fromView, toView, reverse?);
    protected preRender(): void;
    private renderCheckbox(args);
    private checkItem(args, checkboxElement);
    private checkboxRevert();
    private setCheckbox();
    private clickHandler(e);
    private removeElement(element);
    private hoverHandler(e);
    private leaveHandler(e);
    private homeKeyHandler(e, end?);
    private arrowKeyHandler(e, prev?);
    private enterKeyHandler(e);
    private spaceKeyHandler(e);
    private keyActionHandler(e);
    private swipeActionHandler(e);
    private focusout();
    private wireEvents();
    private unWireEvents();
    private tabFocus(e);
    private removeHover();
    private removeSelect();
    private isValidLI(li);
    private setCheckboxLI(li, e?);
    private selectEventData(li, e?);
    private setSelectLI(li, e?);
    private setHoverLI(li);
    private hoverSiblingLI(prev?);
    private getSubDS();
    private getItemData(li);
    private findItemFromDS(dataSource, fields, parent?);
    private getQuery();
    private setViewDataSource(dataSource?);
    private isInAnimation();
    private setLocalData();
    private reRender();
    private resetCurrentList();
    private createList();
    private renderSubList(li);
    private renderIntoDom(ele);
    private renderList();
    private getElementUID(obj);
    /**
     * It is used to Initialize the control rendering.
     */
    render(): void;
    /**
     * It is used to destroy the ListView component.
     */
    destroy(): void;
    /**
     * It helps to switch back from navigated sub list.
     */
    back(): void;
    /**
     * It is used to select the list item from the ListView.
     * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
     */
    selectItem(obj: Fields | HTMLElement): void;
    private getLiFromObjOrElement(obj);
    selectMultipleItems(obj: Fields[] | HTMLElement[]): void;
    /**
     * It is used to get the currently
     *  {@link http://ej2.syncfusion.com/documentation/list-view/api-selectedItem.html?lang=typescript selected}
     *  item details from the list items.
     */
    getSelectedItems(): SelectedItem | SelectedCollection;
    /**
     * It is used to find out an item details from the current list.
     * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
     */
    findItem(fields: Fields): SelectedItem;
    /**
     * A function that used to enable the disabled list items based on passed element.
     * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
     */
    enableItem(obj: Fields | HTMLElement): void;
    /**
     * It is used to disable the list items based on passed element.
     * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
     */
    disableItem(obj: Fields | HTMLElement): void;
    private setItemState(obj, isEnable);
    /**
     * It is used to show an list item from the ListView.
     * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
     */
    showItem(obj: Fields | HTMLElement): void;
    /**
     * It is used to hide an item from the ListView.
     * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
     */
    hideItem(obj: Fields | HTMLElement): void;
    private showHideItem(obj, isHide, display);
    /**
     * It adds new item to current ListView.
     * To add a new item in the list view, we need to pass ‘data’ as array or object and ‘fields’ as object.
     * For example fields: { text: 'Name', tooltip: 'Name', id:'id'}
     * @param  {{[key:string]:Object}[]} data - Array JSON Data that need to add.
     * @param  {Fields} fields - Fields as an Object with ID and Text fields.
     */
    addItem(data: {
        [key: string]: Object;
    }[], fields: Fields): void;
    /**
     * A function that removes the item from data source based on passed element like fields: { text: 'Name', tooltip: 'Name', id:'id'}
     * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
     */
    removeItem(obj: Element | Fields): void;
    private removeItemFromList(obj, resetList?);
    /**
     * A function that removes multiple item from list view based on given input.
     * @param  {Fields[] | HTMLElement[]} obj - We can pass array of elements or array of field Object with ID and Text fields.
     */
    removeMultipleItems(obj: HTMLElement[] | Fields[]): void;
    protected getModuleName(): string;
    /**
     * Get the properties to be maintained in the persisted state.
     */
    protected getPersistData(): string;
}
export interface SelectedItem {
    /**
     * It denotes the Selected Item text.
     */
    text: string;
    /**
     * It denotes the Selected Item list element.
     */
    item: HTMLElement | Element;
    /**
     * It denotes the Selected Item dataSource JSON object.
     */
    data: {
        [key: string]: Object;
    } | string[];
}
export interface SelectedCollection {
    /**
     * It denotes the Selected Item text data or collection.
     */
    text: string | string[];
    /**
     * It denotes the Selected Item list element or element collection.
     */
    item: HTMLElement | Element[] | HTMLCollection;
    /**
     * It denotes the Selected Item dataSource JSON object or object collection.
     */
    data: {
        [key: string]: Object;
    } | {
        [key: string]: Object;
    }[] | string[];
}
export interface SelectEventArgs extends base.BaseEventArgs, SelectedItem {
    /**
     * Specifies that event has triggered by user interaction.
     */
    isInteracted: boolean;
    /**
     * Specifies that event argument when event raised by other event.
     */
    event: MouseEvent | KeyboardEvent;
    /**
     * It is used to denote the index of the selected element.
     */
    index: number;
    /**
     * It is used to check whether the element is checked or not.
     */
    isChecked?: boolean;
}
export interface ItemCreatedArgs {
    curData: {
        [key: string]: Object;
    };
    dataSource: {
        [key: string]: Object;
    } | string[];
    fields: FieldsMapping;
    item: HTMLElement;
    options: ListBaseOptions;
    text: string;
}
 }
export namespace maps { 

/**
 * exporting all modules from maps index
 */
/**
 * export all modules from maps component
 */
/**
 * Bing map src doc
 */
export  class BingMap {
    /**
     * map instance
     */
    private maps;
    constructor(maps: Maps);
    getBingMap(tile: Tile, key: string, type: BingMapType, language: string): string;
}
/**
 * Bubble module class
 */
export  class Bubble {
    private maps;
    bubbleCollection: Object[];
    /**
     * Bubble Id for current layer
     */
    id: string;
    constructor(maps: Maps);
    /**
     * To render bubble
     */
    renderBubble(bubbleSettings: BubbleSettingsModel, shapeData: object, color: string, range: {
        min: number;
        max: number;
    }, bubbleIndex: number, dataIndex: number, layerIndex: number, layer: LayerSettings, group: Element): void;
    private getPoints(shape, points);
    private getRatioOfBubble(min, max, value, minValue, maxValue);
    /**
     * To check and trigger bubble click event
     */
    bubbleClick(e: PointerEvent): void;
    /**
     * To get bubble from target id
     */
    private getbubble(target);
    /**
     * To check and trigger bubble move event
     */
    bubbleMove(e: PointerEvent): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the bubble.
     * @return {void}
     * @private
     */
    destroy(maps: Maps): void;
}
/**
 * ColorMapping class
 */
export  class ColorMapping {
    private maps;
    constructor(maps: Maps);
    /**
     * To get color based on shape settings.
     * @private
     */
    getShapeColorMapping(shapeSettings: ShapeSettingsModel, layerData: object, color: string): string;
    /**
     * To color by value and color mapping
     */
    getColorByValue(colorMapping: ColorMappingSettingsModel[], colorValue: number, equalValue: string): string;
}
/**
 * DataLabel class
 */
export  class DataLabel {
    private maps;
    private dataLabelObject;
    dataLabelCollections: Object[];
    private intersect;
    private value;
    constructor(maps: Maps);
    private getDataLabel(dataSource, labelPath, shapeName, shapeDataPath);
    renderLabel(layer: LayerSettings, layerIndex: number, shape: object, layerData: object[], group: Element, labelTemplateElement: HTMLElement, index: number): void;
    private getPoint(shapes, points);
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the layers.
     * @return {void}
     * @private
     */
    destroy(maps: Maps): void;
}
/**
 * To calculate and render the shape layer
 */
export  class LayerPanel {
    private mapObject;
    private currentFactor;
    private groupElements;
    private layerObject;
    private currentLayer;
    private rectBounds;
    private tiles;
    private clipRectElement;
    private layerGroup;
    private tileTranslatePoint;
    private urlTemplate;
    private isMapCoordinates;
    private exactBounds;
    private tileSvgObject;
    private ajaxModule;
    private ajaxProcessCount;
    private ajaxResponse;
    constructor(map: Maps);
    measureLayerPanel(): void;
    protected processLayers(layer: LayerSettings, layerIndex: number): void;
    private bubbleCalculation(bubbleSettings, range);
    calculatePathCollection(layerIndex: number, renderData: Object[]): void;
    /**
     *  render datalabel
     */
    private renderLabel(layer, layerIndex, shape, group, shapeIndex, labelTemplateEle);
    /**
     * To render path for multipolygon
     */
    private generateMultiPolygonPath(currentShapeData);
    /**
     * To render bubble
     */
    private renderBubble(layer, bubbleData, color, range, bubbleIndex, dataIndex, group, layerIndex, bubbleSettings);
    /**
     * To get the shape color from color mapping module
     */
    private getShapeColorMapping(layer, shape, color);
    generatePoints(type: string, coordinates: Object[], data: Object, properties: Object): void;
    calculateFactor(layer: LayerSettings): number;
    translateLayerElements(layerElement: Element, index: number): void;
    calculateRectBounds(layerData: Object[]): void;
    calculatePolygonBox(coordinates: Object[], data: Object, properties: Object): Object;
    calculateRectBox(coordinates: Object[]): void;
    generateTiles(zoomLevel: number, tileTranslatePoint: Point): void;
    arrangeTiles(): void;
    private templateCompiler(tiles);
    private panTileMap(factorX, factorY, centerPosition);
}
/**
 * Legend module class
 */
export  class Legend {
    legendCollection: Object[];
    legendRenderingCollections: Object[];
    private legendHeight;
    private legendWidth;
    private translate;
    private legendBorderRect;
    private maps;
    private totalPages;
    private page;
    private currentPage;
    private interactiveLocation;
    private legendItemRect;
    private heightIncrement;
    private widthIncrement;
    private textMaxWidth;
    private legendGroup;
    private previousId;
    private areaRect;
    constructor(maps: Maps);
    renderLegend(): void;
    calculateLegendBounds(): void;
    /**
     *
     */
    private getLegends(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);
    private getPageChanged();
    drawLegend(): void;
    private drawLegendItem(page);
    private renderLegendBorder();
    changeNextPage(e: PointerEvent): void;
    private getLegendAlignment(map, width, height, legend);
    private getMarkersLegendCollections(layerIndex, markers);
    private getRangeLegendCollection(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);
    private getOverallLegendItemsCollection(legendText, legendFill, legendData);
    private getEqualLegendCollection(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);
    private getDataLegendCollection(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);
    interactiveHandler(e: PointerEvent): void;
    private renderInteractivePointer(legend, fill, stroke, id, strokeWidth, rect);
    wireEvents(element: Element): void;
    addEventListener(): void;
    removeEventListener(): void;
    private getLegendData(layerIndex, dataIndex, data, dataPath, layerData, shapePropertyPath, value);
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the legend.
     * @return {void}
     * @private
     */
    destroy(maps: Maps): void;
}
/**
 * Marker class
 */
export  class Marker {
    private maps;
    private isMarkerExplode;
    private trackElements;
    private markerSVGObject;
    private previousExplodeId;
    constructor(maps: Maps);
    markerRender(layerElement: Element, layerIndex: number, factor: number): void;
    markerExplode(targetId: string, targetElement: Element): void;
    /**
     * @private
     */
    removeMarkerExplode(): void;
    private removeTrackElements();
    drawSymbol(shape: MarkerType, imageUrl: string, location: Point, markerID: string, shapeCustom: Object): Element;
    /**
     * To check and trigger marker click event
     */
    markerClick(e: PointerEvent): void;
    /**
     * To get marker from target id
     */
    private getMarker(target);
    /**
     * To check and trigger marker move event
     */
    markerMove(e: PointerEvent): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the layers.
     * @return {void}
     * @private
     */
    destroy(maps: Maps): void;
}
/**
 * navigation-selected-line
 */
export  class NavigationLine {
    private maps;
    constructor(maps: Maps);
    renderNavigation(layer: LayerSettings, factor: number, layerIndex: number): Element;
    private convertRadius(point1, point2);
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the layers.
     * @return {void}
     * @private
     */
    destroy(maps: Maps): void;
}
/**
 * Interface for a class Maps
 */
export interface MapsModel extends base.ComponentModel{
    /**
     * To configure the background of the maps container.
     * @default null
     */
    background?: string;
    /**
     * To enable the separator
     * @default false
     */
    useGroupingSeparator?: boolean;
    /**
     * To apply internationalization for maps
     * @default null
     */
    format?: string;
    /**
     * To configure width of maps.
     * @default null
     */
    width?: string;
    /**
     * To configure height of maps.
     * @default null
     */
    height?: string;
    /**
     * To configure the title settings of the maps.
     */
    titleSettings?: TitleSettingsModel;
    /**
     * To configure the zoom settings of the maps.
     */
    zoomSettings?: ZoomSettingsModel;
    /**
     * To configure the legend settings of the maps.
     */
    legendSettings?: LegendSettingsModel;
    /**
     * To configure the layers settings of the maps.
     */
    layers?: LayerSettingsModel[];
    /**
     *  Options for customizing the annotation of maps.
     */
    annotations?: AnnotationModel[];
    /**
     *  Options to customize left, right, top and bottom margins of the maps.
     */
    margin?: MarginModel;
    /**
     * Options for customizing the color and width of the maps border.
     */
    border?: BorderModel;
    /**
     * Specifies the theme for the maps.
     */
    theme?: MapsTheme;
    /**
     * Specifies the base.ProjectionType for the maps.
     */
    projectionType?: ProjectionType;
    /**
     * To configure baseMapIndex of maps. Option to select which layer to be visible.
     * @default 0
     */
    baseLayerIndex?: number;
    /**
     * Description for maps.
     * @default null
     */
    description?: string;
    /**
     * TabIndex value for the maps.
     * @default 1
     */
    tabIndex?: number;
    /**
     * To configure the zoom level of maps.
     * @default { latitude: null, longitude: null}
     */
    centerPosition?: { latitude: number, longitude: number };
    /**
     * To customization Maps area
     */
    mapsArea?: MapsAreaSettingsModel;
    /**
     * Triggers before maps rendered.
     * @event
     */
    load?: base.EmitType<ILoadEventArgs>;
    /**
     * Triggers before the prints gets started.
     * @event
     */
    beforePrint?: base.EmitType<IPrintEventArgs>;
    /**
     * Triggers after maps rendered.
     * @event
     */
    loaded?: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers on clicking the maps.
     * @event
     */
    click?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on double clicking the maps.
     * @event
     */
    doubleClick?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on right clicking the maps.
     * @event
     */
    rightClick?: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on resizing the maps.
     * @event
     */
    resize?: base.EmitType<IResizeEventArgs>;
    /**
     * Triggers before the maps tooltip rendered.
     * @event
     */
    tooltipRender?: base.EmitType<ITooltipRenderEventArgs>;
    /**
     * Triggers while clicking the shape
     * @event
     */
    shapeSelected?: base.EmitType<IShapeSelectedEventArgs>;
    /**
     * Triggers before selection applied
     * @event
     */
    itemSelection?: base.EmitType<ISelectionEventArgs>;
    /**
     * Trigger before highlight applied
     * @event
     */
    itemHighlight?: base.EmitType<ISelectionEventArgs>;
    /**
     * Triggers before highlight applied for shape
     * @event
     */
    shapeHighlight?: base.EmitType<IShapeSelectedEventArgs>;
    /**
     * Triggers before the maps layer rendered.
     * @event
     */
    layerRendering?: base.EmitType<ILayerRenderingEventArgs>;
    /**
     * Triggers before the maps shape rendered.
     * @event
     */
    shapeRendering?: base.EmitType<IShapeRenderingEventArgs>;
    /**
     * Triggers before the maps marker rendered.
     * @event
     */
    markerRendering?: base.EmitType<IMarkerRenderingEventArgs>;
    /**
     * Triggers event mouse clicking on the maps marker element.
     * @event
     */
    markerClick?: base.EmitType<IMarkerClickEventArgs>;
    /**
     * Triggers event mouse moving on the maps marker element.
     * @event
     */
    markerMouseMove?: base.EmitType<IMarkerMoveEventArgs>;
    /**
     * Triggers before the data label get rendered.
     * @event
     */
    dataLabelRendering?: base.EmitType<ILabelRenderingEventArgs>;
    /**
     * Triggers before the maps bubble rendered.
     * @event
     */
    bubbleRendering?: base.EmitType<IBubbleRenderingEventArgs>;
    /**
     * Triggers event mouse clicking on the maps bubble element.
     * @event
     */
    bubbleClick?: base.EmitType<IBubbleClickEventArgs>;
    /**
     * Triggers event mouse moving on the maps bubble element.
     * @event
     */
    bubbleMouseMove?: base.EmitType<IBubbleMoveEventArgs>;
    /**
     * Triggers after the animation completed.
     * @event
     */
    animationComplete?: base.EmitType<IAnimationCompleteEventArgs>;
    /**
     * Triggers before annotation rendering.
     * @event
     */
    annotationRendering?: base.EmitType<IAnnotationRenderingEventArgs>;
}
/**
 * Maps base.Component file
 */
/**
 * Represents the Maps control.
 * ```html
 * <div id="maps"/>
 * <script>
 *   var maps = new Maps();
 *   maps.appendTo("#maps");
 * </script>
 * ```
 */
export  class Maps extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /**
     * `bubbleModule` is used to add bubble to the maps.
     */
    bubbleModule: Bubble;
    /**
     * `markerModule` is used to add marker to the maps.
     */
    markerModule: Marker;
    /**
     * `dataLabelModule` is used to add datalabel to the maps.
     */
    dataLabelModule: DataLabel;
    /**
     * `highlightModule` is used to add highlight to the maps.
     */
    highlightModule: Highlight;
    /**
     * `navigationLineModule` is used to add navigationLine to the maps.
     */
    navigationLineModule: NavigationLine;
    /**
     * `legendModule` is used to add legend to the maps.
     */
    legendModule: Legend;
    /**
     * `selectionModule` is used to add selection to the maps.
     */
    selectionModule: Selection;
    /**
     * `mapsTooltipModule` is used to add tooltip to the maps.
     */
    mapsTooltipModule: MapsTooltip;
    /**
     * `zoomModule` is used to add zoom to the maps.
     */
    zoomModule: Zoom;
    /**
     *  annotationModule is used to place the any text or images into the maps.
     */
    annotationsModule: Annotations;
    /**
     * To configure the background of the maps container.
     * @default null
     */
    background: string;
    /**
     * To enable the separator
     * @default false
     */
    useGroupingSeparator: boolean;
    /**
     * To apply internationalization for maps
     * @default null
     */
    format: string;
    /**
     * To configure width of maps.
     * @default null
     */
    width: string;
    /**
     * To configure height of maps.
     * @default null
     */
    height: string;
    /**
     * To configure the title settings of the maps.
     */
    titleSettings: TitleSettingsModel;
    /**
     * To configure the zoom settings of the maps.
     */
    zoomSettings: ZoomSettingsModel;
    /**
     * To configure the legend settings of the maps.
     */
    legendSettings: LegendSettingsModel;
    /**
     * To configure the layers settings of the maps.
     */
    layers: LayerSettingsModel[];
    /**
     *  Options for customizing the annotation of maps.
     */
    annotations: AnnotationModel[];
    /**
     *  Options to customize left, right, top and bottom margins of the maps.
     */
    margin: MarginModel;
    /**
     * Options for customizing the color and width of the maps border.
     */
    border: BorderModel;
    /**
     * Specifies the theme for the maps.
     */
    theme: MapsTheme;
    /**
     * Specifies the ProjectionType for the maps.
     */
    projectionType: ProjectionType;
    /**
     * To configure baseMapIndex of maps. Option to select which layer to be visible.
     * @default 0
     */
    baseLayerIndex: number;
    /**
     * Description for maps.
     * @default null
     */
    description: string;
    /**
     * TabIndex value for the maps.
     * @default 1
     */
    tabIndex: number;
    /**
     * To configure the zoom level of maps.
     * @default { latitude: null, longitude: null}
     */
    centerPosition: {
        latitude: number;
        longitude: number;
    };
    /**
     * To customization Maps area
     */
    mapsArea: MapsAreaSettingsModel;
    /**
     * Triggers before maps rendered.
     * @event
     */
    load: base.EmitType<ILoadEventArgs>;
    /**
     * Triggers before the prints gets started.
     * @event
     */
    beforePrint: base.EmitType<IPrintEventArgs>;
    /**
     * Triggers after maps rendered.
     * @event
     */
    loaded: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers on clicking the maps.
     * @event
     */
    click: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on double clicking the maps.
     * @event
     */
    doubleClick: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on right clicking the maps.
     * @event
     */
    rightClick: base.EmitType<IMouseEventArgs>;
    /**
     * Triggers on resizing the maps.
     * @event
     */
    resize: base.EmitType<IResizeEventArgs>;
    /**
     * Triggers before the maps tooltip rendered.
     * @event
     */
    tooltipRender: base.EmitType<ITooltipRenderEventArgs>;
    /**
     * Triggers while clicking the shape
     * @event
     */
    shapeSelected: base.EmitType<IShapeSelectedEventArgs>;
    /**
     * Triggers before selection applied
     * @event
     */
    itemSelection: base.EmitType<ISelectionEventArgs>;
    /**
     * Trigger before highlight applied
     * @event
     */
    itemHighlight: base.EmitType<ISelectionEventArgs>;
    /**
     * Triggers before highlight applied for shape
     * @event
     */
    shapeHighlight: base.EmitType<IShapeSelectedEventArgs>;
    /**
     * Triggers before the maps layer rendered.
     * @event
     */
    layerRendering: base.EmitType<ILayerRenderingEventArgs>;
    /**
     * Triggers before the maps shape rendered.
     * @event
     */
    shapeRendering: base.EmitType<IShapeRenderingEventArgs>;
    /**
     * Triggers before the maps marker rendered.
     * @event
     */
    markerRendering: base.EmitType<IMarkerRenderingEventArgs>;
    /**
     * Triggers event mouse clicking on the maps marker element.
     * @event
     */
    markerClick: base.EmitType<IMarkerClickEventArgs>;
    /**
     * Triggers event mouse moving on the maps marker element.
     * @event
     */
    markerMouseMove: base.EmitType<IMarkerMoveEventArgs>;
    /**
     * Triggers before the data label get rendered.
     * @event
     */
    dataLabelRendering: base.EmitType<ILabelRenderingEventArgs>;
    /**
     * Triggers before the maps bubble rendered.
     * @event
     */
    bubbleRendering: base.EmitType<IBubbleRenderingEventArgs>;
    /**
     * Triggers event mouse clicking on the maps bubble element.
     * @event
     */
    bubbleClick: base.EmitType<IBubbleClickEventArgs>;
    /**
     * Triggers event mouse moving on the maps bubble element.
     * @event
     */
    bubbleMouseMove: base.EmitType<IBubbleMoveEventArgs>;
    /**
     * Triggers after the animation completed.
     * @event
     */
    animationComplete: base.EmitType<IAnimationCompleteEventArgs>;
    /**
     * Triggers before annotation rendering.
     * @event
     */
    annotationRendering: base.EmitType<IAnnotationRenderingEventArgs>;
    /**
     * Format method
     * @private
     */
    formatFunction: Function;
    /**
     * svg renderer object.
     * @private
     */
    renderer: base.SvgRenderer;
    /**
     * maps svg element's object
     * @private
     */
    svgObject: Element;
    /**
     * Maps available height, width
     * @private
     */
    availableSize: Size;
    /**
     * localization object
     * @private
     */
    localeObject: base.L10n;
    /**
     * It contains default values of localization values
     */
    private defaultLocalConstants;
    /**
     * Internal use of internationalization instance.
     * @private
     */
    intl: base.Internationalization;
    /**
     * Check layer whether is normal or tile
     * @private
     */
    isTileMap: boolean;
    /**
     * Resize the map
     */
    private resizeTo;
    /**
     * @private
     * Stores the map area rect
     */
    mapAreaRect: Rect;
    /**
     * @private
     * Stores layers collection for rendering
     */
    layersCollection: LayerSettings[];
    /**
     * @private
     * Calculate the axes bounds for map.
     * @hidden
     */
    mapLayerPanel: LayerPanel;
    /**
     * @private
     * Render the data label.
     * @hidden
     */
    dataLabel: DataLabel;
    /** @private */
    isTouch: boolean;
    /** @private */
    baseSize: Size;
    /** @private */
    scale: number;
    /** @private */
    baseScale: number;
    /** @private */
    baseMapBounds: GeoLocation;
    /** @private */
    baseMapRectBounds: Object;
    /** @private */
    translatePoint: Point;
    /** @private */
    baseTranslatePoint: Point;
    /** @private */
    tileTranslatePoint: Point;
    /** @private */
    baseTileTranslatePoint: Point;
    /** @private */
    isDevice: Boolean;
    /** @private */
    tileZoomLevel: number;
    /** @private */
    serverProcess: Object;
    /** @private */
    previousScale: number;
    /** @private */
    previousPoint: Point;
    /**
     * Constructor for creating the widget
     */
    constructor(options?: MapsModel, element?: string | HTMLElement);
    /**
     * Gets the localized label by locale keyword.
     * @param  {string} key
     * @return {string}
     */
    getLocalizedLabel(key: string): string;
    /**
     * Initializing pre-required values.
     */
    protected preRender(): void;
    private setTextStyle(theme, font);
    /**
     * To change font styles of map based on themes
     */
    private themeEffect();
    /**
     * To change datalabel font
     * @param layers
     * @param style
     */
    private setLabelFont(layers, style);
    /**
     * To Initialize the control rendering.
     */
    protected render(): void;
    protected processRequestJsonData(): void;
    processResponseJsonData(type?: string, data?: object | string, layer?: LayerSettings): void;
    private renderMap();
    /**
     * Render the map area border
     */
    private renderArea();
    /**
     * To add tab index for map element
     */
    private addTabIndex();
    private zoomingChange();
    private createSecondaryElement();
    private arrangeTemplate();
    private createTile();
    /**
     * To initilize the private varibales of maps.
     */
    private initPrivateVariable();
    private findBaseAndSubLayers();
    /**
     * @private
     * Render the map border
     */
    private renderBorder();
    /**
     * @private
     * Render the title and subtitle
     */
    private renderTitle(title, type, bounds, groupEle);
    /**
     * To create svg element for maps
     */
    private createSVG();
    /**
     * To Remove the SVG
     */
    private removeSvg();
    /**
     * To bind event handlers for maps.
     */
    private wireEVents();
    /**
     * To unbind event handlers from maps.
     */
    private unWireEVents();
    /**
     * To handle the click event for the maps.
     */
    mapsOnClick(e: PointerEvent): void;
    /**
     * To handle the right click event for the maps.
     */
    /**
     *
     */
    mouseEndOnMap(e: PointerEvent): boolean;
    /**
     *
     */
    mouseDownOnMap(e: PointerEvent): void;
    /**
     * To handle the double click event for the maps.
     */
    mapsOnDoubleClick(e: PointerEvent): void;
    /**
     *
     */
    mouseMoveOnMap(e: PointerEvent): void;
    /**
     * To handle the window resize event on maps.
     */
    mapsOnResize(e: Event): boolean;
    zoomByPosition(centerPosition: {
        latitude: number;
        longitude: number;
    }, zoomFactor: number): void;
    /**
     * To add layers to maps
     */
    addLayer(layer: LayerSettingsModel): void;
    /**
     * To remove layers from maps
     */
    removeLayer(index: number): void;
    /**
     * To add marker to layers
     */
    addMarker(layerIndex: number, marker: MarkerSettingsModel): void;
    /**
     * Method to set culture for maps
     */
    private setCulture();
    /**
     * Method to set locale constants
     */
    private setLocaleConstants();
    /**
     * To destroy maps control.
     */
    destroy(): void;
    /**
     * Get component name
     */
    getModuleName(): string;
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    getPersistData(): string;
    /**
     * Called internally if any of the property value changed.
     * @private
     */
    onPropertyChanged(newProp: MapsModel, oldProp: MapsModel): void;
    /**
     * To provide the array of modules needed for maps rendering
     * @return {base.ModuleDeclaration[]}
     * @private
     */
    requiredModules(): base.ModuleDeclaration[];
    /**
     * To find marker visibility
     */
    private isMarkersVisible();
    /**
     * To find DataLabel visibility
     */
    private isDataLabelVisible();
    /**
     * To find navigation line visibility
     */
    private isNavigationVisible();
    /**
     * To find marker visibility
     */
    private isBubbleVisible();
    /**
     * To find the bubble visibility from layer
     * @private
     */
    getBubbleVisible(layer: LayerSettingsModel): boolean;
    /**
     * Handles the print method for chart control.
     */
    print(id?: string[] | string | Element): void;
    /**
     * Handles the export method for chart control.
     * @param type
     * @param fileName
     */
    export(type: ExportType, fileName: string, orientation?: pdfexport.PdfPageOrientation): void;
    /**
     * To find visibility of layers and markers for required modules load.
     */
    private findVisibleLayers(layers, isLayerVisible?, isBubblevisible?, istooltipVisible?, isSelection?, isHighlight?);
}
/**
 * Interface for a class Annotation
 */
export interface AnnotationModel {
    /**
     * Specifies the id of html element.
     */
    content?: string;
    /**
     * Specifies the position of x.
     */
    x?: string;
    /**
     * Specifies the position of y.
     */
    y?: string;
    /**
     * Specifies the vertical alignment of annotation.
     */
    verticalAlignment?: AnnotationAlignment;
    /**
     * Specifies the horizontal alignment of annotation.
     */
    horizontalAlignment?: AnnotationAlignment;
    /**
     * Specifies the zIndex of the annotation.
     * @default '-1'
     */
    zIndex?: string;
}
/**
 * Interface for a class Arrow
 */
export interface ArrowModel {
    /**
     * arrowPosition
     */
    position?: string;
    /**
     * show
     */
    showArrow?: boolean;
    /**
     * size
     */
    size?: number;
    /**
     * color
     */
    color?: string;
    /**
     * offset the arrow in navigation line by specified pixels
     */
    offSet?: number;
}
/**
 * Interface for a class Font
 */
export interface FontModel {
    /**
     * Font size for the text.
     */
    size?: string;
    /**
     * Color for the text.
     */
    color?: string;
    /**
     * FontFamily for the text.
     */
    fontFamily?: string;
    /**
     * FontWeight for the text.
     */
    fontWeight?: string;
    /**
     * FontStyle for the text.
     */
    fontStyle?: string;
    /**
     * Opacity for the text.
     */
    opacity?: number;
}
/**
 * Interface for a class Border
 */
export interface BorderModel {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     */
    color?: string;
    /**
     * The width of the border in pixels.
     */
    width?: number;
}
/**
 * Interface for a class TooltipSettings
 */
export interface TooltipSettingsModel {
    /**
     * Toggle the tooltip visibility.
     * @default false
     */
    visible?: boolean;
    /**
     * To customize the tooltip template.
     * @default ''
     */
    template?: string;
    /**
     * To customize the fill color of the tooltip.
     * @default '#363F4C'
     */
    fill?: string;
    /**
     * Options for customizing the color and width of the tooltip.
     */
    border?: BorderModel;
    /**
     * Options for customizing text styles of the tooltip.
     */
    textStyle?: FontModel;
    /**
     * To customize the format of the tooltip.
     * @default null
     */
    format?: string;
    /**
     * To customize the value of the tooltip.
     * @default null
     */
    valuePath?: string;
}
/**
 * Interface for a class Margin
 */
export interface MarginModel {
    /**
     * Left margin in pixels.
     * @default 10
     */
    left?: number;
    /**
     * Right margin in pixels.
     * @default 10
     */
    right?: number;
    /**
     * Top margin in pixels.
     * @default 10
     */
    top?: number;
    /**
     * Bottom margin in pixels.
     * @default 10
     */
    bottom?: number;
}
/**
 * Interface for a class ColorMappingSettings
 */
export interface ColorMappingSettingsModel {
    /**
     * To configure from
     * @default null
     */
    from?: number;
    /**
     * To configure to
     * @default null
     */
    to?: number;
    /**
     * To configure value
     * @default null
     */
    value?: string;
    /**
     * To configure color
     * @default null
     */
    color?: string;
    /**
     * To configure labels
     * @default null
     */
    label?: string;
}
/**
 * Interface for a class SelectionSettings
 */
export interface SelectionSettingsModel {
    /**
     * Toggle the selection settings.
     * @default false
     */
    enable?: boolean;
    /**
     * To customize the fill color of the Selection.
     * @default '#D2691E'
     */
    fill?: string;
    /**
     * To customize the opacity of the Selection.
     * @default 1
     */
    opacity?: number;
    /**
     * Toggle the multi selection.
     * @default false
     */
    enableMultiSelect?: boolean;
    /**
     * Options for customizing the color and width of the selection.
     */
    border?: BorderModel;
}
/**
 * Interface for a class HighlightSettings
 */
export interface HighlightSettingsModel {
    /**
     * To customize the fill color of the highlight.
     * @default '#6B8E23'
     */
    fill?: string;
    /**
     * Toggle the highlight settings.
     * @default false
     */
    enable?: boolean;
    /**
     * To customize the opacity of the highlight.
     * @default 1
     */
    opacity?: number;
    /**
     * Options for customizing the color and width of the highlight.
     */
    border?: BorderModel;
}
/**
 * Interface for a class NavigationLineSettings
 */
export interface NavigationLineSettingsModel {
    /**
     * NavigationSelectedLine visible
     *  @default false
     */
    visible?: boolean;
    /**
     * Configures the label border
     * @default 1
     */
    width?: number;
    /**
     * NavigationSelectedLine longitude
     *  @default []
     */
    longitude?: number[];
    /**
     * NavigationSelectedLine latitude
     *  @default []
     */
    latitude?: number[];
    /**
     * dashArray
     *  @default ''
     */
    dashArray?: string;
    /**
     * NavigationSelectedLine color
     */
    color?: string;
    /**
     * Specifies the angle of curve connecting different locations in map
     * @default 0
     */
    angle?: number;
    /**
     * arrow
     */
    arrowSettings?: ArrowModel;
    /**
     * To configure the selection settings of the maps.
     */
    selectionSettings?: SelectionSettingsModel;
    /**
     * To configure the highlight settings of the maps.
     */
    highlightSettings?: HighlightSettingsModel;
}
/**
 * Interface for a class BubbleSettings
 */
export interface BubbleSettingsModel {
    /**
     * Configures the bubble border
     */
    border?: BorderModel;
    /**
     * Toggle the visibility of bubble
     * @default false
     */
    visible?: boolean;
    /**
     * Specifies the data source for bubble.
     * @default []
     */
    dataSource?: object[];
    /**
     * To configure bubble animation duration
     * @default 1000
     */
    animationDuration?: number;
    /**
     * Animation duration
     * @default 0
     */
    animationDelay?: number;
    /**
     * To configure bubble fill color
     * @default ''
     */
    fill?: string;
    /**
     * To configure bubble minRadius
     * @default 10
     */
    minRadius?: number;
    /**
     * To configure bubble maxRadius
     * @default 20
     */
    maxRadius?: number;
    /**
     * To configure bubble opacity
     * @default 1
     */
    opacity?: number;
    /**
     * To configure bubble valuePath
     * @default null
     */
    valuePath?: string;
    /**
     * To configure bubble shape type
     * @default Circle
     */
    bubbleType?: BubbleType;
    /**
     * To configure bubble colorValuePath
     * @default null
     */
    colorValuePath?: string;
    /**
     * To configure bubble colorMapping
     * @default []
     */
    colorMapping?: ColorMappingSettingsModel[];
    /**
     * To configure the tooltip settings of the bubble .
     */
    tooltipSettings?: TooltipSettingsModel;
    /**
     * To configure the selection settings of the maps.
     */
    selectionSettings?: SelectionSettingsModel;
    /**
     * To configure the highlight settings of the maps.
     */
    highlightSettings?: HighlightSettingsModel;
}
/**
 * Interface for a class CommonTitleSettings
 */
export interface CommonTitleSettingsModel {
    /**
     * To customize the text of the title.
     * @default ''
     */
    text?: string;
    /**
     * To customize title description for the accessibility.
     * @default ''
     */
    description?: string;
}
/**
 * Interface for a class SubTitleSettings
 */
export interface SubTitleSettingsModel extends CommonTitleSettingsModel{
    /**
     * Options for customizing title styles of the Maps.
     */
    textStyle?: FontModel;
    /**
     * text alignment
     */
    alignment?: Alignment;
}
/**
 * Interface for a class TitleSettings
 */
export interface TitleSettingsModel extends CommonTitleSettingsModel{
    /**
     * Options for customizing title styles of the Maps.
     */
    textStyle?: FontModel;
    /**
     * text alignment
     */
    alignment?: Alignment;
    /**
     * To configure sub title of maps.
     */
    subtitleSettings?: SubTitleSettingsModel;
}
/**
 * Interface for a class ZoomSettings
 */
export interface ZoomSettingsModel {
    /**
     * Toggle the visibility of zooming.
     * @default false
     */
    enable?: boolean;
    /**
     * Configures tool bar orientation
     */
    toolBarOrientation?: Orientation;
    /**
     * Specifies the tool bar color.
     */
    color?: string;
    /**
     * Specifies the tool bar highlight color.
     */
    highlightColor?: string;
    /**
     * Specifies the tool bar selection color.
     * 
     */
    selectionColor?: string;
    /**
     * Configures vertical placement of tool bar 
     */
    horizontalAlignment?: Alignment;
    /**
     * Configures vertical placement of tool bar 
     */
    verticalAlignment?: Alignment;
    /**
     * To configure zooming items.
     */
    toolbars?: string[];
    /**
     * Toggle the mouse wheel zooming.
     * @default true
     */
    mouseWheelZoom?: boolean;
    /**
     * Double tab zooming
     * @default false
     */
    doubleClickZoom?: boolean;
    /**
     * Toggle the pinch zooming.
     * @default true
     */
    pinchZooming?: boolean;
    /**
     * Toggle the selection on zooming.
     * @default false
     */
    zoomOnClick?: boolean;
    /**
     * Configures zoom factor.
     * @default 1
     */
    zoomFactor?: number;
    /**
     * Configures max zooming.
     * @default 10
     */
    maxZoom?: number;
    /**
     * Configures minimum zooming.
     * @default 1
     */
    minZoom?: number;
}
/**
 * Interface for a class LegendSettings
 */
export interface LegendSettingsModel {
    /**
     * Toggle the legend selection
     * @default false
     */
    toggleVisibility?: boolean;
    /**
     * Toggle the legend visibility.
     * @default false
     */
    visible?: boolean;
    /**
     * Customize the legend background
     * @default transparent
     */
    background?: string;
    /**
     * base.Type of the legend rendering
     */
    type?: LegendType;
    /**
     * Inverted pointer for interactive legend
     */
    invertedPointer?: boolean;
    /**
     * To place the label position for interactive legend.
     */
    labelPosition?: LabelPosition;
    /**
     * Specifies the label intersect action.
     */
    labelDisplayMode?: LabelIntersectAction;
    /**
     * Customize the legend shape of the maps.
     * @default Circle
     */
    shape?: LegendShape;
    /**
     * Customize the legend width of the maps.
     * @default ''
     */
    width?: string;
    /**
     * Customize the legend height of the maps.
     * @default ''
     */
    height?: string;
    /**
     * Options for customizing text styles of the legend.
     */
    textStyle?: FontModel;
    /**
     * Customize the legend width of the maps.
     * @default 15
     */
    shapeWidth?: number;
    /**
     * Customize the legend height of the maps.
     * @default 15
     */
    shapeHeight?: number;
    /**
     * Customize the shape padding
     * @default 10
     */
    shapePadding?: number;
    /**
     * Options for customizing the color and width of the legend border.
     */
    border?: BorderModel;
    /**
     * Options for customizing the color and width of the shape border.
     */
    shapeBorder?: BorderModel;
    /**
     * To configure the title of the legend.
     */
    title?: CommonTitleSettingsModel;
    /**
     * Options for customizing text styles of the legend.
     */
    titleStyle?: FontModel;
    /**
     * Customize the legend position of the maps.
     * @default Bottom
     */
    position?: LegendPosition;
    /**
     * Customize the legend alignment of the maps.
     * @default Center
     */
    alignment?: Alignment;
    /**
     * Customize the legend items placed
     */
    orientation?: LegendArrangement;
    /**
     * Customize the legend placed by given x and y values. 
     */
    location?: Point;
    /**
     * Specifies the legend shape color
     */
    fill?: string;
    /**
     * Customize the legend mode.
     * @default Default
     */
    mode?: LegendMode;
}
/**
 * Interface for a class DataLabelSettings
 */
export interface DataLabelSettingsModel {
    /**
     * Toggle the data label visibility.
     * @default false
     */
    visible?: boolean;
    /**
     * Configures the label border
     */
    border?: BorderModel;
    /**
     * configure the fill
     */
    fill?: string;
    /**
     * configure the label opacity
     */
    opacity?: number;
    /**
     * rectangle rx 
     * @default 10
     */
    rx?: number;
    /**
     * ry value
     * @default 10
     */
    ry?: number;
    /**
     * Options for customizing text styles of the data label.
     */
    textStyle?: FontModel;
    /**
     * To customize the label path values.
     * @default ''
     */
    labelPath?: string;
    /**
     * To customize the smartLabels.
     * @default none
     */
    smartLabelMode?: SmartLabelMode;
    /**
     * intersection action
     */
    intersectionAction?: IntersectAction;
    /**
     * To customize the data label template.
     * @default ''
     */
    template?: string;
}
/**
 * Interface for a class ShapeSettings
 */
export interface ShapeSettingsModel {
    /**
     * To customize the fill color of the shape.
     * @default '#A6A6A6'
     */
    fill?: string;
    /**
     * To customize the palette of the shape.
     * @default []
     */
    palette?: string[];
    /**
     * Customize the radius for points
     */
    circleRadius?: number;
    /**
     * Options for customizing the color and width of the shape.
     */
    border?: BorderModel;
    /**
     * Dash array of line
     */
    dashArray?: string;
    /**
     * To customize the opacity of the shape.
     * @default 1
     */
    opacity?: number;
    /**
     * To customize the colorValuePath of the shape.
     * @default null
     */
    colorValuePath?: string;
    /**
     * To customize the valuePath of the shape.
     * @default null
     */
    valuePath?: string;
    /**
     * To configure shape colorMapping
     * @default []
     */
    colorMapping?: ColorMappingSettingsModel[];
    /**
     * Toggle the auto fill.
     * @default false
     */
    autofill?: boolean;
}
/**
 * Interface for a class MarkerSettings
 */
export interface MarkerSettingsModel {
    /**
     * Options for customizing the color and width of the marker.
     */
    border?: BorderModel;
    /**
     * Options for customizing the dash array options
     */
    dashArray?: string;
    /**
     * Toggle the visibility of the marker.
     * @default false
     */
    visible?: boolean;
    /**
     * To customize the fill color of the marker.
     * @default '#FF471A'
     */
    fill?: string;
    /**
     * To customize the height of the marker.
     * @default 1
     */
    height?: number;
    /**
     * To customize the width of the marker.
     * @default 1
     */
    width?: number;
    /**
     * To customize the opacity of the marker.
     * @default 1
     */
    opacity?: number;
    /**
     * To customize the shape of the marker.
     * @default Balloon
     */
    shape?: MarkerType;
    /**
     * To provide the dataSource field to display legend text
     * @default ''
     */
    legendText?: string;
    /**
     * To move the marker by setting offset values
     */
    offset?: Point;
    /**
     * To provide the image url for rendering marker image
     */
    imageUrl?: string;
    /**
     * To customize the template of the marker.
     * @default null
     */
    template?: string;
    /**
     * To configure the dataSource of the marker.
     * @default []
     */
    dataSource?: Object[];
    /**
     * To configure the tooltip settings of the maps marker.
     */
    tooltipSettings?: TooltipSettingsModel;
    /**
     * Animation duration time
     * @default 1000
     */
    animationDuration?: number;
    /**
     * Animation delay time
     * @default 0
     */
    animationDelay?: number;
    /**
     * To configure the selection settings of the maps.
     */
    selectionSettings?: SelectionSettingsModel;
    /**
     * To configure the highlight settings of the maps.
     */
    highlightSettings?: HighlightSettingsModel;
}
/**
 * Interface for a class LayerSettings
 */
export interface LayerSettingsModel {
    /**
     * Specifies the shape data for the layer.
     * @default null
     */
    shapeData?: Object | data.DataManager | base.Ajax;
    /**
     * Specifies the query to select particular data from the shape data. 
     * This property is applicable only when the DataSource is `ej.data.DataManager`.
     * @default null
     */
    query?: data.Query;
    /**
     * Specifies the shape properties 
     */
    shapeSettings?: ShapeSettingsModel;
    /**
     * Specifies the data source for the layer.
     * @default []
     */
    dataSource?: object[];
    /**
     * Specifies the type for the layer.
     * @default Layer
     */
    type?: Type;
    /**
     * Specifies the geometry type
     */
    geometryType?: GeometryType;
    /**
     * Specifies the type for the bing map.
     * @default Aerial
     */
    bingMapType?: BingMapType;
    /**
     * Specifies the key for the layer.
     * @default ''
     */
    key?: string;
    /**
     * Specifies the layerType for the layer.
     * @default Geometry
     */
    layerType?: ShapeLayerType;
    /**
     * Specifies the urlTemplate for the layer.
     * @default 'http://a.tile.openstreetmap.org/level/tileX/tileY.png'
     */
    urlTemplate?: string;
    /**
     * Toggle the visibility of the layers.
     * @default true
     */
    visible?: boolean;
    /**
     * Specifies the shapeDataPath for the layer.
     * @default 'name'
     */
    shapeDataPath?: string;
    /**
     * Specifies the shapePropertyPath for the layer.
     * @default 'name'
     */
    shapePropertyPath?: string;
    /**
     * Specifies the animation duration for the layer.
     * @default `500`
     */
    animationDuration?: number;
    /**
     * To configure the marker settings.
     */
    markerSettings?: MarkerSettingsModel[];
    /**
     * To configure the datalabel settings of the maps.
     */
    dataLabelSettings?: DataLabelSettingsModel;
    /**
     * To configure the bubble settings of the maps.
     */
    bubbleSettings?: BubbleSettingsModel[];
    /**
     * navigationLineSetting
     */
    navigationLineSettings?: NavigationLineSettingsModel[];
    /**
     * To configure the tooltip settings of the maps layer.
     */
    tooltipSettings?: TooltipSettingsModel;
    /**
     * To configure the selection settings of the maps.
     */
    selectionSettings?: SelectionSettingsModel;
    /**
     * To configure the highlight settings of the maps.
     */
    highlightSettings?: HighlightSettingsModel;
}
/**
 * Interface for a class Tile
 */
export interface TileModel {
}
/**
 * Interface for a class MapsAreaSettings
 */
export interface MapsAreaSettingsModel {
    /**
     * To configure maps area background color
     */
    background?: string;
    /**
     * Options for customizing the color and width of maps area.
     */
    border?: BorderModel;
}
/**
 * Maps base doc
 */
/**
 * Options for customizing the annotation.
 */
export  class Annotation extends base.ChildProperty<Annotation> {
    /**
     * Specifies the id of html element.
     */
    content: string;
    /**
     * Specifies the position of x.
     */
    x: string;
    /**
     * Specifies the position of y.
     */
    y: string;
    /**
     * Specifies the vertical alignment of annotation.
     */
    verticalAlignment: AnnotationAlignment;
    /**
     * Specifies the horizontal alignment of annotation.
     */
    horizontalAlignment: AnnotationAlignment;
    /**
     * Specifies the zIndex of the annotation.
     * @default '-1'
     */
    zIndex: string;
}
export  class Arrow extends base.ChildProperty<Arrow> {
    /**
     * arrowPosition
     */
    position: string;
    /**
     * show
     */
    showArrow: boolean;
    /**
     * size
     */
    size: number;
    /**
     * color
     */
    color: string;
    /**
     * offset the arrow in navigation line by specified pixels
     */
    offSet: number;
}
/**
 * Configures the fonts in maps.
 */
export  class Font extends base.ChildProperty<Font> {
    /**
     * Font size for the text.
     */
    size: string;
    /**
     * Color for the text.
     */
    color: string;
    /**
     * FontFamily for the text.
     */
    fontFamily: string;
    /**
     * FontWeight for the text.
     */
    fontWeight: string;
    /**
     * FontStyle for the text.
     */
    fontStyle: string;
    /**
     * Opacity for the text.
     */
    opacity: number;
}
/**
 * Configures the borders in the maps.
 */
export  class Border extends base.ChildProperty<Border> {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     */
    color: string;
    /**
     * The width of the border in pixels.
     */
    width: number;
}
/**
 * To configure the tooltip settings of the maps.
 */
export  class TooltipSettings extends base.ChildProperty<TooltipSettings> {
    /**
     * Toggle the tooltip visibility.
     * @default false
     */
    visible: boolean;
    /**
     * To customize the tooltip template.
     * @default ''
     */
    template: string;
    /**
     * To customize the fill color of the tooltip.
     * @default '#363F4C'
     */
    fill: string;
    /**
     * Options for customizing the color and width of the tooltip.
     */
    border: BorderModel;
    /**
     * Options for customizing text styles of the tooltip.
     */
    textStyle: FontModel;
    /**
     * To customize the format of the tooltip.
     * @default null
     */
    format: string;
    /**
     * To customize the value of the tooltip.
     * @default null
     */
    valuePath: string;
}
/**
 * Configures the maps margins.
 */
export  class Margin extends base.ChildProperty<Margin> {
    /**
     * Left margin in pixels.
     * @default 10
     */
    left: number;
    /**
     * Right margin in pixels.
     * @default 10
     */
    right: number;
    /**
     * Top margin in pixels.
     * @default 10
     */
    top: number;
    /**
     * Bottom margin in pixels.
     * @default 10
     */
    bottom: number;
}
/**
 * To configure ColorMapping in Maps
 */
export  class ColorMappingSettings extends base.ChildProperty<ColorMappingSettings> {
    /**
     * To configure from
     * @default null
     */
    from: number;
    /**
     * To configure to
     * @default null
     */
    to: number;
    /**
     * To configure value
     * @default null
     */
    value: string;
    /**
     * To configure color
     * @default null
     */
    color: string;
    /**
     * To configure labels
     * @default null
     */
    label: string;
}
/**
 * To configure the selection settings
 */
export  class SelectionSettings extends base.ChildProperty<SelectionSettings> {
    /**
     * Toggle the selection settings.
     * @default false
     */
    enable: boolean;
    /**
     * To customize the fill color of the Selection.
     * @default '#D2691E'
     */
    fill: string;
    /**
     * To customize the opacity of the Selection.
     * @default 1
     */
    opacity: number;
    /**
     * Toggle the multi selection.
     * @default false
     */
    enableMultiSelect: boolean;
    /**
     * Options for customizing the color and width of the selection.
     */
    border: BorderModel;
}
/**
 * To configure the highlight settings
 */
export  class HighlightSettings extends base.ChildProperty<HighlightSettings> {
    /**
     * To customize the fill color of the highlight.
     * @default '#6B8E23'
     */
    fill: string;
    /**
     * Toggle the highlight settings.
     * @default false
     */
    enable: boolean;
    /**
     * To customize the opacity of the highlight.
     * @default 1
     */
    opacity: number;
    /**
     * Options for customizing the color and width of the highlight.
     */
    border: BorderModel;
}
/**
 * NavigationSelectedLine
 */
export  class NavigationLineSettings extends base.ChildProperty<NavigationLineSettings> {
    /**
     * NavigationSelectedLine visible
     *  @default false
     */
    visible: boolean;
    /**
     * Configures the label border
     * @default 1
     */
    width: number;
    /**
     * NavigationSelectedLine longitude
     *  @default []
     */
    longitude: number[];
    /**
     * NavigationSelectedLine latitude
     *  @default []
     */
    latitude: number[];
    /**
     * dashArray
     *  @default ''
     */
    dashArray: string;
    /**
     * NavigationSelectedLine color
     */
    color: string;
    /**
     * Specifies the angle of curve connecting different locations in map
     * @default 0
     */
    angle: number;
    /**
     * arrow
     */
    arrowSettings: ArrowModel;
    /**
     * To configure the selection settings of the maps.
     */
    selectionSettings: SelectionSettingsModel;
    /**
     * To configure the highlight settings of the maps.
     */
    highlightSettings: HighlightSettingsModel;
}
/**
 * Bubble settings model class
 */
export  class BubbleSettings extends base.ChildProperty<BubbleSettings> {
    /**
     * Configures the bubble border
     */
    border: BorderModel;
    /**
     * Toggle the visibility of bubble
     * @default false
     */
    visible: boolean;
    /**
     * Specifies the data source for bubble.
     * @default []
     */
    dataSource: object[];
    /**
     * To configure bubble animation duration
     * @default 1000
     */
    animationDuration: number;
    /**
     * Animation duration
     * @default 0
     */
    animationDelay: number;
    /**
     * To configure bubble fill color
     * @default ''
     */
    fill: string;
    /**
     * To configure bubble minRadius
     * @default 10
     */
    minRadius: number;
    /**
     * To configure bubble maxRadius
     * @default 20
     */
    maxRadius: number;
    /**
     * To configure bubble opacity
     * @default 1
     */
    opacity: number;
    /**
     * To configure bubble valuePath
     * @default null
     */
    valuePath: string;
    /**
     * To configure bubble shape type
     * @default Circle
     */
    bubbleType: BubbleType;
    /**
     * To configure bubble colorValuePath
     * @default null
     */
    colorValuePath: string;
    /**
     * To configure bubble colorMapping
     * @default []
     */
    colorMapping: ColorMappingSettingsModel[];
    /**
     * To configure the tooltip settings of the bubble .
     */
    tooltipSettings: TooltipSettingsModel;
    /**
     * To configure the selection settings of the maps.
     */
    selectionSettings: SelectionSettingsModel;
    /**
     * To configure the highlight settings of the maps.
     */
    highlightSettings: HighlightSettingsModel;
}
/**
 * To configure title of the maps.
 */
export  class CommonTitleSettings extends base.ChildProperty<CommonTitleSettings> {
    /**
     * To customize the text of the title.
     * @default ''
     */
    text: string;
    /**
     * To customize title description for the accessibility.
     * @default ''
     */
    description: string;
}
/**
 * To configure subtitle of the maps.
 */
export  class SubTitleSettings extends CommonTitleSettings {
    /**
     * Options for customizing title styles of the Maps.
     */
    textStyle: FontModel;
    /**
     * text alignment
     */
    alignment: Alignment;
}
/**
 * To configure title of the maps.
 */
export  class TitleSettings extends CommonTitleSettings {
    /**
     * Options for customizing title styles of the Maps.
     */
    textStyle: FontModel;
    /**
     * text alignment
     */
    alignment: Alignment;
    /**
     * To configure sub title of maps.
     */
    subtitleSettings: SubTitleSettingsModel;
}
/**
 * Options to configure maps Zooming Settings.
 */
export  class ZoomSettings extends base.ChildProperty<ZoomSettings> {
    /**
     * Toggle the visibility of zooming.
     * @default false
     */
    enable: boolean;
    /**
     * Configures tool bar orientation
     */
    toolBarOrientation: Orientation;
    /**
     * Specifies the tool bar color.
     */
    color: string;
    /**
     * Specifies the tool bar highlight color.
     */
    highlightColor: string;
    /**
     * Specifies the tool bar selection color.
     *
     */
    selectionColor: string;
    /**
     * Configures vertical placement of tool bar
     */
    horizontalAlignment: Alignment;
    /**
     * Configures vertical placement of tool bar
     */
    verticalAlignment: Alignment;
    /**
     * To configure zooming items.
     */
    toolbars: string[];
    /**
     * Toggle the mouse wheel zooming.
     * @default true
     */
    mouseWheelZoom: boolean;
    /**
     * Double tab zooming
     * @default false
     */
    doubleClickZoom: boolean;
    /**
     * Toggle the pinch zooming.
     * @default true
     */
    pinchZooming: boolean;
    /**
     * Toggle the selection on zooming.
     * @default false
     */
    zoomOnClick: boolean;
    /**
     * Configures zoom factor.
     * @default 1
     */
    zoomFactor: number;
    /**
     * Configures max zooming.
     * @default 10
     */
    maxZoom: number;
    /**
     * Configures minimum zooming.
     * @default 1
     */
    minZoom: number;
}
/**
 * Configures the legend settings.
 */
export  class LegendSettings extends base.ChildProperty<LegendSettings> {
    /**
     * Toggle the legend selection
     * @default false
     */
    toggleVisibility: boolean;
    /**
     * Toggle the legend visibility.
     * @default false
     */
    visible: boolean;
    /**
     * Customize the legend background
     * @default transparent
     */
    background: string;
    /**
     * Type of the legend rendering
     */
    type: LegendType;
    /**
     * Inverted pointer for interactive legend
     */
    invertedPointer: boolean;
    /**
     * To place the label position for interactive legend.
     */
    labelPosition: LabelPosition;
    /**
     * Specifies the label intersect action.
     */
    labelDisplayMode: LabelIntersectAction;
    /**
     * Customize the legend shape of the maps.
     * @default Circle
     */
    shape: LegendShape;
    /**
     * Customize the legend width of the maps.
     * @default ''
     */
    width: string;
    /**
     * Customize the legend height of the maps.
     * @default ''
     */
    height: string;
    /**
     * Options for customizing text styles of the legend.
     */
    textStyle: FontModel;
    /**
     * Customize the legend width of the maps.
     * @default 15
     */
    shapeWidth: number;
    /**
     * Customize the legend height of the maps.
     * @default 15
     */
    shapeHeight: number;
    /**
     * Customize the shape padding
     * @default 10
     */
    shapePadding: number;
    /**
     * Options for customizing the color and width of the legend border.
     */
    border: BorderModel;
    /**
     * Options for customizing the color and width of the shape border.
     */
    shapeBorder: BorderModel;
    /**
     * To configure the title of the legend.
     */
    title: CommonTitleSettingsModel;
    /**
     * Options for customizing text styles of the legend.
     */
    titleStyle: FontModel;
    /**
     * Customize the legend position of the maps.
     * @default Bottom
     */
    position: LegendPosition;
    /**
     * Customize the legend alignment of the maps.
     * @default Center
     */
    alignment: Alignment;
    /**
     * Customize the legend items placed
     */
    orientation: LegendArrangement;
    /**
     * Customize the legend placed by given x and y values.
     */
    location: Point;
    /**
     * Specifies the legend shape color
     */
    fill: string;
    /**
     * Customize the legend mode.
     * @default Default
     */
    mode: LegendMode;
}
/**
 * Customization for Data label settings.
 */
export  class DataLabelSettings extends base.ChildProperty<DataLabelSettings> {
    /**
     * Toggle the data label visibility.
     * @default false
     */
    visible: boolean;
    /**
     * Configures the label border
     */
    border: BorderModel;
    /**
     * configure the fill
     */
    fill: string;
    /**
     * configure the label opacity
     */
    opacity: number;
    /**
     * rectangle rx
     * @default 10
     */
    rx: number;
    /**
     * ry value
     * @default 10
     */
    ry: number;
    /**
     * Options for customizing text styles of the data label.
     */
    textStyle: FontModel;
    /**
     * To customize the label path values.
     * @default ''
     */
    labelPath: string;
    /**
     * To customize the smartLabels.
     * @default none
     */
    smartLabelMode: SmartLabelMode;
    /**
     * intersection action
     */
    intersectionAction: IntersectAction;
    /**
     * To customize the data label template.
     * @default ''
     */
    template: string;
}
/**
 * To configure the shapeSettings in the maps.
 */
export  class ShapeSettings extends base.ChildProperty<ShapeSettings> {
    /**
     * To customize the fill color of the shape.
     * @default '#A6A6A6'
     */
    fill: string;
    /**
     * To customize the palette of the shape.
     * @default []
     */
    palette: string[];
    /**
     * Customize the radius for points
     */
    circleRadius: number;
    /**
     * Options for customizing the color and width of the shape.
     */
    border: BorderModel;
    /**
     * Dash array of line
     */
    dashArray: string;
    /**
     * To customize the opacity of the shape.
     * @default 1
     */
    opacity: number;
    /**
     * To customize the colorValuePath of the shape.
     * @default null
     */
    colorValuePath: string;
    /**
     * To customize the valuePath of the shape.
     * @default null
     */
    valuePath: string;
    /**
     * To configure shape colorMapping
     * @default []
     */
    colorMapping: ColorMappingSettingsModel[];
    /**
     * Toggle the auto fill.
     * @default false
     */
    autofill: boolean;
}
/**
 * To configure the marker settings for the maps.
 */
export  class MarkerSettings extends base.ChildProperty<MarkerSettings> {
    /**
     * Options for customizing the color and width of the marker.
     */
    border: BorderModel;
    /**
     * Options for customizing the dash array options
     */
    dashArray: string;
    /**
     * Toggle the visibility of the marker.
     * @default false
     */
    visible: boolean;
    /**
     * To customize the fill color of the marker.
     * @default '#FF471A'
     */
    fill: string;
    /**
     * To customize the height of the marker.
     * @default 1
     */
    height: number;
    /**
     * To customize the width of the marker.
     * @default 1
     */
    width: number;
    /**
     * To customize the opacity of the marker.
     * @default 1
     */
    opacity: number;
    /**
     * To customize the shape of the marker.
     * @default Balloon
     */
    shape: MarkerType;
    /**
     * To provide the dataSource field to display legend text
     * @default ''
     */
    legendText: string;
    /**
     * To move the marker by setting offset values
     */
    offset: Point;
    /**
     * To provide the image url for rendering marker image
     */
    imageUrl: string;
    /**
     * To customize the template of the marker.
     * @default null
     */
    template: string;
    /**
     * To configure the dataSource of the marker.
     * @default []
     */
    dataSource: Object[];
    /**
     * To configure the tooltip settings of the maps marker.
     */
    tooltipSettings: TooltipSettingsModel;
    /**
     * Animation duration time
     * @default 1000
     */
    animationDuration: number;
    /**
     * Animation delay time
     * @default 0
     */
    animationDelay: number;
    /**
     * To configure the selection settings of the maps.
     */
    selectionSettings: SelectionSettingsModel;
    /**
     * To configure the highlight settings of the maps.
     */
    highlightSettings: HighlightSettingsModel;
}
/**
 * To configure the layers of the maps.
 */
export  class LayerSettings extends base.ChildProperty<LayerSettings> {
    /**
     * Specifies the shape data for the layer.
     * @default null
     */
    shapeData: Object | data.DataManager | base.Ajax;
    /**
     * Specifies the query to select particular data from the shape data.
     * This property is applicable only when the DataSource is `ej.data.DataManager`.
     * @default null
     */
    query: data.Query;
    /**
     * Specifies the shape properties
     */
    shapeSettings: ShapeSettingsModel;
    /**
     * Specifies the data source for the layer.
     * @default []
     */
    dataSource: object[];
    /**
     * Specifies the type for the layer.
     * @default Layer
     */
    type: Type;
    /**
     * Specifies the geometry type
     */
    geometryType: GeometryType;
    /**
     * Specifies the type for the bing map.
     * @default Aerial
     */
    bingMapType: BingMapType;
    /**
     * Specifies the key for the layer.
     * @default ''
     */
    key: string;
    /**
     * Specifies the layerType for the layer.
     * @default Geometry
     */
    layerType: ShapeLayerType;
    /**
     * Specifies the urlTemplate for the layer.
     * @default 'http://a.tile.openstreetmap.org/level/tileX/tileY.png'
     */
    urlTemplate: string;
    /**
     * Toggle the visibility of the layers.
     * @default true
     */
    visible: boolean;
    /**
     * Specifies the shapeDataPath for the layer.
     * @default 'name'
     */
    shapeDataPath: string;
    /**
     * Specifies the shapePropertyPath for the layer.
     * @default 'name'
     */
    shapePropertyPath: string;
    /**
     * Specifies the animation duration for the layer.
     * @default `500`
     */
    animationDuration: number;
    /**
     * To configure the marker settings.
     */
    markerSettings: MarkerSettingsModel[];
    /**
     * To configure the datalabel settings of the maps.
     */
    dataLabelSettings: DataLabelSettingsModel;
    /**
     * To configure the bubble settings of the maps.
     */
    bubbleSettings: BubbleSettingsModel[];
    /**
     * navigationLineSetting
     */
    navigationLineSettings: NavigationLineSettingsModel[];
    /**
     * To configure the tooltip settings of the maps layer.
     */
    tooltipSettings: TooltipSettingsModel;
    /**
     * To configure the selection settings of the maps.
     */
    selectionSettings: SelectionSettingsModel;
    /**
     * To configure the highlight settings of the maps.
     */
    highlightSettings: HighlightSettingsModel;
    /** @private */
    layerData: Object[];
    /**
     * @private
     */
    isBaseLayer: boolean;
    /**
     * @private
     */
    factor: number;
    /**
     * @private
     * Stores the layer bounds
     */
    layerBounds: GeoLocation;
    /**
     * @private
     * Stores the rect bounds
     */
    rectBounds: Object;
    /**
     * @private
     */
    translatePoint: Point;
}
/**
 * Internal use for bing type layer rendering
 */
export  class Tile {
    x: number;
    y: number;
    top: number;
    left: number;
    height: number;
    width: number;
    src: string;
    constructor(x: number, y: number, height?: number, width?: number, top?: number, left?: number, src?: string);
}
/**
 * Maps area configuration
 */
export  class MapsAreaSettings extends base.ChildProperty<MapsAreaSettings> {
    /**
     * To configure maps area background color
     */
    background: string;
    /**
     * Options for customizing the color and width of maps area.
     */
    border: BorderModel;
}
/**
 * Maps constants doc
 */
/**
 * Specifies maps load event name.
 * @private
 */
export  const load: string;
/**
 * Specifies maps loaded event name.
 * @private
 */
export  const loaded: string;
/**
 * Specifies maps click event name.
 * @private
 */
export  const click: string;
/**
 * Specifies maps loaded event name.
 * @private
 */
export  const rightClick: string;
/**
 * Specifies maps double click event name.
 * @private
 */
export  const doubleClick: string;
/**
 * Specifies maps resize event name.
 * @private
 */
export  const resize: string;
/**
 * Specifies the map tooltip render event
 */
export  const tooltipRender: string;
/**
 * Specifies the map shapeSelected event
 */
export  const shapeSelected: string;
/**
 * Specifies the map shapeHighlight event
 */
export  const shapeHighlight: string;
/**
 * Specifies maps mousemove event name.
 * @private
 */
export  const mousemove: string;
/**
 * Specifies maps mouseup event name.
 * @private
 */
export  const mouseup: string;
/**
 * Specifies maps mousedown event name.
 * @private
 */
export  const mousedown: string;
/**
 * Specifies maps layerRendering event name.
 * @private
 */
export  const layerRendering: string;
/**
 * Specifies maps shapeRendering event name.
 * @private
 */
export  const shapeRendering: string;
/**
 * Specifies maps markerRendering event name.
 * @private
 */
export  const markerRendering: string;
/**
 * Specifies maps markerClick event name.
 * @private
 */
export  const markerClick: string;
/**
 * Specifies maps markerMouseMove event name.
 * @private
 */
export  const markerMouseMove: string;
/**
 * Specifies maps dataLabelRendering event name.
 * @private
 */
export  const dataLabelRendering: string;
/**
 * Specifies maps bubbleRendering event name.
 * @private
 */
export  const bubbleRendering: string;
/**
 * Specifies maps bubbleClick event name.
 * @private
 */
export  const bubbleClick: string;
/**
 * Specifies maps bubbleMouseMove event name.
 * @private
 */
export  const bubbleMouseMove: string;
/**
 * Specifies maps animationComplete event name.
 * @private
 */
export  const animationComplete: string;
/**
 * Specifies maps legendRendering event name.
 * @private
 */
export  const legendRendering: string;
/**
 * Specifies maps annotationRendering event name.
 * @private
 */
export  const annotationRendering: string;
/**
 * Specifies maps itemSelection event name
 * @private
 */
export  const itemSelection: string;
/**
 * Specifies maps itemHighlight event name
 */
export  const itemHighlight: string;
/**
 * Specifies maps beforePrint event name
 */
export  const beforePrint: string;
/**
 * Maps interfaces doc
 */
/**
 * Specifies Maps Events
 * @private
 */
export interface IMapsEventArgs {
    /** Defines the name of the event */
    name: string;
    /** Defines the event cancel status */
    cancel: boolean;
}
/**
 * specifies Print Events
 */
export interface IPrintEventArgs extends IMapsEventArgs {
    htmlContent: Element;
}
/**
 * Specifies the Loaded Event arguments.
 */
export interface ILoadedEventArgs extends IMapsEventArgs {
    /** Defines the current Maps instance */
    maps: Maps;
}
/**
 * Specifies the Load Event arguments.
 */
export interface ILoadEventArgs extends IMapsEventArgs {
    /** Defines the current Maps instance */
    maps: Maps;
}
/**
 * Specifies the data label Event arguments.
 */
export interface IDataLabelArgs extends IMapsEventArgs {
    /** Defines the current Maps instance */
    maps: Maps;
    /**
     * define event
     */
    dataLabel: DataLabelSettingsModel;
}
/**
 * Specifies the Chart Mouse Event arguments.
 */
export interface IMouseEventArgs extends IMapsEventArgs {
    /** Defines current mouse event target id */
    target: string;
    /** Defines current mouse x location */
    x: number;
    /** Defines current mouse y location */
    y: number;
}
/**
 * Maps Resize event arguments.
 */
export interface IResizeEventArgs {
    /** Defines the name of the Event */
    name: string;
    /** Defines the previous size of the maps */
    previousSize: Size;
    /** Defines the current size of the maps */
    currentSize: Size;
    /** Defines the Maps instance */
    maps: Maps;
}
/** @private */
export interface IFontMapping {
    size?: string;
    color?: string;
    fontWeight?: string;
    fontStyle?: string;
    fontFamily?: string;
}
/**
 * Specifies TooltipRender event arguments for maps.
 */
export interface ITooltipRenderEventArgs extends IMapsEventArgs {
    /**
     * content event argument
     */
    content?: string | HTMLElement;
    /**
     * textStyle event argument
     */
    textStyle?: FontModel;
    /**
     * border event argument
     */
    border?: BorderModel;
    /**
     * fill color event argument
     */
    fill?: string;
}
/**
 * Specifies itemSelection event arguments for maps.
 */
export interface ISelectionEventArgs extends IMapsEventArgs {
    /**
     * fill event argument
     */
    fill?: string;
    /**
     * opacity event argument
     */
    opacity?: number;
    /**
     * border event argument
     */
    border?: BorderModel;
    /**
     * Defines current mouse event target id
     */
    target?: string;
    /**
     * shape data event argument
     */
    shapeData?: object;
    /**
     * data from data source
     */
    data?: object;
}
/**
 * Specifies shapeSelected event arguments for maps.
 */
export interface IShapeSelectedEventArgs extends IMapsEventArgs {
    /**
     * fill event argument
     */
    fill?: string;
    /**
     * opacity event argument
     */
    opacity?: number;
    /**
     * border event argument
     */
    border?: BorderModel;
    /**
     * shapeData event argument
     */
    shapeData?: object;
    /**
     * data source event argument
     */
    data?: object;
    /** Defines current mouse event target id */
    target?: string;
}
/** @private */
export interface ITouches {
    pageX?: number;
    pageY?: number;
    pointerId?: number;
}
/** @private */
export interface IShapes {
    renderOption?: Object;
    functionName?: string;
}
/**
 * Specifies layerRendering event arguments for maps.
 */
export interface ILayerRenderingEventArgs extends IMapsEventArgs {
    /**
     * layer index event argument
     */
    index?: number;
    /**
     * maps instance event argument
     */
    maps?: Maps;
    /**
     * layer options event argument
     */
    layer?: LayerSettingsModel;
}
/**
 * Specifies shapeRendering event arguments for maps.
 */
export interface IShapeRenderingEventArgs extends IMapsEventArgs {
    /**
     * shape index event argument
     */
    index?: number;
    /**
     * maps instance event argument
     */
    maps?: Maps;
    /**
     * current shape settings
     */
    shape?: ShapeSettingsModel;
    /**
     * current shape fill
     */
    fill?: string;
    /**
     * current shape border
     */
    border?: BorderModel;
    /**
     * shape data source event argument
     */
    data?: object;
}
/**
 * Specifies markerRendering event arguments for maps.
 */
export interface IMarkerRenderingEventArgs extends IMapsEventArgs {
    /**
     * maps instance event argument
     */
    maps?: Maps;
    /**
     * marker instance. This is Read Only option.
     */
    marker?: MarkerSettingsModel;
    /**
     * Marker fill.
     */
    fill?: string;
    /**
     * To customize the height of the marker.
     */
    height?: number;
    /**
     * To customize the width of the marker.
     */
    width?: number;
    /**
     * To customize the shape of the marker.
     */
    shape?: MarkerType;
    /**
     * To provide the image url for rendering marker image
     */
    imageUrl?: string;
    /**
     * To customize the template of the marker.
     */
    template?: string;
    /**
     * Configures the marker border
     */
    border?: BorderModel;
    /**
     * marker data event argument
     */
    data?: object;
}
/**
 * Specifies markerClick event arguments for maps.
 */
export interface IMarkerClickEventArgs extends IMouseEventArgs {
    /**
     * maps instance event argument
     */
    maps?: Maps;
    /**
     * marker instance event argument
     */
    marker?: MarkerSettingsModel;
    /**
     * marker data event argument
     */
    data?: object;
}
/**
 * Specifies markerMove event arguments for maps.
 */
export interface IMarkerMoveEventArgs extends IMouseEventArgs {
    /**
     * maps instance event argument
     */
    maps?: Maps;
    /**
     * marker data event argument. This is Read Only option.
     */
    data?: object;
}
/**
 * Specifies labelRendering event arguments for maps.
 */
export interface ILabelRenderingEventArgs extends IMapsEventArgs {
    /**
     * maps instance event argument
     */
    maps?: Maps;
    /**
     * data label text event argument
     */
    text?: string;
    /**
     * Configures the label border
     */
    border?: BorderModel;
    /**
     * configure the fill
     */
    fill?: string;
    /**
     * To customize the data label template.
     */
    template?: string;
    /**
     * label instance event argument
     */
    datalabel?: DataLabelSettingsModel;
}
/**
 * Specifies bubbleRendering event arguments for maps.
 */
export interface IBubbleRenderingEventArgs extends IMapsEventArgs {
    /**
     * maps instance event argument
     */
    maps?: Maps;
    /**
     * bubble fill event argument
     */
    fill?: string;
    /**
     * bubble border event argument
     */
    border?: BorderModel;
    /**
     * current bubble center x
     */
    cx?: number;
    /**
     * current bubble center y
     */
    cy?: number;
    /**
     * current bubble radius
     */
    radius?: number;
    /**
     * current bubble data
     */
    data?: object;
}
/**
 * Specifies bubbleClick event arguments for maps.
 */
export interface IBubbleClickEventArgs extends IMouseEventArgs {
    /**
     * maps instance event argument
     */
    maps?: Maps;
    /**
     * bubble current data event argument
     */
    data?: object;
}
/**
 * Specifies bubbleMove event arguments for maps.
 */
export interface IBubbleMoveEventArgs extends IMouseEventArgs {
    /**
     * maps instance event argument
     */
    maps?: Maps;
    /**
     * bubble current data event argument
     */
    data?: object;
}
/**
 * Specifies animationComplete event arguments for maps.
 */
export interface IAnimationCompleteEventArgs extends IMapsEventArgs {
    /**
     * maps instance event argument
     */
    maps?: Maps;
    /**
     * animation element type event argument
     */
    element: string;
}
/**
 * Specifies legendRendering event arguments for maps.
 */
export interface ILegendRenderingEventArgs extends IMapsEventArgs {
    /**
     * maps instance event argument
     */
    maps?: Maps;
    /**
     * Specifies the legend shape color
     */
    fill?: string;
    /**
     * Options for customizing the color and width of the shape border.
     */
    shapeBorder?: BorderModel;
    /**
     * Customize the legend shape of the maps.
     */
    shape?: LegendShape;
}
/**
 * Specifies annotationRendering event arguments for maps.
 */
export interface IAnnotationRenderingEventArgs extends IMapsEventArgs {
    /**
     * maps instance event argument
     */
    maps?: Maps;
    /**
     * Specifies the annotation content
     */
    content?: string;
    /**
     * Specifies the annotation instance
     */
    annotation?: Annotation;
}
/**
 * Maps Themes doc
 */
/**
 * Specifies Maps Themes
 */
export  namespace Theme {
    /** @private */
    let mapsTitleFont: IFontMapping;
    /** @private */
    let mapsSubTitleFont: IFontMapping;
    /** @private */
    let tooltipLabelFont: IFontMapping;
    /** @private */
    let legendTitleFont: IFontMapping;
    /** @private */
    let legendLabelFont: IFontMapping;
    /** @private */
    let dataLabelFont: IFontMapping;
}
export  namespace FabricTheme {
    /** @private */
    let mapsTitleFont: IFontMapping;
    /** @private */
    let mapsSubTitleFont: IFontMapping;
    /** @private */
    let tooltipLabelFont: IFontMapping;
    /** @private */
    let legendTitleFont: IFontMapping;
    /** @private */
    let legendLabelFont: IFontMapping;
    /** @private */
    let dataLabelFont: IFontMapping;
}
export  namespace BootstrapTheme {
    /** @private */
    let mapsTitleFont: IFontMapping;
    /** @private */
    let mapsSubTitleFont: IFontMapping;
    /** @private */
    let tooltipLabelFont: IFontMapping;
    /** @private */
    let legendTitleFont: IFontMapping;
    /** @private */
    let legendLabelFont: IFontMapping;
    /** @private */
    let dataLabelFont: IFontMapping;
}
/**
 * Internal use of Method to getting colors based on themes.
 * @private
 * @param theme
 */
export  function getShapeColor(theme: MapsTheme): string[];
/**
 * HighContrast Theme configuration
 */
export  namespace HighContrastTheme {
    /** @private */
    let mapsTitleFont: IFontMapping;
    /** @private */
    let mapsSubTitleFont: IFontMapping;
    /** @private */
    let tooltipLabelFont: IFontMapping;
    /** @private */
    let legendTitleFont: IFontMapping;
    /** @private */
    let legendLabelFont: IFontMapping;
    /** @private */
    let dataLabelFont: IFontMapping;
}
/**
 * Represent the annotation rendering for map
 */
export  class Annotations {
    private map;
    constructor(map: Maps);
    renderAnnotationElements(): void;
    /**
     * To create annotation elements
     */
    createAnnotationTemplate(parentElement: HTMLElement, annotation: Annotation, annotationIndex: number): void;
    protected getModuleName(): string;
    /**
     * To destroy the annotation.
     * @return {void}
     * @private
     */
    destroy(map: Maps): void;
}
/**
 * Highlight module class
 */
export  class Highlight {
    private maps;
    private highlightSettings;
    constructor(maps: Maps);
    /**
     * To bind events for highlight module
     */
    private addEventListener();
    /**
     * To unbind events for highlight module
     */
    private removeEventListener();
    /**
     * Public method for highlight module
     */
    addHighlight(layerIndex: number, name: string, enable: boolean): void;
    private mouseMove(e);
    private mapHighlight(targetEle, shapeData, data);
    private highlightMap(targetEle, eventArgs);
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the highlight.
     * @return {void}
     * @private
     */
    destroy(maps: Maps): void;
}
/**
 * Selection module class
 */
export  class Selection {
    private maps;
    private selectionsettings;
    private selectionType;
    constructor(maps: Maps);
    /**
     * For binding events to selection module
     */
    private addEventListener();
    /**
     * For removing events from selection modue
     */
    private removeEventListener();
    private mouseClick(targetEle);
    /**
     * Public method for selection
     */
    addSelection(layerIndex: number, name: string, enable: boolean): void;
    /**
     * Method for selection
     */
    private selectMap(targetEle, shapeData, data);
    /**
     * Remove legend selection
     */
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the selection.
     * @return {void}
     * @private
     */
    destroy(maps: Maps): void;
}
/**
 * Tooltip module class
 */
export  class MapsTooltip {
    private maps;
    private tooltipEle;
    private element;
    private ejTooltip;
    private currentValue;
    private currentData;
    private border;
    private shapeColor;
    private textStyle;
    private options;
    private previousId;
    private isTouch;
    private position;
    private mouse;
    private size;
    private customTooltip;
    private touchDelay;
    constructor(maps: Maps);
    /**
     * To bind events for tooltip module
     */
    private addEventListener();
    /**
     * To unbind events for tooltip module
     */
    private removeEventListener();
    private mouseMove(e);
    private setMouseXY(e);
    /**
     * Method to render the tooltip for maps.
     */
    renderTooltip(e: MouseEvent): void;
    private getTargetElement(element);
    private closeTooltip(delay, duration?, effect?);
    private manipulateTarget(currentTarget);
    /**
     * Method to append the target element for tooltip
     */
    private appendTargetElement(location, padding?);
    private formatter(format, data);
    /**
     * Method to perform the tooltip for maps.
     */
    private onBeforeRender(args);
    /**
     * To get content for the current toolitp
     */
    private setTooltipContent(options?);
    private joinElements(elements);
    /**
     * Method to customize the tooltip elements for maps.
     */
    private tooltipCustomization(args, options?);
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the tooltip.
     * @return {void}
     * @private
     */
    destroy(maps: Maps): void;
}
/**
 * Zoom module class
 */
export  class Zoom {
    private maps;
    toolBarGroup: Element;
    private groupElements;
    private currentToolbarEle;
    zoomingRect: Rect;
    selectionColor: string;
    private fillColor;
    private zoomInElements;
    private zoomOutElements;
    private zoomElements;
    private panElements;
    isPanning: boolean;
    mouseEnter: boolean;
    baseTranslatePoint: Point;
    private wheelEvent;
    private cancelEvent;
    currentScale: number;
    isTouch: boolean;
    rectZoomingStart: boolean;
    touchStartList: ITouches[] | TouchList;
    touchMoveList: ITouches[] | TouchList;
    previousTouchMoveList: ITouches[] | TouchList;
    private pinchRect;
    mouseDownPoints: Point;
    mouseMovePoints: Point;
    currentLayer: LayerSettings;
    private panColor;
    zoomColor: string;
    browserName: string;
    isPointer: Boolean;
    private handled;
    private fingers;
    firstMove: boolean;
    private interaction;
    private lastScale;
    private pinchFactor;
    private startTouches;
    private templateCount;
    /** @private */
    layerCollectionEle: Element;
    constructor(maps: Maps);
    performZooming(position: Point, newZoomFactor: number, type: string): void;
    private getTileTranslatePosition(prevLevel, currentLevel, position);
    performRectZooming(): void;
    private setInteraction(newInteraction);
    private updateInteraction();
    performPinchZooming(e: PointerEvent | TouchEvent): void;
    drawZoomRectangle(): void;
    /**
     * To animate the zooming process
     */
    private animateTransform(element, animate, x, y, scale);
    applyTransform(animate?: boolean): void;
    /**
     * To translate the layer template elements
     * @private
     */
    processTemplate(x: number, y: number, scale: number, maps: Maps): void;
    private dataLabelTranslate(element, factor, x, y, scale, type, animate?);
    private markerTranslate(element, factor, x, y, scale, type, animate?);
    panning(): void;
    toolBarZooming(zoomFactor: number, type: string): void;
    createZoomingToolbars(): void;
    performToolBarAction(e: PointerEvent): void;
    /**
     *
     * @private
     */
    performZoomingByToolBar(type: string): void;
    private panningStyle(toolbar);
    private applySelection(elements, color);
    showTooltip(e: PointerEvent): void;
    removeTooltip(): void;
    alignToolBar(): void;
    /**
     * To bind events.
     * @return {void}
     * @private
     */
    wireEvents(element: Element, process: Function): void;
    mapMouseWheel(e: WheelEvent): void;
    doubleClick(e: PointerEvent): void;
    mouseDownHandler(e: PointerEvent | TouchEvent): void;
    mouseMoveHandler(e: PointerEvent | TouchEvent): void;
    mouseUpHandler(e: PointerEvent | TouchEvent): void;
    mouseCancelHandler(e: PointerEvent): void;
    click(e: PointerEvent): void;
    getMousePosition(pageX: number, pageY: number): Point;
    addEventListener(): void;
    removeEventListener(): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the zoom.
     * @return {void}
     * @private
     */
    destroy(maps: Maps): void;
}
/**
 * Maps enum doc
 */
/**
 * Defines the Alignment. They are
 * * near - Align the element to the left.
 * * center - Align the element to the center.
 * * far - Align the element to the right.
 * *
 */
export  type Alignment = 'Near' | 'Center' | 'Far';
/**
 * Defines Theme of the maps. They are
 * * Material - Render a maps with Material theme.
 * * Fabric - Render a maps with Fabric theme
 * * Bootstrap - Render a maps with Bootstrap theme
 */
export  type MapsTheme = 'Material' | 'Fabric' | 'Highcontrast' | 'Bootstrap';
/**
 * Defines the position of the legend. They are
 * * top - Displays the legend on the top of maps.
 * * left - Displays the legend on the left of maps.
 * * bottom - Displays the legend on the bottom of maps.
 * * right - Displays the legend on the right of maps.
 * * float - Displays the legend  based on given x and y value.
 */
export  type LegendPosition = 'Top' | 'Left' | 'Bottom' | 'Right' | 'Float';
/**
 * Defines the Legend types. They are
 * * Layers - Legend applicable to Layers.
 * * Bubbles - Legend applicable to Bubbles.
 * * Markers - Legend applicable to Markers.
 */
export  type LegendType = 'Layers' | 'Bubbles' | 'Markers';
/**
 * Defines the smart label mode. They are
 * * Trim - Trims the datalabel which exceed the region
 * * None - Smart label mode is not applied
 * * hide - Hide the datalabel which exceeds the region
 */
export  type SmartLabelMode = 'Trim' | 'None' | 'Hide';
/**
 * Defines the arrow position in navigation line. They are
 * * Start - Arrow is positioned at the starting position of navigation line
 * * End - Arrow is positioned at the ending position of navigation line
 */
export  type ArrowPosition = 'Start' | 'End';
/**
 * Defines the label intersect action. They are
 * * Trim - Trims the intersected datalabel
 * * None - Intersection action is not applied
 * * Hide - Hides the intersected datalabel
 */
export  type IntersectAction = 'Trim' | 'None' | 'Hide';
/**
 * Defines the Legend modes. They are
 * * Default - Specifies the Default mode.
 * * interactive - specifies the Interactive mode.
 */
export  type LegendMode = 'Default' | 'Interactive';
/**
 * Defines the Layer types.
 * * Geometry - Specifies the geometry type.
 * * Bing - Specifies the Bing type.
 */
export  type ShapeLayerType = 'Geometry' | 'OSM' | 'Bing';
/**
 * Defines the map layer types.
 * * Layer - Specifies the layer type.
 * * SubLayer - Specifies the sublayer type.
 */
export  type Type = 'Layer' | 'SubLayer';
/**
 * Defines the marker types.
 * * Circle - Specifies the Circle type.
 * * Rectangle - Specifies the Rectangle type.
 * * Cross - Specifies the Cross type.
 * * Diamond - Specifies the Diamond type.
 * * Star - Specifies the Star type.
 * * Balloon - Specifies the Balloon type.
 * * Triangle - Specifies the Triangle type.
 * * HorizontalLine - Specifies the HorizontalLine type.
 * * VerticalLine - Specifies the VerticalLine type.
 */
export  type MarkerType = 'Circle' | 'Rectangle' | 'Cross' | 'Diamond' | 'Star' | 'Balloon' | 'Triangle' | 'HorizontalLine' | 'VerticalLine' | 'Image';
/**
 * Defines the projection type of the maps.
 * * Mercator -Specifies the Mercator projection type.
 */
export  type ProjectionType = 'Mercator' | 'Winkel3' | 'Miller' | 'Eckert3' | 'Eckert5' | 'Eckert6' | 'AitOff' | 'Equirectangular';
/**
 * Defines bing map types
 * * Aerial - specifies the Aerial type
 * * AerialWithLabel - specifies the AerialWithLabel type
 * * Road - specifies the Road type
 */
export  type BingMapType = 'Aerial' | 'AerialWithLabel' | 'Road';
/**
 * Defines the tool bar orientation
 */
export  type Orientation = 'Horizontal' | 'Vertical';
/**
 * Defines the shape of legend. They are
 * * circle - Renders a circle.
 * * rectangle - Renders a rectangle.
 * * triangle - Renders a triangle.
 * * diamond - Renders a diamond.
 * * cross - Renders a cross.
 * * Star - Renders a star.
 * * horizontalLine - Renders a horizontalLine.
 * * verticalLine - Renders a verticalLine.
 * * pentagon - Renders a pentagon.
 * * invertedTriangle - Renders a invertedTriangle.
 */
export  type LegendShape = 'Circle' | 'Rectangle' | 'Triangle' | 'Diamond' | 'Cross' | 'Star' | 'HorizontalLine' | 'VerticalLine' | 'Pentagon' | 'InvertedTriangle';
/**
 * Defines the legend arrangement
 */
export  type LegendArrangement = 'None' | 'Horizontal' | 'Vertical';
/**
 * Defines the Alignment. They are
 * * none - Default alignment as none
 * * near - Align the element to the left.
 * * center - Align the element to the center.
 * * far - Align the element to the right.
 * *
 */
export  type AnnotationAlignment = 'None' | 'Near' | 'Center' | 'Far';
/**
 * Defines the geometry type. They are
 * * Geographic - Default value of geometry layer.
 * * Normal - Normal rendering of geometry layer.
 * *
 */
export  type GeometryType = 'Geographic' | 'Normal';
/**
 * Defines the bubble type
 */
export  type BubbleType = 'Circle' | 'Square';
/**
 * Defines the label placement type
 */
export  type LabelPosition = 'Before' | 'After';
/**
 * Defines the label intersect action types
 */
export  type LabelIntersectAction = 'None' | 'Trim' | 'Hide';
/**
 * Export Type
 */
export  type ExportType = 'PNG' | 'JPEG' | 'SVG' | 'PDF';
/**
 * Annotation Module handles the Annotation for Maps
 */
export  class ExportUtils {
    private control;
    private printWindow;
    /**
     * Constructor for Maps
     * @param control
     */
    constructor(control: Maps);
    /**
     * To print the Maps
     * @param elements
     */
    print(elements?: string[] | string | Element): void;
    /**
     * To get the html string of the Maps
     * @param elements
     * @private
     */
    getHTMLContent(elements?: string[] | string | Element): Element;
    /**
     * To export the file as image/svg format
     * @param type
     * @param fileName
     */
    export(type: ExportType, fileName: string, orientation?: pdfexport.PdfPageOrientation): void;
    /**
     * To trigger the download element
     * @param fileName
     * @param type
     * @param url
     */
    triggerDownload(fileName: string, type: ExportType, url: string, isDownload: boolean): void;
}
/**
 * Maps internal use of `Size` type
 * @private
 */
export  class Size {
    height: number;
    width: number;
    constructor(width: number, height: number);
}
/**
 * To find number from string
 * @private
 */
export  function stringToNumber(value: string, containerSize: number): number;
/**
 * Method to calculate the width and height of the maps
 */
export  function calculateSize(maps: Maps): void;
/**
 * Method to create svg for maps.
 */
export  function createSvg(maps: Maps): void;
/**
 * Method to convert degrees to radians
 */
export  function degreesToRadians(deg: number): number;
/**
 * Convert radians to degrees method
 */
export  function radiansToDegrees(radian: number): number;
/**
 * Method for converting from latitude and longitude values to points
 */
export  function convertGeoToPoint(latitude: number, longitude: number, factor: number, layer: LayerSettings, mapModel: Maps): Point;
/**
 * Converting tile latitude and longitude to point
 */
export  function convertTileLatLongToPoint(center: MapLocation, zoomLevel: number, tileTranslatePoint: MapLocation, isMapCoordinates: boolean): MapLocation;
/**
 * Method for calculate x point
 */
export  function xToCoordinate(mapObject: Maps, val: number): number;
/**
 * Method for calculate y point
 */
export  function yToCoordinate(mapObject: Maps, val: number): number;
/**
 * Method for calculate aitoff projection
 */
export  function aitoff(x: number, y: number): Point;
/**
 * Method to round the number
 */
export  function roundTo(a: number, b: number): number;
export  function sinci(x: number): number;
export  function acos(a: number): number;
/**
 * Method to calculate bound
 */
export  function calculateBound(value: number, min: number, max: number): number;
/**
 * Map internal class for point
 */
export  class Point {
    x: number;
    y: number;
    constructor(x: number, y: number);
}
/**
 * Map internal class for min and max
 *
 */
export  class MinMax {
    min: number;
    max: number;
    constructor(min: number, max: number);
}
/**
 * Map internal class locations
 */
export  class GeoLocation {
    latitude: MinMax;
    longitude: MinMax;
    constructor(latitude: MinMax, longitude: MinMax);
}
/**
 * Function to measure the height and width of the text.
 * @param  {string} text
 * @param  {FontModel} font
 * @param  {string} id
 * @returns no
 * @private
 */
export  function measureText(text: string, font: FontModel): Size;
/**
 * Internal use of text options
 * @private
 */
export  class TextOption {
    id: string;
    anchor: string;
    text: string | string[];
    transform: string;
    x: number;
    y: number;
    baseLine: string;
    constructor(id?: string, x?: number, y?: number, anchor?: string, text?: string | string[], transform?: string, baseLine?: string);
}
/**
 * Internal use of path options
 * @private
 */
export  class PathOption {
    id: string;
    opacity: number;
    fill: string;
    stroke: string;
    ['stroke-width']: number;
    ['stroke-dasharray']: string;
    d: string;
    constructor(id: string, fill: string, width: number, color: string, opacity?: number, dashArray?: string, d?: string);
}
/**
 * Internal use of rectangle options
 * @private
 */
export  class RectOption extends PathOption {
    x: number;
    y: number;
    height: number;
    width: number;
    rx: number;
    ry: number;
    transform: string;
    ['stroke-dasharray']: string;
    constructor(id: string, fill: string, border: BorderModel, opacity: number, rect: Rect, rx?: number, ry?: number, transform?: string, dashArray?: string);
}
/**
 * Internal use of circle options
 * @private
 */
export  class CircleOption extends PathOption {
    cy: number;
    cx: number;
    r: number;
    ['stroke-dasharray']: string;
    constructor(id: string, fill: string, border: BorderModel, opacity: number, cx: number, cy: number, r: number, dashArray: string);
}
/**
 * Internal use of polygon options
 * @private
 */
export  class PolygonOption extends PathOption {
    points: string;
    constructor(id: string, points: string, fill: string, width: number, color: string, opacity?: number, dashArray?: string);
}
/**
 * Internal use of polyline options
 * @private
 */
export  class PolylineOption extends PolygonOption {
    constructor(id: string, points: string, fill: string, width: number, color: string, opacity?: number, dashArray?: string);
}
/**
 * Internal use of line options
 * @private
 */
export  class LineOption extends PathOption {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
    constructor(id: string, line: Line, fill: string, width: number, color: string, opacity?: number, dashArray?: string);
}
/**
 * Internal use of line
 * @property
 */
export  class Line {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
    constructor(x1: number, y1: number, x2: number, y2: number);
}
/**
 * Internal use of map location type
 * @private
 */
export  class MapLocation {
    x: number;
    y: number;
    constructor(x: number, y: number);
}
/**
 * Internal use of type rect
 * @private
 */
export  class Rect {
    x: number;
    y: number;
    height: number;
    width: number;
    constructor(x: number, y: number, width: number, height: number);
}
/**
 * Internal use of pattern unit types enum.
 * @private
 */
export  type patternUnits = 'userSpaceOnUse' | 'objectBoundingBox';
/**
 * Internal use for pattern creation.
 * @property
 */
export  class PatternOptions {
    id: string;
    patternUnits: patternUnits;
    patternContentUnits: patternUnits;
    patternTransform: string;
    x: number;
    y: number;
    width: number;
    height: number;
    href: string;
    constructor(id: string, x: number, y: number, width: number, height: number, patternUnits?: patternUnits, patternContentUnits?: patternUnits, patternTransform?: string, href?: string);
}
/**
 * Internal rendering of text
 * @private
 */
export  function renderTextElement(options: TextOption, font: FontModel, color: string, parent: HTMLElement | Element, isMinus?: boolean): Element;
/**
 * @private
 */
export  function convertElement(element: HTMLCollection, markerId: string, data: Object, index: number, mapObj: Maps): HTMLElement;
export  function convertElementFromLabel(element: Element, labelId: string, data: object, index: number, mapObj: Maps): HTMLElement;
/**
 * Internal use of append shape element
 * @private
 */
export  function appendShape(shape: Element, element: Element): Element;
/**
 * Internal rendering of Circle
 * @private
 */
export  function drawCircle(maps: Maps, options: CircleOption, element?: Element): Element;
/**
 * Internal rendering of Rectangle
 * @private
 */
export  function drawRectangle(maps: Maps, options: RectOption, element?: Element): Element;
/**
 * Internal rendering of Path
 * @private
 */
export  function drawPath(maps: Maps, options: PathOption, element?: Element): Element;
/**
 * Internal rendering of Polygon
 * @private
 */
export  function drawPolygon(maps: Maps, options: PolygonOption, element?: Element): Element;
/**
 * Internal rendering of Polyline
 * @private
 */
export  function drawPolyline(maps: Maps, options: PolylineOption, element?: Element): Element;
/**
 * Internal rendering of Line
 * @private
 */
export  function drawLine(maps: Maps, options: LineOption, element?: Element): Element;
/**
 * @private
 * Calculate marker shapes
 */
export  function calculateShapes(maps: Maps, shape: MarkerType, options: PathOption, size: Size, location: MapLocation, markerEle: Element): Element;
/**
 * Internal rendering of Diamond
 * @private
 */
export  function drawDiamond(maps: Maps, options: PathOption, size: Size, location: MapLocation, element?: Element): Element;
/**
 * Internal rendering of Triangle
 * @private
 */
export  function drawTriangle(maps: Maps, options: PathOption, size: Size, location: MapLocation, element?: Element): Element;
/**
 * Internal rendering of Cross
 * @private
 */
export  function drawCross(maps: Maps, options: PathOption, size: Size, location: MapLocation, element?: Element): Element;
/**
 * Internal rendering of HorizontalLine
 * @private
 */
export  function drawHorizontalLine(maps: Maps, options: PathOption, size: Size, location: MapLocation, element?: Element): Element;
/**
 * Internal rendering of VerticalLine
 * @private
 */
export  function drawVerticalLine(maps: Maps, options: PathOption, size: Size, location: MapLocation, element?: Element): Element;
/**
 * Internal rendering of Star
 * @private
 */
export  function drawStar(maps: Maps, options: PathOption, size: Size, location: MapLocation, element?: Element): Element;
/**
 * Internal rendering of Balloon
 * @private
 */
export  function drawBalloon(maps: Maps, options: PathOption, size: Size, location: MapLocation, element?: Element): Element;
/**
 * Internal rendering of Pattern
 * @private
 */
export  function drawPattern(maps: Maps, options: PatternOptions, elements: Element[], element?: Element): Element;
/**
 * Method to get specific field and vaues from data.
 * @private
 */
export  function getFieldData(dataSource: object[], fields: string[]): object[];
/**
 * To find the index of dataSource from shape properties
 */
export  function checkShapeDataFields(dataSource: object[], properties: object, dataPath: string, propertyPath: string): number;
export  function filter(points: MapLocation[], start: number, end: number): MapLocation[];
/**
 * To find the midpoint of the polygon from points
 */
export  function findMidPointOfPolygon(points: MapLocation[]): object;
/**
 * @private
 * Check custom path
 */
export  function isCustomPath(layerData: Object[]): boolean;
/**
 * @private
 * Trim the title text
 */
export  function textTrim(maxWidth: number, text: string, font: FontModel): string;
/**
 * Method to calculate x position of title
 */
export  function findPosition(location: Rect, alignment: Alignment, textSize: Size, type: string): Point;
/**
 * To remove element by id
 */
export  function removeElement(id: string): void;
/**
 * @private
 */
export  function getTranslate(mapObject: Maps, layer: LayerSettings, animate?: boolean): Object;
/**
 * To get the html element by specified id
 */
export  function getElementByID(id: string): Element;
/**
 * To apply internalization
 */
export  function Internalize(maps: Maps, value: number): string;
/**
 * Function     to compile the template function for maps.
 * @returns Function
 * @private
 */
export  function getTemplateFunction(template: string): Function;
/**
 * Function to get element from id.
 * @returns Element
 * @private
 */
export  function getElement(id: string): Element;
/**
 * Function to get shape data using target id
 */
export  function getShapeData(targetId: string, map: Maps): {
    shapeData: object;
    data: object;
};
/**
 * Function to trigger shapeSelected event
 * @private
 */
export  function triggerShapeEvent(targetId: string, selection: SelectionSettingsModel | HighlightSettingsModel, maps: Maps, eventName: string): IShapeSelectedEventArgs;
/**
 * Function to get elements using class name
 */
export  function getElementsByClassName(className: string): HTMLCollectionOf<Element>;
/**
 * Function to get elements using querySelectorAll
 */
/**
 * Function to get elements using querySelector
 */
export  function querySelector(args: string, elementSelector: string): Element;
/**
 * Function to get the element for selection and highlight using public method
 */
export  function getTargetElement(layerIndex: number, name: string, enable: boolean, map: Maps): Element;
/**
 * Function to create style element for highlight and selection
 */
export  function createStyle(id: string, className: string, eventArgs: IShapeSelectedEventArgs): Element;
/**
 * Function to customize the style for highlight and selection
 */
export  function customizeStyle(id: string, className: string, eventArgs: IShapeSelectedEventArgs): void;
/**
 * Function to remove class from element
 */
export  function removeClass(element: Element): void;
/**
 * Animation Effect Calculation End
 * @private
 */
export  function elementAnimate(element: Element, delay: number, duration: number, point: MapLocation, maps: Maps, ele?: string, radius?: number): void;
/** @private */
export  function createTooltip(id: string, text: string, top: number, left: number, fontSize: string): void;
/** @private */
export  function drawSymbol(location: Point, shape: string, size: Size, url: string, options: PathOption): Element;
/** @private */
export  function calculateLegendShapes(location: Point, size: Size, shape: string, options: PathOption, url: string): IShapes;
/**
 * Animation Effect Calculation End
 * @private
 */
/** @private */
export  function getElementOffset(childElement: HTMLElement, parentElement: HTMLElement): Size;
/** @private */
export  function changeBorderWidth(element: Element, index: number, scale: number, maps: Maps): void;
/** @private */
export  function changeNavaigationLineWidth(element: Element, index: number, scale: number, maps: Maps): void;
/** @private */
export  function targetTouches(event: PointerEvent | TouchEvent): ITouches[];
/** @private */
export  function calculateScale(startTouches: ITouches[], endTouches: ITouches[]): number;
/** @private */
export  function getDistance(a: ITouches, b: ITouches): number;
/** @private */
export  function getTouches(touches: ITouches[], maps: Maps): Object[];
/** @private */
export  function getTouchCenter(touches: Object[]): Point;
/** @private */
export  function sum(a: number, b: number): number;
/**
 * Animation Effect Calculation End
 * @private
 */
export  function zoomAnimate(element: Element, delay: number, duration: number, point: MapLocation, scale: number, size: Size, maps: Maps): void;
/**
 * To process custom animation
 */
export  function animate(element: Element, delay: number, duration: number, process: Function, end: Function): void;
/**
 * Animation Translate
 * @private
 */
export  function smoothTranslate(element: Element, delay: number, duration: number, point: MapLocation): void;
 }
export namespace navigations { 

/**
 * Interface for a class AccordionActionSettings
 */
export interface AccordionActionSettingsModel {
    /**
   * Specifies the type of animation.
   * @default : 'SlideDown'
   */
    effect?: 'None' | base.Effect;
    /**
   * Specifies the duration to animate.
   * @default : 400
   */
    duration?: number;
    /**
   * Specifies the animation timing function.
   * @default : 'linear'
   */
    easing?: string;
}
/**
 * Interface for a class AccordionAnimationSettings
 */
export interface AccordionAnimationSettingsModel {
    /**
   * Specifies the animation to appear while collapsing the Accordion item.
   * @default { effect: 'SlideDown', duration: 400, easing: 'linear' }
   */
    collapse?: AccordionActionSettingsModel;
    /**
   * Specifies the animation to appear while expanding the Accordion item.
   * @default { effect: 'SlideDown', duration: 400, easing: 'linear' }
   */
    expand?: AccordionActionSettingsModel;
}
/**
 * Interface for a class AccordionItem
 */
export interface AccordionItemModel {
    /**
     * Sets the text content to be displayed for the Accordion item.
     * You can set the content of the Accordion item using `content` property.
     * It also supports to include the title as `HTML element`, `string`, or `query selector`.
     * ```typescript
     *   let accordionObj: Accordion = new Accordion( { 
     *        items : [ 
     *          { header: 'Accordion Header', content: 'Accordion Content' },
     *          { header: '<div>Accordion Header</div>', content: '<div>Accordion Content</div' },
     *          { header: '#headerContent', content: '#panelContent' }]
     *        });
     *   accordionObj.appendTo('#accordion');
     * ```
     * @default undefined
     */
    content?: string;
    /**
     * Sets the header text to be displayed for the Accordion item.
     * You can set the title of the Accordion item using `header` property.
     * It also supports to include the title as `HTML element`, `string`, or `query selector`.
     * ```typescript
     *   let accordionObj: Accordion = new Accordion( { 
     *        items : [ 
     *          { header: 'Accordion Header', content: 'Accordion Content' },
     *          { header: '<div>Accordion Header</div>', content: '<div>Accordion Content</div' },
     *          { header: '#headerContent', content: '#panelContent' }]
     *        });
     *   accordionObj.appendTo('#accordion');
     * ```
     * @default undefined
     */
    header?: string;
    /**
     * Defines single/multiple classes (separated by a space) are to be used for Accordion item customization.
     * @default undefined
     */
    cssClass?: string;
    /**
     * Defines an icon with the given custom CSS class that is to be rendered before the header text.
     * Add the css classes to the `iconCss` property and write the css styles to the defined class to set images/icons.
     * Adding icon is applicable only to the header.
     * ```typescript
     *   let accordionObj: Accordion = new Accordion( { 
     *        items : [ 
     *          { header: 'Accordion Header', iconCss: 'e-app-icon' }]
     *        });
     *   accordionObj.appendTo('#accordion');
     * ```
     * ```css
     * .e-app-icon::before {
     *   content: "\e710";
     * }
     * ```
     * @default undefined
     */
    iconCss?: string;
    /**
     * Sets the expand (true) or collapse (false) state of the Accordion item. By default, all the items are in a collapsed state.
     * @default 'false'
     */
    expanded?: Boolean;
}
/**
 * Interface for a class Accordion
 */
export interface AccordionModel extends base.ComponentModel{
    /**
     * An array of item that is used to specify Accordion items.
     * ```typescript
     *   let accordionObj: Accordion = new Accordion( { 
     *        items : [ 
     *          { header: 'Accordion Header', content: 'Accordion Content' }]
     *        });
     *   accordionObj.appendTo('#accordion');
     * ```
     * @default []
     */
    items?: AccordionItemModel[];
    /**
     * Specifies the width of the Accordion in pixels/number/percentage. Number value is considered as pixels.
     * @default '100%'
     */
    width?: string | number;
    /**
     * Specifies the height of the Accordion in pixels/number/percentage. Number value is considered as pixels.
     * @default 'auto'
     */
    height?: string | number;
    /**
     * Specifies the options to expand single or multiple panel at a time.
     * The possible values are:
     * - Single: Sets to expand only one Accordion item at a time.
     * - Multiple: Sets to expand more than one Accordion item at a time.
     * @default 'Multiple'
     */
    expandMode?: ExpandMode;
    /**
     * Specifies the animation configuration settings for expanding and collapsing the panel.
     * @default { expand: { effect: 'SlideDown', duration: 400, easing: 'linear' },
     * collapse: { effect: 'SlideUp', duration: 400, easing: 'linear' }}
     */
    animation?: AccordionAnimationSettingsModel;
    /**
     * The event will be fired while clicking on the Accordion headers.
     * @event
     */
    clicked?: base.EmitType<AccordionClickArgs>;
    /**
     * The event will be fired before the item gets collapsed/expanded.
     * @event
     */
    expanding?: base.EmitType<ExpandEventArgs>;
    /**
     * The event will be fired after the item gets collapsed/expanded.
     * @event
     */
    expanded?: base.EmitType<ExpandEventArgs>;
    /**
     * The event will be fired once the control rendering is completed.
     * @event
     */
    created?: base.EmitType<Event>;
    /**
     * The event will be fired when the control gets destroyed.
     * @event
     */
    destroyed?: base.EmitType<Event>;
}
/**
 * Specifies the option to expand single or multiple panel at a time.
 */
export  type ExpandMode = 'Single' | 'Multiple';
export interface AccordionClickArgs extends base.BaseEventArgs {
    /** Defines the current Accordion Item Object. */
    item?: AccordionItemModel;
    /** Defines the current Event arguments. */
    originalEvent?: Event;
}
export interface ExpandEventArgs extends base.BaseEventArgs {
    /** Defines the current Accordion Item Object. */
    item?: AccordionItemModel;
    /** Defines the current Accordion Item Element. */
    element?: HTMLElement;
    /** Defines the expand/collapse state. */
    isExpanded?: boolean;
    /** Defines the prevent action. */
    cancel?: boolean;
}
export  class AccordionActionSettings extends base.ChildProperty<AccordionActionSettings> {
    /**
     * Specifies the type of animation.
     * @default : 'SlideDown'
     */
    effect: 'None' | base.Effect;
    /**
     * Specifies the duration to animate.
     * @default : 400
     */
    duration: number;
    /**
     * Specifies the animation timing function.
     * @default : 'linear'
     */
    easing: string;
}
export  class AccordionAnimationSettings extends base.ChildProperty<AccordionAnimationSettings> {
    /**
     * Specifies the animation to appear while collapsing the Accordion item.
     * @default { effect: 'SlideDown', duration: 400, easing: 'linear' }
     */
    collapse: AccordionActionSettingsModel;
    /**
     * Specifies the animation to appear while expanding the Accordion item.
     * @default { effect: 'SlideDown', duration: 400, easing: 'linear' }
     */
    expand: AccordionActionSettingsModel;
}
/**
 * An item object that is used to configure Accordion items.
 */
export  class AccordionItem extends base.ChildProperty<AccordionItem> {
    /**
     * Sets the text content to be displayed for the Accordion item.
     * You can set the content of the Accordion item using `content` property.
     * It also supports to include the title as `HTML element`, `string`, or `query selector`.
     * ```typescript
     *   let accordionObj: Accordion = new Accordion( {
     *        items : [
     *          { header: 'Accordion Header', content: 'Accordion Content' },
     *          { header: '<div>Accordion Header</div>', content: '<div>Accordion Content</div' },
     *          { header: '#headerContent', content: '#panelContent' }]
     *        });
     *   accordionObj.appendTo('#accordion');
     * ```
     * @default undefined
     */
    content: string;
    /**
     * Sets the header text to be displayed for the Accordion item.
     * You can set the title of the Accordion item using `header` property.
     * It also supports to include the title as `HTML element`, `string`, or `query selector`.
     * ```typescript
     *   let accordionObj: Accordion = new Accordion( {
     *        items : [
     *          { header: 'Accordion Header', content: 'Accordion Content' },
     *          { header: '<div>Accordion Header</div>', content: '<div>Accordion Content</div' },
     *          { header: '#headerContent', content: '#panelContent' }]
     *        });
     *   accordionObj.appendTo('#accordion');
     * ```
     * @default undefined
     */
    header: string;
    /**
     * Defines single/multiple classes (separated by a space) are to be used for Accordion item customization.
     * @default undefined
     */
    cssClass: string;
    /**
     * Defines an icon with the given custom CSS class that is to be rendered before the header text.
     * Add the css classes to the `iconCss` property and write the css styles to the defined class to set images/icons.
     * Adding icon is applicable only to the header.
     * ```typescript
     *   let accordionObj: Accordion = new Accordion( {
     *        items : [
     *          { header: 'Accordion Header', iconCss: 'e-app-icon' }]
     *        });
     *   accordionObj.appendTo('#accordion');
     * ```
     * ```css
     * .e-app-icon::before {
     *   content: "\e710";
     * }
     * ```
     * @default undefined
     */
    iconCss: string;
    /**
     * Sets the expand (true) or collapse (false) state of the Accordion item. By default, all the items are in a collapsed state.
     * @default 'false'
     */
    expanded: Boolean;
}
/**
 * The Accordion is a vertically collapsible content panel that displays one or more panels at a time within the available space.
 * ```html
 * <div id='accordion'/>
 * <script>
 *   var accordionObj = new Accordion();
 *   accordionObj.appendTo('#accordion');
 * </script>
 * ```
 */
export  class Accordion extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    private trgtEle;
    private ctrlTem;
    private keyModule;
    private expandedItems;
    private initExpand;
    private isNested;
    private isDestroy;
    private templateEle;
    /**
     * Contains the keyboard configuration of the Accordion.
     */
    private keyConfigs;
    /**
     * An array of item that is used to specify Accordion items.
     * ```typescript
     *   let accordionObj: Accordion = new Accordion( {
     *        items : [
     *          { header: 'Accordion Header', content: 'Accordion Content' }]
     *        });
     *   accordionObj.appendTo('#accordion');
     * ```
     * @default []
     */
    items: AccordionItemModel[];
    /**
     * Specifies the width of the Accordion in pixels/number/percentage. Number value is considered as pixels.
     * @default '100%'
     */
    width: string | number;
    /**
     * Specifies the height of the Accordion in pixels/number/percentage. Number value is considered as pixels.
     * @default 'auto'
     */
    height: string | number;
    /**
     * Specifies the options to expand single or multiple panel at a time.
     * The possible values are:
     * - Single: Sets to expand only one Accordion item at a time.
     * - Multiple: Sets to expand more than one Accordion item at a time.
     * @default 'Multiple'
     */
    expandMode: ExpandMode;
    /**
     * Specifies the animation configuration settings for expanding and collapsing the panel.
     * @default { expand: { effect: 'SlideDown', duration: 400, easing: 'linear' },
     * collapse: { effect: 'SlideUp', duration: 400, easing: 'linear' }}
     */
    animation: AccordionAnimationSettingsModel;
    /**
     * The event will be fired while clicking on the Accordion headers.
     * @event
     */
    clicked: base.EmitType<AccordionClickArgs>;
    /**
     * The event will be fired before the item gets collapsed/expanded.
     * @event
     */
    expanding: base.EmitType<ExpandEventArgs>;
    /**
     * The event will be fired after the item gets collapsed/expanded.
     * @event
     */
    expanded: base.EmitType<ExpandEventArgs>;
    /**
     * The event will be fired once the control rendering is completed.
     * @event
     */
    created: base.EmitType<Event>;
    /**
     * The event will be fired when the control gets destroyed.
     * @event
     */
    destroyed: base.EmitType<Event>;
    /**
     * Initializes a new instance of the Accordion class.
     * @param options  - Specifies Accordion model properties as options.
     * @param element  - Specifies the element that is rendered as an Accordion.
     */
    constructor(options?: AccordionModel, element?: string | HTMLElement);
    /**
     * Removes the control from the DOM and also removes all its related events.
     * @returns void
     */
    destroy(): void;
    protected preRender(): void;
    private add(ele, val);
    private remove(ele, val);
    /**
     * To initialize the control rendering
     * @private
     */
    protected render(): void;
    private initialize();
    private renderControl();
    private unwireEvents();
    private wireEvents();
    private focusIn(e);
    private focusOut(e);
    private ctrlTemplate();
    private toggleIconGenerate();
    private initItemExpand();
    private renderItems();
    private clickHandler(e);
    private eleMoveFocus(action, root, trgt);
    private keyActionHandler(e);
    private headerEleGenerate();
    private renderInnerItem(item, index);
    private fetchElement(ele, value, index, isHeader);
    private ariaAttrUpdate(itemEle);
    private contentRendering(index);
    private expand(trgt);
    private expandAnimation(ef, icn, trgt, trgtItemEle, animate, args);
    private expandProgress(progress, icon, trgt, trgtItemEle, eventArgs);
    private expandedItemsPush(item);
    private getIndexByItem(item);
    private expandedItemsPop(item);
    private collapse(trgt);
    private collapseAnimation(ef, trgt, trgtItEl, icn, animate, args);
    private collapseProgress(progress, icon, trgt, trgtItemEle, eventArgs);
    /**
     * Returns the current module name.
     * @returns string
     * @private
     */
    protected getModuleName(): string;
    private itemAttribUpdate();
    /**
     * Adds new item to the Accordion with the specified index of the Accordion.
     * @param  {AccordionItemModel} item - Item array that is to be added to the Accordion.
     * @param  {number} index - Number value that determines where the item should be added.
     * By default, item is added at the last index if the index is not specified.
     * @returns void
     */
    addItem(item: AccordionItemModel, index?: number): void;
    private expandedItemRefresh(ele);
    /**
     * Dynamically removes item from Accordion.
     * @param  {number} index - Number value that determines which item should be removed.
     * @returns void.
     */
    removeItem(index: number): void;
    /**
     * Sets focus to the specified index item header in Accordion.
     * @param  {number} index - Number value that determines which item should be focused.
     * @returns void.
     */
    select(index: number): void;
    /**
     * Shows or hides the specified item from Accordion.
     * @param  {number} index - Number value that determines which item should be hidden/shown.
     * @param  {Boolean} isHidden - Boolean value that determines the action either hide (true) or show (false). Default value is false.
     *  If the `isHidden` value is false, the item is shown or else item it is hidden.
     * @returns void.
     */
    hideItem(index: number, isHidden?: Boolean): void;
    /**
     * Enables/Disables the specified Accordion item.
     * @param  {number} index - Number value that determines which item should be enabled/disabled.
     * @param  {boolean} isEnable - Boolean value that determines the action as enable (true) or disable (false).
     * If the `isEnable` value is true, the item is enabled or else it is disabled.
     * @returns void.
     */
    enableItem(index: number, isEnable: boolean): void;
    /**
     * Expands/Collapses the specified Accordion item.
     * @param  {boolean} isExpand - Boolean value that determines the action as expand or collapse.
     * @param  {number} index - Number value that determines which item should be expanded/collapsed.`index` is optional parameter.
     *  Without Specifying index, based on the `isExpand` value all Accordion item can be expanded or collapsed.
     * @returns void.
     */
    expandItem(isExpand: boolean, index?: number): void;
    private itemExpand(isExpand, ele, index);
    private destroyItems();
    private updateItem(item, index);
    protected getPersistData(): string;
    /**
     * Gets called when the model property changes.The data that describes the old and new values of the property that changed.
     * @param  {AccordionModel} newProp
     * @param  {AccordionModel} oldProp
     * @returns void
     * @private
     */
    onPropertyChanged(newProp: AccordionModel, oldProp: AccordionModel): void;
}
/**
 * Accordion all modules
 */
/**
 * Interface for a class HScroll
 */
export interface HScrollModel extends base.ComponentModel{
    /**
     * Specifies the left or right scrolling distance of the horizontal scrollbar moving.
     * @default '40'
     */
    scrollStep?: number;
}
/**
 * HScroll module is introduces horizontal scroller when content exceeds the current viewing area.
 * It can be useful for the components like Toolbar, Tab which needs horizontal scrolling alone.
 * Hidden content can be view by touch moving or icon click.
 * ```html
 * <div id="scroll"/>
 * <script>
 *   var scrollObj = new HScroll();
 *   scrollObj.appendTo("#scroll");
 * </script>
 * ```
 */
export  class HScroll extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    private touchModule;
    private scrollEle;
    private scrollItems;
    private uniqueId;
    private timeout;
    private keyTimeout;
    private keyTimer;
    private browser;
    private browserCheck;
    private ieCheck;
    private isDevice;
    /**
     * Specifies the left or right scrolling distance of the horizontal scrollbar moving.
     * @default '40'
     */
    scrollStep: number;
    /**
     * Initialize the event handler
     * @private
     */
    protected preRender(): void;
    /**
     * To Initialize the control rendering
     * @private
     */
    protected render(): void;
    /**
     * Initializes a new instance of the HScroll class.
     * @param options  - Specifies HScroll model properties as options.
     * @param element  - Specifies the element for which horizontal scrolling applies.
     */
    constructor(options?: HScrollModel, element?: string | HTMLElement);
    private initialize();
    protected getPersistData(): string;
    /**
     * Returns the current module name.
     * @returns string
     * @private
     */
    protected getModuleName(): string;
    /**
     * Removes the control from the DOM and also removes all its related events.
     * @returns void
     */
    destroy(): void;
    private createNavIcon(element);
    private onKeyPress(e);
    private onKeyUp(e);
    private eventBinding(ele);
    private repeatScroll();
    private tabHoldHandler(e);
    private contains(ele, className);
    private eleScrolling(scrollDis, trgt);
    private clickEventHandler(e);
    private touchHandler(e);
    private arrowDisabling(addDisable, removeDisable);
    private scrollHandler(e);
    /**
     * Gets called when the model property changes.The data that describes the old and new values of property that changed.
     * @param  {HScrollModel} newProp
     * @param  {HScrollModel} oldProp
     * @returns void
     * @private
     */
    onPropertyChanged(newProp: HScrollModel, oldProp: HScrollModel): void;
}
/**
 * Navigation Common modules
 */
/**
 * Interface for a class MenuItem
 */
export interface MenuItemModel {
    /**
     * Defines class/multiple classes separated by a space for the menu Item that is used to include an icon.
     * Menu Item can include font icon and sprite image.
     * @default ''
     */
    iconCss?: string;
    /**
     * Specifies the id for menu item.
     * @default ''
     */
    id?: string;
    /**
     * Specifies separator between the menu items. Separator are horizontal lines used to group menu items.
     * @default false
     */
    separator?: boolean;
    /**
     * Specifies the sub menu items that is the array of MenuItem model.
     * @default []
     */
    items?: MenuItemModel[];
    /**
     * Specifies text for menu item.
     * @default ''
     */
    text?: string;
    /**
     * Specifies url for menu item that creates the anchor link to navigate to the url provided.
     * @default ''
     */
    url?: string;
}
/**
 * Interface for a class ContextMenu
 */
export interface ContextMenuModel extends base.ComponentModel{
    /**
     * Defines class/multiple classes separated by a space in the ContextMenu wrapper.
     * ContextMenu customization can be achieved by using this.
     * @default ''
     */
    cssClass?: string;
    /**
     * Specifies the filter selector for elements inside the target in that the context menu will be opened.
     * @default ''
     */
    filter?: string;
    /**
     * Specifies whether to show the sub menu or not on click.
     * When set to true, the sub menu will open only on mouse click.
     * @default false
     */
    showItemOnClick?: boolean;
    /**
     * Specifies menu items with its properties which will be rendered as Context Menu.
     * @default []
     */
    items?: MenuItemModel[];
    /**
     * Specifies target element selector in which the ContextMenu should be opened.
     * @default ''
     */
    target?: string;
    /**
     * Specifies the animation settings for the sub menu open.
     * @default { duration: 400, easing: 'ease', effect: 'SlideDown' }
     */
    animationSettings?: MenuAnimationSettings;
    /**
     * Triggers while rendering each menu item.
     * @event
     */
    beforeItemRender?: base.EmitType<MenuEventArgs>;
    /**
     * Triggers before opening the menu item.
     * @event
     */
    beforeOpen?: base.EmitType<BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers while opening the menu item.
     * @event
     */
    onOpen?: base.EmitType<OpenCloseMenuEventArgs>;
    /**
     * Triggers before closing the menu.
     * @event
     */
    beforeClose?: base.EmitType<BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers while closing the menu.
     * @event
     */
    onClose?: base.EmitType<OpenCloseMenuEventArgs>;
    /**
     * Triggers while selecting menu item.
     * @event
     */
    select?: base.EmitType<MenuEventArgs>;
}
/**
 * Menu animation effects
 */
export  type MenuEffect = 'None' | 'SlideDown' | 'ZoomIn' | 'FadeIn';
/**
 * Specifies context menu items.
 */
export  class MenuItem extends base.ChildProperty<MenuItem> {
    /**
     * Defines class/multiple classes separated by a space for the menu Item that is used to include an icon.
     * Menu Item can include font icon and sprite image.
     * @default ''
     */
    iconCss: string;
    /**
     * Specifies the id for menu item.
     * @default ''
     */
    id: string;
    /**
     * Specifies separator between the menu items. Separator are horizontal lines used to group menu items.
     * @default false
     */
    separator: boolean;
    /**
     * Specifies the sub menu items that is the array of MenuItem model.
     * @default []
     */
    items: MenuItemModel[];
    /**
     * Specifies text for menu item.
     * @default ''
     */
    text: string;
    /**
     * Specifies url for menu item that creates the anchor link to navigate to the url provided.
     * @default ''
     */
    url: string;
}
/**
 * The ContextMenu is a graphical user interface that appears on the user right click/touch hold operation.
 * ```html
 * <div id = 'target'></div>
 * <ul id = 'contextmenu'></ul>
 * ```
 * ```typescript
 * <script>
 * var contextMenuObj = new ContextMenu({items: [{ text: 'Cut' }, { text: 'Copy' },{ text: 'Paste' }], target: '#target'});
 * </script>
 * ```
 */
export  class ContextMenu extends base.Component<HTMLUListElement> implements base.INotifyPropertyChanged {
    private animation;
    private ngElement;
    private navIdx;
    private isTapHold;
    private targetElement;
    private delegateClickHandler;
    /**
     * Defines class/multiple classes separated by a space in the ContextMenu wrapper.
     * ContextMenu customization can be achieved by using this.
     * @default ''
     */
    cssClass: string;
    /**
     * Specifies the filter selector for elements inside the target in that the context menu will be opened.
     * @default ''
     */
    filter: string;
    /**
     * Specifies whether to show the sub menu or not on click.
     * When set to true, the sub menu will open only on mouse click.
     * @default false
     */
    showItemOnClick: boolean;
    /**
     * Specifies menu items with its properties which will be rendered as Context Menu.
     * @default []
     */
    items: MenuItemModel[];
    /**
     * Specifies target element selector in which the ContextMenu should be opened.
     * @default ''
     */
    target: string;
    /**
     * Specifies the animation settings for the sub menu open.
     * @default { duration: 400, easing: 'ease', effect: 'SlideDown' }
     */
    animationSettings: MenuAnimationSettings;
    /**
     * Triggers while rendering each menu item.
     * @event
     */
    beforeItemRender: base.EmitType<MenuEventArgs>;
    /**
     * Triggers before opening the menu item.
     * @event
     */
    beforeOpen: base.EmitType<BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers while opening the menu item.
     * @event
     */
    onOpen: base.EmitType<OpenCloseMenuEventArgs>;
    /**
     * Triggers before closing the menu.
     * @event
     */
    beforeClose: base.EmitType<BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers while closing the menu.
     * @event
     */
    onClose: base.EmitType<OpenCloseMenuEventArgs>;
    /**
     * Triggers while selecting menu item.
     * @event
     */
    select: base.EmitType<MenuEventArgs>;
    /**
     * Constructor for creating the widget.
     * @private
     */
    constructor(options?: ContextMenuModel, element?: string | HTMLUListElement);
    /**
     * Initialized animation with parent menu animation settings.
     * @private
     */
    protected preRender(): void;
    /**
     * Initialize the control rendering
     * @private
     */
    protected render(): void;
    private initWrapper();
    private renderItems();
    private wireEvents();
    private mouseDownHandler(e);
    private keyBoardHandler(e);
    private upDownKeyHandler(e);
    private isValidLI(cli, index, action);
    private rightEnterKeyHandler(e);
    private leftEscKeyHandler(e);
    private scrollHandler(e);
    private touchHandler(e);
    private cmenuHandler(e);
    /**
     * Closes the ContextMenu if it is opened.
     */
    close(): void;
    private closeMenu(ulIndex?, e?);
    private isMenuVisible();
    private canOpen(target);
    /**
     * This method is used to open the ContextMenu in specified position.
     * @param top To specify ContextMenu vertical positioning.
     * @param left To specify ContextMenu horizontal positioning.
     * @returns void
     */
    open(top: number, left: number): void;
    private openMenu(li, item, top?, left?, e?);
    private setPosition(li, ul, top, left);
    private toggleVisiblity(ul, isVisible?);
    private createItems(items);
    private toRawObject(items);
    private moverHandler(e);
    private hasField(items, field);
    private getWrapper();
    private clickHandler(e);
    private setLISelected(li);
    private getLIByClass(ul, classname);
    private getItem(navIdx);
    private getItems(navIdx);
    private getIdx(ul, li, skipHdr?);
    private getLI(elem);
    /**
     * Called internally if any of the property value changed
     * @private
     * @param {ContextMenuModel} newProp
     * @param {ContextMenuModel} oldProp
     * @returns void
     */
    onPropertyChanged(newProp: ContextMenuModel, oldProp: ContextMenuModel): void;
    private getChangedItemIndex(newProp, index, idx);
    private removeItem(item, navIdx, idx);
    /**
     * Used to unwire the bind events.
     * @private
     */
    protected unWireEvents(): void;
    private toggleAnimation(ul, isMenuOpen?);
    private end(ul, isMenuOpen);
    /**
     * Get the properties to be maintained in the persisted state.
     * @returns string
     */
    protected getPersistData(): string;
    /**
     * Get component name.
     * @returns string
     * @private
     */
    protected getModuleName(): string;
    private getIndex(data, items?, navIdx?, isCallBack?);
    /**
     * This method is used to enable or disable the menu items in the ContextMenu based on the items and enable argument.
     * @param items Text items that needs to be enabled/disabled.
     * @param enable Set `true`/`false` to enable/disable the list items.
     * @returns void
     */
    enableItems(items: string[], enable?: boolean): void;
    /**
     * This method is used to show the menu items in the ContextMenu based on the items text.
     * @param items Text items that needs to be shown.
     * @returns void
     */
    showItems(items: string[]): void;
    /**
     * This method is used to hide the menu items in the ContextMenu based on the items text.
     * @param items Text items that needs to be hidden.
     * @returns void
     */
    hideItems(items: string[]): void;
    private showHideItems(items, ishide);
    /**
     * It is used to remove the menu items from the ContextMenu based on the items text.
     * @param items Text items that needs to be removed.
     * @returns void
     */
    removeItems(items: string[]): void;
    /**
     * It is used to insert the menu items after the specified menu item text.
     * @param items Items that needs to be inserted.
     * @param text Text item after that the element to be inserted.
     * @returns void
     */
    insertAfter(items: MenuItemModel[], text: string): void;
    /**
     * It is used to insert the menu items before the specified menu item text.
     * @param items Items that needs to be inserted.
     * @param text Text item before that the element to be inserted.
     * @returns void
     */
    insertBefore(items: MenuItemModel[], text: string): void;
    private insertItems(items, text, isAfter?);
    private getZIndex();
    /**
     * Destroys the widget.
     * @returns void
     */
    destroy(): void;
}
/**
 * Interface for before item render / select event.
 * @private
 */
export interface MenuEventArgs extends base.BaseEventArgs {
    element: HTMLElement;
    item: MenuItemModel;
}
/**
 * Interface for before open / close event.
 * @private
 */
export interface BeforeOpenCloseMenuEventArgs extends base.BaseEventArgs {
    element: HTMLElement;
    items: MenuItemModel[];
    parentItem: MenuItemModel;
    event: Event;
    cancel: boolean;
}
/**
 * Interface for open/close event.
 */
export interface OpenCloseMenuEventArgs extends base.BaseEventArgs {
    element: HTMLElement;
    items: MenuItemModel[];
    parentItem: MenuItemModel;
}
/**
 * Animation configuration settings.
 */
export interface MenuAnimationSettings {
    /**
     * Specifies the effect that shown in the sub menu transform.
     * The possible effects are:
     * * None: Specifies the sub menu transform with no animation effect.
     * * SlideDown: Specifies the sub menu transform with slide down effect.
     * * ZoomIn: Specifies the sub menu transform with zoom in effect.
     * * FadeIn: Specifies the sub menu transform with fade in effect.
     */
    effect?: MenuEffect;
    /**
     * Specifies the time duration to transform object.
     */
    duration?: number;
    /**
     * Specifies the easing effect applied while transform.
     */
    easing?: string;
}
export interface ListBaseMenuModel extends MenuItemModel {
    htmlAttributes: {
        [key: string]: string;
    };
}
/**
 * ContextMenu modules
 */
/**
 * Navigation all modules
 */
/**
 * Sidebar modules
 */
/**
 * Interface for a class Sidebar
 */
export interface SidebarModel extends base.ComponentModel{
    /**
     * Specifies the size of the sidebar in dock state.
     * @default 'auto'
     */
    dockSize?: string | number;
    /**
     * The media query specifies whether the sidebar needs to be opened when the resolution is met.
     * @default null
     */
    mediaQuery?: MediaQueryList;
    /**
     * Specifies the docking state of the component.
     * @default false
     */
    enableDock?: boolean;
    /**
     * Enables expand or collapse while swiping on touch devices.
     * @default true
     */
    enableGestures?: boolean;
    /**
     * Specifies the sidebar in RTL state.
     * @default false
     */
    enableRtl?: boolean;
    /**
     * Specifies whether the sidebar animation is to be enabled or not.
     * @default true
     */
    animate?: boolean;
    /**
     * Specifies the height of the sidebar.
     * @default 'auto'
     */
    height?: string | number;
    /**
     * Specifies whether the sidebar needs to be closed or not when document area is clicked.
     * @default false
     */
    closeOnDocumentClick?: boolean;
    /**
     * Specifies the position of the sidebar (Left/Right) corresponding to the primary content.
     * @default 'Left'
     */
    position?: SidebarPosition;
    /**
     * Specifies the position of the sidebar inside an element.
     * @default null
     */
    contextTo?: HTMLElement;
    /**
     * Specifies the whether to apply overlay options to primary content when the sidebar is in an open state.
     * @default false
     */
    showBackdrop?: boolean;
    /**
     * Specifies the expanding types of the sidebar.
     * @default 'Auto'
     */
    type?: SidebarType;
    /**
     * Specifies the width of the sidebar.
     * @default 'auto'
     */
    width?: string | number;
    /**
     * Specifies the z-index of the sidebar.
     * @default 1000
     */
    zIndex?: string | number;
    /**
     * Triggers the event when component is created.
     * @event 
     */
    created?: base.EmitType<Event>;
    /**
     * Triggers when component is closed.
     *  @event 
     */
    close?: base.EmitType<Event>;
    /**
     * Triggers when the component is opened.
     *  @event 
     */
    open?: base.EmitType<Event>;
    /**
     * Triggers when the component is shown or hidden.
     *  @event 
     */
    change?: base.EmitType<Event>;
    /**
     * Triggers when component is destroyed.
     *  @event 
     */
    destroyed?: base.EmitType<Event>;
}
/**
 * Specifies the Sidebar types.
 */
export  type SidebarType = 'Slide' | 'Over' | 'Push' | 'Auto';
/**
 * Specifies the Sidebar positions.
 */
export  type SidebarPosition = 'Left' | 'Right';
/**
 * Sidebar is an expandable and collapsible
 * component that typically act as a side container to place the primary or secondary content alongside of the main content.
 * ```html
 * <aside id="sidebar">
 * </aside>
 * ````
 * ````typescript
 * <script>
 *   let sidebarObject = new Sidebar({ });
 *   sidebarObject.appendTo("#sidebar");
 * </script>
 * ```
 */
export  class Sidebar extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    private eventArguments;
    private modal;
    private mainContentEle;
    private sidebarEle;
    /**
     * Specifies the size of the sidebar in dock state.
     * @default 'auto'
     */
    dockSize: string | number;
    /**
     * The media query specifies whether the sidebar needs to be opened when the resolution is met.
     * @default null
     */
    mediaQuery: MediaQueryList;
    /**
     * Specifies the docking state of the component.
     * @default false
     */
    enableDock: boolean;
    /**
     * Enables expand or collapse while swiping on touch devices.
     * @default true
     */
    enableGestures: boolean;
    /**
     * Specifies the sidebar in RTL state.
     * @default false
     */
    enableRtl: boolean;
    /**
     * Specifies whether the sidebar animation is to be enabled or not.
     * @default true
     */
    animate: boolean;
    /**
     * Specifies the height of the sidebar.
     * @default 'auto'
     */
    height: string | number;
    /**
     * Specifies whether the sidebar needs to be closed or not when document area is clicked.
     * @default false
     */
    closeOnDocumentClick: boolean;
    /**
     * Specifies the position of the sidebar (Left/Right) corresponding to the primary content.
     * @default 'Left'
     */
    position: SidebarPosition;
    /**
     * Specifies the position of the sidebar inside an element.
     * @default null
     */
    contextTo: HTMLElement;
    /**
     * Specifies the whether to apply overlay options to primary content when the sidebar is in an open state.
     * @default false
     */
    showBackdrop: boolean;
    /**
     * Specifies the expanding types of the sidebar.
     * @default 'Auto'
     */
    type: SidebarType;
    /**
     * Specifies the width of the sidebar.
     * @default 'auto'
     */
    width: string | number;
    /**
     * Specifies the z-index of the sidebar.
     * @default 1000
     */
    zIndex: string | number;
    /**
     * Triggers the event when component is created.
     * @event
     */
    created: base.EmitType<Event>;
    /**
     * Triggers when component is closed.
     *  @event
     */
    close: base.EmitType<Event>;
    /**
     * Triggers when the component is opened.
     *  @event
     */
    open: base.EmitType<Event>;
    /**
     * Triggers when the component is shown or hidden.
     *  @event
     */
    change: base.EmitType<Event>;
    /**
     * Triggers when component is destroyed.
     *  @event
     */
    destroyed: base.EmitType<Event>;
    constructor(options?: SidebarModel, element?: string | HTMLElement);
    protected preRender(): void;
    protected render(): void;
    protected initialize(): void;
    private setContext();
    private setWidth();
    private setZindex();
    private addClass();
    private destroyBackDrop();
    /**
     * Hides the sidebar component.
     * @returns void
     */
    hide(): void;
    /**
     * Shows the sidebar component.
     * @returns void
     */
    show(): void;
    private setAnimation();
    private setDock();
    private createBackDrop();
    protected getPersistData(): string;
    /**
     * Returns the current module name.
     * @returns string
     * @private
     */
    protected getModuleName(): string;
    /**
     * Shows or hides the sidebar based on the current state.
     * @returns void
     */
    toggle(e?: Event): void;
    /**
     * Specifies the current state of the sidebar component.
     * @returns boolean
     */
    isOpen(): boolean;
    private setMediaQuery();
    protected resize(e: Event): void;
    private documentclickHandler(e);
    private enableGestureHandler(args);
    private setEnableGestures();
    private wireEvents();
    private unWireEvents();
    onPropertyChanged(newProp: SidebarModel, oldProp: SidebarModel): void;
    protected setType(type?: string): void;
    /**
     * Removes the control from the DOM and removes all its related events
     * @returns void
     */
    destroy(): void;
}
/**
 * Defines the event arguments for the event.
 * @returns void
 */
export interface EventArgs {
    name: string;
    element: HTMLElement;
}
/**
 * Tab modules
 */
/**
 * Interface for a class TabActionSettings
 */
export interface TabActionSettingsModel {
    /**
     * Specifies the animation effect for displaying Tab content.
     * @default : 'SlideLeftIn'
     */
    effect?: 'None' | base.Effect;
    /**
     * Specifies the time duration to transform content.
     * @default : 600
     */
    duration?: number;
    /**
     * Specifies easing effect applied while transforming content.
     * @default : 'ease'
     */
    easing?: string;
}
/**
 * Interface for a class TabAnimationSettings
 */
export interface TabAnimationSettingsModel {
    /**
     * Specifies the animation to appear while moving to previous Tab content.
     * @default { effect: 'SlideLeftIn', duration: 600, easing: 'ease' }
     */
    previous?: TabActionSettingsModel;
    /**
     * Specifies the animation to appear while moving to next Tab content.
     * @default { effect: 'SlideRightIn', duration: 600, easing: 'ease' }
     */
    next?: TabActionSettingsModel;
}
/**
 * Interface for a class Header
 */
export interface HeaderModel {
    /**
     * Specifies the display text of the Tab item header.
     * @default ''
     */
    text?: string | HTMLElement;
    /**
     * Specifies the icon class that is used to render an icon in the Tab header.
     * @default ''
     */
    iconCss?: string;
    /**
     * Options for positioning the icon in the Tab item header. This property depends on `iconCss` property.
     * The possible values are:
     * - Left: Places the icon to the `left` of the item.
     * - Top: Places the icon on the `top` of the item.
     * - Right: Places the icon to the `right` end of the item.
     * - Bottom: Places the icon at the `bottom` of the item.
     * @default 'left'
     */
    iconPosition?: string;
}
/**
 * Interface for a class TabItem
 */
export interface TabItemModel {
    /**
     * The object used for configuring the Tab item header properties.
     * @default {}
     */
    header?: HeaderModel;
    /**
     * Specifies the content of Tab item, that is displayed when concern item header is selected.
     * @default ''
     */
    content?: string | HTMLElement;
    /**
     * Sets the CSS classes to the Tab item to customize its styles.
     * @default ''
     */
    cssClass?: string;
    /**
     * Sets true to disable user interactions of the Tab item.
     * @default false
     */
    disabled?: boolean;
}
/**
 * Interface for a class Tab
 */
export interface TabModel extends base.ComponentModel{
    /**
     * An array of object that is used to configure the Tab component.
     * ```typescript
     *   let tabObj: Tab = new Tab( {
     *     items: [
     *       { header: { text: 'TabItem1' }, content: 'Tab Item1 Content' },
     *       { header: { text: 'TabItem2' }, content: 'Tab Item2 Content' }
     *     ]
     *   });
     *   tabObj.appendTo('#tab');
     * ```
     * @default []
     */
    items?: TabItemModel[];
    /**
     * Specifies the width of the Tab component. Default, Tab width sets based on the width of its parent.
     * @default '100%'
     */
    width?: string | number;
    /**
     * Specifies the height of the Tab component. By default, Tab height is set based on the height of its parent.
     * To use height property, heightAdjustMode must be set to 'None'.
     * @default 'auto'
     */
    height?: string | number;
    /**
     * Sets the CSS classes to root element of the Tab that helps to customize component styles.
     * @default ''
     */
    cssClass?: string;
    /**
     * Specifies the index for activating the current Tab item.
     * ```typescript
     *   let tabObj: Tab = new Tab( {
     *     selectedItem: 1,
     *     items: [
     *       { header: { text: 'TabItem1' }, content: 'Tab Item1 Content' },
     *       { header: { text: 'TabItem2' }, content: 'Tab Item2 Content' }
     *     ]
     *   });
     *   tabObj.appendTo('#tab');
     * ```
     * @default 0
     */
    selectedItem?: number;
    /**
     * Specifies the orientation of Tab header.
     * The possible values are:
     * - Top: Places the Tab header on the top.
     * - Bottom: Places the Tab header at the bottom.
     * @default 'Top'
     */
    headerPlacement?: HeaderPosition;
    /**
     * Specifies the height style for Tab content.
     * The possible values are:
     * - None: Based on the given height property, the content panel height is set.
     * - Auto: Tallest panel height of a given Tab content is set to all the other panels.
     * - Content: Based on the corresponding content height, the content panel height is set.
     * - Fill: Based on the parent height, the content panel hight is set.
     * @default 'Content'
     */
    heightAdjustMode?: HeightStyles;
    /**
     * Specifies the Tab display mode when Tab content exceeds the viewing area.
     * The possible modes are:
     * - Scrollable: All the elements are displayed in a single line with horizontal scrolling enabled.
     * - base.Popup: Tab container holds the items that can be placed within the available space and rest of the items are moved to the popup.
     * If the popup content overflows the height of the page, the rest of the elements can be viewed by scrolling the popup.
     * @default 'Scrollable'
     */
    overflowMode?: OverflowMode;
    /**
     * Specifies the direction of the Tab. For the culture like Arabic, direction can be switched as right-to-left.
     * @default false
     */
    enableRtl?: boolean;
    /**
     * Enable or disable persisting component's state between page reloads. 
     * If enabled, following list of states will be persisted.
     * 1. selectedItem
     * @default false.
     */
    enablePersistence?: boolean;
    /**
     * Specifies whether to show the close button for header items to remove the item from the Tab.
     * @default false
     */
    showCloseButton?: boolean;
    /**
     * Specifies the animation configuration settings while showing the content of the Tab.
     * @default 
     * { previous: { effect: 'SlideLeftIn', duration: 600, easing: 'ease' },
     *   next: { effect: 'SlideRightIn', duration: 600, easing: 'ease' } }
     */
    animation?: TabAnimationSettingsModel;
    /**
     * The event will be fired once the component rendering is completed.
     * @event
     */
    created?: base.EmitType<Event>;
    /**
     * The event will be fired before adding the item to the Tab.
     * @event
     */
    adding?: base.EmitType<Event>;
    /**
     * The event will be fired after adding the item to the Tab.
     * @event
     */
    added?: base.EmitType<Event>;
    /**
     * The event will be fired before the item gets selected.
     * @event
     */
    selecting?: base.EmitType<SelectEventArgs>;
    /**
     * The event will be fired after the item gets selected.
     * @event
     */
    selected?: base.EmitType<SelectEventArgs>;
    /**
     * The event will be fired before removing the item from the Tab.
     * @event
     */
    removing?: base.EmitType<RemoveEventArgs>;
    /**
     * The event will be fired after removing the item from the Tab.
     * @event
     */
    removed?: base.EmitType<RemoveEventArgs>;
    /**
     * The event will be fired when the component gets destroyed.
     * @event
     */
    destroyed?: base.EmitType<Event>;
}
/**
 * Options to set the orientation of Tab header.
 */
export  type HeaderPosition = 'Top' | 'Bottom';
/**
 * Options to set the content element height adjust modes.
 */
export  type HeightStyles = 'None' | 'Auto' | 'Content' | 'Fill';
export interface SelectEventArgs extends base.BaseEventArgs {
    /** Defines the previous Tab item element. */
    previousItem: HTMLElement;
    /** Defines the previous Tab item index. */
    previousIndex: number;
    /** Defines the selected Tab item element. */
    selectedItem: HTMLElement;
    /** Defines the selected Tab item index. */
    selectedIndex: number;
    /** Defines the content selection done through swiping. */
    isSwiped: boolean;
    /** Defines the prevent action. */
    cancel?: boolean;
}
export interface RemoveEventArgs extends base.BaseEventArgs {
    /** Defines the removed Tab item element. */
    removedItem: HTMLElement;
    /** Defines the removed Tab item index. */
    removedIndex: number;
}
export  class TabActionSettings extends base.ChildProperty<TabActionSettings> {
    /**
     * Specifies the animation effect for displaying Tab content.
     * @default : 'SlideLeftIn'
     */
    effect: 'None' | base.Effect;
    /**
     * Specifies the time duration to transform content.
     * @default : 600
     */
    duration: number;
    /**
     * Specifies easing effect applied while transforming content.
     * @default : 'ease'
     */
    easing: string;
}
export  class TabAnimationSettings extends base.ChildProperty<TabAnimationSettings> {
    /**
     * Specifies the animation to appear while moving to previous Tab content.
     * @default { effect: 'SlideLeftIn', duration: 600, easing: 'ease' }
     */
    previous: TabActionSettingsModel;
    /**
     * Specifies the animation to appear while moving to next Tab content.
     * @default { effect: 'SlideRightIn', duration: 600, easing: 'ease' }
     */
    next: TabActionSettingsModel;
}
/**
 * Objects used for configuring the Tab item header properties.
 */
export  class Header extends base.ChildProperty<Header> {
    /**
     * Specifies the display text of the Tab item header.
     * @default ''
     */
    text: string | HTMLElement;
    /**
     * Specifies the icon class that is used to render an icon in the Tab header.
     * @default ''
     */
    iconCss: string;
    /**
     * Options for positioning the icon in the Tab item header. This property depends on `iconCss` property.
     * The possible values are:
     * - Left: Places the icon to the `left` of the item.
     * - Top: Places the icon on the `top` of the item.
     * - Right: Places the icon to the `right` end of the item.
     * - Bottom: Places the icon at the `bottom` of the item.
     * @default 'left'
     */
    iconPosition: string;
}
/**
 * An array of object that is used to configure the Tab.
 */
export  class TabItem extends base.ChildProperty<TabItem> {
    /**
     * The object used for configuring the Tab item header properties.
     * @default {}
     */
    header: HeaderModel;
    /**
     * Specifies the content of Tab item, that is displayed when concern item header is selected.
     * @default ''
     */
    content: string | HTMLElement;
    /**
     * Sets the CSS classes to the Tab item to customize its styles.
     * @default ''
     */
    cssClass: string;
    /**
     * Sets true to disable user interactions of the Tab item.
     * @default false
     */
    disabled: boolean;
}
/**
 * Tab is a content panel to show multiple contents in a single space, one at a time.
 * Each Tab item has an associated content, that will be displayed based on the active Tab header item.
 * ```html
 * <div id="tab"></div>
 * <script>
 *   var tabObj = new Tab();
 *   tab.appendTo("#tab");
 * </script>
 * ```
 */
export  class Tab extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    private hdrEle;
    private cntEle;
    private tbObj;
    private tbItems;
    private tbItem;
    private tbPop;
    private isTemplate;
    private isPopup;
    private isReplace;
    private prevIndex;
    private prevItem;
    private popEle;
    private actEleId;
    private bdrLine;
    private popObj;
    private btnCls;
    private cnt;
    private show;
    private hide;
    private enableAnimation;
    private keyModule;
    private tabKeyModule;
    private touchModule;
    private animateOptions;
    private animObj;
    private maxHeight;
    private title;
    private initRender;
    private prevActiveEle;
    private isSwipeed;
    private isNested;
    private templateEle;
    /**
     * Contains the keyboard configuration of the Tab.
     */
    private keyConfigs;
    /**
     * An array of object that is used to configure the Tab component.
     * ```typescript
     *   let tabObj: Tab = new Tab( {
     *     items: [
     *       { header: { text: 'TabItem1' }, content: 'Tab Item1 Content' },
     *       { header: { text: 'TabItem2' }, content: 'Tab Item2 Content' }
     *     ]
     *   });
     *   tabObj.appendTo('#tab');
     * ```
     * @default []
     */
    items: TabItemModel[];
    /**
     * Specifies the width of the Tab component. Default, Tab width sets based on the width of its parent.
     * @default '100%'
     */
    width: string | number;
    /**
     * Specifies the height of the Tab component. By default, Tab height is set based on the height of its parent.
     * To use height property, heightAdjustMode must be set to 'None'.
     * @default 'auto'
     */
    height: string | number;
    /**
     * Sets the CSS classes to root element of the Tab that helps to customize component styles.
     * @default ''
     */
    cssClass: string;
    /**
     * Specifies the index for activating the current Tab item.
     * ```typescript
     *   let tabObj: Tab = new Tab( {
     *     selectedItem: 1,
     *     items: [
     *       { header: { text: 'TabItem1' }, content: 'Tab Item1 Content' },
     *       { header: { text: 'TabItem2' }, content: 'Tab Item2 Content' }
     *     ]
     *   });
     *   tabObj.appendTo('#tab');
     * ```
     * @default 0
     */
    selectedItem: number;
    /**
     * Specifies the orientation of Tab header.
     * The possible values are:
     * - Top: Places the Tab header on the top.
     * - Bottom: Places the Tab header at the bottom.
     * @default 'Top'
     */
    headerPlacement: HeaderPosition;
    /**
     * Specifies the height style for Tab content.
     * The possible values are:
     * - None: Based on the given height property, the content panel height is set.
     * - Auto: Tallest panel height of a given Tab content is set to all the other panels.
     * - Content: Based on the corresponding content height, the content panel height is set.
     * - Fill: Based on the parent height, the content panel hight is set.
     * @default 'Content'
     */
    heightAdjustMode: HeightStyles;
    /**
     * Specifies the Tab display mode when Tab content exceeds the viewing area.
     * The possible modes are:
     * - Scrollable: All the elements are displayed in a single line with horizontal scrolling enabled.
     * - Popup: Tab container holds the items that can be placed within the available space and rest of the items are moved to the popup.
     * If the popup content overflows the height of the page, the rest of the elements can be viewed by scrolling the popup.
     * @default 'Scrollable'
     */
    overflowMode: OverflowMode;
    /**
     * Specifies the direction of the Tab. For the culture like Arabic, direction can be switched as right-to-left.
     * @default false
     */
    enableRtl: boolean;
    /**
     * Enable or disable persisting component's state between page reloads.
     * If enabled, following list of states will be persisted.
     * 1. selectedItem
     * @default false.
     */
    enablePersistence: boolean;
    /**
     * Specifies whether to show the close button for header items to remove the item from the Tab.
     * @default false
     */
    showCloseButton: boolean;
    /**
     * Specifies the animation configuration settings while showing the content of the Tab.
     * @default
     * { previous: { effect: 'SlideLeftIn', duration: 600, easing: 'ease' },
     *   next: { effect: 'SlideRightIn', duration: 600, easing: 'ease' } }
     */
    animation: TabAnimationSettingsModel;
    /**
     * The event will be fired once the component rendering is completed.
     * @event
     */
    created: base.EmitType<Event>;
    /**
     * The event will be fired before adding the item to the Tab.
     * @event
     */
    adding: base.EmitType<Event>;
    /**
     * The event will be fired after adding the item to the Tab.
     * @event
     */
    added: base.EmitType<Event>;
    /**
     * The event will be fired before the item gets selected.
     * @event
     */
    selecting: base.EmitType<SelectEventArgs>;
    /**
     * The event will be fired after the item gets selected.
     * @event
     */
    selected: base.EmitType<SelectEventArgs>;
    /**
     * The event will be fired before removing the item from the Tab.
     * @event
     */
    removing: base.EmitType<RemoveEventArgs>;
    /**
     * The event will be fired after removing the item from the Tab.
     * @event
     */
    removed: base.EmitType<RemoveEventArgs>;
    /**
     * The event will be fired when the component gets destroyed.
     * @event
     */
    destroyed: base.EmitType<Event>;
    /**
     * Removes the component from the DOM and detaches all its related event handlers, attributes and classes.
     * @returns void
     */
    destroy(): void;
    /**
     * Initialize component
     * @private
     */
    protected preRender(): void;
    /**
     * Initializes a new instance of the Tab class.
     * @param options  - Specifies Tab model properties as options.
     * @param element  - Specifies the element that is rendered as a Tab.
     */
    constructor(options?: TabModel, element?: string | HTMLElement);
    /**
     * Initialize the component rendering
     * @private
     */
    protected render(): void;
    private renderContainer();
    private renderHeader();
    private renderContent();
    private parseObject(items, index);
    private removeActiveClass(id);
    private checkPopupOverflow(ele);
    private popupHandler(target);
    private setCloseButton(val);
    private prevCtnAnimation(prev, current);
    private triggerPrevAnimation(oldCnt, prevIndex);
    private triggerAnimation(id, value);
    private keyPressed(trg);
    private getEleIndex(item);
    private extIndex(id);
    private expTemplateContent();
    private templateCompile(ele, cnt);
    private getContent(ele, index, callType);
    private getTrgContent(cntEle, no);
    private findEle(items, key);
    private setOrientation(place, ele);
    private setCssClass(ele, cls, val);
    private setContentHeight(val);
    private getHeight(ele);
    private setActiveBorder();
    private setActive(value);
    private setItems(items);
    private setRTL(value);
    private refreshActiveBorder();
    private wireEvents();
    private unWireEvents();
    private clickHandler(args);
    private swipeHandler(e);
    private spaceKeyDown(e);
    private keyHandler(e);
    private refreshActElePosition();
    private refreshItemVisibility(target);
    private hoverHandler(e);
    /**
     * Enables or disables the specified Tab item. On passing value as `false`, the item will be disabled.
     * @param  {number} index - Index value of target Tab item.
     * @param  {boolean} value - Boolean value that determines whether the command should be enabled or disabled.
     * By default, isEnable is true.
     * @returns void.
     */
    enableTab(index: number, value: boolean): void;
    /**
     * Adds new items to the Tab that accepts an array as Tab items.
     * @param  {TabItemsModel[]} items - An array of item that is added to the Tab.
     * @param  {number} index - Number value that determines where the items to be added. By default, index is 0.
     * @returns void.
     */
    addTab(items: TabItemModel[], index?: number): void;
    /**
     * Removes the items in the Tab from the specified index.
     * @param  {number} index - Index of target item that is going to be removed.
     * @returns void.
     */
    removeTab(index: number): void;
    /**
     * Shows or hides the Tab that is in the specified index.
     * @param  {number} index - Index value of target item.
     * @param  {boolean} value - Based on this Boolean value, item will be hide (false) or show (true). By default, value is true.
     * @returns void.
     */
    hideTab(index: number, value?: boolean): void;
    /**
     * Specifies the index or HTMLElement to select an item from the Tab.
     * @param  {number | HTMLElement} args - Index or DOM element is used for selecting an item from the Tab.
     * @returns void.
     */
    select(args: number | HTMLElement): void;
    /**
     * Specifies the value to disable/enable the Tab component.
     * When set to `true`, the component will be disabled.
     * @param  {boolean} value - Based on this Boolean value, Tab will be enabled (false) or disabled (true).
     * @returns void.
     */
    disable(value: boolean): void;
    /**
     * Get the properties to be maintained in the persisted state.
     * @returns string
     */
    protected getPersistData(): string;
    /**
     * Returns the current module name.
     * @returns string
     * @private
     */
    protected getModuleName(): string;
    /**
     * Gets called when the model property changes.The data that describes the old and new values of the property that changed.
     * @param  {TabModel} newProp
     * @param  {TabModel} oldProp
     * @returns void
     * @private
     */
    onPropertyChanged(newProp: TabModel, oldProp: TabModel): void;
}
/**
 * Toolbar modules
 */
/**
 * Interface for a class Item
 */
export interface ItemModel {
    /**
     * Specifies the unique ID to be used with button or input element of Toolbar items.
     * @default ""
     */
    id?: string;
    /**
     * Specifies the text to be displayed on the Toolbar button.
     * @default ""
     */
    text?: string;
    /**
     * Specifies the width of the Toolbar button commands.
     * @default 'auto'
     */
    width?: number | string;
    /**
     * Defines single/multiple classes (separated by space) to be used for customization of commands.
     * @default ""
     */
    cssClass?: string;
    /**
     * Defines the priority of items to display it in popup always.
     * It allows to maintain toolbar item on popup always but it does not work for toolbar priority items.
     * @default false
     */
    showAlwaysInPopup?: boolean;
    /**
     * Defines single/multiple classes separated by space used to specify an icon for the button.
     * The icon will be positioned before the text content if text is available, otherwise the icon alone will be rendered.
     * @default ""
     */
    prefixIcon?: string;
    /**
     * Defines single/multiple classes separated by space used to specify an icon for the button.
     * The icon will be positioned after the text content if text is available.
     * @default ""
     */
    suffixIcon?: string;
    /**
     * Specifies the Toolbar command display area when an element's content is too large to fit available space.
     * This is applicable only to `popup` mode. Possible values are:
     * - show:  Always shows the item as the primary priority on the *Toolbar*.
     * - hide: Always shows the item as the secondary priority on the *popup*.
     * - none: No priority for display, and as per normal order moves to popup when content exceeds.
     * @default 'None'
     */
    overflow?: OverflowOption;
    /**
     * Specifies the HTML element/element ID as a string that can be added as a Toolbar command.
     * ```
     * E.g - items: [{ template: '<input placeholder="Search"/>' },{ template: '#checkbox1' }]
     * ```
     * @default ""
     */
    template?: string | Object;
    /**
     * Specifies the types of command to be rendered in the Toolbar.
     * Supported types are:
     * - base.Button: Creates the base.Button control with its given properties like text, prefixIcon, etc.
     * - Separator: Adds a horizontal line that separates the Toolbar commands.
     * - Input: Creates an input element that is applicable to template rendering with Syncfusion controls like DropDownList,
     * AutoComplete, etc.
     * @default 'base.Button'
     */
    type?: ItemType;
    /**
     * Specifies where the button text will be displayed on *popup mode* of the Toolbar.
     * Possible values are:
     * - Toolbar:  Text will be displayed on *Toolbar* only.
     * - Overflow: Text will be displayed only when content overflows to *popup*.
     * - Both: Text will be displayed on *popup* and *Toolbar*.
     * @default 'Both'
     */
    showTextOn?: DisplayMode;
    /**
     * Defines htmlAttributes used to add custom base.attributes to Toolbar command.
     * Supports HTML base.attributes such as style, class, etc.
     * @default 'null'
     */
    htmlAttributes?: { [key: string]: string; };
    /**
     * Specifies the text to be displayed on the Toolbar button.
     * @default ""
     */
    tooltipText?: string;
    /**
     * Specifies the location for aligning Toolbar items on the Toolbar. Each command will be aligned according to the `align` property.
     * Possible values are:
     * - Left: To align commands to the left side of the Toolbar.
     * - Center: To align commands at the center of the Toolbar.
     * - Right: To align commands to the right side of the Toolbar.
     * ```html
     * <div id="element"> </div>
     * ```
     * ```typescript
     * let toolbar: Toolbar = new Toolbar({
     *     items: [
     *         { text: "Home" },
     *         { text: "My Home Page" , align: 'Center' },
     *         { text: "Search", align: 'Right' }
     *         { text: "Settings", align: 'Right' }
     *     ]
     * });
     * toolbar.appendTo('#element');
     * ```
     * @default "Left"
     */
    align?: ItemAlign;
}
/**
 * Interface for a class Toolbar
 */
export interface ToolbarModel extends base.ComponentModel{
    /**
     * An array of items that is used to configure Toolbar commands.
     * @default []
     */
    items?: ItemModel[];
    /**
     * Specifies the width of the Toolbar in pixels/numbers/percentage. Number value is considered as pixels.
     * @default 'auto'
     */
    width?: string | number;
    /**
     * Specifies the height of the Toolbar in pixels/number/percentage. Number value is considered as pixels.
     * @default 'auto'
     */
    height?: string | number;
    /**
     * Specifies the Toolbar display mode when Toolbar content exceeds the viewing area.
     * Possible modes are:
     * - Scrollable: All the elements are displayed in a single line with horizontal scrolling enabled.
     * - base.Popup: Prioritized elements are displayed on the Toolbar and the rest of elements are moved to the *popup*.
     * If the popup content overflows the height of the page, the rest of the elements will be hidden.
     * @default 'Scrollable'
     */
    overflowMode?: OverflowMode;
    /**
     * Specifies the direction of the Toolbar commands. For cultures like Arabic, Hebrew, etc. direction can be switched to right to left.
     * @default 'false'
     */
    enableRtl?: boolean;
    /**
     * The event will be fired on clicking the Toolbar elements.
     * @event
     */
    clicked?: base.EmitType<ClickEventArgs>;
    /**
     * The event will be fired when the control is rendered.
     * @event
     */
    created?: base.EmitType<Event>;
    /**
     * The event will be fired when the control gets destroyed.
     * @event
     */
    destroyed?: base.EmitType<Event>;
    /**
     * The event will be fired before the control is rendered on a page.
     * @event
     */
    beforeCreate?: base.EmitType<Event>;
}
/**
 * Specifies the options for supporting element types of Toolbar command.
 */
export  type ItemType = 'Button' | 'Separator' | 'Input';
/**
 * Specifies the options of where the text will be displayed in popup mode of the Toolbar.
 */
export  type DisplayMode = 'Both' | 'Overflow' | 'Toolbar';
/**
 * Specifies the options of the Toolbar item display area when the Toolbar content overflows to available space.Applicable to `popup` mode.
 */
export  type OverflowOption = 'None' | 'Show' | 'Hide';
/**
 * Specifies the options of Toolbar display mode. Display option is considered when Toolbar content exceeds the available space.
 */
export  type OverflowMode = 'Scrollable' | 'Popup';
export  type ItemAlign = 'Left' | 'Center' | 'Right';
export interface ClickEventArgs extends base.BaseEventArgs {
    /** Defines the current Toolbar Item Object. */
    item: ItemModel;
    /** Defines the current Event arguments. */
    originalEvent: Event;
    /** Defines the prevent action. */
    cancel?: boolean;
}
/**
 * An item object that is used to configure Toolbar commands.
 */
export  class Item extends base.ChildProperty<Item> {
    /**
     * Specifies the unique ID to be used with button or input element of Toolbar items.
     * @default ""
     */
    id: string;
    /**
     * Specifies the text to be displayed on the Toolbar button.
     * @default ""
     */
    text: string;
    /**
     * Specifies the width of the Toolbar button commands.
     * @default 'auto'
     */
    width: number | string;
    /**
     * Defines single/multiple classes (separated by space) to be used for customization of commands.
     * @default ""
     */
    cssClass: string;
    /**
     * Defines the priority of items to display it in popup always.
     * It allows to maintain toolbar item on popup always but it does not work for toolbar priority items.
     * @default false
     */
    showAlwaysInPopup: boolean;
    /**
     * Defines single/multiple classes separated by space used to specify an icon for the button.
     * The icon will be positioned before the text content if text is available, otherwise the icon alone will be rendered.
     * @default ""
     */
    prefixIcon: string;
    /**
     * Defines single/multiple classes separated by space used to specify an icon for the button.
     * The icon will be positioned after the text content if text is available.
     * @default ""
     */
    suffixIcon: string;
    /**
     * Specifies the Toolbar command display area when an element's content is too large to fit available space.
     * This is applicable only to `popup` mode. Possible values are:
     * - show:  Always shows the item as the primary priority on the *Toolbar*.
     * - hide: Always shows the item as the secondary priority on the *popup*.
     * - none: No priority for display, and as per normal order moves to popup when content exceeds.
     * @default 'None'
     */
    overflow: OverflowOption;
    /**
     * Specifies the HTML element/element ID as a string that can be added as a Toolbar command.
     * ```
     * E.g - items: [{ template: '<input placeholder="Search"/>' },{ template: '#checkbox1' }]
     * ```
     * @default ""
     */
    template: string | Object;
    /**
     * Specifies the types of command to be rendered in the Toolbar.
     * Supported types are:
     * - Button: Creates the Button control with its given properties like text, prefixIcon, etc.
     * - Separator: Adds a horizontal line that separates the Toolbar commands.
     * - Input: Creates an input element that is applicable to template rendering with Syncfusion controls like DropDownList,
     * AutoComplete, etc.
     * @default 'Button'
     */
    type: ItemType;
    /**
     * Specifies where the button text will be displayed on *popup mode* of the Toolbar.
     * Possible values are:
     * - Toolbar:  Text will be displayed on *Toolbar* only.
     * - Overflow: Text will be displayed only when content overflows to *popup*.
     * - Both: Text will be displayed on *popup* and *Toolbar*.
     * @default 'Both'
     */
    showTextOn: DisplayMode;
    /**
     * Defines htmlAttributes used to add custom attributes to Toolbar command.
     * Supports HTML attributes such as style, class, etc.
     * @default 'null'
     */
    htmlAttributes: {
        [key: string]: string;
    };
    /**
     * Specifies the text to be displayed on the Toolbar button.
     * @default ""
     */
    tooltipText: string;
    /**
     * Specifies the location for aligning Toolbar items on the Toolbar. Each command will be aligned according to the `align` property.
     * Possible values are:
     * - Left: To align commands to the left side of the Toolbar.
     * - Center: To align commands at the center of the Toolbar.
     * - Right: To align commands to the right side of the Toolbar.
     * ```html
     * <div id="element"> </div>
     * ```
     * ```typescript
     * let toolbar: Toolbar = new Toolbar({
     *     items: [
     *         { text: "Home" },
     *         { text: "My Home Page" , align: 'Center' },
     *         { text: "Search", align: 'Right' }
     *         { text: "Settings", align: 'Right' }
     *     ]
     * });
     * toolbar.appendTo('#element');
     * ```
     * @default "Left"
     */
    align: ItemAlign;
}
/**
 * The Toolbar control contains a group of commands that are aligned horizontally.
 * ```html
 * <div id="toolbar"/>
 * <script>
 *   var toolbarObj = new Toolbar();
 *   toolbarObj.appendTo("#toolbar");
 * </script>
 * ```
 */
export  class Toolbar extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    private trgtEle;
    private ctrlTem;
    /** @hidden */
    private popObj;
    /** @hidden */
    private tbarEle;
    /** @hidden */
    private tbarAlgEle;
    /** @hidden */
    private tbarAlign;
    /** @hidden */
    private tbarEleMrgn;
    /** @hidden */
    private tbResize;
    private offsetWid;
    private keyModule;
    private scrollModule;
    private activeEle;
    private popupPriCount;
    private tbarItemsCol;
    /**
     * Contains the keyboard configuration of the Toolbar.
     */
    private keyConfigs;
    /**
     * An array of items that is used to configure Toolbar commands.
     * @default []
     */
    items: ItemModel[];
    /**
     * Specifies the width of the Toolbar in pixels/numbers/percentage. Number value is considered as pixels.
     * @default 'auto'
     */
    width: string | number;
    /**
     * Specifies the height of the Toolbar in pixels/number/percentage. Number value is considered as pixels.
     * @default 'auto'
     */
    height: string | number;
    /**
     * Specifies the Toolbar display mode when Toolbar content exceeds the viewing area.
     * Possible modes are:
     * - Scrollable: All the elements are displayed in a single line with horizontal scrolling enabled.
     * - Popup: Prioritized elements are displayed on the Toolbar and the rest of elements are moved to the *popup*.
     * If the popup content overflows the height of the page, the rest of the elements will be hidden.
     * @default 'Scrollable'
     */
    overflowMode: OverflowMode;
    /**
     * Specifies the direction of the Toolbar commands. For cultures like Arabic, Hebrew, etc. direction can be switched to right to left.
     * @default 'false'
     */
    enableRtl: boolean;
    /**
     * The event will be fired on clicking the Toolbar elements.
     * @event
     */
    clicked: base.EmitType<ClickEventArgs>;
    /**
     * The event will be fired when the control is rendered.
     * @event
     */
    created: base.EmitType<Event>;
    /**
     * The event will be fired when the control gets destroyed.
     * @event
     */
    destroyed: base.EmitType<Event>;
    /**
     * The event will be fired before the control is rendered on a page.
     * @event
     */
    beforeCreate: base.EmitType<Event>;
    /**
     * Removes the control from the DOM and also removes all its related events.
     * @returns void.
     */
    destroy(): void;
    /**
     * Initialize the event handler
     * @private
     */
    protected preRender(): void;
    /**
     * Initializes a new instance of the Toolbar class.
     * @param options  - Specifies Toolbar model properties as options.
     * @param element  - Specifies the element that is rendered as a Toolbar.
     */
    constructor(options?: ToolbarModel, element?: string | HTMLElement);
    private wireEvents();
    private docKeyDown(e);
    private unwireEvents();
    private clearProperty();
    private docEvent(e);
    private destroyHScroll();
    private destroyItems();
    private destroyMode();
    private add(ele, val);
    private remove(ele, val);
    private elementFocus(ele);
    private clstElement(tbrNavChk, trgt);
    private keyHandling(clst, e, trgt, navChk, scrollChk);
    private keyActionHandler(e);
    private eleFocus(closest, pos);
    private clickHandler(e);
    private popupClickHandler(ele, popupNav, CLS_RTL);
    /**
     * To Initialize the control rendering
     * @private
     */
    protected render(): void;
    private initialize();
    private renderControl();
    private initHScroll(element, innerItems);
    private itemWidthCal(items);
    private checkOverflow(element, innerItem);
    /** @hidden */
    refreshOverflow(): void;
    private renderOverflowMode();
    private createPopupEle(ele, innerEle);
    private pushingPoppedEle(tbarObj, popupPri, ele, eleHeight);
    private createPopup();
    private popupInit(element, ele);
    private popupOpen(e);
    private popupClose(e);
    private checkPriority(ele, inEle, eleWidth, pre);
    private createPopupIcon(element);
    private tbarPriRef(inEle, indx, sepPri, el, des, elWid, wid, ig);
    private popupRefresh(popupEle, destroy);
    private ignoreEleFetch(index, innerEle);
    private checkPopupRefresh(root, popEle);
    private popupEleWidth(el);
    private popupEleRefresh(width, popupEle, destroy);
    private removePositioning();
    private refreshPositioning();
    private itemPositioning();
    private tbarItemAlign(item, itemEle, pos);
    private ctrlTemplate();
    private renderItems();
    private setAttr(attr, element);
    /**
     * Enables or disables the specified Toolbar item.
     * @param  {HTMLElement|NodeList} items - DOM element or an array of items to be enabled or disabled.
     * @param  {boolean} isEnable  - Boolean value that determines whether the command should be enabled or disabled.
     * By default, `isEnable` is set to true.
     * @returns void.
     */
    enableItems(items: HTMLElement | NodeList, isEnable?: boolean): void;
    /**
     * Adds new items to the Toolbar that accepts an array as Toolbar items.
     * @param  {ItemsModel[]} items - DOM element or an array of items to be added to the Toolbar.
     * @param  {number} index - Number value that determines where the command is to be added. By default, index is 0.
     * @returns void.
     */
    addItems(items: ItemModel[], index?: number): void;
    /**
     * Removes the items from the Toolbar. Acceptable arguments are index of item/HTMLElement/node list.
     * @param  {number|HTMLElement|NodeList|HTMLElement[]} args
     * Index or DOM element or an Array of item which is to be removed from the Toolbar.
     * @returns void.
     */
    removeItems(args: number | HTMLElement | NodeList | Element | HTMLElement[]): void;
    private removeItemByIndex(index, innerItems);
    private templateRender(templateProp, innerEle, item);
    private buttonRendering(item, innerEle);
    private renderSubComponent(item);
    private itemClick(e);
    private activeEleSwitch(ele);
    private activeEleRemove(curEle);
    protected getPersistData(): string;
    /**
     * Returns the current module name.
     * @returns string
     * @private
     */
    protected getModuleName(): string;
    private itemsRerender(newProp);
    private resize();
    /**
     * Gets called when the model property changes.The data that describes the old and new values of the property that changed.
     * @param  {ToolbarModel} newProp
     * @param  {ToolbarModel} oldProp
     * @returns void
     * @private
     */
    onPropertyChanged(newProp: ToolbarModel, oldProp: ToolbarModel): void;
    /**
     * Shows or hides the Toolbar item that is in the specified index.
     * @param  {number} index - Index value of target item.
     * @param  {boolean} value - Based on this Boolean value, item will be hide (true) or show (false). By default, value is false.
     * @returns void.
     */
    hideItem(index: number, value?: boolean): void;
}
/**
 * TreeView modules
 */
/**
 * Interface for a class FieldsSettings
 */
export interface FieldsSettingsModel {
    /**
     * Binds the field settings for child nodes or mapping field for nested nodes objects that contain array of JSON objects.
     */
    child?: string | FieldsSettingsModel;
    /**
     * Specifies the array of JavaScript objects or instance of data.DataManager to populate the nodes.
     * @default []
     */
    dataSource?: data.DataManager | { [key: string]: Object }[];
    /**
     * Specifies the mapping field for expand state of the TreeView node.
     */
    expanded?: string;
    /**
     * Specifies the mapping field for hasChildren to check whether a node has child nodes or not.
     */
    hasChildren?: string;
    /**
     * Specifies the mapping field for htmlAttributes to be added to the TreeView node.
     */
    htmlAttributes?: string;
    /**
     * Specifies the mapping field for icon class of each TreeView node that will be added before the text.
     */
    iconCss?: string;
    /**
     * Specifies the ID field mapped in dataSource.
     */
    id?: string;
    /**
     * Specifies the mapping field for image URL of each TreeView node where image will be added before the text.
     */
    imageUrl?: string;
    /**
     * Specifies the field for checked state of the TreeView node.
     */
    isChecked?: string;
    /**
     * Specifies the parent ID field mapped in dataSource.
     */
    parentID?: string;
    /**
     * Defines the external [`data.Query`](http://ej2.syncfusion.com/documentation/data/api-query.html) 
     * that will execute along with data processing.    
     * @default null    
     */
    query?: data.Query;
    /**
     * Specifies the mapping field for selected state of the TreeView node.
     */
    selected?: string;
    /**
     * Specifies the table name used to fetch data from a specific table in the server.
     */
    tableName?: string;
    /**
     * Specifies the mapping field for text displayed as TreeView node's display text.
     */
    text?: string;
    /**
     * Specifies the mapping field for tooltip that will be displayed as hovering text of the TreeView node.
     */
    tooltip?: string;
    /**
     * Specifies the mapping field for navigateUrl to be added as hyper-link of the TreeView node.
     */
    navigateUrl?: string;
}
/**
 * Interface for a class ActionSettings
 */
export interface ActionSettingsModel {
    /**
     * Specifies the type of animation.
     * @default : 'SlideDown';
     */
    effect?: base.Effect;
    /**
     * Specifies the duration to animate.
     * @default : 400;
     */
    duration?: number;
    /**
     * Specifies the animation timing function.
     * @default : 'linear';
     */
    easing?: string;
}
/**
 * Interface for a class NodeAnimationSettings
 */
export interface NodeAnimationSettingsModel {
    /**
     * Specifies the animation that applies on collapsing the nodes.
     * @default { effect: 'SlideUp', duration: 400, easing: 'linear' }
     */
    collapse?: ActionSettingsModel;
    /**
     * Specifies the animation that applies on expanding the nodes.
     * @default { effect: 'SlideDown', duration: 400, easing: 'linear' }
     */
    expand?: ActionSettingsModel;
}
/**
 * Interface for a class TreeView
 */
export interface TreeViewModel extends base.ComponentModel{
    /**
     * Indicates whether the TreeView allows drag and drop of nodes. To drag and drop a node in
     * desktop, hold the mouse on the node, drag it to the target node and drop the node by releasing
     * the mouse. For touch devices, drag and drop operation is performed by touch, touch move
     * and touch end. For more information on drag and drop nodes concept, refer to 
     * [Drag and Drop](./drag-and-drop.html).
     * @default false
     */
    allowDragAndDrop?: boolean;
    /**
     * Enables or disables editing of the text in the TreeView node. When `allowEditing` property is set 
     * to true, the TreeView allows you to edit the node by double clicking the node or by navigating to
     * the node and pressing **F2** key. For more information on node editing, refer
     * to [Node Editing](./node-editing.html).
     * @default false
     */
    allowEditing?: boolean;
    /**
     * Enables or disables multi-selection of nodes. To base.select multiple nodes:
     * * Select the nodes by holding down the CTRL key while clicking on the nodes.
     * * Select consecutive nodes by clicking the first node to base.select and hold down the **SHIFT** key
     * and click the last node to base.select.
     * 
     * For more information on multi-selection, refer to 
     * [Multi-Selection](./multi-selection.html).
     * @default false
     */
    allowMultiSelection?: boolean;
    /**
     * Specifies the type of animation applied on expanding and collapsing the nodes along with duration.
     * @default {expand: { effect: 'SlideDown', duration: 400, easing: 'linear' },
     * collapse: { effect: 'SlideUp', duration: 400, easing: 'linear' }}
     */
    animation?: NodeAnimationSettingsModel;
    /**
     * The `checkedNodes` property is used to set the nodes that need to be checked or
     * get the ID of nodes that are currently checked in the TreeView component.
     * The `checkedNodes` property depends upon the value of `showCheckBox` property.
     * For more information on checkedNodes, refer to
     * [checkedNodes](./checkbox.html#checked-nodes).
     * @default []
     */
    checkedNodes?: string[];
    /**
     * Specifies the CSS classes to be added with root element of the TreeView to help customize the appearance of the component.
     * @default ''
     */
    cssClass?: string;
    /**
     * Enables or disables persisting TreeView state between page reloads. If enabled, following APIs will persist.
     * 1. `selectedNodes` - Represents the nodes that are selected in the TreeView component.
     * 2. `checkedNodes`  - Represents the nodes that are checked in the TreeView component.
     * @default false
     */
    enablePersistence?: boolean;
    /**
     * Enables or disables RTL mode on the component that displays the content in the right to left direction.
     * @default false
     */
    enableRtl?: boolean;
    /**
     * Specifies the action on which the node expands or collapses. The available actions are,
     * * `Auto` - In desktop, the expand/collapse operation happens when you double-click the node, and in mobile devices it
     * happens on single-click.
     * * `Click` - The expand/collapse operation happens when you single-click the node in both desktop and mobile devices.
     * * `DblClick` - The expand/collapse operation happens when you double-click the node in both desktop and mobile devices.
     * @default 'Auto'
     */
    expandOn?: ExpandOnSettings;
    /**
     * Specifies the data source and mapping fields to render TreeView nodes.
     * @default {id: 'id', text: 'text', dataSource: [], child: 'child', parentID: 'parentID', hasChildren: 'hasChildren',
     *  expanded: 'expanded', htmlAttributes: 'htmlAttributes', iconCss: 'iconCss', imageUrl: 'imageUrl', isChecked: 'isChecked',
     *  query: null, selected: 'selected', tableName: null, tooltip: 'tooltip', navigateUrl: 'navigateUrl'}
     */
    fields?: FieldsSettingsModel;
    /**
     * On enabling this property, the entire row of the TreeView node gets selected by clicking a node. 
     * When disabled only the corresponding node's text gets selected.
     * For more information on Fields concept, refer to
     * [Fields](./data-binding.html#local-data).
     * @default true
     */
    fullRowSelect?: boolean;
    /**
     * Specifies a template to render customized content for all the nodes. If the `nodeTemplate` property 
     * is set, the template content overrides the displayed node text. The property accepts template string
     * [template string](http://ej2.syncfusion.com/documentation/base/template-engine.html) 
     * or HTML element ID holding the content. For more information on template concept, refer to
     * [Template](./template.html).
     * @default null
     */
    nodeTemplate?: string;
    /**
     * Represents the selected nodes in the TreeView component. We can set the nodes that need to be 
     * selected or get the ID of the nodes that are currently selected by using this property. 
     * On enabling `allowMultiSelection` property we can base.select multiple nodes and on disabling 
     * it we can base.select only a single node.
     * For more information on selectedNodes, refer to 
     * [selectedNodes](./multi-selection.html#selected-nodes).
     * @default []
     */
    selectedNodes?: string[];
    /**
     * Specifies a value that indicates whether the nodes are sorted in the ascending or descending order,
     * or are not sorted at all. The available types of sort order are,
     * * `None` - The nodes are not sorted.
     * * `Ascending` - The nodes are sorted in the ascending order.
     * * `Descending` - The nodes are sorted in the ascending order.
     * @default 'None'
     */
    sortOrder?: SortOrder;
    /**
     * Indicates that the nodes will display CheckBoxes in the TreeView.
     * The CheckBox will be displayed next to the expand/collapse icon of the node. For more information on CheckBoxes, refer to
     * [CheckBox](./checkbox.html).
     * @default false
     */
    showCheckBox?: boolean;
    /**
     * Triggers when the TreeView control is created successfully.
     * @event
     */
    created?: base.EmitType<Object>;
    /**
     * Triggers when data source is populated in the TreeView.
     * @event 
     */
    dataBound?: base.EmitType<DataBoundEventArgs>;
    /**
     * Triggers before the TreeView node is appended to the TreeView element. It helps to customize specific nodes.
     * @event
     */
    drawNode?: base.EmitType<DrawNodeEventArgs>;
    /**
     * Triggers when the TreeView control is destroyed successfully.
     * @event
     */
    destroyed?: base.EmitType<Object>;
    /**
     * Triggers when key press is successful. It helps to customize the operations at key press.
     * @event
     */
    keyPress?: base.EmitType<NodeKeyPressEventArgs>;
    /**
     * Triggers when the TreeView node is checked/unchecked successfully.
     * @event 
     */
    nodeChecked?: base.EmitType<NodeCheckEventArgs>;
    /**
     * Triggers before the TreeView node is to be checked/unchecked.
     * @event 
     */
    nodeChecking?: base.EmitType<NodeCheckEventArgs>;
    /**
     * Triggers when the TreeView node is clicked successfully.
     * @event
     */
    nodeClicked?: base.EmitType<NodeClickEventArgs>;
    /**
     * Triggers when the TreeView node collapses successfully.
     * @event 
     */
    nodeCollapsed?: base.EmitType<NodeExpandEventArgs>;
    /**
     * Triggers before the TreeView node collapses.
     * @event 
     */
    nodeCollapsing?: base.EmitType<NodeExpandEventArgs>;
    /**
     * Triggers when the TreeView node is dragged (moved) continuously.
     * @event 
     */
    nodeDragging?: base.EmitType<DragAndDropEventArgs>;
    /**
     * Triggers when the TreeView node drag (move) starts.
     * @event 
     */
    nodeDragStart?: base.EmitType<DragAndDropEventArgs>;
    /**
     * Triggers when the TreeView node drag (move) is stopped.
     * @event 
     */
    nodeDragStop?: base.EmitType<DragAndDropEventArgs>;
    /**
     * Triggers when the TreeView node is dropped on target element successfully.
     * @event 
     */
    nodeDropped?: base.EmitType<DragAndDropEventArgs>;
    /**
     * Triggers when the TreeView node is renamed successfully.
     * @event 
     */
    nodeEdited?: base.EmitType<NodeEditEventArgs>;
    /**
     * Triggers before the TreeView node is renamed.
     * @event 
     */
    nodeEditing?: base.EmitType<NodeEditEventArgs>;
    /**
     * Triggers when the TreeView node expands successfully.
     * @event 
     */
    nodeExpanded?: base.EmitType<NodeExpandEventArgs>;
    /**
     * Triggers before the TreeView node is to be expanded.
     * @event 
     */
    nodeExpanding?: base.EmitType<NodeExpandEventArgs>;
    /**
     * Triggers when the TreeView node is selected/unselected successfully.
     * @event 
     */
    nodeSelected?: base.EmitType<NodeSelectEventArgs>;
    /**
     * Triggers before the TreeView node is selected/unselected.
     * @event 
     */
    nodeSelecting?: base.EmitType<NodeSelectEventArgs>;
}
export interface EJ2Instance extends HTMLElement {
    ej2_instances: Object[];
}
export interface NodeExpandEventArgs {
    /**
     * If you want to cancel this event then, set cancel as true. Otherwise, false.
     */
    cancel: boolean;
    /**
     * If the event is triggered by interaction, it returns true. Otherwise, it returns false.
     */
    isInteracted: boolean;
    /**
     * Return the expanded/collapsed TreeView node.
     */
    node: HTMLLIElement;
    /**
     * Return the expanded/collapsed node as JSON object from data source.
     */
    nodeData: {
        [key: string]: Object;
    };
}
export interface NodeSelectEventArgs {
    /**
     * Return the name of action like select or un-select.
     */
    action: string;
    /**
     * If you want to cancel this event then, set cancel as true. Otherwise, false.
     */
    cancel: boolean;
    /**
     * If the event is triggered by interaction, it returns true. Otherwise, it returns false.
     */
    isInteracted: boolean;
    /**
     * Return the currently selected TreeView node.
     */
    node: HTMLLIElement;
    /**
     * Return the currently selected node as JSON object from data source.
     */
    nodeData: {
        [key: string]: Object;
    };
}
export interface NodeCheckEventArgs {
    /**
     * Return the name of action like check or un-check.
     */
    action: string;
    /**
     * If you want to cancel this event then, set cancel as true. Otherwise, false.
     */
    cancel: boolean;
    /**
     * If the event is triggered by interaction, it returns true. Otherwise, it returns false.
     */
    isInteracted: boolean;
    /**
     * Return the currently checked TreeView node.
     */
    node: HTMLLIElement;
    /**
     * Return the currently checked node as JSON object from data source.
     */
    data: {
        [key: string]: Object;
    }[];
}
export interface NodeEditEventArgs {
    /**
     * If you want to cancel this event then, set cancel as true. Otherwise, false.
     */
    cancel: boolean;
    /**
     * Return the current TreeView node new text.
     */
    newText: string;
    /**
     * Return the current TreeView node.
     */
    node: HTMLLIElement;
    /**
     * Return the current node as JSON object from data source.
     */
    nodeData: {
        [key: string]: Object;
    };
    /**
     * Return the current TreeView node old text.
     */
    oldText: string;
    /**
     * Gets or sets the inner HTML of TreeView node while editing.
     */
    innerHtml: string;
}
export interface DragAndDropEventArgs {
    /**
     * If you want to cancel this event then, set cancel as true. Otherwise, false.
     */
    cancel: boolean;
    /**
     * Return the actual event.
     */
    event: MouseEvent & TouchEvent;
    /**
     * Return the currently dragged TreeView node.
     */
    draggedNode: HTMLLIElement;
    /**
     * Return the currently dragged node as array of JSON object from data source.
     */
    draggedNodeData: {
        [key: string]: Object;
    };
    /**
     * Return the dropped TreeView node.
     */
    droppedNode: HTMLLIElement;
    /**
     * Return the dropped node as array of JSON object from data source.
     */
    droppedNodeData: {
        [key: string]: Object;
    };
    /**
     * Return the target element from which drag starts/end.
     */
    target: HTMLElement;
}
export interface DrawNodeEventArgs {
    /**
     * Return the current rendering node.
     */
    node: HTMLLIElement;
    /**
     * Return the current rendering node as JSON object.
     */
    nodeData: {
        [key: string]: Object;
    };
    /**
     * Return the current rendering node text.
     */
    text: string;
}
export interface NodeClickEventArgs {
    /**
     * Return the actual event.
     */
    event: MouseEvent;
    /**
     * Return the current clicked TreeView node.
     */
    node: HTMLLIElement;
}
export interface NodeKeyPressEventArgs {
    /**
     * If you want to cancel this event then, set cancel as true. Otherwise, false.
     */
    cancel: boolean;
    /**
     * Return the actual event.
     */
    event: base.KeyboardEventArgs;
    /**
     * Return the current active TreeView node.
     */
    node: HTMLLIElement;
}
export interface DataBoundEventArgs {
    /**
     * Return the TreeView data.
     */
    data: {
        [key: string]: Object;
    }[];
}
export interface ItemCreatedArgs {
    curData: {
        [key: string]: Object;
    };
    item: HTMLElement;
    options: lists.ListBaseOptions;
    text: string;
    fields: lists.FieldsMapping;
}
/**
 * Configures the fields to bind to the properties of node in the TreeView component.
 */
export  class FieldsSettings extends base.ChildProperty<FieldsSettings> {
    /**
     * Binds the field settings for child nodes or mapping field for nested nodes objects that contain array of JSON objects.
     */
    child: string | FieldsSettingsModel;
    /**
     * Specifies the array of JavaScript objects or instance of data.DataManager to populate the nodes.
     * @default []
     */
    dataSource: data.DataManager | {
        [key: string]: Object;
    }[];
    /**
     * Specifies the mapping field for expand state of the TreeView node.
     */
    expanded: string;
    /**
     * Specifies the mapping field for hasChildren to check whether a node has child nodes or not.
     */
    hasChildren: string;
    /**
     * Specifies the mapping field for htmlAttributes to be added to the TreeView node.
     */
    htmlAttributes: string;
    /**
     * Specifies the mapping field for icon class of each TreeView node that will be added before the text.
     */
    iconCss: string;
    /**
     * Specifies the ID field mapped in dataSource.
     */
    id: string;
    /**
     * Specifies the mapping field for image URL of each TreeView node where image will be added before the text.
     */
    imageUrl: string;
    /**
     * Specifies the field for checked state of the TreeView node.
     */
    isChecked: string;
    /**
     * Specifies the parent ID field mapped in dataSource.
     */
    parentID: string;
    /**
     * Defines the external [`data.Query`](http://ej2.syncfusion.com/documentation/data/api-query.html)
     * that will execute along with data processing.
     * @default null
     */
    query: data.Query;
    /**
     * Specifies the mapping field for selected state of the TreeView node.
     */
    selected: string;
    /**
     * Specifies the table name used to fetch data from a specific table in the server.
     */
    tableName: string;
    /**
     * Specifies the mapping field for text displayed as TreeView node's display text.
     */
    text: string;
    /**
     * Specifies the mapping field for tooltip that will be displayed as hovering text of the TreeView node.
     */
    tooltip: string;
    /**
     * Specifies the mapping field for navigateUrl to be added as hyper-link of the TreeView node.
     */
    navigateUrl: string;
}
export  type ExpandOnSettings = 'Auto' | 'Click' | 'DblClick';
export  type SortOrder = 'None' | 'Ascending' | 'Descending';
/**
 * Configures animation settings for the TreeView component.
 */
export  class ActionSettings extends base.ChildProperty<ActionSettings> {
    /**
     * Specifies the type of animation.
     * @default : 'SlideDown';
     */
    effect: base.Effect;
    /**
     * Specifies the duration to animate.
     * @default : 400;
     */
    duration: number;
    /**
     * Specifies the animation timing function.
     * @default : 'linear';
     */
    easing: string;
}
/**
 * Configures the animation settings for expanding and collapsing nodes in TreeView.
 */
export  class NodeAnimationSettings extends base.ChildProperty<NodeAnimationSettings> {
    /**
     * Specifies the animation that applies on collapsing the nodes.
     * @default { effect: 'SlideUp', duration: 400, easing: 'linear' }
     */
    collapse: ActionSettingsModel;
    /**
     * Specifies the animation that applies on expanding the nodes.
     * @default { effect: 'SlideDown', duration: 400, easing: 'linear' }
     */
    expand: ActionSettingsModel;
}
/**
 * The TreeView component is used to represent hierarchical data in a tree like structure with advanced
 * functions to perform edit, drag and drop, selection with check-box, and more.
 * ```html
 *  <div id="tree"></div>
 * ```
 * ```typescript
 *  let treeObj: TreeView = new TreeView();
 *  treeObj.appendTo('#tree');
 * ```
 */
export  class TreeView extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    private cloneElement;
    private treeData;
    private rootData;
    private groupedData;
    private ulElement;
    private listBaseOption;
    private dataType;
    private rippleFn;
    private rippleIconFn;
    private isNumberTypeId;
    private expandOnType;
    private keyboardModule;
    private liList;
    private aniObj;
    private treeList;
    private isLoaded;
    private expandArgs;
    private oldText;
    private dragObj;
    private dropObj;
    private dragTarget;
    private dragLi;
    private dragData;
    private startNode;
    private nodeTemplateFn;
    private currentLoadData;
    private checkActionNodes;
    private touchEditObj;
    private touchClickObj;
    private dragStartAction;
    private touchExpandObj;
    private inputObj;
    private isAnimate;
    private spinnerElement;
    private touchClass;
    private editData;
    private editFields;
    private keyConfigs;
    /**
     * Indicates whether the TreeView allows drag and drop of nodes. To drag and drop a node in
     * desktop, hold the mouse on the node, drag it to the target node and drop the node by releasing
     * the mouse. For touch devices, drag and drop operation is performed by touch, touch move
     * and touch end. For more information on drag and drop nodes concept, refer to
     * [Drag and Drop](./drag-and-drop.html).
     * @default false
     */
    allowDragAndDrop: boolean;
    /**
     * Enables or disables editing of the text in the TreeView node. When `allowEditing` property is set
     * to true, the TreeView allows you to edit the node by double clicking the node or by navigating to
     * the node and pressing **F2** key. For more information on node editing, refer
     * to [Node Editing](./node-editing.html).
     * @default false
     */
    allowEditing: boolean;
    /**
     * Enables or disables multi-selection of nodes. To select multiple nodes:
     * * Select the nodes by holding down the CTRL key while clicking on the nodes.
     * * Select consecutive nodes by clicking the first node to select and hold down the **SHIFT** key
     * and click the last node to select.
     *
     * For more information on multi-selection, refer to
     * [Multi-Selection](./multi-selection.html).
     * @default false
     */
    allowMultiSelection: boolean;
    /**
     * Specifies the type of animation applied on expanding and collapsing the nodes along with duration.
     * @default {expand: { effect: 'SlideDown', duration: 400, easing: 'linear' },
     * collapse: { effect: 'SlideUp', duration: 400, easing: 'linear' }}
     */
    animation: NodeAnimationSettingsModel;
    /**
     * The `checkedNodes` property is used to set the nodes that need to be checked or
     * get the ID of nodes that are currently checked in the TreeView component.
     * The `checkedNodes` property depends upon the value of `showCheckBox` property.
     * For more information on checkedNodes, refer to
     * [checkedNodes](./checkbox.html#checked-nodes).
     * @default []
     */
    checkedNodes: string[];
    /**
     * Specifies the CSS classes to be added with root element of the TreeView to help customize the appearance of the component.
     * @default ''
     */
    cssClass: string;
    /**
     * Enables or disables persisting TreeView state between page reloads. If enabled, following APIs will persist.
     * 1. `selectedNodes` - Represents the nodes that are selected in the TreeView component.
     * 2. `checkedNodes`  - Represents the nodes that are checked in the TreeView component.
     * @default false
     */
    enablePersistence: boolean;
    /**
     * Enables or disables RTL mode on the component that displays the content in the right to left direction.
     * @default false
     */
    enableRtl: boolean;
    /**
     * Specifies the action on which the node expands or collapses. The available actions are,
     * * `Auto` - In desktop, the expand/collapse operation happens when you double-click the node, and in mobile devices it
     * happens on single-click.
     * * `Click` - The expand/collapse operation happens when you single-click the node in both desktop and mobile devices.
     * * `DblClick` - The expand/collapse operation happens when you double-click the node in both desktop and mobile devices.
     * @default 'Auto'
     */
    expandOn: ExpandOnSettings;
    /**
     * Specifies the data source and mapping fields to render TreeView nodes.
     * @default {id: 'id', text: 'text', dataSource: [], child: 'child', parentID: 'parentID', hasChildren: 'hasChildren',
     *  expanded: 'expanded', htmlAttributes: 'htmlAttributes', iconCss: 'iconCss', imageUrl: 'imageUrl', isChecked: 'isChecked',
     *  query: null, selected: 'selected', tableName: null, tooltip: 'tooltip', navigateUrl: 'navigateUrl'}
     */
    fields: FieldsSettingsModel;
    /**
     * On enabling this property, the entire row of the TreeView node gets selected by clicking a node.
     * When disabled only the corresponding node's text gets selected.
     * For more information on Fields concept, refer to
     * [Fields](./data-binding.html#local-data).
     * @default true
     */
    fullRowSelect: boolean;
    /**
     * Specifies a template to render customized content for all the nodes. If the `nodeTemplate` property
     * is set, the template content overrides the displayed node text. The property accepts template string
     * [template string](http://ej2.syncfusion.com/documentation/base/template-engine.html)
     * or HTML element ID holding the content. For more information on template concept, refer to
     * [Template](./template.html).
     * @default null
     */
    nodeTemplate: string;
    /**
     * Represents the selected nodes in the TreeView component. We can set the nodes that need to be
     * selected or get the ID of the nodes that are currently selected by using this property.
     * On enabling `allowMultiSelection` property we can select multiple nodes and on disabling
     * it we can select only a single node.
     * For more information on selectedNodes, refer to
     * [selectedNodes](./multi-selection.html#selected-nodes).
     * @default []
     */
    selectedNodes: string[];
    /**
     * Specifies a value that indicates whether the nodes are sorted in the ascending or descending order,
     * or are not sorted at all. The available types of sort order are,
     * * `None` - The nodes are not sorted.
     * * `Ascending` - The nodes are sorted in the ascending order.
     * * `Descending` - The nodes are sorted in the ascending order.
     * @default 'None'
     */
    sortOrder: SortOrder;
    /**
     * Indicates that the nodes will display CheckBoxes in the TreeView.
     * The CheckBox will be displayed next to the expand/collapse icon of the node. For more information on CheckBoxes, refer to
     * [CheckBox](./checkbox.html).
     * @default false
     */
    showCheckBox: boolean;
    /**
     * Triggers when the TreeView control is created successfully.
     * @event
     */
    created: base.EmitType<Object>;
    /**
     * Triggers when data source is populated in the TreeView.
     * @event
     */
    dataBound: base.EmitType<DataBoundEventArgs>;
    /**
     * Triggers before the TreeView node is appended to the TreeView element. It helps to customize specific nodes.
     * @event
     */
    drawNode: base.EmitType<DrawNodeEventArgs>;
    /**
     * Triggers when the TreeView control is destroyed successfully.
     * @event
     */
    destroyed: base.EmitType<Object>;
    /**
     * Triggers when key press is successful. It helps to customize the operations at key press.
     * @event
     */
    keyPress: base.EmitType<NodeKeyPressEventArgs>;
    /**
     * Triggers when the TreeView node is checked/unchecked successfully.
     * @event
     */
    nodeChecked: base.EmitType<NodeCheckEventArgs>;
    /**
     * Triggers before the TreeView node is to be checked/unchecked.
     * @event
     */
    nodeChecking: base.EmitType<NodeCheckEventArgs>;
    /**
     * Triggers when the TreeView node is clicked successfully.
     * @event
     */
    nodeClicked: base.EmitType<NodeClickEventArgs>;
    /**
     * Triggers when the TreeView node collapses successfully.
     * @event
     */
    nodeCollapsed: base.EmitType<NodeExpandEventArgs>;
    /**
     * Triggers before the TreeView node collapses.
     * @event
     */
    nodeCollapsing: base.EmitType<NodeExpandEventArgs>;
    /**
     * Triggers when the TreeView node is dragged (moved) continuously.
     * @event
     */
    nodeDragging: base.EmitType<DragAndDropEventArgs>;
    /**
     * Triggers when the TreeView node drag (move) starts.
     * @event
     */
    nodeDragStart: base.EmitType<DragAndDropEventArgs>;
    /**
     * Triggers when the TreeView node drag (move) is stopped.
     * @event
     */
    nodeDragStop: base.EmitType<DragAndDropEventArgs>;
    /**
     * Triggers when the TreeView node is dropped on target element successfully.
     * @event
     */
    nodeDropped: base.EmitType<DragAndDropEventArgs>;
    /**
     * Triggers when the TreeView node is renamed successfully.
     * @event
     */
    nodeEdited: base.EmitType<NodeEditEventArgs>;
    /**
     * Triggers before the TreeView node is renamed.
     * @event
     */
    nodeEditing: base.EmitType<NodeEditEventArgs>;
    /**
     * Triggers when the TreeView node expands successfully.
     * @event
     */
    nodeExpanded: base.EmitType<NodeExpandEventArgs>;
    /**
     * Triggers before the TreeView node is to be expanded.
     * @event
     */
    nodeExpanding: base.EmitType<NodeExpandEventArgs>;
    /**
     * Triggers when the TreeView node is selected/unselected successfully.
     * @event
     */
    nodeSelected: base.EmitType<NodeSelectEventArgs>;
    /**
     * Triggers before the TreeView node is selected/unselected.
     * @event
     */
    nodeSelecting: base.EmitType<NodeSelectEventArgs>;
    constructor(options?: TreeViewModel, element?: string | HTMLElement);
    /**
     * Get component name.
     * @returns string
     * @private
     */
    getModuleName(): string;
    /**
     * Initialize the event handler
     */
    protected preRender(): void;
    /**
     * Get the properties to be maintained in the persisted state.
     * @returns string
     * @hidden
     */
    getPersistData(): string;
    /**
     * To Initialize the control rendering
     * @private
     */
    protected render(): void;
    private initialize();
    private setEnableRtl();
    private setRipple();
    private setFullRow(isEnabled);
    private setMultiSelect(isEnabled);
    private templateComplier(template);
    private setDataBinding();
    private getQuery(mapper, value?);
    private getType();
    private setRootData();
    private renderItems(isSorted);
    private beforeNodeCreate(e);
    private frameMouseHandler(e);
    private addActionClass(e, action, cssClass);
    private getDataType(ds, mapper);
    private getGroupedData(dataSource, groupBy);
    private getSortedData(list);
    private finalizeNode(element);
    private updateCheckedProp();
    private ensureParentCheckState(element);
    private ensureChildCheckState(element, e?);
    private doCheckBoxAction(nodes, doCheck);
    private changeState(wrapper, state, e?, isPrevent?, isAdd?);
    private addCheck(liEle);
    private removeCheck(liEle);
    private getCheckEvent(currLi, action, e);
    private finalize();
    private doSelectionAction();
    private selectGivenNodes(sNodes);
    private clickHandler(e);
    private nodeCheckingEvent(wrapper, isCheck, e);
    private nodeCheckedEvent(wrapper, isCheck, e);
    private triggerClickEvent(e, li);
    private expandNode(currLi, icon);
    private expandedNode(currLi, ul, icon);
    private collapseNode(currLi, icon, e);
    private setHeight(currLi, ul);
    private animateHeight(args, start, end);
    private renderChildNodes(parentLi, expandChild?);
    private ensureCheckNode(element);
    private getFields(mapper, nodeLevel, dataLevel);
    private getChildFields(mapper, nodeLevel, dataLevel);
    private getChildMapper(mapper);
    private getChildNodes(obj, parentId, isRoot?);
    private getChildGroup(data, parentId, isRoot);
    private renderSubChild(element, expandChild?);
    private toggleSelect(li, e, multiSelect?);
    private isActive(li);
    private selectNode(li, e, multiSelect?);
    private unselectNode(li, e);
    private setFocusElement(li);
    private addSelect(liEle);
    private removeSelect(liEle);
    private removeSelectAll();
    private getSelectEvent(currLi, action, e);
    private setExpandOnType();
    private expandHandler(e);
    private expandCollapseAction(currLi, e);
    private expandAction(currLi, icon, e, expandChild?);
    private keyActionHandler(e);
    private navigateToFocus(isUp);
    private isVisibleInViewport(txtWrap);
    private getScrollParent(node);
    private shiftKeySelect(isTowards, e);
    private checkNode(e);
    private validateCheckNode(checkWrap, isCheck, li, e);
    private openNode(toBeOpened, e);
    private navigateNode(isTowards);
    private navigateRootNode(isBackwards);
    private getFocusedNode();
    private focusNextNode(li, isTowards);
    private getNextNode(li);
    private getPrevNode(li);
    private getRootNode();
    private getEndNode();
    private setFocus(preNode, nextNode);
    private updateIdAttr(preNode, nextNode);
    private focusIn();
    private focusOut();
    private onMouseOver(e);
    private setHover(li);
    private onMouseLeave(e);
    private removeHover();
    private getNodeData(currLi, fromDS?);
    private getText(currLi, fromDS?);
    private getExpandEvent(currLi, e);
    private reRenderNodes();
    private setCssClass(oldClass, newClass);
    private editingHandler(e);
    private createTextbox(liEle, e);
    private updateOldText(liEle);
    private inputFocusOut(e);
    private appendNewText(liEle, txtEle, newText, isInput);
    private getElement(ele);
    private getEditEvent(liEle, newText, inpEle);
    private getNodeObject(id);
    private getChildNodeObject(obj, mapper, id);
    private setDragAndDrop(toBind);
    private initializeDrag();
    private dragAction(e, virtualEle);
    private dropAction(e);
    private appendNode(dropTarget, dragLi, dropLi, e, dragObj, offsetY);
    private dropAsSiblingNode(dragLi, dropLi, e, dragObj);
    private dropAsChildNode(dragLi, dropLi, dragObj, index?, e?, pos?);
    private expandParent(dropLi);
    private updateElement(dragParentUl, dragParentLi);
    private updateAriaLevel(dragLi);
    private updateChildAriaLevel(element, level);
    private renderVirtualEle(e);
    private removeVirtualEle();
    private destroyDrag();
    private getDragEvent(event, obj, dropTarget, target);
    private addFullRow(toAdd);
    private createFullRow(item);
    private addMultiSelect(toAdd);
    private collapseByLevel(element, level, excludeHiddenNodes);
    private collapseAllNodes(excludeHiddenNodes);
    private expandByLevel(element, level, excludeHiddenNodes);
    private expandAllNodes(excludeHiddenNodes);
    private getVisibleNodes(excludeHiddenNodes, nodes);
    private removeNode(node);
    private updateInstance();
    private updateList();
    private updateSelectedNodes();
    private doGivenAction(nodes, selector, toExpand);
    private addGivenNodes(nodes, dropLi, index, isRemote?);
    private updateMapper(level);
    private doDisableAction(nodes);
    private doEnableAction(nodes);
    private setTouchClass();
    private wireInputEvents(inpEle);
    private wireEditingEvents(toBind);
    private wireClickEvent(toBind);
    private wireExpandOnEvent(toBind);
    private mouseDownStatus;
    private mouseDownHandler(e);
    private preventContextMenu(e);
    private wireEvents();
    private unWireEvents();
    private parents(element, selector);
    private isDescendant(parent, child);
    protected showSpinner(element: HTMLElement): void;
    protected hideSpinner(element: HTMLElement): void;
    private setCheckedNodes(nodes);
    /**
     * Called internally if any of the property value changed.
     * @param  {TreeView} newProp
     * @param  {TreeView} oldProp
     * @returns void
     * @private
     */
    onPropertyChanged(newProp: TreeViewModel, oldProp: TreeViewModel): void;
    /**
     * Removes the component from the DOM and detaches all its related event handlers. It also removes the attributes and classes.
     */
    destroy(): void;
    /**
     * Adds the collection of TreeView nodes based on target and index position. If target node is not specified,
     * then the nodes are added as children of the given parentID or in the root level of TreeView.
     * @param  { Object[] } nodes - Specifies the array of JSON data that has to be added.
     * @param  { string | Element } target - Specifies ID of TreeView node/TreeView node as target element.
     * @param  { number } index - Specifies the index to place the newly added nodes in the target element.
     */
    addNodes(nodes: {
        [key: string]: Object;
    }[], target: string | Element, index: number): void;
    /**
     * Instead of clicking on the TreeView node for editing, we can enable it by using
     * `beginEdit` property. On passing the node ID or element through this property, the edit textBox
     * will be created for the particular node thus allowing us to edit it.
     * @param  {string | Element} node - Specifies ID of TreeView node/TreeView node.
     */
    beginEdit(node: string | Element): void;
    /**
     * Checks all the unchecked nodes. You can also check specific nodes by passing array of unchecked nodes
     * as argument to this method.
     * @param  {string[] | Element[]} nodes - Specifies the array of TreeView nodes ID/array of TreeView node.
     */
    checkAll(nodes?: string[] | Element[]): void;
    /**
     * Collapses all the expanded TreeView nodes. You can collapse specific nodes by passing array of nodes as argument to this method.
     * You can also collapse all the nodes excluding the hidden nodes by setting **excludeHiddenNodes** to true. If you want to collapse
     * a specific level of nodes, set **level** as argument to collapseAll method.
     * @param  {string[] | Element[]} nodes - Specifies the array of TreeView nodes ID/ array of TreeView node.
     * @param  {number} level - TreeView nodes will collapse up to the given level.
     * @param  {boolean} excludeHiddenNodes - Whether or not to exclude hidden nodes of TreeView when collapsing all nodes.
     */
    collapseAll(nodes?: string[] | Element[], level?: number, excludeHiddenNodes?: boolean): void;
    /**
     * Disables the collection of nodes by passing the ID of nodes or node elements in the array.
     * @param  {string[] | Element[]} nodes - Specifies the array of TreeView nodes ID/array of TreeView nodes.
     */
    disableNodes(nodes: string[] | Element[]): void;
    /**
     * Enables the collection of disabled nodes by passing the ID of nodes or node elements in the array.
     * @param  {string[] | Element[]} nodes - Specifies the array of TreeView nodes ID/array of TreeView nodes.
     */
    enableNodes(nodes: string[] | Element[]): void;
    /**
     * Ensures visibility of the TreeView node by using node ID or node element.
     * When many TreeView nodes are present and we need to find a particular node, `ensureVisible` property
     * helps bring the node to visibility by expanding the TreeView and scrolling to the specific node.
     * @param  {string | Element} node - Specifies ID of TreeView node/TreeView nodes.
     */
    ensureVisible(node: string | Element): void;
    /**
     * Expands all the collapsed TreeView nodes. You can expand the specific nodes by passing the array of collapsed nodes
     * as argument to this method. You can also expand all the collapsed nodes by excluding the hidden nodes by setting
     * **excludeHiddenNodes** to true to this method. To expand a specific level of nodes, set **level** as argument to expandAll method.
     * @param  {string[] | Element[]} nodes - Specifies the array of TreeView nodes ID/array of TreeView nodes.
     * @param  {number} level - TreeView nodes will expand up to the given level.
     * @param  {boolean} excludeHiddenNodes - Whether or not to exclude hidden nodes when expanding all nodes.
     */
    expandAll(nodes?: string[] | Element[], level?: number, excludeHiddenNodes?: boolean): void;
    /**
     * Get the node's data such as id, text, parentID, selected, isChecked, and expanded by passing the node element or it's ID.
     * @param  {string | Element} node - Specifies ID of TreeView node/TreeView node.
     */
    getNode(node: string | Element): {
        [key: string]: Object;
    };
    /**
     * Moves the collection of nodes within the same TreeView based on target or its index position.
     * @param  {string[] | Element[]} sourceNodes - Specifies the array of TreeView nodes ID/array of TreeView node.
     * @param  {string | Element} target - Specifies ID of TreeView node/TreeView node as target element.
     * @param  {number} index - Specifies the index to place the moved nodes in the target element.
     */
    moveNodes(sourceNodes: string[] | Element[], target: string | Element, index: number): void;
    /**
     * Removes the collection of TreeView nodes by passing the array of node details as argument to this method.
     * @param  {string[] | Element[]} nodes - Specifies the array of TreeView nodes ID/array of TreeView node.
     */
    removeNodes(nodes: string[] | Element[]): void;
    /**
     * Replaces the text of the TreeView node with the given text.
     * @param  {string | Element} target - Specifies ID of TreeView node/TreeView node as target element.
     * @param  {string} newText - Specifies the new text of TreeView node.
     */
    updateNode(target: string | Element, newText: string): void;
    /**
     * Unchecks all the checked nodes. You can also uncheck the specific nodes by passing array of checked nodes
     * as argument to this method.
     * @param  {string[] | Element[]} nodes - Specifies the array of TreeView nodes ID/array of TreeView node.
     */
    uncheckAll(nodes?: string[] | Element[]): void;
}
 }
export namespace notifications { 

/**
 * Notification Components
 */
/**
 * Toast modules
 */
/**
 * Interface for a class ToastPosition
 */
export interface ToastPositionModel {
    /**
   * Specifies the position of the Toast notification with respect to the target container's left edge.
   * @default 'Left'
   * @aspType string
   */
    X?: PositionX | number | string;
    /**
   * Specifies the position of the Toast notification with respect to the target container's top edge.
   * @default 'Top'
   * @aspType string
   */
    Y?: PositionY | number | string;
}
/**
 * Interface for a class ButtonModelProps
 */
export interface ButtonModelPropsModel {
    /**
   * Specifies the base.Button component model properties to render the Toast action buttons.
   * ```html
   * <div id="element"> </div>
   * ```
   * ```typescript
   * let toast: Toast =  new Toast({ 
   *      buttons:
   *      [{ 
   *         model: { content:`Button1`, cssClass: `e-success` }
   *      }] 
   * });
   * toast.appendTo('#element');
   * ```
   *  
   * @default 'null'
   */
    model?: buttons.ButtonModel;
    /**
   * Specifies the click event binding of action buttons created within Toast.
   * @event
   */
    click?: base.EmitType<Event>;
}
/**
 * Interface for a class ToastAnimations
 */
export interface ToastAnimationsModel {
    /**
   * Specifies the type of animation.
   * @default : 'FadeIn'
   * @aspType string
   */
    effect?: base.Effect;
    /**
   * Specifies the duration to animate.
   * @default : 600
   */
    duration?: number;
    /**
   * Specifies the animation timing function.
   * @default : 'ease'
   */
    easing?: string;
}
/**
 * Interface for a class ToastAnimationSettings
 */
export interface ToastAnimationSettingsModel {
    /**
   * Specifies the animation to appear while showing the Toast.
   * @default { effect: 'FadeIn', duration: 600, easing: 'ease' }
   */
    show?: ToastAnimationsModel;
    /**
   * Specifies the animation to appear while hiding the Toast.
   * @default { effect: 'FadeOut', duration: 600, easing: 'ease' }
   */
    hide?: ToastAnimationsModel;
}
/**
 * Interface for a class Toast
 */
export interface ToastModel extends base.ComponentModel{
    /**
     * Specifies the width of the Toast in pixels/numbers/percentage. Number value is considered as pixels.
     * In mobile devices, default width is considered as `100%`. 
     * @default '300'
     */
    width?: string | number;
    /**
     * Specifies the height of the Toast in pixels/number/percentage. Number value is considered as pixels.
     * @default 'auto'
     */
    height?: string | number;
    /**
     * Specifies the title to be displayed on the Toast.
     * @default null
     */
    title?: string;
    /**
     * Specifies the content to be displayed on the Toast.
     * @default null
     */
    content?: string;
    /**
     * Defines CSS classes to specify an icon for the Toast which is to be displayed at top left corner of the Toast.
     * @default null
     */
    icon?: string;
    /**
     * Defines single/multiple classes (separated by space) to be used for customization of Toast.
     * @default null
     */
    cssClass?: string;
    /**
     * Specifies the HTML element/element ID as a string that can be displayed as a Toast.
     * The given template is taken as preference to render the Toast, even if the built-in properties such as title and content are defined.
     * @default null
     */
    template?: string;
    /**
     * Specifies the newly created Toast message display order while multiple toast's are added to page one after another.
     * By default, newly added Toast will be added after old Toast's.
     * @default true
     */
    newestOnTop?: boolean;
    /**
     * Specifies whether to show the close button in Toast message to close the Toast.
     * @default false
     */
    showCloseButton?: boolean;
    /**
     * Specifies whether to show the progress bar to denote the Toast message display timeout.
     * @default false
     */
    showProgressBar?: boolean;
    /**
     * Specifies the Toast display time duration on the page in milliseconds. 
     * - Once the time expires, Toast message will be removed.
     * - Setting 0 as a time out value displays the Toast on the page until the user closes it manually.
     * @default 5000
     */
    timeOut?: number;
    /**
     * Specifies the Toast display time duration after interacting with the Toast. 
     * @default 1000
     */
    extendedTimeout?: number;
    /**
     * Specifies the animation configuration settings for showing and hiding the Toast.
     * @default { show: { effect: 'FadeIn', duration: 600, easing: 'linear' },
     * hide: { effect: 'FadeOut', duration: 600, easing: 'linear' }}
     */
    animation?: ToastAnimationSettingsModel;
    /**
     * Specifies the position of the Toast message to be displayed within target container.
     * In the case of multiple Toast display, new Toast position will not update on dynamic change of property values
     * until the old Toast messages removed.
     * X values are: Left , Right ,Center
     * Y values are: Top , Bottom
     * @default { X: "Left", Y: "Top"}
     */
    position?: ToastPositionModel;
    /**
     * Specifies the collection of Toast action `buttons` to be rendered with the given
     * base.Button model properties and its click action handler.
     * @default [{}]
     */
    buttons?: ButtonModelPropsModel[];
    /**
     * Specifies the target container where the Toast to be displayed.
     * Based on the target, the positions such as `Left`, `Top` will be applied to the Toast.
     * @default document.body
     * @aspType string
     */
    target?: HTMLElement | Element | string;
    /**
     * Triggers the event after the Toast gets created.
     * @event
     */
    created?: base.EmitType<Event>;
    /**
     * Triggers the event after the Toast gets destroyed.
     * @event
     */
    destroyed?: base.EmitType<Event>;
    /**
     * Triggers the event after the Toast shown on the target container.
     * @event
     */
    open?: base.EmitType<ToastOpenArgs>;
    /**
     * Triggers the event before the toast shown.
     * @event
     */
    beforeOpen?: base.EmitType<ToastBeforeOpenArgs>;
    /**
     * Trigger the event after the Toast hides.
     * @event
     */
    close?: base.EmitType<ToastCloseArgs>;
    /**
     * The event will be fired while clicking on the Toast.
     * @event
     */
    click?: base.EmitType<ToastClickEventArgs>;
}
/**
 * Specifies the options for positioning the Toast in Y axis.
 */
export  type PositionY = 'Top' | 'Bottom';
/**
 * Specifies the options for positioning the Toast in X axis.
 */
export  type PositionX = 'Left' | 'Right' | 'Center';
/**
 * Specifies the event arguments of Toast click.
 */
export interface ToastClickEventArgs extends base.BaseEventArgs {
    /** Defines the Toast element. */
    element: HTMLElement;
    /** Defines the Toast object. */
    toastObj: Toast;
    /** Defines the prevent action for Toast click event. */
    cancel: boolean;
    /** Defines the close action for click or tab on the Toast. */
    clickToClose: boolean;
    /** Defines the current event object. */
    originalEvent: Event;
}
/**
 * Specifies the event arguments of Toast before open.
 */
export interface ToastBeforeOpenArgs extends base.BaseEventArgs {
    /** Defines the Toast element. */
    element: HTMLElement;
    /** Defines the Toast object. */
    toastObj: Toast;
    /** Defines the prevent action for before opening toast. */
    cancel: boolean;
}
/**
 * Specifies the event arguments of Toast open.
 */
export interface ToastOpenArgs extends base.BaseEventArgs {
    /** Defines the Toast element. */
    element: HTMLElement;
    /** Defines the Toast object. */
    toastObj: Toast;
}
/**
 * Specifies the event arguments of Toast close.
 */
export interface ToastCloseArgs extends base.BaseEventArgs {
    /** Defines the Toast container element. */
    toastContainer: HTMLElement;
    /** Defines the Toast object. */
    toastObj: Toast;
}
/**
 * An object that is used to configure the Toast X Y positions.
 */
export  class ToastPosition extends base.ChildProperty<ToastPosition> {
    /**
     * Specifies the position of the Toast notification with respect to the target container's left edge.
     * @default 'Left'
     * @aspType string
     */
    X: PositionX | number | string;
    /**
     * Specifies the position of the Toast notification with respect to the target container's top edge.
     * @default 'Top'
     * @aspType string
     */
    Y: PositionY | number | string;
}
/**
 * An object that is used to configure the action button model properties and event.
 */
export  class ButtonModelProps extends base.ChildProperty<ButtonModelProps> {
    /**
     * Specifies the Button component model properties to render the Toast action buttons.
     * ```html
     * <div id="element"> </div>
     * ```
     * ```typescript
     * let toast: Toast =  new Toast({
     *      buttons:
     *      [{
     *         model: { content:`Button1`, cssClass: `e-success` }
     *      }]
     * });
     * toast.appendTo('#element');
     * ```
     *
     * @default 'null'
     */
    model: buttons.ButtonModel;
    /**
     * Specifies the click event binding of action buttons created within Toast.
     * @event
     */
    click: base.EmitType<Event>;
}
/**
 * An object that is used to configure the animation object of Toast.
 */
export  class ToastAnimations extends base.ChildProperty<ToastAnimations> {
    /**
     * Specifies the type of animation.
     * @default : 'FadeIn'
     * @aspType string
     */
    effect: base.Effect;
    /**
     * Specifies the duration to animate.
     * @default : 600
     */
    duration: number;
    /**
     * Specifies the animation timing function.
     * @default : 'ease'
     */
    easing: string;
}
/**
 * An object that is used to configure the show/hide animation settings of Toast.
 */
export  class ToastAnimationSettings extends base.ChildProperty<ToastAnimationSettings> {
    /**
     * Specifies the animation to appear while showing the Toast.
     * @default { effect: 'FadeIn', duration: 600, easing: 'ease' }
     */
    show: ToastAnimationsModel;
    /**
     * Specifies the animation to appear while hiding the Toast.
     * @default { effect: 'FadeOut', duration: 600, easing: 'ease' }
     */
    hide: ToastAnimationsModel;
}
/**
 * The Toast is a notification pop-up that showing on desired position which can provide an information to the user.
 *  * ```html
 * <div id="toast"/>
 * <script>
 *   var toastObj = new Toast();
 *   toastObj.appendTo("#toast");
 * </script>
 * ```
 */
export  class Toast extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    private toastContainer;
    private toastEle;
    private progressBarEle;
    private intervalId;
    private progressObj;
    private titleTemplate;
    private contentTemplate;
    private toastTemplate;
    private customPosition;
    /**
     * Initializes a new instance of the Toast class.
     * @param options  - Specifies Toast model properties as options.
     * @param element  - Specifies the element that is rendered as a Toast.
     */
    constructor(options?: ToastModel, element?: HTMLElement);
    /**
     * Specifies the width of the Toast in pixels/numbers/percentage. Number value is considered as pixels.
     * In mobile devices, default width is considered as `100%`.
     * @default '300'
     */
    width: string | number;
    /**
     * Specifies the height of the Toast in pixels/number/percentage. Number value is considered as pixels.
     * @default 'auto'
     */
    height: string | number;
    /**
     * Specifies the title to be displayed on the Toast.
     * @default null
     */
    title: string;
    /**
     * Specifies the content to be displayed on the Toast.
     * @default null
     */
    content: string;
    /**
     * Defines CSS classes to specify an icon for the Toast which is to be displayed at top left corner of the Toast.
     * @default null
     */
    icon: string;
    /**
     * Defines single/multiple classes (separated by space) to be used for customization of Toast.
     * @default null
     */
    cssClass: string;
    /**
     * Specifies the HTML element/element ID as a string that can be displayed as a Toast.
     * The given template is taken as preference to render the Toast, even if the built-in properties such as title and content are defined.
     * @default null
     */
    template: string;
    /**
     * Specifies the newly created Toast message display order while multiple toast's are added to page one after another.
     * By default, newly added Toast will be added after old Toast's.
     * @default true
     */
    newestOnTop: boolean;
    /**
     * Specifies whether to show the close button in Toast message to close the Toast.
     * @default false
     */
    showCloseButton: boolean;
    /**
     * Specifies whether to show the progress bar to denote the Toast message display timeout.
     * @default false
     */
    showProgressBar: boolean;
    /**
     * Specifies the Toast display time duration on the page in milliseconds.
     * - Once the time expires, Toast message will be removed.
     * - Setting 0 as a time out value displays the Toast on the page until the user closes it manually.
     * @default 5000
     */
    timeOut: number;
    /**
     * Specifies the Toast display time duration after interacting with the Toast.
     * @default 1000
     */
    extendedTimeout: number;
    /**
     * Specifies the animation configuration settings for showing and hiding the Toast.
     * @default { show: { effect: 'FadeIn', duration: 600, easing: 'linear' },
     * hide: { effect: 'FadeOut', duration: 600, easing: 'linear' }}
     */
    animation: ToastAnimationSettingsModel;
    /**
     * Specifies the position of the Toast message to be displayed within target container.
     * In the case of multiple Toast display, new Toast position will not update on dynamic change of property values
     * until the old Toast messages removed.
     * X values are: Left , Right ,Center
     * Y values are: Top , Bottom
     * @default { X: "Left", Y: "Top"}
     */
    position: ToastPositionModel;
    /**
     * Specifies the collection of Toast action `buttons` to be rendered with the given
     * Button model properties and its click action handler.
     * @default [{}]
     */
    buttons: ButtonModelPropsModel[];
    /**
     * Specifies the target container where the Toast to be displayed.
     * Based on the target, the positions such as `Left`, `Top` will be applied to the Toast.
     * @default document.body
     * @aspType string
     */
    target: HTMLElement | Element | string;
    /**
     * Triggers the event after the Toast gets created.
     * @event
     */
    created: base.EmitType<Event>;
    /**
     * Triggers the event after the Toast gets destroyed.
     * @event
     */
    destroyed: base.EmitType<Event>;
    /**
     * Triggers the event after the Toast shown on the target container.
     * @event
     */
    open: base.EmitType<ToastOpenArgs>;
    /**
     * Triggers the event before the toast shown.
     * @event
     */
    beforeOpen: base.EmitType<ToastBeforeOpenArgs>;
    /**
     * Trigger the event after the Toast hides.
     * @event
     */
    close: base.EmitType<ToastCloseArgs>;
    /**
     * The event will be fired while clicking on the Toast.
     * @event
     */
    click: base.EmitType<ToastClickEventArgs>;
    /**
     * Gets the base.Component module name.
     * @private
     */
    getModuleName(): string;
    /**
     * Gets the persisted state properties of the base.Component.
     */
    protected getPersistData(): string;
    /**
     * Removes the component from the DOM and detaches all its related event handlers, attributes and classes.
     */
    destroy(): void;
    /**
     * Initialize the event handler
     * @private
     */
    protected preRender(): void;
    /**
     * Initialize the component rendering
     * @private
     */
    render(): void;
    /**
     * To show Toast element on screen.
     * @param  {ToastModel} toastObj?
     * @returns void
     */
    show(toastObj?: ToastModel): void;
    private templateChanges(toastObj);
    private setCSSClass(cssClass);
    private setWidthHeight();
    private templateRendering();
    hide(element?: HTMLElement | Element | string): void;
    private fetchEle(ele, value, prob);
    private clearProgress(intervalId);
    private clearContainerPos();
    private clearTitleTemplate();
    private clearContentTemplate();
    private clearToastTemplate();
    private destroyToast(toastEle);
    private personalizeToast();
    private setAria();
    private setPositioning(pos);
    private setCloseButton();
    private setProgress();
    private toastHoverAction(id);
    private delayedToastProgress(id);
    private updateProgressBar(progressObj);
    private setIcon();
    private setTitle();
    private setContent();
    private appendMessageContainer(element);
    private actionButtons();
    private appendToTarget();
    private clickHandler(e);
    private displayToast(toastEle);
    private getContainer();
    /**
     * Called internally if any of the property value changed.
     * @private
     */
    onPropertyChanged(newProp: ToastModel, oldProp: ToastModel): void;
}
 }
export namespace pdfexport { 

/**
 * `PdfAction` class represents base class for all action types.
 * @private
 */
export  abstract class PdfAction implements IPdfWrapper {
    /**
     * Specifies the Next `action` to perform.
     * @private
     */
    private action;
    /**
     * Specifies the Internal variable to store `dictionary`.
     * @private
     */
    private pdfDictionary;
    /**
     * Specifies the Internal variable to store `dictionary properties`.
     * @private
     */
    protected dictionaryProperties: DictionaryProperties;
    /**
     * Initialize instance for `Action` class.
     * @private
     */
    protected constructor();
    /**
     * Gets and Sets the `Next` action to perform.
     * @private
     */
    next: PdfAction;
    /**
     * Gets and Sets the instance of PdfDictionary class for `Dictionary`.
     * @private
     */
    readonly dictionary: PdfDictionary;
    /**
     * `Initialize` the action type.
     * @private
     */
    protected initialize(): void;
    /**
     * Gets the `Element` as IPdfPrimitive class.
     * @private
     */
    readonly element: IPdfPrimitive;
}
/**
 * Actions classes
 * @hidden
 */
/**
 * `PdfUriAction` class for initialize the uri related internals.
 * @private
 */
export  class PdfUriAction extends PdfAction {
    /**
     * Specifies the `uri` string.
     * @default ''.
     * @private
     */
    private uniformResourceIdentifier;
    /**
     * Initialize instance of `PdfUriAction` class.
     * @private
     */
    constructor();
    /**
     * Initialize instance of `PdfUriAction` class.
     * @private
     */
    constructor(uri: string);
    /**
     * Gets and Sets the value of `Uri`.
     * @private
     */
    uri: string;
    /**
     * `Initialize` the internals.
     * @private
     */
    protected initialize(): void;
}
/**
 * Represents base class for `link annotations` with associated action.
 * @private
 */
export  abstract class PdfActionLinkAnnotation extends PdfLinkAnnotation {
    /**
     * Internal variable to store annotation's `action`.
     * @default null
     * @private
     */
    private pdfAction;
    /**
     * Internal variable to store annotation's `Action`.
     * @private
     */
    abstract action: PdfAction;
    /**
     * Specifies the constructor for `ActionLinkAnnotation`.
     * @private
     */
    constructor(rectangle: RectangleF);
    /**
     * get and set the `action`.
     * @hidden
     */
    getSetAction(value?: PdfAction): PdfAction | void;
}
/**
 * `PdfAnnotationCollection` class represents the collection of 'PdfAnnotation' objects.
 * @private
 */
export  class PdfAnnotationCollection implements IPdfWrapper {
    /**
     * `Error` constant message.
     * @private
     */
    private alreadyExistsAnnotationError;
    /**
     * `Error` constant message.
     * @private
     */
    private missingAnnotationException;
    /**
     * Specifies the Internal variable to store fields of `PdfDictionaryProperties`.
     * @private
     */
    protected dictionaryProperties: DictionaryProperties;
    /**
     * Parent `page` of the collection.
     * @private
     */
    private page;
    /**
     * Array of the `annotations`.
     * @private
     */
    private internalAnnotations;
    /**
     * privte `list` for the annotations.
     * @private
     */
    lists: PdfAnnotation[];
    /**
     * Gets the `PdfAnnotation` object at the specified index. Read-Only.
     * @private
     */
    annotations: PdfArray;
    /**
     * Initializes a new instance of the `PdfAnnotationCollection` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `PdfAnnotationCollection` class with the specified page.
     * @private
     */
    constructor(page: PdfPage);
    /**
     * `Adds` a new annotation to the collection.
     * @private
     */
    add(annotation: PdfAnnotation): void | number;
    /**
     * `Adds` a Annotation to collection.
     * @private
     */
    protected doAdd(annotation: PdfAnnotation): void | number;
    /**
     * `Set a color of an annotation`.
     * @private
     */
    private setColor(annotation);
    /**
     * Gets the `Element` representing this object.
     * @private
     */
    readonly element: IPdfPrimitive;
}
/**
 * `PdfAnnotation` class represents the base class for annotation objects.
 * @private
 */
export  abstract class PdfAnnotation implements IPdfWrapper {
    /**
     * Specifies the Internal variable to store fields of `PdfDictionaryProperties`.
     * @private
     */
    protected dictionaryProperties: DictionaryProperties;
    /**
     * `Color` of the annotation
     * @private
     */
    private pdfColor;
    /**
     * `Bounds` of the annotation.
     * @private
     */
    private rectangle;
    /**
     * Parent `page` of the annotation.
     * @private
     */
    private pdfPage;
    /**
     * `Brush of the text` of the annotation.
     * @default new PdfSolidBrush(new PdfColor(0, 0, 0))
     * @private
     */
    private textBrush;
    /**
     * `Font of the text` of the annotation.
     * @default new PdfStandardFont(PdfFontFamily.TimesRoman, 10)
     * @private
     */
    private textFont;
    /**
     * `StringFormat of the text` of the annotation.
     * @default new PdfStringFormat(PdfTextAlignment.Left)
     * @private
     */
    private format;
    /**
     * `Text` of the annotation.
     * @private
     */
    private content;
    /**
     * Internal variable to store `dictionary`.
     * @private
     */
    private pdfDictionary;
    /**
     * To specifying the `Inner color` with which to fill the annotation
     * @private
     */
    private internalColor;
    /**
     * `opacity or darkness` of the annotation.
     * @private
     * @default 1.0
     */
    private darkness;
    /**
     * `Color` of the annotation
     * @private
     */
    color: PdfColor;
    /**
     * To specifying the `Inner color` with which to fill the annotation
     * @private
     */
    innerColor: PdfColor;
    /**
     * `bounds` of the annotation.
     * @private
     */
    bounds: RectangleF;
    /**
     * Parent `page` of the annotation.
     * @private
     */
    readonly page: PdfPage;
    /**
     * To specifying the `Font of the text` in the annotation.
     * @private
     */
    font: PdfFont;
    /**
     * To specifying the `StringFormat of the text` in the annotation.
     * @private
     */
    stringFormat: PdfStringFormat;
    /**
     * To specifying the `Brush of the text` in the annotation.
     * @private
     */
    brush: PdfBrush;
    /**
     * `Text` of the annotation.
     * @private
     */
    text: string;
    /**
     * Internal variable to store `dictionary`.
     * @hidden
     */
    dictionary: PdfDictionary;
    /**
     * Object initialization for `Annotation` class
     * @private
     */
    constructor();
    constructor(bounds: RectangleF);
    /**
     * `Initialize` the annotation event handler and specifies the type of the annotation.
     * @private
     */
    protected initialize(): void;
    /**
     * Sets related `page` of the annotation.
     * @private
     */
    setPage(page: PdfPageBase): void;
    /**
     * Handles the `BeginSave` event of the Dictionary.
     * @private
     */
    beginSave(): void;
    /**
     * `Saves` an annotation.
     * @private
     */
    protected save(): void;
    /**
     * Gets the `element`.
     * @private
     */
    readonly element: IPdfPrimitive;
}
/**
 * `PdfDocumentLinkAnnotation` class represents an annotation object with holds link on another location within a document.
 * ```typescript
 * // create a new PDF document
 * let document : PdfDocument = new PdfDocument();
 * // create new pages
 * let page1 : PdfPage = document.pages.add();
 * let page2 : PdfPage = document.pages.add();
 * // create a new rectangle
 * let bounds : RectangleF = new RectangleF({x : 10, y : 200}, {width : 300, height : 25});
 * //
 * // create a new document link annotation
 * let documentLinkAnnotation : PdfDocumentLinkAnnotation = new PdfDocumentLinkAnnotation(bounds);
 * // set the annotation text
 * documentLinkAnnotation.text = 'Document link annotation';
 * // set the destination
 * documentLinkAnnotation.destination = new PdfDestination(page2);
 * // set the documentlink annotation location
 * documentLinkAnnotation.destination.location = new PointF(10, 0);
 * // add this annotation to a new page
 * page1.annotations.add(documentLinkAnnotation);
 * //
 * // save the document to disk
 * document.save('output.pdf');
 * // destroy the document
 * document.destroy();
 * ```
 */
export  class PdfDocumentLinkAnnotation extends PdfLinkAnnotation {
    /**
     * `Destination` of the annotation.
     * @default null
     * @private
     */
    private pdfDestination;
    /**
     * Gets or sets the `destination` of the annotation.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create new pages
     * let page1 : PdfPage = document.pages.add();
     * let page2 : PdfPage = document.pages.add();
     * // create a new rectangle
     * let bounds : RectangleF = new RectangleF({x : 10, y : 200}, {width : 300, height : 25});
     * //
     * // create a new document link annotation
     * let documentLinkAnnotation : PdfDocumentLinkAnnotation = new PdfDocumentLinkAnnotation(bounds);
     * // set the annotation text
     * documentLinkAnnotation.text = 'Document link annotation';
     * // set the destination
     * documentLinkAnnotation.destination = new PdfDestination(page2);
     * // set the documentlink annotation location
     * documentLinkAnnotation.destination.location = new PointF(10, 0);
     * // add this annotation to a new page
     * page1.annotations.add(documentLinkAnnotation);
     * //
     * // save the document to disk
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @default null
     */
    destination: PdfDestination;
    /**
     * Initializes new `PdfDocumentLinkAnnotation` instance with specified bounds.
     * @private
     */
    constructor(rectangle: RectangleF);
    /**
     * Initializes new `PdfDocumentLinkAnnotation` instance with specified bounds and destination.
     * @private
     */
    constructor(rectangle: RectangleF, destination: PdfDestination);
    /**
     * `Saves` annotation object.
     * @private
     */
    save(): void;
    /**
     * `Clone` the document link annotation.
     * @private
     */
    clone(): PdfDocumentLinkAnnotation;
}
/**
 * Annotations classes
 * @hidden
 */
/**
 * `PdfLinkAnnotation` class represents the ink annotation class.
 * @private
 */
export  abstract class PdfLinkAnnotation extends PdfAnnotation {
    /**
     * Initializes new instance of `PdfLineAnnotation` class with specified points.
     * @private
     */
    constructor();
    /**
     * Initializes new instance of `PdfLineAnnotation` class with set of points and annotation text.
     * @private
     */
    constructor(rectangle: RectangleF);
    /**
     * `Initializes` annotation object.
     * @private
     */
    protected initialize(): void;
}
/**
 * `PdfTextWebLink` class represents the class for text web link annotation.
 * ```typescript
 * // create a new PDF document.
 * let document : PdfDocument = new PdfDocument();
 * // add a page to the document.
 * let page1 : PdfPage = document.pages.add();
 * // create the font
 * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);
 * //
 * // create the Text Web Link
 * let textLink : PdfTextWebLink = new PdfTextWebLink();
 * // set the hyperlink
 * textLink.url = 'http://www.google.com';
 * // set the link text
 * textLink.text = 'Google';
 * // set the font
 * textLink.font = font;
 * // draw the hyperlink in PDF page
 * textLink.draw(page1, new PointF(10, 40));
 * //
 * // save the document.
 * document.save('output.pdf');
 * // destroy the document
 * document.destroy();
 * ```
 */
export  class PdfTextWebLink extends PdfTextElement {
    /**
     * Internal variable to store `Url`.
     * @default ''
     * @private
     */
    private uniformResourceLocator;
    /**
     * Internal variable to store `Uri Annotation` object.
     * @default null
     * @private
     */
    private uriAnnotation;
    /**
     * Checks whether the drawTextWebLink method with `PointF` overload is called or not.
     * If it set as true, then the start position of each lines excluding firest line is changed as (0, Y).
     * @private
     * @hidden
     */
    private recalculateBounds;
    private defaultBorder;
    /**
     * Gets or sets the `Uri address`.
     * ```typescript
     * // create a new PDF document.
     * let document : PdfDocument = new PdfDocument();
     * // add a page to the document.
     * let page1 : PdfPage = document.pages.add();
     * // create the font
     * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);
     * // create the Text Web Link
     * let textLink : PdfTextWebLink = new PdfTextWebLink();
     * //
     * // set the hyperlink
     * textLink.url = 'http://www.google.com';
     * //
     * // set the link text
     * textLink.text = 'Google';
     * // set the font
     * textLink.font = font;
     * // draw the hyperlink in PDF page
     * textLink.draw(page1, new PointF(10, 40));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    url: string;
    /**
     * Initializes a new instance of the `PdfTextWebLink` class.
     * @private
     */
    constructor();
    /**
     * `Draws` a Text Web Link on the Page with the specified location.
     * @private
     */
    draw(page: PdfPage, location: PointF): PdfLayoutResult;
    /**
     * `Draws` a Text Web Link on the Page with the specified bounds.
     * @private
     */
    draw(page: PdfPage, bounds: RectangleF): PdfLayoutResult;
    /**
     * `Draw` a Text Web Link on the Graphics with the specified location.
     * @private
     */
    draw(graphics: PdfGraphics, location: PointF): PdfLayoutResult;
    /**
     * `Draw` a Text Web Link on the Graphics with the specified bounds.
     * @private
     */
    draw(graphics: PdfGraphics, bounds: RectangleF): PdfLayoutResult;
    /**
     * Helper method `Draw` a Multiple Line Text Web Link on the Graphics with the specified location.
     * @private
     */
    private drawMultipleLineWithPoint(result, page, location);
    /**
     * Helper method `Draw` a Multiple Line Text Web Link on the Graphics with the specified bounds.
     * @private
     */
    private drawMultipleLineWithBounds(result, page, bounds);
    private calculateBounds(currentBounds, lineWidth, maximumWidth, startPosition);
}
/**
 * PdfUriAnnotation.ts class for EJ2-PDF
 */
/**
 * `PdfUriAnnotation` class represents the Uri annotation.
 * @private
 */
export  class PdfUriAnnotation extends PdfActionLinkAnnotation {
    /**
     * Internal variable to store `acton` for the annotation.
     * @private
     */
    private pdfUriAction;
    /**
     * Get `action` of the annotation.
     * @private
     */
    readonly uriAction: PdfUriAction;
    /**
     * Gets or sets the `Uri` address.
     * @private
     */
    uri: string;
    /**
     * Gets or sets the `action`.
     * @private
     */
    action: PdfAction;
    /**
     * Initializes a new instance of the `PdfUriAnnotation` class with specified bounds.
     * @private
     */
    constructor(rectangle: RectangleF);
    /**
     * Initializes a new instance of the `PdfUriAnnotation` class with specified bounds and URI.
     * @private
     */
    constructor(rectangle: RectangleF, uri: string);
    /**
     * `Initializes` annotation object.
     * @private
     */
    protected initialize(): void;
}
/**
 * @private
 * @hidden
 */
export interface IDictionaryPair<K, V> {
    key: K;
    value: V;
}
/**
 * @private
 * @hidden
 */
export  class Dictionary<K, V> {
    /**
     * @private
     * @hidden
     */
    protected table: {
        [key: string]: IDictionaryPair<K, V>;
    };
    /**
     * @private
     * @hidden
     */
    protected nElements: number;
    /**
     * @private
     * @hidden
     */
    protected toStr: (key: K) => string;
    /**
     * @private
     * @hidden
     */
    constructor(toStringFunction?: (key: K) => string);
    /**
     * @private
     * @hidden
     */
    getValue(key: K): V;
    /**
     * @private
     * @hidden
     */
    setValue(key: K, value: V): V;
    /**
     * @private
     * @hidden
     */
    remove(key: K): V;
    /**
     * @private
     * @hidden
     */
    keys(): K[];
    /**
     * @private
     * @hidden
     */
    values(): V[];
    /**
     * @private
     * @hidden
     */
    containsKey(key: K): boolean;
    /**
     * @private
     * @hidden
     */
    clear(): void;
    /**
     * @private
     * @hidden
     */
    size(): number;
}
/**
 * Collections classes
 * @hidden
 */
/**
 * Dictionary class
 * @private
 * @hidden
 */
export  class TemporaryDictionary<K, V> {
    /**
     * @hidden
     * @private
     */
    private mKeys;
    /**
     * @hidden
     * @private
     */
    private mValues;
    /**
     * @hidden
     * @private
     */
    size(): number;
    /**
     * @hidden
     * @private
     */
    add(key: K, value: V): number;
    /**
     * @hidden
     * @private
     */
    keys(): K[];
    /**
     * @hidden
     * @private
     */
    values(): V[];
    /**
     * @hidden
     * @private
     */
    getValue(key: K): V;
    /**
     * @hidden
     * @private
     */
    setValue(key: K, value: V): void;
    /**
     * @hidden
     * @private
     */
    remove(key: K): boolean;
    /**
     * @hidden
     * @private
     */
    containsKey(key: K): boolean;
    /**
     * @hidden
     * @private
     */
    clear(): void;
}
/**
 * ObjectObjectPair classes
 * @hidden
 */
/**
 * Utils.ts class for EJ2-PDF
 * @private
 * @hidden
 */
export interface ICompareFunction<T> {
    (a: T, b: T): number;
}
/**
 * @private
 * @hidden
 */
export interface IEqualsFunction<T> {
    (a: T, b: T): boolean;
}
/**
 * @private
 * @hidden
 */
export interface ILoopFunction<T> {
    (a: T): boolean | void;
}
/**
 * @private
 * @hidden
 */
export  function defaultToString(item: string | number | string[] | number[] | Object | Object[] | boolean): string;
/**
 * PdfAutomaticFieldInfoCollection.ts class for EJ2-PDF
 * @private
 */
/**
 * Represent a `collection of automatic fields information`.
 * @private
 */
export  class PdfAutomaticFieldInfoCollection {
    /**
     * Internal variable to store instance of `pageNumberFields` class.
     * @private
     */
    private automaticFieldsInformation;
    /**
     * Gets the `page number fields collection`.
     * @private
     */
    readonly automaticFields: PdfAutomaticFieldInfo[];
    /**
     * Initializes a new instance of the 'PdfPageNumberFieldInfoCollection' class.
     * @private
     */
    constructor();
    /**
     * Add page number field into collection.
     * @private
     */
    add(fieldInfo: PdfAutomaticFieldInfo): number;
}
/**
 * PdfAutomaticFieldInfo.ts class for EJ2-PDF
 * @private
 */
/**
 * Represents information about the automatic field.
 * @private
 */
export  class PdfAutomaticFieldInfo {
    /**
     * Internal variable to store location of the field.
     * @private
     */
    private pageNumberFieldLocation;
    /**
     * Internal variable to store field.
     * @private
     */
    private pageNumberField;
    /**
     * Internal variable to store x scaling factor.
     * @private
     */
    private scaleX;
    /**
     * Internal variable to store y scaling factor.
     * @private
     */
    private scaleY;
    /**
     * Initializes a new instance of the 'PdfAutomaticFieldInfo' class.
     * @private
     */
    constructor(field: PdfAutomaticFieldInfo);
    /**
     * Initializes a new instance of the 'PdfAutomaticFieldInfo' class.
     * @private
     */
    constructor(field: PdfAutomaticField, location: PointF);
    /**
     * Initializes a new instance of the 'PdfAutomaticFieldInfo' class.
     * @private
     */
    constructor(field: PdfAutomaticField, location: PointF, scaleX: number, scaleY: number);
    /**
     * Gets or sets the location.
     * @private
     */
    location: PointF;
    /**
     * Gets or sets the field.
     * @private
     */
    field: PdfAutomaticField;
    /**
     * Gets or sets the scaling X factor.
     * @private
     */
    scalingX: number;
    /**
     * Gets or sets the scaling Y factor.
     * @private
     */
    scalingY: number;
}
/**
 * PdfAutomaticField.ts class for EJ2-PDF
 */
/**
 * Represents a fields which is calculated before the document saves.
 */
export  abstract class PdfAutomaticField extends PdfGraphicsElement {
    private internalBounds;
    private internalFont;
    private internalBrush;
    private internalPen;
    private internalStringFormat;
    private internalTemplateSize;
    protected constructor();
    bounds: RectangleF;
    size: SizeF;
    location: PointF;
    font: PdfFont;
    brush: PdfBrush;
    pen: PdfPen;
    stringFormat: PdfStringFormat;
    abstract getValue(graphics: PdfGraphics): string;
    abstract performDraw(graphics: PdfGraphics, location: PointF, scalingX: number, scalingY: number): void;
    performDrawHelper(graphics: PdfGraphics, location: PointF, scalingX: number, scalingY: number): void;
    draw(graphics: PdfGraphics): void;
    draw(graphics: PdfGraphics, location: PointF): void;
    draw(graphics: PdfGraphics, x: number, y: number): void;
    protected getSize(): SizeF;
    protected drawInternal(graphics: PdfGraphics): void;
    protected getBrush(): PdfBrush;
    protected getFont(): PdfFont;
    getPageFromGraphics(graphics: PdfGraphics): PdfPage;
}
/**
 * PdfCompositeField.ts class for EJ2-PDF
 */
/**
 * Represents class which can concatenate multiple automatic fields into single string.
 */
export  class PdfCompositeField extends PdfMultipleValueField {
    /**
     * Stores the array of automatic fields.
     * @private
     */
    private internalAutomaticFields;
    /**
     * Stores the text value of the field.
     * @private
     */
    private internalText;
    /**
     * Initialize a new instance of `PdfCompositeField` class.
     * @param font Font of the field.
     * @param brush Color of the field.
     * @param text Content of the field.
     * @param list List of the automatic fields in specific order based on the text content.
     */
    constructor(font: PdfFont, brush: PdfBrush, text: string, ...list: PdfAutomaticField[]);
    /**
     * Gets and sets the content of the field.
     * @public
     */
    text: string;
    /**
     * Gets and sets the list of the field to drawn.
     * @public
     */
    automaticFields: PdfAutomaticField[];
    /**
     * Return the actual value generated from the list of automatic fields.
     * @public
     */
    getValue(graphics: PdfGraphics): string;
}
/**
 * Automatic fields classes
 * @hidden
 */
/**
 * PdfAutomaticField.ts class for EJ2-PDF
 */
/**
 * Represents automatic field which has the same value within the `PdfGraphics`.
 */
export  abstract class PdfMultipleValueField extends PdfAutomaticField {
    /**
     * Stores the instance of dictionary values of `graphics and template value pair`.
     * @private
     */
    private list;
    constructor();
    performDraw(graphics: PdfGraphics, location: PointF, scalingX: number, scalingY: number): void;
}
/**
 * PdfPageCountField.ts class for EJ2-PDF
 */
/**
 * Represents total PDF document page count automatic field.
 */
export  class PdfPageCountField extends PdfSingleValueField {
    /**
     * Stores the number style of the field.
     * @private
     */
    private internalNumberStyle;
    /**
     * Initialize a new instance for page number field.
     * @public
     */
    constructor(font: PdfFont);
    /**
     * Initialize a new instance for page number field.
     * @public
     */
    constructor(font: PdfFont, bounds: RectangleF);
    /**
     * Initialize a new instance for page number field.
     * @public
     */
    constructor(font: PdfFont, brush: PdfBrush);
    /**
     * Gets and sets the number style of the field.
     * @public
     */
    numberStyle: PdfNumberStyle;
    /**
     * Return the actual value of the content to drawn.
     * @public
     */
    getValue(graphics: PdfGraphics): string;
}
/**
 * PdfNumbersConvertor.ts class for EJ2-PDF
 * @private
 */
/**
 * `PdfNumbersConvertor` for convert page number into numbers, roman letters, etc.,
 * @private
 */
export  class PdfNumbersConvertor {
    /**
     * numbers of letters in english [readonly].
     * @default = 26.0
     * @private
     */
    private static readonly letterLimit;
    /**
     * Resturns `acsii start index` value.
     * @default 64
     * @private
     */
    private static readonly acsiiStartIndex;
    /**
     * Convert string value from page number with correct format.
     * @private
     */
    static convert(intArabic: number, numberStyle: PdfNumberStyle): string;
    /**
     * Converts `arabic to roman` letters.
     * @private
     */
    private static arabicToRoman(intArabic);
    /**
     * Converts `arabic to normal letters`.
     * @private
     */
    private static arabicToLetter(arabic);
    /**
     * Generate a string value of an input number.
     * @private
     */
    private static generateNumber(value, magnitude, letter);
    /**
     * Convert a input number into letters.
     * @private
     */
    private static convertToLetter(arabic);
    /**
     * Convert number to actual string value.
     * @private
     */
    private static appendChar(builder, value);
}
/**
 * PdfPageNumberField.ts class for EJ2-PDF
 */
/**
 * Represents PDF document `page number field`.
 * @public
 */
export  class PdfPageNumberField extends PdfMultipleValueField {
    /**
     * Initialize a new instance for page number field.
     * @public
     */
    constructor(font: PdfFont);
    /**
     * Initialize a new instance for page number field.
     * @public
     */
    constructor(font: PdfFont, bounds: RectangleF);
    /**
     * Initialize a new instance for page number field.
     * @public
     */
    constructor(font: PdfFont, brush: PdfBrush);
    /**
     * Stores the number style of the page number field.
     * @private
     */
    private internalNumberStyle;
    /**
     * Gets and sets the number style of the page number field.
     * @private
     */
    numberStyle: PdfNumberStyle;
    /**
     * Return the `string` value of page number field.
     * @public
     */
    getValue(graphics: PdfGraphics): string;
    /**
     * Internal method to `get actual value of page number`.
     * @private
     */
    protected internalGetValue(page: PdfPage): string;
}
/**
 * PdfTemplateValuePair.ts class for EJ2-PDF
 * @private
 */
/**
 * Represent class to store information about `template and value pairs`.
 * @private
 */
export  class PdfTemplateValuePair {
    /**
     * Internal variable to store template.
     * @default null
     * @private
     */
    private pdfTemplate;
    /**
     * Intenal variable to store value.
     * @private
     */
    private content;
    /**
     * Initializes a new instance of the 'PdfTemplateValuePair' class.
     * @private
     */
    constructor();
    constructor(template: PdfTemplate, value: string);
    /**
     * Gets or sets the template.
     * @private
     */
    template: PdfTemplate;
    /**
     * Gets or sets the value.
     * @private
     */
    value: string;
}
/**
 * PdfSingleValueField.ts class for EJ2-PDF
 */
/**
 * Represents automatic field which has the same value in the whole document.
 */
export  abstract class PdfSingleValueField extends PdfAutomaticField {
    private list;
    private painterGraphics;
    constructor();
    performDraw(graphics: PdfGraphics, location: PointF, scalingX: number, scalingY: number): void;
}
/**
 * Document classes
 * @hidden
 */
/**
 * PdfCatalog.ts class for EJ2-PDF
 */
/**
 * `PdfCatalog` class represents internal catalog of the Pdf document.
 * @private
 */
export  class PdfCatalog extends PdfDictionary {
    /**
     * Internal variable to store collection of `sections`.
     * @default null
     * @private
     */
    private sections;
    /**
     * Internal variable for accessing fields from `DictionryProperties` class.
     * @private
     */
    private tempDictionaryProperties;
    /**
     * Initializes a new instance of the `PdfCatalog` class.
     * @private
     */
    constructor();
    /**
     * Gets or sets the sections, which contain `pages`.
     * @private
     */
    pages: PdfSectionCollection;
}
/**
 * PdfDocumentBase.ts class for EJ2-PDF
 */
/**
 * `PdfDocumentBase` class represent common properties of PdfDocument classes.
 * @private
 */
export  class PdfDocumentBase {
    /**
     * Collection of the main `objects`.
     * @private
     */
    private objects;
    /**
     * The `cross table`.
     * @private
     */
    private pdfCrossTable;
    /**
     * `Object` that is saving currently.
     * @private
     */
    private currentSavingObject;
    /**
     * Document `catlog`.
     * @private
     */
    private pdfCatalog;
    /**
     * If the stream is copied,  then it specifies true.
     * @private
     */
    isStreamCopied: boolean;
    /**
     * Instance of parent `document`.
     * @private
     */
    private document;
    /**
     * Initializes a new instance of the `PdfDocumentBase` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `PdfDocumentBase` class with instance of PdfDocument as argument.
     * @private
     */
    constructor(document: PdfDocument);
    /**
     * Gets the `PDF objects` collection, which stores all objects and references to it..
     * @private
     */
    readonly pdfObjects: PdfMainObjectCollection;
    /**
     * Gets the `cross-reference` table.
     * @private
     */
    readonly crossTable: PdfCrossTable;
    /**
     * Gets or sets the current saving `object number`.
     * @private
     */
    currentSavingObj: PdfReference;
    /**
     * Gets the PDF document `catalog`.
     * @private
     */
    catalog: PdfCatalog;
    /**
     * Sets the `main object collection`.
     * @private
     */
    setMainObjectCollection(mainObjectCollection: PdfMainObjectCollection): void;
    /**
     * Sets the `cross table`.
     * @private
     */
    setCrossTable(cTable: PdfCrossTable): void;
    /**
     * Sets the `catalog`.
     * @private
     */
    setCatalog(catalog: PdfCatalog): void;
    /**
     * `Saves` the document to the specified filename.
     * @private
     */
    save(): Promise<{
        blobData: Blob;
    }>;
    /**
     * `Saves` the document to the specified filename.
     * @public
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a pages to the document
     * let page1 : PdfPage = document.pages.add();
     * //
     * // save the document
     * document.save('output.pdf');
     * //
     * // destroy the document
     * document.destroy();
     * ```
     * @param filename Specifies the file name to save the output pdf document.
     */
    save(filename: string): void;
    /**
     * `Clone` of parent object - PdfDocument.
     * @private
     */
    clone(): PdfDocument;
}
/**
 * PdfDocumentTemplate.ts class for EJ2-PDF
 */
/**
 * `PdfDocumentTemplate` class encapsulates a page template for all the pages in the document.
 * @private
 */
export  class PdfDocumentTemplate {
    /**
     * `Left` page template object.
     * @private
     */
    private leftTemplate;
    /**
     * `Top` page template object.
     * @private
     */
    private topTemplate;
    /**
     * `Right` page template object.
     * @private
     */
    private rightTemplate;
    /**
     * `Bottom` page template object.
     * @private
     */
    private bottomTemplate;
    /**
     * `EvenLeft` page template object.
     * @private
     */
    private evenLeft;
    /**
     * `EvenTop` page template object.
     * @private
     */
    private evenTop;
    /**
     * `EvenRight` page template object.
     * @private
     */
    private evenRight;
    /**
     * `EventBottom` page template object.
     * @private
     */
    private evenBottom;
    /**
     * `OddLeft` page template object.
     * @private
     */
    private oddLeft;
    /**
     * `OddTop` page template object.
     * @private
     */
    private oddTop;
    /**
     * `OddRight` page template object.
     * @private
     */
    private oddRight;
    /**
     * `OddBottom` page template object.
     * @private
     */
    private oddBottom;
    /**
     * `Left` page template object.
     * @public
     */
    left: PdfPageTemplateElement;
    /**
     * `Top` page template object.
     * @public
     */
    top: PdfPageTemplateElement;
    /**
     * `Right` page template object.
     * @public
     */
    right: PdfPageTemplateElement;
    /**
     * `Bottom` page template object.
     * @public
     */
    bottom: PdfPageTemplateElement;
    /**
     * `EvenLeft` page template object.
     * @public
     */
    EvenLeft: PdfPageTemplateElement;
    /**
     * `EvenTop` page template object.
     * @public
     */
    EvenTop: PdfPageTemplateElement;
    /**
     * `EvenRight` page template object.
     * @public
     */
    EvenRight: PdfPageTemplateElement;
    /**
     * `EvenBottom` page template object.
     * @public
     */
    EvenBottom: PdfPageTemplateElement;
    /**
     * `OddLeft` page template object.
     * @public
     */
    OddLeft: PdfPageTemplateElement;
    /**
     * `OddTop` page template object.
     * @public
     */
    OddTop: PdfPageTemplateElement;
    /**
     * `OddRight` page template object.
     * @public
     */
    OddRight: PdfPageTemplateElement;
    /**
     * `OddBottom` page template object.
     * @public
     */
    OddBottom: PdfPageTemplateElement;
    /**
     * Initializes a new instance of the `PdfDocumentTemplate` class.
     * @public
     */
    constructor();
    /**
     * Returns `left` template.
     * @public
     */
    getLeft(page: PdfPage): PdfPageTemplateElement;
    /**
     * Returns `top` template.
     * @public
     */
    getTop(page: PdfPage): PdfPageTemplateElement;
    /**
     * Returns `right` template.
     * @public
     */
    getRight(page: PdfPage): PdfPageTemplateElement;
    /**
     * Returns `bottom` template.
     * @public
     */
    getBottom(page: PdfPage): PdfPageTemplateElement;
    /**
     * Checks whether the page `is even`.
     * @private
     */
    private isEven(page);
    /**
     * Checks a `template element`.
     * @private
     */
    private checkElement(templateElement, type);
}
/**
 * Represents a PDF document and can be used to create a new PDF document from the scratch.
 * ```typescript
 * // create a new PDF document
 * let document : PdfDocument = new PdfDocument();
 * // add a new page to the document
 * let page1 : PdfPage = document.pages.add();
 * // set the font
 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
 * // create black brush
 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
 * // draw the text
 * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
 * // save the document
 * document.save('output.pdf');
 * // destroy the document
 * document.destroy();
 * ```
 */
export  class PdfDocument extends PdfDocumentBase {
    /**
     * `Cache` of the objects.
     * @private
     */
    private static cacheCollection;
    /**
     * Default `margin` value.
     * @default 40.0
     * @private
     */
    readonly defaultMargin: number;
    /**
     * Default page `settings`.
     * @private
     */
    private settings;
    /**
     * Internal variable to store document`s collection of `sections`.
     * @private
     */
    private sectionCollection;
    /**
     * Internal variable to store document`s collection of `pages`.
     * @private
     */
    private documentPageCollection;
    /**
     * Internal variable to store instance of `fileutils.StreamWriter` classes..
     * @default null
     * @private
     */
    streamWriter: fileutils.StreamWriter;
    /**
     * Defines the `color space` of the document
     * @private
     */
    private pdfColorSpace;
    /**
     * Internal variable to store `template` which is applied to each page of the document.
     * @private
     */
    private pageTemplate;
    /**
     * `Font` used in complex objects to draw strings and text when it is not defined explicitly.
     * @default null
     * @private
     */
    private static defaultStandardFont;
    /**
     * Initializes a new instance of the `PdfDocument` class.
     * @public
     */
    constructor();
    /**
     * Initializes a new instance of the `PdfDocument` class.
     * @private
     */
    constructor(isMerging: boolean);
    /**
     * Gets the `default font`. It is used for complex objects when font is not explicitly defined.
     * @private
     */
    static readonly defaultFont: PdfFont;
    /**
     * Gets the collection of the `sections` in the document.
     * @private
     */
    readonly sections: PdfSectionCollection;
    /**
     * Gets the document's page setting.
     * @public
     */
    /**
     * Sets the document's page setting.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     *
     * // sets the right margin of the page
     * document.pageSettings.margins.right = 0;
     * // set the page size.
     * document.pageSettings.size = new SizeF(500, 500);
     * // change the page orientation to landscape
     * document.pageSettings.orientation = PdfPageOrientation.Landscape;
     * // apply 90 degree rotation on the page
     * document.pageSettings.rotate = PdfPageRotateAngle.RotateAngle90;
     *
     * // add a pages to the document
     * let page1 : PdfPage = document.pages.add();
     * // set font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // set brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * // set the specified Point
     * let point : PointF = new PointF(page1.getClientSize().width - 200, page1.getClientSize().height - 200);
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, point);
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    pageSettings: PdfPageSettings;
    /**
     * Represents the collection of pages in the PDF document.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * //
     * // get the collection of pages in the document
     * let pageCollection : PdfDocumentPageCollection  = document.pages;
     * //
     * // add pages
     * let page1 : PdfPage = pageCollection.add();
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    readonly pages: PdfDocumentPageCollection;
    /**
     * Gets collection of the `cached objects`.
     * @private
     */
    /**
     * Sets collection of the `cached objects`.
     * @private
     */
    static cache: PdfCacheCollection;
    /**
     * Gets or sets the `color space` of the document. This property can be used to create PDF document in RGB, Gray scale or CMYK color spaces.
     * @private
     */
    colorSpace: PdfColorSpace;
    /**
     * Gets or sets a `template` to all pages in the document.
     * @private
     */
    template: PdfDocumentTemplate;
    /**
     * Saves the document to the specified output stream and return the stream as Blob.
     * @private
     */
    docSave(stream: fileutils.StreamWriter, isBase: boolean): Blob;
    /**
     * Saves the document to the specified output stream.
     * @private
     */
    docSave(stream: fileutils.StreamWriter, filename: string, isBase: boolean): void;
    /**
     * Checks the pages `presence`.
     * @private
     */
    private checkPagesPresence();
    /**
     * disposes the current instance of `PdfDocument` class.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a new page to the document
     * let page1 : PdfPage = document.pages.add();
     * // set the font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // create black brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    destroy(): void;
}
/**
 * Drawing classes
 * @hidden
 */
/**
 * Coordinates of Position for `PointF`.
 * @private
 */
export  class PointF {
    /**
     * Value of `X`.
     * @private
     */
    x: number;
    /**
     * Value of `Y`.
     * @private
     */
    y: number;
    /**
     * Instance of `PointF` class.
     * @private
     */
    constructor();
    /**
     * Instance of `PointF` class with X, Y co-ordinates.
     * @private
     */
    constructor(x: number, y: number);
}
/**
 * Width and Height as `Size`.
 * @private
 */
export  class SizeF {
    /**
     * Value of ``Height``.
     * @private
     */
    height: number;
    /**
     * Value of `Width`.
     * @private
     */
    width: number;
    /**
     * Instance of `SizeF` class.
     * @private
     */
    constructor();
    /**
     * Instance of `SizeF` class with Width and Height.
     * @private
     */
    constructor(width: number, height: number);
}
/**
 * `RectangleF` with Position and size.
 * @private
 */
export  class RectangleF {
    /**
     * Value of `X`.
     * @private
     */
    x: number;
    /**
     * Value of `Y`.
     * @private
     */
    y: number;
    /**
     * Value of `Height`.
     * @private
     */
    height: number;
    /**
     * Value of `Width`.
     * @private
     */
    width: number;
    /**
     * Instance of `RectangleF` class.
     * @private
     */
    constructor();
    /**
     * Instance of `RectangleF` class with X, Y, Width and Height.
     * @private
     */
    constructor(x: number, y: number, height: number, width: number);
    /**
     * Instance of `RectangleF` class with PointF, SizeF.
     * @private
     */
    constructor(pointF: PointF, sizeF: SizeF);
}
/**
 * public Enum for `PdfDestinationMode`.
 * @private
 */
export  enum PdfDestinationMode {
    /**
     * Specifies the type of `Location`.
     * @private
     */
    Location = 0,
    /**
     * Specifies the type of `FitToPage`.
     * @private
     */
    FitToPage = 1,
    /**
     * Specifies the type of `FitR`.
     * @private
     */
    FitR = 2,
}
/**
 * General classes
 * @hidden
 */
/**
 * `Collection of the cached objects`.
 * @private
 */
export  class PdfCacheCollection {
    /**
     * Stores the similar `objects`.
     * @private
     */
    private referenceObjects;
    /**
     * Stores the references of font with GUID `objects`.
     * @private
     */
    private pdfFontCollection;
    /**
     * Initializes a new instance of the `PdfCacheCollection` class.
     * @private
     */
    constructor();
    /**
     * `Searches` for the similar cached object. If is not found - adds the object to the cache.
     * @private
     */
    search(obj: IPdfCache): IPdfCache;
    /**
     * `Creates` a new group.
     * @private
     */
    private createNewGroup();
    destroy(): void;
}
/**
 * PdfCollection.ts class for EJ2-PDF
 * The class used to handle the collection of PdF objects.
 */
export  class PdfCollection {
    /**
     * Stores the `objects` as array.
     * @private
     */
    private collection;
    /**
     * Initializes a new instance of the `Collection` class.
     * @private
     */
    constructor();
    /**
     * Gets the `Count` of stored objects.
     * @private
     */
    readonly count: number;
    /**
     * Gets the `list` of stored objects.
     * @private
     */
    readonly list: Object[];
}
/**
 * PdfDestination.ts class for EJ2-PDF
 */
/**
 * `PdfDestination` class represents an anchor in the document
 * where bookmarks or annotations can direct when clicked.
 */
export  class PdfDestination implements IPdfWrapper {
    /**
     * Internal variable for accessing fields from `DictionryProperties` class.
     * @private
     */
    protected dictionaryProperties: DictionaryProperties;
    /**
     * Type of the `destination`.
     * @private
     */
    private destinationMode;
    /**
     * `Zoom` factor.
     * @private
     * @default 0
     */
    private zoomFactor;
    /**
     * `Location` of the destination.
     * @default new PointF() with 0 ,0 as co-ordinates
     * @private
     */
    private destinationLocation;
    /**
     * `Bounds` of the destination as RectangleF.
     * @default RectangleF.Empty
     * @private
     */
    private bounds;
    /**
     * Parent `page` reference.
     * @private
     */
    private pdfPage;
    /**
     * Pdf primitive representing `this` object.
     * @private
     */
    private array;
    /**
     * Initializes a new instance of the `PdfDestination` class with page object.
     * @private
     */
    constructor(page: PdfPageBase);
    /**
     * Initializes a new instance of the `PdfDestination` class with page object and location.
     * @private
     */
    constructor(page: PdfPageBase, location: PointF);
    /**
     * Initializes a new instance of the `PdfDestination` class with page object and bounds.
     * @private
     */
    constructor(page: PdfPageBase, rectangle: RectangleF);
    /**
     * Gets and Sets the `zoom` factor.
     * @private
     */
    zoom: number;
    /**
     * Gets and Sets the `page` object.
     * @private
     */
    page: PdfPageBase;
    /**
     * Gets and Sets the destination `mode`.
     * @private
     */
    mode: PdfDestinationMode;
    /**
     * Gets and Sets the `location`.
     * @private
     */
    location: PointF;
    /**
     * `Translates` co-ordinates to PDF co-ordinate system (lower/left).
     * @private
     */
    private pointToNativePdf(page, point);
    /**
     * `In fills` array by correct values.
     * @private
     */
    private initializePrimitive();
    /**
     * Gets the `element` representing this object.
     * @private
     */
    readonly element: IPdfPrimitive;
}
/**
 * Collections classes
 * @hidden
 */
/**
 * PdfBrush.ts class for EJ2-PDF
 */
/**
 * `PdfBrush` class provides objects used to fill the interiors of graphical shapes such as rectangles,
 * ellipses, pies, polygons, and paths.
 * @private
 */
export  abstract class PdfBrush {
    /**
     * Creates instanceof `PdfBrush` class.
     * @hidden
     * @private
     */
    constructor();
    /**
     * Stores the instance of `PdfColor` class.
     * @private
     */
    color: PdfColor;
    /**
     * `MonitorChanges` abstract method overload.
     * @hidden
     * @private
     */
    abstract monitorChanges(brush: PdfBrush, streamWriter: PdfStreamWriter, getResources: GetResourceEventHandler, saveChanges: boolean, currentColorSpace: PdfColorSpace): boolean;
    /**
     * `MonitorChanges` abstract method overload.
     * @hidden
     * @private
     */
    abstract monitorChanges(brush: PdfBrush, streamWriter: PdfStreamWriter, getResources: GetResourceEventHandler, saveChanges: boolean, currentColorSpace: PdfColorSpace, check: boolean): boolean;
    /**
     * `MonitorChanges` abstract method overload.
     * @hidden
     * @private
     */
    abstract monitorChanges(brush: PdfBrush, streamWriter: PdfStreamWriter, getResources: GetResourceEventHandler, saveChanges: boolean, currentColorSpace: PdfColorSpace, check: boolean, iccBased: boolean): boolean;
    /**
     * `MonitorChanges` abstract method overload.
     * @hidden
     * @private
     */
    abstract monitorChanges(brush: PdfBrush, streamWriter: PdfStreamWriter, getResources: GetResourceEventHandler, saveChanges: boolean, currentColorSpace: PdfColorSpace, check: boolean, iccBased: boolean, indexed: boolean): boolean;
    /**
     * `MonitorChanges` abstract method overload.
     * @hidden
     * @private
     */
    abstract resetChanges(streamWriter: PdfStreamWriter): void;
}
/**
 * Represents a brush that fills any object with a solid color.
 * ```typescript
 * // create a new PDF document
 * let document : PdfDocument = new PdfDocument();
 * // add a pages to the document
 * let page1 : PdfPage = document.pages.add();
 * // set font
 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
 * // set brush
 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
 * // draw the text
 * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10));
 * // save the document
 * document.save('output.pdf');
 * // destroy the document
 * document.destroy();
 * ```
 */
export  class PdfSolidBrush extends PdfBrush {
    /**
     * The `colour` of the brush.
     * @private
     */
    pdfColor: PdfColor;
    /**
     * Indicates if the brush is `immutable`.
     * @private
     */
    private bImmutable;
    /**
     * The `color space` of the brush.
     * @private
     */
    private colorSpace;
    /**
     * Initializes a new instance of the `PdfSolidBrush` class.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a pages to the document
     * let page1 : PdfPage = document.pages.add();
     * // set font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // set brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10));
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param color color of the brush
     */
    constructor(color: PdfColor);
    /**
     * Gets or sets the `color` of the brush.
     * @private
     */
    color: PdfColor;
    /**
     * `Monitors` the changes of the brush and modify PDF state respectively.
     * @private
     */
    monitorChanges(brush: PdfBrush, streamWriter: PdfStreamWriter, getResources: GetResourceEventHandler, saveChanges: boolean, currentColorSpace: PdfColorSpace): boolean;
    /**
     * `Resets` the changes, which were made by the brush.
     * @private
     */
    resetChanges(streamWriter: PdfStreamWriter): void;
}
/**
 * `constants.ts` class for EJ2-PDF
 * @private
 */
export  class ProcedureSets {
    /**
     * Specifies the `PDF` procedure set.
     * @private
     */
    readonly pdf: string;
    /**
     * Specifies the `Text` procedure set.
     * @private
     */
    readonly text: string;
    /**
     * Specifies the `ImageB` procedure set.
     * @private
     */
    readonly imageB: string;
    /**
     * Specifies the `ImageC` procedure set.
     * @private
     */
    readonly imageC: string;
    /**
     * Specifies the `ImageI` procedure set.
     * @private
     */
    readonly imageI: string;
}
/**
 * public Enum for `PdfHorizontalAlignment`.
 * @private
 */
export  enum PdfHorizontalAlignment {
    /**
     * Specifies the type of `Left`.
     * @private
     */
    Left = 0,
    /**
     * Specifies the type of `Center`.
     * @private
     */
    Center = 1,
    /**
     * Specifies the type of `Right`.
     * @private
     */
    Right = 2,
}
/**
 * public Enum for `PdfVerticalAlignment`.
 * @private
 */
export  enum PdfVerticalAlignment {
    /**
     * Specifies the type of `Top`.
     * @private
     */
    Top = 0,
    /**
     * Specifies the type of `Middle`.
     * @private
     */
    Middle = 1,
    /**
     * Specifies the type of `Bottom`.
     * @private
     */
    Bottom = 2,
}
/**
 * public Enum for `public`.
 * @private
 */
export  enum PdfTextAlignment {
    /**
     * Specifies the type of `Left`.
     * @private
     */
    Left = 0,
    /**
     * Specifies the type of `Center`.
     * @private
     */
    Center = 1,
    /**
     * Specifies the type of `Right`.
     * @private
     */
    Right = 2,
    /**
     * Specifies the type of `Justify`.
     * @private
     */
    Justify = 3,
}
/**
 * public Enum for `TextRenderingMode`.
 * @private
 */
export  enum TextRenderingMode {
    /**
     * Specifies the type of `Fill`.
     * @private
     */
    Fill = 0,
    /**
     * Specifies the type of `Stroke`.
     * @private
     */
    Stroke = 1,
    /**
     * Specifies the type of `FillStroke`.
     * @private
     */
    FillStroke = 2,
    /**
     * Specifies the type of `None`.
     * @private
     */
    None = 3,
    /**
     * Specifies the type of `ClipFlag`.
     * @private
     */
    ClipFlag = 4,
    /**
     * Specifies the type of `ClipFill`.
     * @private
     */
    ClipFill = 4,
    /**
     * Specifies the type of `ClipStroke`.
     * @private
     */
    ClipStroke = 5,
    /**
     * Specifies the type of `ClipFillStroke`.
     * @private
     */
    ClipFillStroke = 6,
    /**
     * Specifies the type of `Clip`.
     * @private
     */
    Clip = 7,
}
/**
 * public Enum for `PdfLineJoin`.
 * @private
 */
export  enum PdfLineJoin {
    /**
     * Specifies the type of `Miter`.
     * @private
     */
    Miter = 0,
    /**
     * Specifies the type of `Round`.
     * @private
     */
    Round = 1,
    /**
     * Specifies the type of `Bevel`.
     * @private
     */
    Bevel = 2,
}
/**
 * public Enum for `PdfLineCap`.
 * @private
 */
export  enum PdfLineCap {
    /**
     * Specifies the type of `Flat`.
     * @private
     */
    Flat = 0,
    /**
     * Specifies the type of `Round`.
     * @private
     */
    Round = 1,
    /**
     * Specifies the type of `Square`.
     * @private
     */
    Square = 2,
}
/**
 * public Enum for `PdfDashStyle`.
 * @private
 */
export  enum PdfDashStyle {
    /**
     * Specifies the type of `Solid`.
     * @private
     */
    Solid = 0,
    /**
     * Specifies the type of `Dash`.
     * @private
     */
    Dash = 1,
    /**
     * Specifies the type of `Dot`.
     * @private
     */
    Dot = 2,
    /**
     * Specifies the type of `DashDot`.
     * @private
     */
    DashDot = 3,
    /**
     * Specifies the type of `DashDotDot`.
     * @private
     */
    DashDotDot = 4,
    /**
     * Specifies the type of `Custom`.
     * @private
     */
    Custom = 5,
}
/**
 * public Enum for `PdfFillMode`.
 * @private
 */
export  enum PdfFillMode {
    /**
     * Specifies the type of `Winding`.
     * @private
     */
    Winding = 0,
    /**
     * Specifies the type of `Alternate`.
     * @private
     */
    Alternate = 1,
}
/**
 * public Enum for `PdfColorSpace`.
 * @private
 */
export  enum PdfColorSpace {
    /**
     * Specifies the type of `Rgb`.
     * @private
     */
    Rgb = 0,
    /**
     * Specifies the type of `Cmyk`.
     * @private
     */
    Cmyk = 1,
    /**
     * Specifies the type of `GrayScale`.
     * @private
     */
    GrayScale = 2,
    /**
     * Specifies the type of `Indexed`.
     * @private
     */
    Indexed = 3,
}
/**
 * public Enum for `PdfBlendMode`.
 * @private
 */
export  enum PdfBlendMode {
    /**
     * Specifies the type of `Normal`.
     * @private
     */
    Normal = 0,
    /**
     * Specifies the type of `Multiply`.
     * @private
     */
    Multiply = 1,
    /**
     * Specifies the type of `Screen`.
     * @private
     */
    Screen = 2,
    /**
     * Specifies the type of `Overlay`.
     * @private
     */
    Overlay = 3,
    /**
     * Specifies the type of `Darken`.
     * @private
     */
    Darken = 4,
    /**
     * Specifies the type of `Lighten`.
     * @private
     */
    Lighten = 5,
    /**
     * Specifies the type of `ColorDodge`.
     * @private
     */
    ColorDodge = 6,
    /**
     * Specifies the type of `ColorBurn`.
     * @private
     */
    ColorBurn = 7,
    /**
     * Specifies the type of `HardLight`.
     * @private
     */
    HardLight = 8,
    /**
     * Specifies the type of `SoftLight`.
     * @private
     */
    SoftLight = 9,
    /**
     * Specifies the type of `Difference`.
     * @private
     */
    Difference = 10,
    /**
     * Specifies the type of `Exclusion`.
     * @private
     */
    Exclusion = 11,
    /**
     * Specifies the type of `Hue`.
     * @private
     */
    Hue = 12,
    /**
     * Specifies the type of `Saturation`.
     * @private
     */
    Saturation = 13,
    /**
     * Specifies the type of `Color`.
     * @private
     */
    Color = 14,
    /**
     * Specifies the type of `Luminosity`.
     * @private
     */
    Luminosity = 15,
}
/**
 * public Enum for `PdfGraphicsUnit`.
 * @private
 */
export  enum PdfGraphicsUnit {
    /**
     * Specifies the type of `Centimeter`.
     * @private
     */
    Centimeter = 0,
    /**
     * Specifies the type of `Pica`.
     * @private
     */
    Pica = 1,
    /**
     * Specifies the type of `Pixel`.
     * @private
     */
    Pixel = 2,
    /**
     * Specifies the type of `Point`.
     * @private
     */
    Point = 3,
    /**
     * Specifies the type of `Inch`.
     * @private
     */
    Inch = 4,
    /**
     * Specifies the type of `Document`.
     * @private
     */
    Document = 5,
    /**
     * Specifies the type of `Millimeter`.
     * @private
     */
    Millimeter = 6,
}
/**
 * public Enum for `PdfGridImagePosition`.
 * @private
 */
export  enum PdfGridImagePosition {
    /**
     * Specifies the type of `Fit`.
     * @private
     */
    Fit = 0,
    /**
     * Specifies the type of `Center`.
     * @private
     */
    Center = 1,
    /**
     * Specifies the type of `Stretch`.
     * @private
     */
    Stretch = 2,
    /**
     * Specifies the type of `Tile`.
     * @private
     */
    Tile = 3,
}
/**
 * ElementLayouter.ts class for EJ2-PDF
 */
/**
 * Base class for `elements lay outing`.
 * @private
 */
export  abstract class ElementLayouter {
    /**
     * Layout the `element`.
     * @private
     */
    private layoutElement;
    /**
     * Initializes a new instance of the `ElementLayouter` class.
     * @private
     */
    constructor(element: PdfLayoutElement);
    /**
     * Gets the `element`.
     * @private
     */
    readonly elements: PdfLayoutElement;
    /**
     * Gets the `element`.
     * @private
     */
    getElement(): PdfLayoutElement;
    /**
     * `Layouts` the element.
     * @private
     */
    layout(param: PdfLayoutParams): PdfLayoutResult;
    layout(param: PdfLayoutParams, isBoundsChanged: boolean): PdfLayoutResult;
    /**
     * Returns the `next page`.
     * @private
     */
    getNextPage(currentPage: PdfPage): PdfPage;
    /**
     * `Layouts` the element.
     * @private
     */
    protected abstract layoutInternal(param: PdfLayoutParams, isBoundsChanged?: boolean): PdfLayoutResult;
}
export  class PdfLayoutFormat {
    /**
     * Indicates whether `PaginateBounds` were set and should be used or not.
     * @private
     */
    private boundsSet;
    /**
     * `Bounds` for the paginating.
     * @private
     */
    private layoutPaginateBounds;
    /**
     * `Layout` type of the element.
     * @private
     */
    private layoutType;
    /**
     * `Break` type of the element.
     * @private
     */
    private breakType;
    /**
     * Gets or sets `layout` type of the element.
     * @private
     */
    layout: PdfLayoutType;
    /**
     * Gets or sets `break` type of the element.
     * @private
     */
    break: PdfLayoutBreakType;
    /**
     * Gets or sets the `bounds` on the next page.
     * @private
     */
    paginateBounds: RectangleF;
    /**
     * Gets a value indicating whether [`use paginate bounds`].
     * @private
     */
    readonly usePaginateBounds: boolean;
    /**
     * Initializes a new instance of the `PdfLayoutFormat` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `PdfLayoutFormat` class.
     * @private
     */
    constructor(baseFormat: PdfLayoutFormat);
}
export  class PdfLayoutParams {
    /**
     * The last `page` where the element was drawn.
     * @private
     */
    private pdfPage;
    /**
     * The `bounds` of the element on the last page where it was drawn.
     * @private
     */
    private layoutBounds;
    /**
     * Layout settings as `format`.
     * @private
     */
    private layoutFormat;
    /**
     * Gets or sets the layout `page` for the element.
     * @private
     */
    page: PdfPage;
    /**
     * Gets or sets layout `bounds` for the element.
     * @private
     */
    bounds: RectangleF;
    /**
     * Gets or sets `layout settings` for the element.
     * @private
     */
    format: PdfLayoutFormat;
}
export  class PdfLayoutResult {
    /**
     * The last `page` where the element was drawn.
     * @private
     */
    private pdfPage;
    /**
     * The `bounds` of the element on the last page where it was drawn.
     * @private
     */
    private layoutBounds;
    /**
     * Gets the last `page` where the element was drawn.
     * @private
     */
    readonly page: PdfPage;
    /**
     * Gets the `bounds` of the element on the last page where it was drawn.
     * @private
     */
    readonly bounds: RectangleF;
    /**
     * Initializes the new instance of `PdfLayoutResult` class.
     * @private
     */
    constructor(page: PdfPage, bounds: RectangleF);
}
/**
 * PdfGraphicsElement.ts class for EJ2-PDF
 */
/**
 * Represents a base class for all page graphics elements.
 */
export  abstract class PdfGraphicsElement {
    protected constructor();
    /**
     * `Draws` the page number field.
     * @public
     */
    drawHelper(graphics: PdfGraphics, x: number, y: number): void;
    protected abstract drawInternal(graphics: PdfGraphics): void;
}
/**
 * Figures Base classes
 * @hidden
 */
/**
 * PdfShapeElement.ts class for EJ2-PDF
 * @private
 */
/**
 * Base class for the main shapes.
 * @private
 */
export  abstract class PdfShapeElement extends PdfLayoutElement {
    /**
     * Gets the bounds.
     * @private
     */
    getBounds(): RectangleF;
    /**
     * Returns a rectangle that bounds this element.
     * @private
     */
    protected abstract getBoundsInternal(): RectangleF;
    /**
     * Layouts the element.
     * @private
     */
    protected layout(param: PdfLayoutParams): PdfLayoutResult;
}
/**
 * ShapeLayouter.ts class for EJ2-PDF
 * @private
 */
/**
 * ShapeLayouter class.
 * @private
 */
export  class ShapeLayouter extends ElementLayouter {
    /**
     * Initializes the object to store `older form elements` of previous page.
     * @default 0
     * @private
     */
    olderPdfForm: number;
    /**
     * Initializes the offset `index`.
     * * @default 0
     * @private
     */
    private static index;
    /**
     * Initializes the `difference in page height`.
     * * @default 0
     * @private
     */
    private static splitDiff;
    /**
     * Determines the `end of Vertical offset` values.
     * * @default false
     * @private
     */
    private static last;
    /**
     * Determines the document link annotation `border width`.
     * * @default 0
     * @private
     */
    private static readonly borderWidth;
    /**
     * Checks weather `is pdf grid` or not.
     * @private
     */
    isPdfGrid: boolean;
    /**
     * The `bounds` of the shape element.
     * * @default new RectangleF()
     * @private
     */
    shapeBounds: RectangleF;
    /**
     * The `bottom cell padding`.
     * @private
     */
    bottomCellPadding: number;
    /**
     * Total Page size of the web page.
     * * @default 0
     * @private
     */
    private totalPageSize;
    /**
     * Initializes a new instance of the `ShapeLayouter` class.
     * @private
     */
    constructor(element: PdfShapeElement);
    /**
     * Gets shape element.
     * @private
     */
    readonly element: PdfShapeElement;
    /**
     * Layouts the element.
     * @private
     */
    protected layoutInternal(param: PdfLayoutParams): PdfLayoutResult;
}
/**
 * TextLayouter.ts class for EJ2-PDF
 */
/**
 * Class that `layouts the text`.
 * @private
 */
export  class TextLayouter extends ElementLayouter {
    /**
     * String `format`.
     * @private
     */
    private format;
    /**
     * Gets the layout `element`.
     * @private
     */
    readonly element: PdfTextElement;
    /**
     * Initializes a new instance of the `TextLayouter` class.
     * @private
     */
    constructor(element: PdfTextElement);
    /**
     * `Layouts` the element.
     * @private
     */
    protected layoutInternal(param: PdfLayoutParams): PdfLayoutResult;
    /**
     * Raises `PageLayout` event if needed.
     * @private
     */
    private getLayoutResult(pageResult);
    /**
     * `Layouts` the text on the page.
     * @private
     */
    private layoutOnPage(text, currentPage, currentBounds, param);
    /**
     * `Corrects current bounds` on the page.
     * @private
     */
    private checkCorrectBounds(currentPage, currentBounds);
    /**
     * Returns a `rectangle` where the text was printed on the page.
     * @private
     */
    private getTextPageBounds(currentPage, currentBounds, stringResult);
}
export  class TextPageLayoutResult {
    /**
     * The last `page` where the text was drawn.
     * @private
     */
    page: PdfPage;
    /**
     * The `bounds` of the element on the last page where it was drawn.
     * @private
     */
    bounds: RectangleF;
    /**
     * Indicates whether the lay outing has been finished [`end`].
     * @private
     */
    end: boolean;
    /**
     * The `text` that was not printed.
     * @private
     */
    remainder: string;
    /**
     * Gets or sets a `bounds` of the last text line that was printed.
     * @private
     */
    lastLineBounds: RectangleF;
}
export  class PdfTextLayoutResult extends PdfLayoutResult {
    /**
     * The `text` that was not printed.
     * @private
     */
    private remainderText;
    /**
     * The `bounds` of the last line that was printed.
     * @private
     */
    private lastLineTextBounds;
    /**
     * Gets a value that contains the `text` that was not printed.
     * @private
     */
    readonly remainder: string;
    /**
     * Gets a value that indicates the `bounds` of the last line that was printed on the page.
     * @private
     */
    readonly lastLineBounds: RectangleF;
    /**
     * Initializes the new instance of `PdfTextLayoutResult` class.
     * @private
     */
    constructor(page: PdfPage, bounds: RectangleF, remainder: string, lastLineBounds: RectangleF);
}
/**
 * public Enum for `PdfLayoutType`.
 * @private
 */
export  enum PdfLayoutType {
    /**
     * Specifies the type of `Paginate`.
     * @private
     */
    Paginate = 0,
    /**
     * Specifies the type of `OnePage`.
     * @private
     */
    OnePage = 1,
}
/**
 * public Enum for `PdfLayoutBreakType`.
 * @private
 */
export  enum PdfLayoutBreakType {
    /**
     * Specifies the type of `FitPage`.
     * @private
     */
    FitPage = 0,
    /**
     * Specifies the type of `FitElement`.
     * @private
     */
    FitElement = 1,
    /**
     * Specifies the type of `FitColumnsToPage`.
     * @private
     */
    FitColumnsToPage = 2,
}
/**
 * Figures classes
 * @hidden
 */
/**
 * PdfLayoutElement.ts class for EJ2-PDF
 */
/**
 * `PdfLayoutElement` class represents the base class for all elements that can be layout on the pages.
 * @private
 */
export  abstract class PdfLayoutElement {
    /**
     * Indicating whether [`embed fonts`]
     * @private
     */
    private bEmbedFonts;
    /**
     * `Draws` the element on the page with the specified page and "PointF" class
     * @private
     */
    drawHelper(page: PdfPage, location: PointF): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page and pair of coordinates
     * @private
     */
    drawHelper(page: PdfPage, x: number, y: number): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page and "RectangleF" class
     * @private
     */
    drawHelper(page: PdfPage, layoutRectangle: RectangleF): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page, "PointF" class and layout format
     * @private
     */
    drawHelper(page: PdfPage, location: PointF, format: PdfLayoutFormat): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page, pair of coordinates and layout format
     * @private
     */
    drawHelper(page: PdfPage, x: number, y: number, format: PdfLayoutFormat): PdfLayoutResult;
    /**
     * `Draws` the element on the page.
     * @private
     */
    drawHelper(page: PdfPage, layoutRectangle: RectangleF, embedFonts: boolean): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page, "RectangleF" class and layout format
     * @private
     */
    drawHelper(page: PdfPage, layoutRectangle: RectangleF, format: PdfLayoutFormat): PdfLayoutResult;
    /**
     * `Layouts` the specified param.
     * @private
     */
    protected abstract layout(param: PdfLayoutParams): PdfLayoutResult;
}
/**
 * PdfTemplate.ts class for EJ2-PDF
 */
/**
 * Represents `Pdf Template` object.
 * @private
 */
export  class PdfTemplate implements IPdfWrapper {
    /**
     * Stores the value of current `graphics`.
     * @private
     */
    private pdfGraphics;
    /**
     * Stores the instance of `PdfResources` class.
     * @private
     */
    private resources;
    /**
     * Stores the `size` of the 'PdfTemplate'.
     * @private
     */
    private templateSize;
    /**
     * Initialize an instance for `DictionaryProperties` class.
     * @private
     * @hidden
     */
    private dictionaryProperties;
    /**
     * Stores the `content` of the 'PdfTemplate'.
     * @private
     */
    content: PdfStream;
    /**
     * Checks whether the transformation 'is performed'.
     * @default true
     * @private
     */
    writeTransformation: boolean;
    /**
     * Gets the size of the 'PdfTemplate'.
     */
    readonly size: SizeF;
    /**
     * Gets the width of the 'PdfTemplate'.
     */
    readonly width: number;
    /**
     * Gets the height of the 'PdfTemplate'.
     */
    readonly height: number;
    /**
     * Gets the `graphics` of the 'PdfTemplate'.
     */
    readonly graphics: PdfGraphics;
    /**
     * Gets the resources and modifies the template dictionary.
     * @private
     */
    getResources(): PdfResources;
    /**
     * Create the new instance for `PdfTemplate` class.
     * @private
     */
    constructor();
    /**
     * Create the new instance for `PdfTemplate` class with Size.
     * @private
     */
    constructor(arg1: SizeF);
    /**
     * Create the new instance for `PdfTemplate` class with width and height.
     * @private
     */
    constructor(arg1: number, arg2: number);
    /**
     * `Initialize` the type and subtype of the template.
     * @private
     */
    private initialize();
    /**
     * `Adds type key`.
     * @private
     */
    private addType();
    /**
     * `Adds SubType key`.
     * @private
     */
    private addSubType();
    /**
     * `Reset` the size of the 'PdfTemplate'.
     */
    reset(): void;
    reset(size: SizeF): void;
    /**
     * `Set the size` of the 'PdfTemplate'.
     * @private
     */
    private setSize(size);
    /**
     * Gets the `content stream` of 'PdfTemplate' class.
     * @private
     */
    readonly element: IPdfPrimitive;
}
/**
 * PdfTextElement.ts class for EJ2-PDF
 */
/**
 * `PdfTextElement` class represents the text area with the ability to span several pages
 * and inherited from the 'PdfLayoutElement' class.
 * @private
 */
export  class PdfTextElement extends PdfLayoutElement {
    /**
     * `Text` data.
     * @private
     */
    private content;
    /**
     * `Value` of text data.
     * @private
     */
    private elementValue;
    /**
     * `Pen` for text drawing.
     * @private
     */
    private pdfPen;
    /**
     * `Brush` for text drawing.
     * @private
     */
    private pdfBrush;
    /**
     * `Font` for text drawing.
     * @private
     */
    private pdfFont;
    /**
     * Text `format`.
     * @private
     */
    private format;
    /**
     * indicate whether the drawText with PointF overload is called or not.
     * @default false
     * @private
     */
    private hasPointOverload;
    /**
     * indicate whether the PdfGridCell value is `PdfTextElement`
     * @default false
     * @private
     */
    isPdfTextElement: boolean;
    /**
     * Initializes a new instance of the `PdfTextElement` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `PdfTextElement` class with text to draw into the PDF.
     * @private
     */
    constructor(text: string);
    /**
     * Initializes a new instance of the `PdfTextElement` class with the text and `PdfFont`.
     * @private
     */
    constructor(text: string, font: PdfFont);
    /**
     * Initializes a new instance of the `PdfTextElement` class with text,`PdfFont` and `PdfPen`.
     * @private
     */
    constructor(text: string, font: PdfFont, pen: PdfPen);
    /**
     * Initializes a new instance of the `PdfTextElement` class with text,`PdfFont` and `PdfBrush`.
     * @private
     */
    constructor(text: string, font: PdfFont, brush: PdfBrush);
    /**
     * Initializes a new instance of the `PdfTextElement` class with text,`PdfFont`,`PdfPen`,`PdfBrush` and `PdfStringFormat`.
     * @private
     */
    constructor(text: string, font: PdfFont, pen: PdfPen, brush: PdfBrush, format: PdfStringFormat);
    /**
     * Gets or sets a value indicating the `text` that should be printed.
     * ```typescript
     * // create a new PDF document.
     * let document : PdfDocument = new PdfDocument();
     * // add a page to the document.
     * let page1 : PdfPage = document.pages.add();
     * // create the font
     * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);
     * // create the Text Web Link
     * let textLink : PdfTextWebLink = new PdfTextWebLink();
     * // set the hyperlink
     * textLink.url = 'http://www.google.com';
     * //
     * // set the link text
     * textLink.text = 'Google';
     * //
     * // set the font
     * textLink.font = font;
     * // draw the hyperlink in PDF page
     * textLink.draw(page1, new PointF(10, 40));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    text: string;
    /**
     * Gets or sets a `value` indicating the text that should be printed.
     * @private
     */
    readonly value: string;
    /**
     * Gets or sets a `PdfPen` that determines the color, width, and style of the text
     * @private
     */
    pen: PdfPen;
    /**
     * Gets or sets the `PdfBrush` that will be used to draw the text with color and texture.
     * @private
     */
    brush: PdfBrush;
    /**
     * Gets or sets a `PdfFont` that defines the text format.
     * ```typescript
     * // create a new PDF document.
     * let document : PdfDocument = new PdfDocument();
     * // add a page to the document.
     * let page1 : PdfPage = document.pages.add();
     * // create the font
     * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);
     * // create the Text Web Link
     * let textLink : PdfTextWebLink = new PdfTextWebLink();
     * // set the hyperlink
     * textLink.url = 'http://www.google.com';
     * // set the link text
     * textLink.text = 'Google';
     * //
     * // set the font
     * textLink.font = font;
     * //
     * // draw the hyperlink in PDF page
     * textLink.draw(page1, new PointF(10, 40));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    font: PdfFont;
    /**
     * Gets or sets the `PdfStringFormat` that will be used to set the string format
     * @private
     */
    stringFormat: PdfStringFormat;
    /**
     * Gets a `brush` for drawing.
     * @private
     */
    getBrush(): PdfBrush;
    /**
     * `Layouts` the element.
     * @private
     */
    protected layout(param: PdfLayoutParams): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page and "PointF" class
     * @private
     */
    drawText(page: PdfPage, location: PointF): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page and pair of coordinates
     * @private
     */
    drawText(page: PdfPage, x: number, y: number): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page and "RectangleF" class
     * @private
     */
    drawText(page: PdfPage, layoutRectangle: RectangleF): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page, "PointF" class and layout format
     * @private
     */
    drawText(page: PdfPage, location: PointF, format: PdfLayoutFormat): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page, pair of coordinates and layout format
     * @private
     */
    drawText(page: PdfPage, x: number, y: number, format: PdfLayoutFormat): PdfLayoutResult;
    /**
     * `Draws` the element on the page.
     * @private
     */
    drawText(page: PdfPage, layoutRectangle: RectangleF, embedFonts: boolean): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page, "RectangleF" class and layout format
     * @private
     */
    drawText(page: PdfPage, layoutRectangle: RectangleF, format: PdfLayoutFormat): PdfLayoutResult;
    private calculateResultBounds(result, lineWidth, maximumWidth, startPosition);
}
/**
 * public Enum for `PdfFontStyle`.
 * @private
 */
export  enum PdfFontStyle {
    /**
     * Specifies the type of `Regular`.
     * @private
     */
    Regular = 0,
    /**
     * Specifies the type of `Bold`.
     * @private
     */
    Bold = 1,
    /**
     * Specifies the type of `Italic`.
     * @private
     */
    Italic = 2,
    /**
     * Specifies the type of `Underline`.
     * @private
     */
    Underline = 4,
    /**
     * Specifies the type of `Strikeout`.
     * @private
     */
    Strikeout = 8,
}
/**
 * Specifies the font family from the standard font.
 * ```typescript
 * // create a new PDF document
 * let document : PdfDocument = new PdfDocument();
 * // add a new page to the document
 * let page1 : PdfPage = document.pages.add();
 * // create new standard font
 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
 * // create black brush
 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
 * // draw the text
 * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
 * // save the document
 * document.save('output.pdf');
 * ```
 */
export  enum PdfFontFamily {
    /**
     * Specifies the `Helvetica` font.
     */
    Helvetica = 0,
    /**
     * Specifies the `Courier` font.
     */
    Courier = 1,
    /**
     * Specifies the `TimesRoman` font.
     */
    TimesRoman = 2,
    /**
     * Specifies the `Symbol` font.
     */
    Symbol = 3,
    /**
     * Specifies the `ZapfDingbats` font.
     */
    ZapfDingbats = 4,
}
/**
 * public Enum for `PdfFontType`.
 * @private
 */
export  enum PdfFontType {
    /**
     * Specifies the type of `Standard`.
     * @private
     */
    Standard = 0,
    /**
     * Specifies the type of `TrueType`.
     * @private
     */
    TrueType = 1,
    /**
     * Specifies the type of `TrueTypeEmbedded`.
     * @private
     */
    TrueTypeEmbedded = 2,
}
/**
 * public Enum for `PdfWordWrapType`.
 * @private
 */
export  enum PdfWordWrapType {
    /**
     * Specifies the type of `None`.
     * @private
     */
    None = 0,
    /**
     * Specifies the type of `Word`.
     * @private
     */
    Word = 1,
    /**
     * Specifies the type of `WordOnly`.
     * @private
     */
    WordOnly = 2,
    /**
     * Specifies the type of `Character`.
     * @private
     */
    Character = 3,
}
/**
 * public Enum for `PdfSubSuperScript`.
 * @private
 */
export  enum PdfSubSuperScript {
    /**
     * Specifies the type of `None`.
     * @private
     */
    None = 0,
    /**
     * Specifies the type of `SuperScript`.
     * @private
     */
    SuperScript = 1,
    /**
     * Specifies the type of `SubScript`.
     * @private
     */
    SubScript = 2,
}
/**
 * public Enum for `FontEncoding`.
 * @private
 */
export  enum FontEncoding {
    /**
     * Specifies the type of `Unknown`.
     * @private
     */
    Unknown = 0,
    /**
     * Specifies the type of `StandardEncoding`.
     * @private
     */
    StandardEncoding = 1,
    /**
     * Specifies the type of `MacRomanEncoding`.
     * @private
     */
    MacRomanEncoding = 2,
    /**
     * Specifies the type of `MacExpertEncoding`.
     * @private
     */
    MacExpertEncoding = 3,
    /**
     * Specifies the type of `WinAnsiEncoding`.
     * @private
     */
    WinAnsiEncoding = 4,
    /**
     * Specifies the type of `PdfDocEncoding`.
     * @private
     */
    PdfDocEncoding = 5,
    /**
     * Specifies the type of `IdentityH`.
     * @private
     */
    IdentityH = 6,
}
/**
 * Font classes
 * @hidden
 */
/**
 * PdfFontMetrics.ts class for EJ2-PDF
 */
/**
 * `Metrics` of the font.
 * @private
 */
export  class PdfFontMetrics {
    /**
     * Gets `ascent` of the font.
     * @private
     */
    ascent: number;
    /**
     * Gets `descent` of the font.
     * @private
     */
    descent: number;
    /**
     * `Name` of the font.
     * @private
     */
    name: string;
    /**
     * Gets `PostScript` Name of the  font.
     * @private
     */
    postScriptName: string;
    /**
     * Gets `size` of the font.
     * @private
     */
    size: number;
    /**
     * Gets `height` of the font.
     * @private
     */
    height: number;
    /**
     * `First char` of the font.
     * @private
     */
    firstChar: number;
    /**
     * `Last char` of the font.
     * @private
     */
    lastChar: number;
    /**
     * `Line gap`.
     * @private
     */
    lineGap: number;
    /**
     * `Subscript` size factor.
     * @private
     */
    subScriptSizeFactor: number;
    /**
     * `Superscript` size factor.
     * @private
     */
    superscriptSizeFactor: number;
    /**
     * Gets `table` of glyphs` width.
     * @private
     */
    internalWidthTable: WidthTable;
    /**
     * Checks whether is it `unicode font` or not.
     * @private
     */
    isUnicodeFont: boolean;
    /**
     * Returns `ascent` taking into consideration font`s size.
     * @private
     */
    getAscent(format: PdfStringFormat): number;
    /**
     * Returns `descent` taking into consideration font`s size.
     * @private
     */
    getDescent(format: PdfStringFormat): number;
    /**
     * Returns `Line gap` taking into consideration font`s size.
     * @private
     */
    getLineGap(format: PdfStringFormat): number;
    /**
     * Returns `height` taking into consideration font`s size.
     * @private
     */
    getHeight(format: PdfStringFormat): number;
    /**
     * Calculates `size` of the font depending on the subscript/superscript value.
     * @private
     */
    getSize(format: PdfStringFormat): number;
    /**
     * `Clones` the metrics.
     * @private
     */
    clone(): PdfFontMetrics;
    /**
     * Gets or sets the `width table`.
     * @private
     */
    widthTable: WidthTable;
}
export  abstract class WidthTable {
    /**
     * Returns the `width` of the specific index.
     * @private
     */
    abstract items(index: number): number;
    /**
     * `Clones` this instance of the WidthTable class.
     * @private
     */
    abstract clone(): WidthTable;
    /**
     * Static `clones` this instance of the WidthTable class.
     * @private
     */
    static clone(): WidthTable;
}
export  class StandardWidthTable extends WidthTable {
    /**
     * The `widths` of the supported characters.
     * @private
     */
    private widths;
    /**
     * Gets the `32 bit number` at the specified index.
     * @private
     */
    items(index: number): number;
    /**
     * Gets the `length` of the internal array.
     * @private
     */
    readonly length: number;
    /**
     * Initializes a new instance of the `StandardWidthTable` class.
     * @private
     */
    constructor(widths: number[]);
    /**
     * `Clones` this instance of the WidthTable class.
     * @private
     */
    clone(): WidthTable;
    /**
     * Converts width table to a `PDF array`.
     * @private
     */
    toArray(): PdfArray;
}
/**
 * PdfFont.ts class for EJ2-PDF
 */
/**
 * Defines a particular format for text, including font face, size, and style attributes.
 * @private
 */
export  abstract class PdfFont implements IPdfWrapper, IPdfCache {
    /**
     * `Multiplier` of the symbol width.
     * @default 0.001
     * @private
     */
    static readonly charSizeMultiplier: number;
    /**
     * `Synchronization` object.
     * @private
     */
    protected static syncObject: Object;
    /**
     * `Size` of the font.
     * @private
     */
    private fontSize;
    /**
     * `Style` of the font.
     * @private
     */
    private fontStyle;
    /**
     * `Metrics` of the font.
     * @private
     */
    private fontMetrics;
    /**
     * PDf `primitive` of the font.
     * @private
     */
    private pdfFontInternals;
    /**
     * Initializes a new instance of the `PdfFont` class.
     * @private
     */
    protected constructor(size: number);
    /**
     * Initializes a new instance of the `PdfFont` class.
     * @private
     */
    protected constructor(size: number, style: PdfFontStyle);
    /**
     * Gets the face name of this Font.
     * @private
     */
    readonly name: string;
    /**
     * Gets the size of this font.
     * @private
     */
    readonly size: number;
    /**
     * Gets the height of the font in points.
     * @private
     */
    readonly height: number;
    /**
     * Gets the style information for this font.
     * @private
     */
    style: PdfFontStyle;
    /**
     * Gets a value indicating whether this `PdfFont` is `bold`.
     * @private
     */
    readonly bold: boolean;
    /**
     * Gets a value indicating whether this `PdfFont` has the `italic` style applied.
     * @private
     */
    readonly italic: boolean;
    /**
     * Gets a value indicating whether this `PdfFont` is `strikeout`.
     * @private
     */
    readonly strikeout: boolean;
    /**
     * Gets a value indicating whether this `PdfFont` is `underline`.
     * @private
     */
    readonly underline: boolean;
    /**
     * Gets or sets the `metrics` for this font.
     * @private
     */
    metrics: PdfFontMetrics;
    /**
     * Gets the `element` representing the font.
     * @private
     */
    readonly element: IPdfPrimitive;
    /**
     * `Measures` a string by using this font.
     * @private
     */
    measureString(text: string): SizeF;
    /**
     * `Measures` a string by using this font.
     * @private
     */
    measureString(text: string, format: PdfStringFormat): SizeF;
    /**
     * `Measures` a string by using this font.
     * @private
     */
    measureString(text: string, format: PdfStringFormat, charactersFitted: number, linesFilled: number): SizeF;
    /**
     * `Measures` a string by using this font.
     * @private
     */
    measureString(text: string, width: number): SizeF;
    /**
     * `Measures` a string by using this font.
     * @private
     */
    measureString(text: string, width: number, format: PdfStringFormat): SizeF;
    /**
     * `Measures` a string by using this font.
     * @private
     */
    measureString(text: string, width: number, format: PdfStringFormat, charactersFitted: number, linesFilled: number): SizeF;
    /**
     * `Measures` a string by using this font.
     * @private
     */
    measureString(text: string, layoutArea: SizeF): SizeF;
    /**
     * `Measures` a string by using this font.
     * @private
     */
    measureString(text: string, layoutArea: SizeF, format: PdfStringFormat): SizeF;
    /**
     * `Measures` a string by using this font.
     * @private
     */
    measureString(text: string, layoutArea: SizeF, format: PdfStringFormat, charactersFitted: number, linesFilled: number): SizeF;
    /**
     * `Checks` whether the object is similar to another object.
     * @private
     */
    equalsTo(obj: IPdfCache): boolean;
    /**
     * Returns `internals` of the object.
     * @private
     */
    getInternals(): IPdfPrimitive;
    /**
     * Sets `internals` to the object.
     * @private
     */
    setInternals(internals: IPdfPrimitive): void;
    /**
     * `Checks` whether fonts are equals.
     * @private
     */
    protected abstract equalsToFont(font: PdfFont): boolean;
    /**
     * Returns `width` of the line.
     * @private
     */
    abstract getLineWidth(line: string, format: PdfStringFormat): number;
    /**
     * Sets the `style` of the font.
     * @private
     */
    protected setStyle(style: PdfFontStyle): void;
    /**
     * Applies `settings` to the default line width.
     * @private
     */
    protected applyFormatSettings(line: string, format: PdfStringFormat, width: number): number;
}
/**
 * PdfStandardFontMetricsFactory.ts class for EJ2-PDF
 */
/**
 * @private
 * `Factory of the standard fonts metrics`.
 */
export  class PdfStandardFontMetricsFactory {
    /**
     * `Multiplier` os subscript superscript.
     * @private
     */
    private static readonly subSuperScriptFactor;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly helveticaAscent;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly helveticaDescent;
    /**
     * `Font type`.
     * @private
     */
    private static readonly helveticaName;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly helveticaBoldAscent;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly helveticaBoldDescent;
    /**
     * `Font type`.
     * @private
     */
    private static readonly helveticaBoldName;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly helveticaItalicAscent;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly helveticaItalicDescent;
    /**
     * `Font type`.
     * @private
     */
    private static readonly helveticaItalicName;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly helveticaBoldItalicAscent;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly helveticaBoldItalicDescent;
    /**
     * `Font type`.
     * @private
     */
    private static readonly helveticaBoldItalicName;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly courierAscent;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly courierDescent;
    /**
     * `Font type`.
     * @private
     */
    private static readonly courierName;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly courierBoldAscent;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly courierBoldDescent;
    /**
     * `Font type`.
     * @private
     */
    private static readonly courierBoldName;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly courierItalicAscent;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly courierItalicDescent;
    /**
     * `Font type`.
     * @private
     */
    private static readonly courierItalicName;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly courierBoldItalicAscent;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly courierBoldItalicDescent;
    /**
     * `Font type`.
     * @private
     */
    private static readonly courierBoldItalicName;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly timesAscent;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly timesDescent;
    /**
     * `Font type`.
     * @private
     */
    private static readonly timesName;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly timesBoldAscent;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly timesBoldDescent;
    /**
     * `Font type`.
     * @private
     */
    private static readonly timesBoldName;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly timesItalicAscent;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly timesItalicDescent;
    /**
     * `Font type`.
     * @private
     */
    private static readonly timesItalicName;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly timesBoldItalicAscent;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly timesBoldItalicDescent;
    /**
     * `Font type`.
     * @private
     */
    private static readonly timesBoldItalicName;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly symbolAscent;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly symbolDescent;
    /**
     * `Font type`.
     * @private
     */
    private static readonly symbolName;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly zapfDingbatsAscent;
    /**
     * `Ascender` value for the font.
     * @private
     */
    private static readonly zapfDingbatsDescent;
    /**
     * `Font type`.
     * @private
     */
    private static readonly zapfDingbatsName;
    /**
     * `Arial` widths table.
     * @private
     */
    private static arialWidth;
    /**
     * `Arial bold` widths table.
     * @private
     */
    private static arialBoldWidth;
    /**
     * `Fixed` widths table.
     * @private
     */
    private static fixedWidth;
    /**
     * `Times` widths table.
     * @private
     */
    private static timesRomanWidth;
    /**
     * `Times bold` widths table.
     * @private
     */
    private static timesRomanBoldWidth;
    /**
     * `Times italic` widths table.
     * @private
     */
    private static timesRomanItalicWidth;
    /**
     * `Times bold italic` widths table.
     * @private
     */
    static timesRomanBoldItalicWidths: number[];
    /**
     * `Symbol` widths table.
     * @private
     */
    private static symbolWidth;
    /**
     * `Zip dingbats` widths table.
     * @private
     */
    private static zapfDingbatsWidth;
    /**
     * Returns `metrics` of the font.
     * @private
     */
    static getMetrics(fontFamily: PdfFontFamily, fontStyle: PdfFontStyle, size: number): PdfFontMetrics;
    /**
     * Creates `Helvetica font metrics`.
     * @private
     */
    private static getHelveticaMetrics(fontFamily, fontStyle, size);
    /**
     * Creates `Courier font metrics`.
     * @private
     */
    private static getCourierMetrics(fontFamily, fontStyle, size);
    /**
     * Creates `Times font metrics`.
     * @private
     */
    private static getTimesMetrics(fontFamily, fontStyle, size);
    /**
     * Creates `Symbol font metrics`.
     * @private
     */
    private static getSymbolMetrics(fontFamily, fontStyle, size);
    /**
     * Creates `ZapfDingbats font metrics`.
     * @private
     */
    private static getZapfDingbatsMetrics(fontFamily, fontStyle, size);
}
/**
 * Represents one of the 14 standard fonts.
 * It's used to create a standard PDF font to draw the text in to the PDF.
 * ```typescript
 * // create a new PDF document
 * let document : PdfDocument = new PdfDocument();
 * // add a new page to the document
 * let page1 : PdfPage = document.pages.add();
 * //
 * // create new standard font
 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
 * //
 * // create black brush
 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
 * // draw the text
 * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
 * // save the document
 * document.save('output.pdf');
 * // destroy the document
 * document.destroy();
 * ```
 */
export  class PdfStandardFont extends PdfFont {
    /**
     * First character `position`.
     * @private
     */
    private static readonly charOffset;
    /**
     * `FontFamily` of the font.
     * @private
     */
    private pdfFontFamily;
    /**
     * Gets `ascent` of the font.
     * @private
     */
    private dictionaryProperties;
    /**
     * Gets `encodings` for internal class use.
     * @hidden
     * @private
     */
    private encodings;
    /**
     * Initializes a new instance of the `PdfStandardFont` class with font family and it`s size.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a new page to the document
     * let page1 : PdfPage = document.pages.add();
     * // create black brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * // set the font with the font family and font size
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param fontFamily Represents the font family to be used.
     * @param size Represents the size of the font.
     */
    constructor(fontFamily: PdfFontFamily, size: number);
    /**
     * Initializes a new instance of the `PdfStandardFont` class with font family, size and font style.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a pages to the document
     * let page1 : PdfPage = document.pages.add();
     * // set font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20, PdfFontStyle.Bold);
     * // set brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10));
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param fontFamily Represents the font family to be used.
     * @param size Represents the size of the font.
     * @param style Represents the font style.
     */
    constructor(fontFamily: PdfFontFamily, size: number, style: PdfFontStyle);
    /**
     * Initializes a new instance of the `PdfStandardFont` class with `PdfStandardFont` as prototype and font size.
     * @private
     */
    constructor(prototype: PdfStandardFont, size: number);
    /**
     * Initializes a new instance of the `PdfStandardFont` class with `PdfStandardFont` as prototype,font size and font style.
     * @private
     */
    constructor(prototype: PdfStandardFont, size: number, style: PdfFontStyle);
    /**
     * Gets the `FontFamily`.
     * @private
     */
    readonly fontFamily: PdfFontFamily;
    /**
     * Checks font `style` of the font.
     * @private
     */
    private checkStyle();
    /**
     * Returns `width` of the line.
     * @public
     */
    getLineWidth(line: string, format: PdfStringFormat): number;
    /**
     * Checks whether fonts are `equals`.
     * @private
     */
    protected equalsToFont(font: PdfFont): boolean;
    /**
     * `Initializes` font internals..
     * @private
     */
    private initializeInternals();
    /**
     * `Creates` font`s dictionary.
     * @private
     */
    private createInternals();
    /**
     * Returns `width` of the char. This methods doesn`t takes into consideration font`s size.
     * @private
     */
    private getCharWidthInternal(charCode, format);
    /**
     * `Converts` the specified text.
     * @private
     */
    static convert(text: string): string;
}
/**
 * PdfStringFormat.ts class for EJ2-PDF
 */
/**
 * `PdfStringFormat` class represents the text layout information on PDF.
 * ```typescript
 * // create a new PDF document
 * let document : PdfDocument = new PdfDocument();
 * // add a pages to the document
 * let page1 : PdfPage = document.pages.add();
 * // set font
 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
 * // set brush
 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
 * //
 * // set the format for string
 * let stringFormat : PdfStringFormat = new PdfStringFormat();
 * // set the text alignment
 * stringFormat.alignment = PdfTextAlignment.Center;
 * // set the vertical alignment
 * stringFormat.lineAlignment = PdfVerticalAlignment.Middle;
 * //
 * // draw the text
 * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
 * // save the document
 * document.save('output.pdf');
 * // destroy the document
 * document.destroy();
 * ```
 */
export  class PdfStringFormat {
    /**
     * `Horizontal text alignment`.
     * @private
     */
    private textAlignment;
    /**
     * `Vertical text alignment`.
     * @private
     */
    private verticalAlignment;
    /**
     * Indicates whether `RTL` should be checked.
     * @private
     */
    private isRightToLeft;
    /**
     * `Character spacing` value.
     * @private
     */
    private internalCharacterSpacing;
    /**
     * `Word spacing` value.
     * @private
     */
    private internalWordSpacing;
    /**
     * Text `leading`.
     * @private
     */
    private leading;
    /**
     * Shows if the text should be a part of the current `clipping` path.
     * @private
     */
    private clip;
    /**
     * Indicates whether the text is in `subscript or superscript` mode.
     * @private
     */
    private pdfSubSuperScript;
    /**
     * The `scaling factor` of the text being drawn.
     * @private
     */
    private scalingFactor;
    /**
     * Indent of the `first line` in the text.
     * @private
     */
    private initialLineIndent;
    /**
     * Indent of the `first line` in the paragraph.
     * @private
     */
    private internalParagraphIndent;
    /**
     * Indicates whether entire lines are laid out in the formatting rectangle only or not[`line limit`].
     * @private
     */
    private internalLineLimit;
    /**
     * Indicates whether spaces at the end of the line should be left or removed[`measure trailing spaces`].
     * @private
     */
    private trailingSpaces;
    /**
     * Indicates whether the text region should be `clipped` or not.
     * @private
     */
    private isNoClip;
    /**
     * Indicates text `wrapping` type.
     * @private
     */
    private wordWrapType;
    /**
     * Initializes a new instance of the `PdfStringFormat` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `PdfStringFormat` class with horizontal alignment of a text.
     * @private
     */
    constructor(alignment: PdfTextAlignment);
    /**
     * Initializes a new instance of the `PdfStringFormat` class with column format.
     * @private
     */
    constructor(columnFormat: string);
    /**
     * Initializes a new instance of the `PdfStringFormat` class with horizontal and vertical alignment.
     * @private
     */
    constructor(alignment: PdfTextAlignment, lineAlignment: PdfVerticalAlignment);
    /**
     * Gets or sets the `horizontal` text alignment
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a pages to the document
     * let page1 : PdfPage = document.pages.add();
     * // set font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // set brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * //
     * // set the format for string
     * let stringFormat : PdfStringFormat = new PdfStringFormat();
     * // set the text alignment
     * stringFormat.alignment = PdfTextAlignment.Center;
     * //
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    alignment: PdfTextAlignment;
    /**
     * Gets or sets the `vertical` text alignment.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a pages to the document
     * let page1 : PdfPage = document.pages.add();
     * // set font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // set brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * //
     * // set the format for string
     * let stringFormat : PdfStringFormat = new PdfStringFormat();
     * // set the vertical alignment
     * stringFormat.lineAlignment = PdfVerticalAlignment.Middle;
     * //
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    lineAlignment: PdfVerticalAlignment;
    /**
     * Gets or sets the value that indicates text `direction` mode.
     * @private
     */
    rightToLeft: boolean;
    /**
     * Gets or sets value that indicates a `size` among the characters in the text.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a pages to the document
     * let page1 : PdfPage = document.pages.add();
     * // set font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // set brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * //
     * // set the format for string
     * let stringFormat : PdfStringFormat = new PdfStringFormat();
     * // set character spacing
     * stringFormat.characterSpacing = 10;
     * //
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    characterSpacing: number;
    /**
     * Gets or sets value that indicates a `size` among the words in the text.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a pages to the document
     * let page1 : PdfPage = document.pages.add();
     * // set font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // set brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * //
     * // set the format for string
     * let stringFormat : PdfStringFormat = new PdfStringFormat();
     * // set word spacing
     * stringFormat.wordSpacing = 10;
     * //
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    wordSpacing: number;
    /**
     * Gets or sets value that indicates the `vertical distance` between the baselines of adjacent lines of text.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a pages to the document
     * let page1 : PdfPage = document.pages.add();
     * // set font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // set brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * // set string
     * let text : string = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
     * incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitati';
     * // set rectangle bounds
     * let rectangle : RectangleF = new RectangleF({x : 0, y : 0}, {width : 300, height : 100})
     * //
     * // set the format for string
     * let stringFormat : PdfStringFormat = new PdfStringFormat();
     * // set line spacing
     * stringFormat.lineSpacing = 10;
     * //
     * // draw the text
     * page1.graphics.drawString(text, font, blackBrush, rectangle, stringFormat);
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    lineSpacing: number;
    /**
     * Gets or sets a value indicating whether the text is `clipped` or not.
     * @private
     */
    clipPath: boolean;
    /**
     * Gets or sets value indicating whether the text is in `subscript or superscript` mode.
     * @private
     */
    subSuperScript: PdfSubSuperScript;
    /**
     * Gets or sets the `indent` of the first line in the paragraph.
     * @private
     */
    paragraphIndent: number;
    /**
     * Gets or sets a value indicating whether [`line limit`].
     * @private
     */
    lineLimit: boolean;
    /**
     * Gets or sets a value indicating whether [`measure trailing spaces`].
     * @private
     */
    measureTrailingSpaces: boolean;
    /**
     * Gets or sets a value indicating whether [`no clip`].
     * @private
     */
    noClip: boolean;
    /**
     * Gets or sets value indicating type of the text `wrapping`.
     * @private
     */
    wordWrap: PdfWordWrapType;
    /**
     * Gets or sets the `scaling factor`.
     * @private
     */
    horizontalScalingFactor: number;
    /**
     * Gets or sets the `indent` of the first line in the text.
     * @private
     */
    firstLineIndent: number;
    /**
     * `Clones` the object.
     * @private
     */
    clone(): Object;
}
/**
 * PdfStringLayouter.ts class for EJ2-PDF
 */
/**
 * Class `lay outing the text`.
 */
export  class PdfStringLayouter {
    /**
     * `Text` data.
     * @private
     */
    private text;
    /**
     * Pdf `font`.
     * @private
     */
    private font;
    /**
     * String `format`.
     * @private
     */
    private format;
    /**
     * `Size` of the text.
     * @private
     */
    private size;
    /**
     * `Bounds` of the text.
     * @private
     */
    private rectangle;
    /**
     * Pdf page `height`.
     * @private
     */
    private pageHeight;
    /**
     * String `tokenizer`.
     * @private
     */
    private reader;
    /**
     * Specifies if [`isTabReplaced`].
     * @private
     */
    private isTabReplaced;
    /**
     * Count of tab `occurance`.
     * @private
     */
    private tabOccuranceCount;
    /**
     * Checks whether the x co-ordinate is need to set as client size or not.
     * @hidden
     * @private
     */
    private isOverloadWithPosition;
    /**
     * Stores client size of the page if the layout method invoked with `PointF` overload.
     * @hidden
     * @private
     */
    private clientSize;
    /**
     * Initializes a new instance of the `StringLayouter` class.
     * @private
     */
    constructor();
    /**
     * `Layouts` the text.
     * @private
     */
    layout(text: string, font: PdfFont, format: PdfStringFormat, rectangle: RectangleF, pageHeight: number, recalculateBounds: boolean, clientSize: SizeF): PdfStringLayoutResult;
    layout(text: string, font: PdfFont, format: PdfStringFormat, size: SizeF, recalculateBounds: boolean, clientSize: SizeF): PdfStringLayoutResult;
    /**
     * `Initializes` internal data.
     * @private
     */
    private initialize(text, font, format, rectangle, pageHeight);
    private initialize(text, font, format, size);
    /**
     * `Clear` all resources.
     * @private
     */
    private clear();
    /**
     * `Layouts` the text.
     * @private
     */
    private doLayout();
    /**
     * Returns `line indent` for the line.
     * @private
     */
    private getLineIndent(firstLine);
    /**
     * Calculates `height` of the line.
     * @private
     */
    private getLineHeight();
    /**
     * Calculates `width` of the line.
     * @private
     */
    private getLineWidth(line);
    /**
     * `Layouts` line.
     * @private
     */
    private layoutLine(line, lineIndent);
    /**
     * `Adds` line to line result.
     * @private
     */
    private addToLineResult(lineResult, lines, line, lineWidth, breakType);
    /**
     * `Copies` layout result from line result to entire result. Checks whether we can proceed lay outing or not.
     * @private
     */
    private copyToResult(result, lineResult, lines, numInserted);
    /**
     * `Finalizes` final result.
     * @private
     */
    private finalizeResult(result, lines);
    /**
     * `Trims` whitespaces at the line.
     * @private
     */
    private trimLine(info, firstLine);
    /**
     * Returns `wrap` type.
     * @private
     */
    private getWrapType();
}
export  class PdfStringLayoutResult {
    /**
     * Layout `lines`.
     * @private
     */
    layoutLines: LineInfo[];
    /**
     * The `text` wasn`t lay outed.
     * @private
     */
    textRemainder: string;
    /**
     * Actual layout text `bounds`.
     * @private
     */
    size: SizeF;
    /**
     * `Height` of the line.
     * @private
     */
    layoutLineHeight: number;
    /**
     * Gets the `text` which is not lay outed.
     * @private
     */
    readonly remainder: string;
    /**
     * Gets the actual layout text `bounds`.
     * @private
     */
    readonly actualSize: SizeF;
    /**
     * Gets layout `lines` information.
     * @private
     */
    readonly lines: LineInfo[];
    /**
     * Gets the `height` of the line.
     * @private
     */
    readonly lineHeight: number;
    /**
     * Gets value that indicates whether any layout text [`empty`].
     * @private
     */
    readonly empty: boolean;
    /**
     * Gets `number of` the layout lines.
     * @private
     */
    readonly lineCount: number;
}
export  class LineInfo {
    /**
     * Line `text`.
     * @private
     */
    content: string;
    /**
     * `Width` of the text.
     * @private
     */
    lineWidth: number;
    /**
     * `Breaking type` of the line.
     * @private
     */
    type: LineType;
    /**
     * Gets the `type` of the line text.
     * @private
     */
    lineType: LineType;
    /**
     * Gets the line `text`.
     * @private
     */
    text: string;
    /**
     * Gets `width` of the line text.
     * @private
     */
    width: number;
}
/**
* Break type of the `line`.
* @private
*/
export  enum LineType {
    /**
     * Specifies the type of `None`.
     * @private
     */
    None = 0,
    /**
     * Specifies the type of `NewLineBreak`.
     * @private
     */
    NewLineBreak = 1,
    /**
     * Specifies the type of `LayoutBreak`.
     * @private
     */
    LayoutBreak = 2,
    /**
     * Specifies the type of `FirstParagraphLine`.
     * @private
     */
    FirstParagraphLine = 4,
    /**
     * Specifies the type of `LastParagraphLine`.
     * @private
     */
    LastParagraphLine = 8,
}
/**
 * StringTokenizer.ts class for EJ2-PDF
 * Utility class for working with strings.
 * @private
 */
export  class StringTokenizer {
    /**
     * `Whitespace` symbol.
     * @private
     */
    static readonly whiteSpace: string;
    /**
     * `tab` symbol.
     * @private
     */
    static readonly tab: string;
    /**
     * Array of `spaces`.
     * @private
     */
    static readonly spaces: string[];
    /**
     * `Pattern` for WhiteSpace.
     * @private
     */
    private static readonly whiteSpacePattern;
    /**
     * `Text` data.
     * @private
     */
    private text;
    /**
     * Current `position`.
     * @private
     */
    private currentPosition;
    /**
     * Initializes a new instance of the `StringTokenizer` class.
     * @private
     */
    constructor(textValue: string);
    /**
     * Gets text `length`.
     * @private
     */
    readonly length: number;
    /**
     * Gets or sets the position.
     * @private
     */
    position: number;
    /**
     * Returns number of symbols occurred in the text.
     * @private
     */
    static getCharsCount(text: string, symbols: string): number;
    /**
     * Returns number of symbols occurred in the text.
     * @private
     */
    static getCharsCount(text: string, symbols: string[]): number;
    /**
     * Reads line of the text.
     * @private
     */
    readLine(): string;
    /**
     * Reads line of the text.
     * @private
     */
    peekLine(): string;
    /**
     * Reads a word from the text.
     * @private
     */
    readWord(): string;
    /**
     * Peeks a word from the text.
     * @private
     */
    peekWord(): string;
    /**
     * Reads char form the data.
     * @private
     */
    read(): string;
    /**
     * Reads count of the symbols.
     * @private
     */
    read(count: number): string;
    /**
     * Peeks char form the data.
     * @private
     */
    peek(): string;
    /**
     * Closes a reader.
     * @private
     */
    close(): void;
    /**
     * Checks whether array contains a symbol.
     * @private
     */
    private static contains(array, symbol);
}
/**
 * ByteArray class
 * Used to keep information about image stream as byte array.
 * @private
 */
export  class ByteArray {
    /**
     * Current stream `position`.
     * @default 0
     * @private
     */
    private mPosition;
    /**
     * Uint8Array for returing `buffer`.
     * @hidden
     * @private
     */
    private buffer;
    /**
     * Specifies the `data view`.
     * @hidden
     * @private
     */
    private dataView;
    /**
     * Initialize the new instance for `byte-array` class
     * @hidden
     * @private
     */
    constructor(length: number);
    /**
     * Gets and Sets a current `position` of byte array.
     * @hidden
     * @private
     */
    position: number;
    /**
     * `Read` from current stream position.
     * @default 0
     * @hidden
     * @private
     */
    read(buffer: ByteArray, offset: number, count: number): void;
    /**
     * @hidden
     */
    getBuffer(index: number): number;
    /**
     * @hidden
     */
    writeFromBase64String(base64: string): void;
    /**
     * @hidden
     */
    encodedString(input: string): Uint8Array;
    /**
     * @hidden
     */
    readByte(offset: number): number;
    /**
     * @hidden
     */
    readonly internalBuffer: Uint8Array;
    /**
     * @hidden
     */
    readonly count: number;
}
/**
 * ImageDecoder class
 */
/**
 * Specifies the image `format`.
 * @private
 */
export  enum ImageFormat {
    /**
     * Specifies the type of `Unknown`.
     * @hidden
     * @private
     */
    Unknown = 0,
    /**
     * Specifies the type of `Bmp`.
     * @hidden
     * @private
     */
    Bmp = 1,
    /**
     * Specifies the type of `Emf`.
     * @hidden
     * @private
     */
    Emf = 2,
    /**
     * Specifies the type of `Gif`.
     * @hidden
     * @private
     */
    Gif = 3,
    /**
     * Specifies the type of `Jpeg`.
     * @hidden
     * @private
     */
    Jpeg = 4,
    /**
     * Specifies the type of `Png`.
     * @hidden
     * @private
     */
    Png = 5,
    /**
     * Specifies the type of `Wmf`.
     * @hidden
     * @private
     */
    Wmf = 6,
    /**
     * Specifies the type of `Icon`.
     * @hidden
     * @private
     */
    Icon = 7,
}
/**
 * `Decode the image stream`.
 * @private
 */
export  class ImageDecoder {
    /**
     * Number array for `png header`.
     * @hidden
     * @private
     */
    private static mPngHeader;
    /**
     * Number Array for `jpeg header`.
     * @hidden
     * @private
     */
    private static mJpegHeader;
    /**
     * Number array for `gif header`.
     * @hidden
     * @private
     */
    private static GIF_HEADER;
    /**
     * Number array for `bmp header.`
     * @hidden
     * @private
     */
    private static BMP_HEADER;
    /**
     * `memory stream` to store image data.
     * @hidden
     * @private
     */
    private mStream;
    /**
     * Specifies `format` of image.
     * @hidden
     * @private
     */
    private mFormat;
    /**
     * `Height` of image.
     * @hidden
     * @private
     */
    private mHeight;
    /**
     * `Width` of image.
     * @hidden
     * @private
     */
    private mWidth;
    /**
     * `Bits per component`.
     * @default 8
     * @hidden
     * @private
     */
    private mbitsPerComponent;
    /**
     * ByteArray to store `image data`.
     * @hidden
     * @private
     */
    private mImageData;
    /**
     * Store an instance of `PdfStream` for an image.
     * @hidden
     * @private
     */
    private imageStream;
    /**
     * Internal variable for accessing fields from `DictionryProperties` class.
     * @hidden
     * @private
     */
    private dictionaryProperties;
    /**
     * Initialize the new instance for `image-decoder` class.
     * @private
     */
    constructor(stream: ByteArray);
    /**
     * Gets the `height` of image.
     * @hidden
     * @private
     */
    readonly height: number;
    /**
     * Gets the `width` of image.
     * @hidden
     * @private
     */
    readonly width: number;
    /**
     * Gets `bits per component`.
     * @hidden
     * @private
     */
    readonly bitsPerComponent: number;
    /**
     * Gets the `size` of an image data.
     * @hidden
     * @private
     */
    readonly size: number;
    /**
     * Gets the value of an `image data`.
     * @hidden
     * @private
     */
    readonly imageData: ByteArray;
    /**
     * Gets the value of an `image data as number array`.
     * @hidden
     * @private
     */
    readonly imageDataAsNumberArray: ArrayBuffer;
    /**
     * `Initialize` image data and image stream.
     * @hidden
     * @private
     */
    private initialize();
    /**
     * `Reset` stream position into 0.
     * @hidden
     * @private
     */
    private reset();
    /**
     * `Parse` Jpeg image.
     * @hidden
     * @private
     */
    private parseJpegImage();
    /**
     * Gets the image `format`.
     * @private
     * @hidden
     */
    readonly format: ImageFormat;
    /**
     * `Checks if JPG`.
     * @private
     * @hidden
     */
    private checkIfJpeg();
    /**
     * Return image `dictionary`.
     * @hidden
     * @private
     */
    getImageDictionary(): PdfStream;
    /**
     * Return `colorSpace` of an image.
     * @hidden
     * @private
     */
    private getColorSpace();
    /**
     * Return `decode parameters` of an image.
     * @hidden
     * @private
     */
    private getDecodeParams();
}
/**
 * Images classes
 * @hidden
 */
/**
 * PdfBitmap.ts class for EJ2-PDF
 */
/**
 * The 'PdfBitmap' contains methods and properties to handle the Bitmap images.
 * ```typescript
 * // create a new PDF document.
 * let document : PdfDocument = new PdfDocument();
 * // add a page to the document.
 * let page1 : PdfPage = document.pages.add();
 * // base64 string of an image
 * let imageString : string = '/9j/3+2w7em7HzY/KiijFw … 1OEYRUYrQ45yc5OUtz/9k=';
 * // load the image from the base64 string of original image.
 * let image : PdfBitmap = new PdfBitmap(imageString);
 * // draw the image
 * page1.graphics.drawImage(image, new RectangleF({x : 10, y : 10}, {width : 200, height : 200}));
 * // save the document.
 * document.save('output.pdf');
 * // destroy the document
 * document.destroy();
 * ```
 */
export  class PdfBitmap extends PdfImage {
    /**
     * Specifies the `status` of an image.
     * @default true.
     * @hidden
     * @private
     */
    private imageStatus;
    /**
     * Internal variable for accessing fields from `DictionryProperties` class.
     * @hidden
     * @private
     */
    private dictionaryProperties;
    /**
     * `Type` of an image.
     * @hidden
     * @private
     */
    checkImageType: number;
    /**
     * Object to store `decoder` of an image.
     * @hidden
     * @private
     */
    decoder: ImageDecoder;
    /**
     * `Load image`.
     * @hidden
     * @private
     */
    private loadImage(encodedString);
    /**
     * Create an instance for `PdfBitmap` class.
     * @param encodedString Base64 string of an image.
     * ```typescript
     * // create a new PDF document.
     * let document : PdfDocument = new PdfDocument();
     * // add a page to the document.
     * let page1 : PdfPage = document.pages.add();
     * // base64 string of an image
     * let imageString : string = '/9j/3+2w7em7HzY/KiijFw … 1OEYRUYrQ45yc5OUtz/9k=';
     * //
     * // load the image from the base64 string of original image.
     * let image : PdfBitmap = new PdfBitmap(imageString);
     * //
     * // draw the image
     * page1.graphics.drawImage(image, new RectangleF({x : 10, y : 10}, {width : 200, height : 200}));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    constructor(encodedString: string);
    /**
     * `Initialize` image parameters.
     * @private
     */
    initializeAsync(encodedString: string): void;
    /**
     * `Saves` the image into stream.
     * @private
     */
    save(): void;
}
/**
 * PdfImage.ts class for EJ2-PDF
 */
/**
 * `PdfImage` class represents the base class for images and provides functionality for the 'PdfBitmap' class.
 * @private
 */
export  abstract class PdfImage implements IPdfWrapper {
    /**
     * `Width` of an image.
     * @private
     */
    private imageWidth;
    /**
     * `Height` of an image.
     * @private
     */
    private imageHeight;
    /**
     * `Bits per component` of an image.
     * @hidden
     * @private
     */
    bitsPerComponent: number;
    /**
     * `horizontal resolution` of an image.
     * @hidden
     * @private
     */
    horizontalResolution: number;
    /**
     * `Vertical resolution` of an image.
     * @hidden
     * @private
     */
    verticalResolution: number;
    /**
     * `physical dimension` of an image.
     * @hidden
     * @private
     */
    private imagePhysicalDimension;
    /**
     * Gets and Sets the `width` of an image.
     * @private
     */
    width: number;
    /**
     * Gets and Sets the `height` of an image.
     * @private
     */
    height: number;
    /**
     * Gets or sets the size of the image.
     * @private
     */
    size: SizeF;
    /**
     * Gets the `physical dimension` of an image.
     * @private
     */
    readonly physicalDimension: SizeF;
    /**
     * return the stored `stream of an image`.
     * @private
     */
    imageStream: PdfStream;
    /**
     * Gets the `element` image stream.
     * @private
     */
    readonly element: IPdfPrimitive;
    /**
     * `Save` the image stream.
     * @private
     */
    abstract save(): void;
    /**
     * Return the value of `width and height of an image` in points.
     * @private
     */
    getPointSize(width: number, height: number): SizeF;
    getPointSize(width: number, height: number, horizontalResolution: number, verticalResolution: number): SizeF;
}
/**
 * Graphics classes
 * @hidden
 */
/**
 * Implements structures and routines working with `color`.
 * ```typescript
 * // create a new PDF document
 * let document : PdfDocument = new PdfDocument();
 * // add a new page to the document
 * let page1 : PdfPage = document.pages.add();
 * // set the font
 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
 * //
 * // set color
 * let brushColor : PdfColor = new PdfColor(0, 0, 0);
 * //
 * // create black brush
 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(brushColor);
 * // draw the text
 * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
 * // save the document
 * document.save('output.pdf');
 * // destroy the document
 * document.destroy();
 * ```
 * @default black color
 */
export  class PdfColor {
    /**
     * Holds `RGB colors` converted into strings.
     * @private
     */
    private static rgbStrings;
    /**
     * Holds Gray scale colors converted into strings for `stroking`.
     * @private
     */
    private static grayStringsSroke;
    /**
     * Holds Gray scale colors converted into strings for `filling`.
     * @private
     */
    private static grayStringsFill;
    /**
     * Value of `Red` channel.
     * @private
     */
    private redColor;
    /**
     * Value of `Cyan` channel.
     * @private
     */
    private cyanColor;
    /**
     * Value of `Green` channel.
     * @private
     */
    private greenColor;
    /**
     * Value of `Magenta` channel.
     * @private
     */
    private magentaColor;
    /**
     * Value of `Blue` channel.
     * @private
     */
    private blueColor;
    /**
     * Value of `Yellow` channel.
     * @private
     */
    private yellowColor;
    /**
     * Value of `Black` channel.
     * @private
     */
    private blackColor;
    /**
     * Value of `Gray` channel.
     * @private
     */
    private grayColor;
    /**
     * `Alpha` channel.
     * @private
     */
    private alpha;
    /**
     * Shows if the color `is empty`.
     * @private
     */
    private filled;
    /**
     * `Max value` of color channel.
     * @private
     */
    static readonly maxColourChannelValue: number;
    /**
     * Initialize a new instance for `PdfColor` class.
     */
    constructor();
    constructor(color1: PdfColor);
    constructor(color1: number, color2: number, color3: number);
    constructor(color1: number, color2: number, color3: number, color4: number);
    /**
     * `Calculate and assign` cyan, megenta, yellow colors from rgb values..
     * @private
     */
    private assignCMYK(r, g, b);
    /**
     * Gets or sets `Red` channel value.
     * @private
     */
    r: number;
    /**
     * Gets the `Red` color
     * @private
     */
    readonly red: number;
    /**
     * Gets or sets `Blue` channel value.
     * @private
     */
    b: number;
    /**
     * Gets the `blue` color.
     * @private
     */
    readonly blue: number;
    /**
     *  Gets or sets `Green` channel value.
     * @private
     */
    g: number;
    /**
     * Gets the `Green` color.
     * @private
     */
    readonly green: number;
    /**
     * Gets or sets `Gray` channel value.
     * @private
     */
    gray: number;
    /**
     * Gets whether the PDFColor `is Empty` or not.
     * @private
     */
    readonly isEmpty: boolean;
    /**
     * Gets or sets `Alpha` channel value.
     * @private
     */
    a: number;
    /**
     * Converts `PDFColor to PDF string` representation.
     * @private
     */
    toString(colorSpace: PdfColorSpace, stroke: boolean): string;
    /**
     * Sets `RGB` color.
     * @private
     */
    private rgbToString(ifStroking);
    /**
     * Converts `colour to a PDF array`.
     * @private
     */
    toArray(colorSpace: PdfColorSpace): PdfArray;
}
/**
 * PdfGraphics.ts class for EJ2-PDF
 */
/**
 * `PdfGraphics` class represents a graphics context of the objects.
 * It's used for performing all the graphics operations.
 * ```typescript
 * // create a new PDF document
 * let document : PdfDocument = new PdfDocument();
 * // add a new page to the document
 * let page1 : PdfPage = document.pages.add();
 * // set the font
 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
 * // create black brush
 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
 * //
 * //graphics of the page
 * let page1Graphics : PdfGraphics = page1.graphics;
 * // draw the text on the page1 graphics
 * page1Graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
 * //
 * // save the document
 * document.save('output.pdf');
 * // destroy the document
 * document.destroy();
 * ```
 */
export  class PdfGraphics {
    /**
     * Specifies the mask of `path type values`.
     * @private
     */
    private static readonly pathTypesValuesMask;
    /**
     * Represents the `Stream writer` object.
     * @private
     */
    private pdfStreamWriter;
    /**
     * Represents the state, whether it `is saved or not`.
     * @private
     */
    private bStateSaved;
    /**
     * Represents the `Current pen`.
     * @private
     */
    private currentPen;
    /**
     * Represents the `Current brush`.
     * @private
     */
    private currentBrush;
    /**
     * Represents the `Current font`.
     * @private
     */
    private currentFont;
    /**
     * Represents the `Current font`.
     * @private
     */
    currentPage: PdfPage;
    /**
     * Represents the `Current color space`.
     * @private
     */
    private currentColorSpace;
    /**
     * The `transformation matrix` monitoring all changes with CTM.
     * @private
     */
    private transformationMatrix;
    /**
     * Stores `previous rendering mode`.
     * @private
     */
    private previousTextRenderingMode;
    /**
     * Previous `character spacing` value or 0.
     * @private
     */
    private previousCharacterSpacing;
    /**
     * Previous `word spacing` value or 0.
     * @private
     */
    private previousWordSpacing;
    /**
     * The `previously used text scaling` value.
     * @private
     */
    private previousTextScaling;
    /**
     * Event handler object to store instance of `PdfResources` class.
     * @private
     */
    private getResources;
    /**
     * Indicates whether `color space was initialized`.
     * @private
     */
    private bCSInitialized;
    /**
     * Represents the `Size of the canvas`.
     * @private
     */
    private canvasSize;
    /**
     * Represents the size of the canvas reduced by `margins and templates`.
     * @private
     */
    clipBounds: RectangleF;
    /**
     * Current `string format`.
     * @private
     */
    private currentStringFormat;
    /**
     * Instance of `ProcedureSets` class.
     * @private
     */
    private procedureSets;
    /**
     * To check wihether it is a `direct text rendering`.
     * @default true
     * @private
     */
    private isNormalRender;
    /**
     * check whether to `use font size` to calculate the shift.
     * @default false
     * @private
     */
    private isUseFontSize;
    /**
     * check whether the font is in `italic type`.
     * @default false
     * @private
     */
    private isItalic;
    /**
     * Check whether it is an `emf Text Matrix`.
     * @default false
     * @private
     */
    isEmfTextScaled: boolean;
    /**
     * Check whether it is an `emf` call.
     * @default false
     * @private
     */
    isEmf: boolean;
    /**
     * Check whether it is an `emf plus` call.
     * @default false
     * @private
     */
    isEmfPlus: boolean;
    /**
     * Check whether it is in `base line format`.
     * @default true
     * @private
     */
    isBaselineFormat: boolean;
    /**
     * Emf Text `Scaling Factor`.
     * @private
     */
    emfScalingFactor: SizeF;
    /**
     * Internal variable to store `layout result` after drawing string.
     * @private
     */
    private pdfStringLayoutResult;
    /**
     * Internal variable to store `layer` on which this graphics lays.
     * @private
     */
    private pageLayer;
    /**
     * To check whether the `last color space` of document and garphics is saved.
     * @private
     */
    private colorSpaceChanged;
    /**
     * Media box upper right `bound`.
     * @hidden
     * @private
     */
    private internalMediaBoxUpperRightBound;
    /**
     * Holds instance of PdfArray as `cropBox`.
     * @private
     */
    cropBox: PdfArray;
    /**
     * Checks whether the object is `transparencyObject`.
     * @hidden
     * @private
     */
    private static transparencyObject;
    /**
     * Stores an instance of `DictionaryProperties`.
     * @private
     */
    private dictionaryProperties;
    /**
     * `last document colorspace`.
     * @hidden
     * @private
     */
    private lastDocumentCS;
    /**
     * `last graphics's colorspace`.
     * @hidden
     * @private
     */
    private lastGraphicsCS;
    /**
     * Checks whether the x co-ordinate is need to set as client size or not.
     * @hidden
     * @private
     */
    private isOverloadWithPosition;
    /**
     * Checks whether the x co-ordinate is need to set as client size or not.
     * @hidden
     * @private
     */
    private isPointOverload;
    /**
     * Current colorspaces.
     * @hidden
     * @private
     */
    private currentColorSpaces;
    /**
     * Checks the current image `is optimized` or not.
     * @default false.
     * @private
     */
    isImageOptimized: boolean;
    /**
     * Returns the `current graphics state`.
     * @private
     */
    private gState;
    /**
     * Stores the `graphics states`.
     * @private
     */
    private graphicsState;
    /**
     * Stores the `trasparencies`.
     * @private
     */
    private trasparencies;
    /**
     * Indicates whether the object `had trasparency`.
     * @default false
     * @private
     */
    private istransparencySet;
    /**
     * Stores the instance of `PdfAutomaticFieldInfoCollection` class .
     * @default null
     * @private
     */
    private internalAutomaticFields;
    /**
     * Stores shift value for draw string with `PointF` overload.
     * @private
     * @hidden
     */
    private shift;
    /**
     * Stores the index of the start line that should draw with in the next page.
     * @private
     */
    private startCutIndex;
    /**
     * Returns the `result` after drawing string.
     * @private
     */
    readonly stringLayoutResult: PdfStringLayoutResult;
    /**
     * Gets the `size` of the canvas.
     * @private
     */
    readonly size: SizeF;
    /**
     * Gets and Sets the value of `MediaBox upper right bound`.
     * @private
     */
    mediaBoxUpperRightBound: number;
    /**
     * Gets the `size` of the canvas reduced by margins and page templates.
     * @private
     */
    readonly clientSize: SizeF;
    /**
     * Gets or sets the current `color space` of the document
     * @private
     */
    colorSpace: PdfColorSpace;
    /**
     * Gets the `stream writer`.
     * @private
     */
    readonly streamWriter: PdfStreamWriter;
    /**
     * Gets the `transformation matrix` reflecting current transformation.
     * @private
     */
    readonly matrix: PdfTransformationMatrix;
    /**
     * Gets the `layer` for the graphics, if exists.
     * @private
     */
    readonly layer: PdfPageLayer;
    /**
     * Gets the `page` for this graphics, if exists.
     * @private
     */
    readonly page: PdfPageBase;
    readonly automaticFields: PdfAutomaticFieldInfoCollection;
    /**
     * Initializes a new instance of the `PdfGraphics` class.
     * @private
     */
    constructor(size: SizeF, resources: GetResourceEventHandler, writer: PdfStreamWriter);
    /**
     * Initializes a new instance of the `PdfGraphics` class.
     * @private
     */
    constructor(size: SizeF, resources: GetResourceEventHandler, stream: PdfStream);
    /**
     * `Initializes` this instance.
     * @private
     */
    initialize(): void;
    /**
     * `Draw the template`.
     * @private
     */
    drawPdfTemplate(template: PdfTemplate, location: PointF): void;
    drawPdfTemplate(template: PdfTemplate, location: PointF, size: SizeF): void;
    /**
     * `Draws the specified text` at the specified location and size with string format.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a pages to the document
     * let page1 : PdfPage = document.pages.add();
     * // set font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // set pen
     * let pen : PdfPen = new PdfPen(new PdfColor(255, 0, 0));
     * // set brush
     * let brush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * // set rectangle bounds
     * let rectangle : RectangleF = new RectangleF({x : 10, y : 10}, {width : 200, height : 200});
     * // set the format for string
     * let stringFormat : PdfStringFormat = new PdfStringFormat();
     * // set the text alignment
     * stringFormat.alignment = PdfTextAlignment.Center;
     * // set the vertical alignment
     * stringFormat.lineAlignment = PdfVerticalAlignment.Middle;
     * //
     * // draw the text
     * page1.graphics.drawString('Hello World', font, pen, brush, rectangle, stringFormat);
     * //
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param s Input text.
     * @param font Font of the text.
     * @param pen Color of the text.
     * @param brush Color of the text.
     * @param layoutRectangle RectangleF structure that specifies the bounds of the drawn text.
     * @param format String formatting information.
     */
    drawString(s: string, font: PdfFont, pen: PdfPen, brush: PdfBrush, x: number, y: number, format: PdfStringFormat): void;
    drawString(s: string, font: PdfFont, pen: PdfPen, brush: PdfBrush, x: number, y: number, width: number, height: number, format: PdfStringFormat): void;
    /**
     * `Draws a line` connecting the two points specified by the coordinate pairs.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * //
     * // draw the line
     * page1.graphics.drawLine(new PdfPen(new PdfColor(0, 0, 255)), new PointF(10, 20), new PointF(100, 200));
     * //
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param pen Color of the line.
     * @param point1 PointF structure that represents the first point to connect.
     * @param point2 PointF structure that represents the second point to connect.
     */
    drawLine(pen: PdfPen, point1: PointF, point2: PointF): void;
    /**
     * `Draws a line` connecting the two points specified by the coordinate pairs.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * //
     * // draw the line
     * page1.graphics.drawLine(new PdfPen(new PdfColor(0, 0, 255)), 10, 20, 100, 200);
     * //
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param pen Color of the line.
     * @param x1 The x-coordinate of the first point.
     * @param y1 The y-coordinate of the first point.
     * @param x2 The x-coordinate of the second point.
     * @param y2 The y-coordinate of the second point.
     */
    drawLine(pen: PdfPen, x1: number, y1: number, x2: number, y2: number): void;
    /**
     * `Draws a rectangle` specified by a pen, a coordinate pair, a width, and a height.
     * ```typescript
     * // create a new PDF document.
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * // create pen for draw rectangle
     * let pen : PdfPen = new PdfPen(new PdfColor(238, 130, 238));
     * //
     * // draw rectangle
     * page1.graphics.drawRectangle(pen, 10, 10, 50, 100);
     * //
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param pen Color of the rectangle.
     * @param x The x-coordinate of the upper-left corner of the rectangle to draw.
     * @param y The y-coordinate of the upper-left corner of the rectangle to draw.
     * @param width Width of the rectangle to draw.
     * @param height Height of the rectangle to draw.
     */
    drawRectangle(pen: PdfPen, x: number, y: number, width: number, height: number): void;
    /**
     * `Draws a rectangle` specified by a brush, coordinate pair, a width, and a height.
     * ```typescript
     * // create a new PDF document.
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * // create brush for draw rectangle
     * let brush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(238, 130, 238));
     * //
     * // draw rectangle
     * page1.graphics.drawRectangle(brush, 10, 10, 50, 100);
     * //
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param brush Color of the rectangle.
     * @param x The x-coordinate of the upper-left corner of the rectangle to draw.
     * @param y The y-coordinate of the upper-left corner of the rectangle to draw.
     * @param width Width of the rectangle to draw.
     * @param height Height of the rectangle to draw.
     */
    drawRectangle(brush: PdfBrush, x: number, y: number, width: number, height: number): void;
    /**
     * `Draws a rectangle` specified by a pen, a coordinate pair, a width, and a height.
     * ```typescript
     * // create a new PDF document.
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * // create brush for draw rectangle
     * let brush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(238, 130, 238));
     * // set pen
     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
     * //
     * // draw rectangle
     * page1.graphics.drawRectangle(pen, brush, 10, 10, 50, 100);
     * //
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param pen A Pen that determines the color, width, and style of the rectangle.
     * @param brush Color of the rectangle.
     * @param x The x-coordinate of the upper-left corner of the rectangle to draw.
     * @param y The y-coordinate of the upper-left corner of the rectangle to draw.
     * @param width Width of the rectangle to draw.
     * @param height Height of the rectangle to draw.
     */
    drawRectangle(pen: PdfPen, brush: PdfBrush, x: number, y: number, width: number, height: number): void;
    /**
     * `Draws the path`.
     * @private
     */
    private drawPath(pen, brush, needClosing);
    /**
     * `Draws the path`.
     * @private
     */
    private drawPath(pen, brush, fillMode, needClosing);
    /**
     * `Draws the specified image`, using its original physical size, at the location specified by a coordinate pair.
     * ```typescript
     * // create a new PDF document.
     * let document : PdfDocument = new PdfDocument();
     * // add a page to the document.
     * let page1 : PdfPage = document.pages.add();
     * // base64 string of an image
     * let imageString : string = '/9j/3+2w7em7HzY/KiijFw … 1OEYRUYrQ45yc5OUtz/9k=';
     * // load the image from the base64 string of original image.
     * let image : PdfBitmap = new PdfBitmap(imageString);
     * //
     * // draw the image
     * page1.graphics.drawImage(image, 10, 10);
     * //
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param image PdfImage to draw.
     * @param x The x-coordinate of the upper-left corner of the drawn image.
     * @param y The y-coordinate of the upper-left corner of the drawn image.
     */
    drawImage(image: PdfImage, x: number, y: number): void;
    /**
     * `Draws the specified image`, using its original physical size, at the location specified by a coordinate pair.
     * ```typescript
     * // create a new PDF document.
     * let document : PdfDocument = new PdfDocument();
     * // add a page to the document.
     * let page1 : PdfPage = document.pages.add();
     * // base64 string of an image
     * let imageString : string = '/9j/3+2w7em7HzY/KiijFw … 1OEYRUYrQ45yc5OUtz/9k=';
     * // load the image from the base64 string of original image.
     * let image : PdfBitmap = new PdfBitmap(imageString);
     * //
     * // draw the image
     * page1.graphics.drawImage(image, 0, 0, 100, 100);
     * //
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param image PdfImage to draw.
     * @param x The x-coordinate of the upper-left corner of the drawn image.
     * @param y The y-coordinate of the upper-left corner of the drawn image.
     * @param width Width of the drawn image.
     * @param height Height of the drawn image.
     */
    drawImage(image: PdfImage, x: number, y: number, width: number, height: number): void;
    /**
     * Returns `bounds` of the line info.
     * @private
     */
    getLineBounds(lineIndex: number, result: PdfStringLayoutResult, font: PdfFont, layoutRectangle: RectangleF, format: PdfStringFormat): RectangleF;
    /**
     * Creates `lay outed rectangle` depending on the text settings.
     * @private
     */
    checkCorrectLayoutRectangle(textSize: SizeF, x: number, y: number, format: PdfStringFormat): RectangleF;
    /**
     * Sets the `layer` for the graphics.
     * @private
     */
    setLayer(layer: PdfPageLayer): void;
    /**
     * Adding page number field before page saving.
     * @private
     */
    pageSave(page: PdfPage): void;
    /**
     * `Draws a layout result`.
     * @private
     */
    drawStringLayoutResult(result: PdfStringLayoutResult, font: PdfFont, pen: PdfPen, brush: PdfBrush, layoutRectangle: RectangleF, format: PdfStringFormat): void;
    /**
     * Gets the `next page`.
     * @private
     */
    getNextPage(): PdfPage;
    /**
     * `Sets the clipping` region of this Graphics to the rectangle specified by a RectangleF structure.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * // create PDF graphics for the page
     * let graphics : PdfGraphics = page1.graphics;
     * // set the font
     * let font : PdfFont = new PdfStandardFont(PdfFontFamily.TimesRoman, 20);
     * // create black brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * //
     * // set clipping with rectangle bounds
     * graphics.setClip(new RectangleF({x : 10, y : 80}, {width : 150 , height : 15}));
     * //
     * // draw the text after clipping
     * graphics.drawString('Text after clipping', font, blackBrush, new PointF(10, 80));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param rectangle RectangleF structure that represents the new clip region.
     */
    setClip(rectangle: RectangleF): void;
    /**
     * `Sets the clipping` region of this Graphics to the result of the specified operation combining the current clip region and the rectangle specified by a RectangleF structure.
     * @private
     */
    setClip(rectangle: RectangleF, mode: PdfFillMode): void;
    /**
     * Applies all the `text settings`.
     * @private
     */
    private applyStringSettings(font, pen, brush, format, bounds);
    /**
     * Calculates `shift value` if the text is vertically aligned.
     * @private
     */
    getTextVerticalAlignShift(textHeight: number, boundsHeight: number, format: PdfStringFormat): number;
    /**
     * `Draws layout result`.
     * @private
     */
    private drawLayoutResult(result, font, format, layoutRectangle);
    /**
     * `Draws Ascii line`.
     * @private
     */
    private drawAsciiLine(lineInfo, layoutRectangle, font, format);
    /**
     * `Justifies` the line if needed.
     * @private
     */
    private justifyLine(lineInfo, boundsWidth, format);
    /**
     * `Reset` or reinitialize the current graphic value.
     * @private
     */
    reset(size: SizeF): void;
    /**
     * Checks whether the line should be `justified`.
     * @private
     */
    private shouldJustify(lineInfo, boundsWidth, format);
    /**
     * Emulates `Underline, Strikeout` of the text if needed.
     * @private
     */
    private underlineStrikeoutText(pen, brush, result, font, layoutRectangle, format);
    /**
     * `Creates a pen` for drawing lines in the text.
     * @private
     */
    private createUnderlineStikeoutPen(pen, brush, font, format);
    /**
     * Return `text rendering mode`.
     * @private
     */
    private getTextRenderingMode(pen, brush, format);
    /**
     * Returns `line indent` for the line.
     * @private
     */
    private getLineIndent(lineInfo, format, layoutBounds, firstLine);
    /**
     * Calculates shift value if the line is `horizontaly aligned`.
     * @private
     */
    private getHorizontalAlignShift(lineWidth, boundsWidth, format);
    /**
     * Gets or sets the value that indicates `text direction` mode.
     * @private
     */
    private rightToLeft(format);
    /**
     * Controls all `state modifications` and react repectively.
     * @private
     */
    private stateControl(pen, brush, font);
    /**
     * Controls all `state modifications` and react respectively.
     * @private
     */
    private stateControl(pen, brush, font, format);
    /**
     * Initializes the `current color space`.
     * @private
     */
    private initCurrentColorSpace(colorspace);
    /**
     * Controls the `pen state`.
     * @private
     */
    private penControl(pen, saveState);
    /**
     * Controls the `brush state`.
     * @private
     */
    private brushControl(brush, saveState);
    /**
     * Saves the font and other `font settings`.
     * @private
     */
    private fontControl(font, format, saveState);
    /**
     * `Sets the transparency` of this Graphics with the specified value for pen.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * // create pen
     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
     * //
     * // set transparency
     * page1.graphics.setTransparency(0.5);
     * //
     * // draw the rectangle after applying transparency
     * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param alpha The alpha value for both pen and brush.
     */
    setTransparency(alpha: number): void;
    /**
     * `Sets the transparency` of this Graphics with the specified value for pen and brush.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * // create pen
     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
     * // set brush
     * let brush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * //
     * // set transparency
     * page1.graphics.setTransparency(0.8, 0.2);
     * //
     * // draw the rectangle after applying transparency
     * page1.graphics.drawRectangle(pen, brush, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param alphaPen The alpha value for pen.
     * @param alphaBrush The alpha value for brush.
     */
    setTransparency(alphaPen: number, alphaBrush: number): void;
    /**
     * `Sets the transparency` of this Graphics with the specified PdfBlendMode.
     * @private
     */
    setTransparency(alphaPen: number, alphaBrush: number, blendMode: PdfBlendMode): void;
    /**
     * Sets the `drawing area and translates origin`.
     * @private
     */
    clipTranslateMargins(clipBounds: RectangleF): void;
    clipTranslateMargins(x: number, y: number, left: number, top: number, right: number, bottom: number): void;
    /**
     * `Updates y` co-ordinate.
     * @private
     */
    updateY(y: number): number;
    /**
     * Used to `translate the transformation`.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * // set pen
     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
     * //
     * // set translate transform
     * page1.graphics.translateTransform(100, 100);
     * //
     * // draw the rectangle after applying translate transform
     * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param offsetX The x-coordinate of the translation.
     * @param offsetY The y-coordinate of the translation.
     */
    translateTransform(offsetX: number, offsetY: number): void;
    /**
     * `Translates` coordinates of the input matrix.
     * @private
     */
    private getTranslateTransform(x, y, input);
    /**
     * Applies the specified `scaling operation` to the transformation matrix of this Graphics by prepending it to the object's transformation matrix.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * // create pen
     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
     * //
     * // apply scaling trasformation
     * page1.graphics.scaleTransform(1.5, 2);
     * //
     * // draw the rectangle after applying scaling transform
     * page1.graphics.drawRectangle(pen, new RectangleF({x : 100, y : 100}, {width : 100, height : 50}));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param scaleX Scale factor in the x direction.
     * @param scaleY Scale factor in the y direction.
     */
    scaleTransform(scaleX: number, scaleY: number): void;
    /**
     * `Scales` coordinates of the input matrix.
     * @private
     */
    private getScaleTransform(x, y, input);
    /**
     * Applies the specified `rotation` to the transformation matrix of this Graphics.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * // create pen
     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
     * //
     * // set RotateTransform with 25 degree of angle
     * page1.graphics.rotateTransform(25);
     * //
     * // draw the rectangle after RotateTransformation
     * page1.graphics.drawRectangle(pen, new RectangleF({x : 100, y : 100}, {width : 100, height : 50}));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param angle Angle of rotation in degrees.
     */
    rotateTransform(angle: number): void;
    /**
     * `Initializes coordinate system`.
     * @private
     */
    initializeCoordinates(): void;
    /**
     * `Rotates` coordinates of the input matrix.
     * @private
     */
    private getRotateTransform(angle, input);
    /**
     * `Saves` the current state of this Graphics and identifies the saved state with a GraphicsState.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * // create pen
     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
     * //
     * // save the graphics state
     * let state1 : PdfGraphicsState = page1.graphics.save();
     * //
     * page1.graphics.scaleTransform(1.5, 2);
     * // draw the rectangle
     * page1.graphics.drawRectangle(pen, new RectangleF({x : 100, y : 100}, {width : 100, height : 50}));
     * // restore the graphics state
     * page1.graphics.restore(state1);
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    save(): PdfGraphicsState;
    /**
     * `Restores the state` of this Graphics to the state represented by a GraphicsState.
     * @private
     */
    restore(): void;
    /**
     * `Restores the state` of this Graphics to the state represented by a GraphicsState.
     * @private
     */
    restore(state: PdfGraphicsState): void;
    /**
     * `Restores graphics state`.
     * @private
     */
    private doRestoreState();
}
/**
 * `GetResourceEventHandler` class is alternate for event handlers and delegates.
 * @private
 * @hidden
 */
export  class GetResourceEventHandler {
    /**
     * Return the instance of `PdfResources` class.
     * @private
     */
    getResources(): PdfResources;
    /**
     * Variable to store instance of `PdfPageBase as sender`.
     * @hidden
     * @private
     */
    sender: PdfPageBase | PdfTemplate;
    /**
     * Initialize instance of `GetResourceEventHandler` class.
     * Alternate for event handlers and delegates.
     * @private
     */
    constructor(sender: PdfPageBase | PdfTemplate);
}
export  class PdfGraphicsState {
    /**
     * `Parent graphics` object.
     * @private
     */
    private pdfGraphics;
    /**
     * The current `transformation matrix`.
     * @private
     */
    private transformationMatrix;
    /**
     * Stores `previous rendering mode`.
     * @default TextRenderingMode.Fill
     * @private
     */
    private internalTextRenderingMode;
    /**
     * `Previous character spacing` value or 0.
     * @default 0.0
     * @private
     */
    private internalCharacterSpacing;
    /**
     * `Previous word spacing` value or 0.
     * @default 0.0
     * @private
     */
    private internalWordSpacing;
    /**
     * The previously used `text scaling value`.
     * @default 100.0
     * @private
     */
    private internalTextScaling;
    /**
     * `Current pen`.
     * @private
     */
    private pdfPen;
    /**
     * `Current brush`.
     * @private
     */
    private pdfBrush;
    /**
     * `Current font`.
     * @private
     */
    private pdfFont;
    /**
     * `Current color space`.
     * @default PdfColorSpace.Rgb
     * @private
     */
    private pdfColorSpace;
    /**
     * Gets the parent `graphics object`.
     * @private
     */
    readonly graphics: PdfGraphics;
    /**
     * Gets the `current matrix`.
     * @private
     */
    readonly matrix: PdfTransformationMatrix;
    /**
     * Gets or sets the `current character spacing`.
     * @private
     */
    characterSpacing: number;
    /**
     * Gets or sets the `word spacing` value.
     * @private
     */
    wordSpacing: number;
    /**
     * Gets or sets the `text scaling` value.
     * @private
     */
    textScaling: number;
    /**
     * Gets or sets the `current pen` object.
     * @private
     */
    pen: PdfPen;
    /**
     * Gets or sets the `brush`.
     * @private
     */
    brush: PdfBrush;
    /**
     * Gets or sets the `current font` object.
     * @private
     */
    font: PdfFont;
    /**
     * Gets or sets the `current color space` value.
     * @private
     */
    colorSpace: PdfColorSpace;
    /**
     * Gets or sets the `text rendering mode`.
     * @private
     */
    textRenderingMode: TextRenderingMode;
    /**
     * `default constructor`.
     * @private
     */
    constructor();
    /**
     * Creates new object for `PdfGraphicsState`.
     * @private
     */
    constructor(graphics: PdfGraphics, matrix: PdfTransformationMatrix);
}
/**
 * PdfMargins.ts class for EJ2-PDF
 * A class representing PDF page margins.
 */
export  class PdfMargins {
    /**
     * Represents the `Left margin` value.
     * @private
     */
    private leftMargin;
    /**
     * Represents the `Top margin` value.
     * @private
     */
    private topMargin;
    /**
     * Represents the `Right margin` value.
     * @private
     */
    private rightMargin;
    /**
     * Represents the `Bottom margin` value.
     * @private
     */
    private bottomMargin;
    /**
     * Represents the `Default Page Margin` value.
     * @default 0.0
     * @private
     */
    private readonly pdfMargin;
    /**
     * Initializes a new instance of the `PdfMargins` class.
     * @private
     */
    constructor();
    /**
     * Gets or sets the `left margin` size.
     * @private
     */
    left: number;
    /**
     * Gets or sets the `top margin` size.
     * @private
     */
    top: number;
    /**
     * Gets or sets the `right margin` size.
     * @private
     */
    right: number;
    /**
     * Gets or sets the `bottom margin` size.
     * @private
     */
    bottom: number;
    /**
     * Sets the `margins`.
     * @private
     */
    all: number;
    /**
     * Sets the `margins`.
     * @private
     */
    setMargins(margin1: number): void;
    /**
     * Sets the `margins`.
     * @private
     */
    setMargins(margin1: number, margin2: number): void;
    /**
     * Sets the `margins`.
     * @private
     */
    setMargins(margin1: number, margin2: number, margin3: number, margin4: number): void;
    /**
     * `Clones` the object.
     * @private
     */
    clone(): PdfMargins;
}
/**
 * PdfPen.ts class for EJ2-PDF
 */
/**
 * `PdfPen` class defining settings for drawing operations, that determines the color,
 * width, and style of the drawing elements.
 * ```typescript
 * // create a new PDF document
 * let document : PdfDocument = new PdfDocument();
 * // create a new page
 * let page1 : PdfPage = document.pages.add();
 * // set pen
 * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
 * // draw rectangle
 * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
 * // save the document.
 * document.save('output.pdf');
 * // destroy the document
 * document.destroy();
 * ```
 */
export  class PdfPen {
    /**
     * Specifies the `color of the pen`.
     * @default new PdfColor()
     * @private
     */
    private pdfColor;
    /**
     * Specifies the `dash offset of the pen`.
     * @default 0
     * @private
     */
    private dashOffsetValue;
    /**
     * Specifies the `dash pattern of the pen`.
     * @default [0]
     * @private
     */
    private penDashPattern;
    /**
     * Specifies the `dash style of the pen`.
     * @default Solid
     * @private
     */
    private pdfDashStyle;
    /**
     * Specifies the `line cap of the pen`.
     * @default 0
     * @private
     */
    private pdfLineCap;
    /**
     * Specifies the `line join of the pen`.
     * @default 0
     * @private
     */
    private pdfLineJoin;
    /**
     * Specifies the `width of the pen`.
     * @default 1.0
     * @private
     */
    private penWidth;
    /**
     * Specifies the `brush of the pen`.
     * @private
     */
    private pdfBrush;
    /**
     * Specifies the `mitter limit of the pen`.
     * @default 0.0
     * @private
     */
    private internalMiterLimit;
    /**
     * Stores the `colorspace` value.
     * @default Rgb
     * @private
     */
    private colorSpace;
    /**
     * Initializes a new instance of the `PdfPen` class with color.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * //
     * // set pen
     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
     * //
     * // draw rectangle
     * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param color Color of the pen.
     */
    constructor(color: PdfColor);
    /**
     * Initializes a new instance of the `PdfPen` class with 'PdfBrush' class and width of the pen.
     * @private
     */
    constructor(brush: PdfBrush, width: number);
    /**
     * Initializes a new instance of the `PdfPen` class with color and width of the pen.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * //
     * // set pen
     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0), 2);
     * //
     * // draw rectangle
     * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @param color Color of the pen.
     * @param width Width of the pen's line.
     */
    constructor(color: PdfColor, width: number);
    /**
     * Gets or sets the `color of the pen`.
     * @private
     */
    color: PdfColor;
    /**
     * Gets or sets the `dash offset of the pen`.
     * @private
     */
    dashOffset: number;
    /**
     * Gets or sets the `dash pattern of the pen`.
     * @private
     */
    dashPattern: number[];
    /**
     * Gets or sets the `dash style of the pen`.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * // set pen
     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
     * //
     * // set pen style
     * pen.dashStyle = PdfDashStyle.DashDot;
     * // get pen style
     * let style : PdfDashStyle = pen.dashStyle;
     * //
     * // draw rectangle
     * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    dashStyle: PdfDashStyle;
    /**
     * Gets or sets the `line cap of the pen`.
     * @private
     */
    lineCap: PdfLineCap;
    /**
     * Gets or sets the `line join style of the pen`.
     * @private
     */
    lineJoin: PdfLineJoin;
    /**
     * Gets or sets the `miter limit`.
     * @private
     */
    miterLimit: number;
    /**
     * Gets or sets the `width of the pen`.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * // set pen
     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
     * //
     * // set pen width
     * pen.width = 2;
     * //
     * // draw rectangle
     * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    width: number;
    /**
     * `Clones` this instance of PdfPen class.
     * @private
     */
    clone(): PdfPen;
    /**
     * `Sets the brush`.
     * @private
     */
    private setBrush(brush);
    /**
     * `Monitors the changes`.
     * @private
     */
    monitorChanges(currentPen: PdfPen, streamWriter: PdfStreamWriter, getResources: GetResourceEventHandler, saveState: boolean, currentColorSpace: PdfColorSpace, matrix: PdfTransformationMatrix): boolean;
    /**
     * `Controls the dash style` and behaviour of each line.
     * @private
     */
    private dashControl(pen, saveState, streamWriter);
    /**
     * `Gets the pattern` of PdfPen.
     * @private
     */
    getPattern(): number[];
}
/**
 * PdfResources.ts class for EJ2-PDF
 */
/**
 * `PdfResources` class used to set resource contents like font, image.
 * @private
 */
export  class PdfResources extends PdfDictionary {
    /**
     * Dictionary for the `objects names`.
     * @private
     */
    private pdfNames;
    /**
     * Dictionary for the `properties names`.
     * @private
     */
    private properties;
    /**
     * `Font name`.
     * @private
     */
    private fontName;
    /**
     * Stores instance of `parent document`.
     * @private
     */
    private pdfDocument;
    /**
     * Initializes a new instance of the `PdfResources` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `PdfResources` class.
     * @private
     */
    constructor(baseDictionary: PdfDictionary);
    /**
     * Gets the `font names`.
     * @private
     */
    private readonly names;
    /**
     * Get or set the `page document`.
     * @private
     */
    document: PdfDocument;
    /**
     * `Generates name` for the object and adds to the resource if the object is new.
     * @private
     */
    getName(obj: IPdfWrapper): PdfName;
    /**
     * Gets `resource names` to font dictionaries.
     * @private
     */
    getNames(): TemporaryDictionary<IPdfPrimitive, PdfName>;
    /**
     * Add `RequireProcedureSet` into procset array.
     * @private
     */
    requireProcedureSet(procedureSetName: string): void;
    /**
     * `Remove font` from array.
     * @private
     */
    removeFont(name: string): void;
    /**
     * Generates `Unique string name`.
     * @private
     */
    private generateName();
    /**
     * `Adds object` to the resources.
     * @private
     */
    add(font: PdfFont, name: PdfName): void;
    /**
     * `Adds object` to the resources.
     * @private
     */
    add(template: PdfTemplate, name: PdfName): void;
    /**
     * `Adds object` to the resources.
     * @private
     */
    add(brush: PdfBrush, name: PdfName): void;
    /**
     * `Adds object` to the resources.
     * @private
     */
    add(transparency: PdfTransparency, name: PdfName): void;
    /**
     * `Adds object` to the resources.
     * @private
     */
    add(image: PdfImage | PdfBitmap, name: PdfName): void;
}
/**
 * Used to create new guid for resources.
 * @private
 */
export  class Guid {
    /**
     * `String value of GUID`.
     * @private
     */
    private stringValue;
    /**
     * static field to store `endding value of current GUID`.
     * @private
     */
    private static guid;
    /**
     * Generate `Random number` for GUID.
     * @private
     */
    private static readonly randomNumber;
    /**
     * Initialize an `instance of GUID` class.
     * @private
     */
    constructor(stringValue?: string);
    /**
     * Return the value of `GUID as string`.
     * @private
     */
    toString(): string;
    /**
     * Generate `new GUID`.
     * @private
     */
    static getNewGuidString(): string;
}
/**
 * PdfTransformationMatrix.ts class for EJ2-PDF
 */
/**
 * Class for representing Root `transformation matrix`.
 */
export  class PdfTransformationMatrix {
    /**
     * Value for `angle converting`.
     * @default Math.PI / 180.0
     * @private
     */
    private static readonly degRadFactor;
    /**
     * Value for `angle converting`.
     * @default 180.0 / Math.PI
     * @private
     */
    private readonly radDegFactor;
    /**
     * `Transformation matrix`.
     * @private
     */
    private transformationMatrix;
    /**
     * Gets or sets the `internal matrix object`.
     * @private
     */
    matrix: Matrix;
    /**
     * Initializes object of `PdfTransformationMatrix` class.
     * @private
     */
    constructor();
    /**
     * Initializes object of `PdfTransformationMatrix` class.
     * @private
     */
    constructor(value: boolean);
    /**
     * `Translates` coordinates by specified coordinates.
     * @private
     */
    translate(offsetX: number, offsetY: number): void;
    /**
     * `Scales` coordinates by specified coordinates.
     * @private
     */
    scale(scaleX: number, scaleY: number): void;
    /**
     * `Rotates` coordinate system in counterclockwise direction.
     * @private
     */
    rotate(angle: number): void;
    /**
     * Gets `PDF representation`.
     * @private
     */
    toString(): string;
    /**
     * `Multiplies` matrices (changes coordinate system.)
     * @private
     */
    multiply(matrix: PdfTransformationMatrix): void;
    /**
     * Converts `degrees to radians`.
     * @private
     */
    static degreesToRadians(degreesX: number): number;
    /**
     * Converts `radians to degrees`.
     * @private
     */
    radiansToDegrees(radians: number): number;
    /**
     * `Clones` this instance of PdfTransformationMatrix.
     * @private
     */
    clone(): PdfTransformationMatrix;
}
export  class Matrix {
    /**
     * `elements` in the matrix.
     * @private
     */
    private metrixElements;
    /**
     * Initializes a new instance of the `Matrix` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `Matrix` class with number array.
     * @private
     */
    constructor(elements: number[]);
    /**
     * Initializes a new instance of the `Matrix` class.
     * @private
     */
    constructor(m11: number, m12: number, m21: number, m22: number, dx: number, dy: number);
    /**
     * Gets the `elements`.
     * @private
     */
    readonly elements: number[];
    /**
     * Gets the off set `X`.
     * @private
     */
    readonly offsetX: number;
    /**
     * Gets the off set `Y`.
     * @private
     */
    readonly offsetY: number;
    /**
     * `Translates` coordinates by specified coordinates.
     * @private
     */
    translate(offsetX: number, offsetY: number): void;
    /**
     * `Translates` the specified offset X.
     * @private
     */
    transform(point: PointF): PointF;
    /**
     * `Multiplies matrices` (changes coordinate system.)
     * @private
     */
    multiply(matrix: Matrix): void;
    /**
     * `Dispose` this instance of PdfTransformationMatrix class.
     * @private
     */
    dispose(): void;
    /**
     * `Clones` this instance of PdfTransformationMatrix class.
     * @private
     */
    clone(): Object;
}
/**
 * PdfTransparency.ts class for EJ2-PDF
 */
/**
 * Represents a simple `transparency`.
 * @private
 */
export  class PdfTransparency implements IPdfWrapper {
    /**
     * Internal variable to store `dictionary`.
     * @default new PdfDictionary()
     * @private
     */
    private dictionary;
    /**
     * Internal variable for accessing fields from `DictionryProperties` class.
     * @default new DictionaryProperties()
     * @private
     */
    private dictionaryProperties;
    /**
     * Initializes a new instance of the `Transparency` class.
     * @private
     */
    constructor(stroke: number, fill: number, mode: PdfBlendMode);
    /**
     * Gets the `element`.
     * @private
     */
    readonly element: IPdfPrimitive;
}
/**
 * PdfUnitConverter.ts class for EJ2-PDF
 */
/**
 * Used to perform `convertion between pixels and points`.
 * @private
 */
export  class PdfUnitConverter {
    /**
     * Indicates default `horizontal resolution`.
     * @default 96
     * @private
     */
    static readonly horizontalResolution: number;
    /**
     * Indicates default `vertical resolution`.
     * @default 96
     * @private
     */
    static readonly verticalResolution: number;
    /**
     * `Width, in millimeters`, of the physical screen.
     * @private
     */
    static readonly horizontalSize: number;
    /**
     * `Height, in millimeters`, of the physical screen.
     * @private
     */
    static readonly verticalSize: number;
    /**
     * `Width, in pixels`, of the screen.
     * @private
     */
    static readonly pxHorizontalResolution: number;
    /**
     * `Height, in pixels`, of the screen.
     * @private
     */
    static readonly pxVerticalResolution: number;
    /**
     * `Matrix` for conversations between different numeric systems.
     * @private
     */
    private proportions;
    /**
     * Initializes a new instance of the `UnitConvertor` class with DPI value.
     * @private
     */
    constructor(dpi: number);
    /**
     * `Converts` the value, from one graphics unit to another graphics unit.
     * @private
     */
    convertUnits(value: number, from: PdfGraphicsUnit, to: PdfGraphicsUnit): number;
    /**
     * Converts the value `to pixel` from specified graphics unit.
     * @private
     */
    convertToPixels(value: number, from: PdfGraphicsUnit): number;
    /**
     * Converts value, to specified graphics unit `from Pixel`.
     * @private
     */
    convertFromPixels(value: number, to: PdfGraphicsUnit): number;
    /**
     * `Update proportions` matrix according to Graphics settings.
     * @private
     */
    private updateProportionsHelper(pixelPerInch);
}
/**
 * Pdf implementation all modules
 * @hidden
 */
/**
 * public Enum for `ObjectType`.
 * @private
 */
export  enum ObjectType {
    /**
     * Specifies the type of `Free`.
     * @private
     */
    Free = 0,
    /**
     * Specifies the type of `Normal`.
     * @private
     */
    Normal = 1,
    /**
     * Specifies the type of `Packed`.
     * @private
     */
    Packed = 2,
}
/**
 * public Enum for `CompositeFontType`.
 * @private
 */
export  enum ObjectStatus {
    /**
     * Specifies the type of `None`.
     * @private
     */
    None = 0,
    /**
     * Specifies the type of `Registered`.
     * @private
     */
    Registered = 1,
}
/**
 * IO classes
 * @hidden
 */
/**
 * `PdfCrossTable` is responsible for intermediate level parsing
 * and savingof a PDF document.
 * @private
 */
export  class PdfCrossTable {
    /**
     * Parent `Document`.
     * @private
     */
    private pdfDocument;
    /**
     * Internal variable to store primtive objects of `main object collection`.
     * @private
     */
    private items;
    /**
     * The `mapped references`.
     * @private
     */
    private mappedReferences;
    /**
     * The modified `objects` that should be saved.
     * @private
     */
    private objects;
    /**
     * The `trailer` for a new document.
     * @private
     */
    private internalTrailer;
    /**
     * Internal variable to store if document `is being merged`.
     * @private
     */
    private merging;
    /**
     * `Flag` that forces an object to be 'a new'.
     * @private
     */
    private bForceNew;
    /**
     * Holds `maximal generation number` or offset to object.
     * @default 0
     * @private
     */
    private maxGenNumIndex;
    /**
     * The `number of the objects`.
     * @default 0
     * @private
     */
    private objectCount;
    /**
     * Internal variable for accessing fields from `DictionryProperties` class.
     * @default new PdfDictionaryProperties()
     * @private
     */
    private dictionaryProperties;
    /**
     * Gets or sets if the document `is merged`.
     * @private
     */
    isMerging: boolean;
    /**
     * Gets the `trailer`.
     * @private
     */
    readonly trailer: PdfDictionary;
    /**
     * Gets or sets the main `PdfDocument` class instance.
     * @private
     */
    document: PdfDocumentBase;
    /**
     * Gets the catched `PDF object` main collection.
     * @private
     */
    readonly pdfObjects: PdfMainObjectCollection;
    /**
     * Gets the `object collection`.
     * @private
     */
    private readonly objectCollection;
    /**
     * Gets or sets the `number of the objects` within the document.
     * @private
     */
    count: number;
    /**
     * Returns `next available object number`.
     * @private
     */
    readonly nextObjNumber: number;
    /**
     * `Saves` the cross-reference table into the stream and return it as Blob.
     * @private
     */
    save(writer: PdfWriter): Blob;
    /**
     * `Saves` the cross-reference table into the stream.
     * @private
     */
    save(writer: PdfWriter, filename: string): void;
    /**
     * `Saves the endess` of the file.
     * @private
     */
    private saveTheEndess(writer, xrefPos);
    /**
     * `Saves the new trailer` dictionary.
     * @private
     */
    private saveTrailer(writer, count, prevXRef);
    /**
     * `Saves the xref section`.
     * @private
     */
    private saveSections(writer);
    /**
     * `Saves a subsection`.
     * @private
     */
    private saveSubsection(writer, objectNum, count);
    /**
     * Generates string for `xref table item`.
     * @private
     */
    getItem(offset: number, genNumber: number, isFree: boolean): string;
    /**
     * `Prepares a subsection` of the current section within the cross-reference table.
     * @private
     */
    private prepareSubsection(objectNum);
    /**
     * `Marks the trailer references` being saved.
     * @private
     */
    private markTrailerReferences();
    /**
     * `Saves the head`.
     * @private
     */
    private saveHead(writer);
    /**
     * Generates the `version` of the file.
     * @private
     */
    private generateFileVersion(document);
    /**
     * Retrieves the `reference` of the object given.
     * @private
     */
    getReference(obj: IPdfPrimitive): PdfReference;
    /**
     * Retrieves the `reference` of the object given.
     * @private
     */
    getReference(obj: IPdfPrimitive, bNew: boolean): PdfReference;
    /**
     * Retrieves the `reference` of the object given.
     * @private
     */
    private getSubReference(obj, bNew);
    /**
     * `Saves all objects` in the collection.
     * @private
     */
    private saveObjects(writer);
    /**
     * `Saves indirect object`.
     * @private
     */
    saveIndirectObject(obj: IPdfPrimitive, writer: PdfWriter): void;
    /**
     * Performs `real saving` of the save object.
     * @private
     */
    private doSaveObject(obj, reference, writer);
    /**
     * `Registers` an archived object.
     * @private
     */
    registerObject(offset: number, reference: PdfReference): void;
    /**
     * `Registers` the object in the cross reference table.
     * @private
     */
    registerObject(offset: number, reference: PdfReference, free: boolean): void;
    /**
     * `Dereferences` the specified primitive object.
     * @private
     */
    static dereference(obj: IPdfPrimitive): IPdfPrimitive;
}
export  class RegisteredObject {
    /**
     * The `object number` of the indirect object.
     * @private
     */
    private object;
    /**
     * The `generation number` of the indirect object.
     * @private
     */
    generation: number;
    /**
     * The `offset` of the indirect object within the file.
     * @private
     */
    private offsetNumber;
    /**
     * Shows if the object `is free`.
     * @private
     */
    type: ObjectType;
    /**
     * Holds the current `cross-reference` table.
     * @private
     */
    private xrefTable;
    /**
     * Gets the `object number`.
     * @private
     */
    readonly objectNumber: number;
    /**
     * Gets the `offset`.
     * @private
     */
    readonly offset: number;
    /**
     * Initialize the `structure` with the proper values.
     * @private
     */
    constructor(offset: number, reference: PdfReference);
    /**
     * Initialize the `structure` with the proper values.
     * @private
     */
    constructor(offset: number, reference: PdfReference, free: boolean);
}
/**
 * dictionaryProperties.ts class for EJ2-PDF
 * PDF dictionary properties.
 * @private
 */
export  class DictionaryProperties {
    /**
     * Specifies the value of `Pages`.
     * @private
     */
    readonly pages: string;
    /**
     * Specifies the value of `Kids`.
     * @private
     */
    readonly kids: string;
    /**
     * Specifies the value of `Count`.
     * @private
     */
    readonly count: string;
    /**
     * Specifies the value of `Resources`.
     * @private
     */
    readonly resources: string;
    /**
     * Specifies the value of `Type`.
     * @private
     */
    readonly type: string;
    /**
     * Specifies the value of `Size`.
     * @private
     */
    readonly size: string;
    /**
     * Specifies the value of `MediaBox`.
     * @private
     */
    readonly mediaBox: string;
    /**
     * Specifies the value of `Parent`.
     * @private
     */
    readonly parent: string;
    /**
     * Specifies the value of `Root`.
     * @private
     */
    readonly root: string;
    /**
     * Specifies the value of `DecodeParms`.
     * @private
     */
    readonly decodeParms: string;
    /**
     * Specifies the value of `Filter`.
     * @private
     */
    readonly filter: string;
    /**
     * Specifies the value of `Font`.
     * @private
     */
    readonly font: string;
    /**
     * Specifies the value of `Type1`.
     * @private
     */
    readonly type1: string;
    /**
     * Specifies the value of `BaseFont`.
     * @private
     */
    readonly baseFont: string;
    /**
     * Specifies the value of `Encoding`.
     * @private
     */
    readonly encoding: string;
    /**
     * Specifies the value of `Subtype`.
     * @private
     */
    readonly subtype: string;
    /**
     * Specifies the value of `Contents`.
     * @private
     */
    readonly contents: string;
    /**
     * Specifies the value of `ProcSet`.
     * @private
     */
    readonly procset: string;
    /**
     * Specifies the value of `ColorSpace`.
     * @private
     */
    readonly colorSpace: string;
    /**
     * Specifies the value of `ExtGState`.
     * @private
     */
    readonly extGState: string;
    /**
     * Specifies the value of `Pattern`.
     * @private
     */
    readonly pattern: string;
    /**
     * Specifies the value of `XObject`.
     * @private
     */
    readonly xObject: string;
    /**
     * Specifies the value of `Length`.
     * @private
     */
    readonly length: string;
    /**
     * Specifies the value of `Width`.
     * @private
     */
    readonly width: string;
    /**
     * Specifies the value of `Height`.
     * @private
     */
    readonly height: string;
    /**
     * Specifies the value of `BitsPerComponent`.
     * @private
     */
    readonly bitsPerComponent: string;
    /**
     * Specifies the value of `Image`.
     * @private
     */
    readonly image: string;
    /**
     * Specifies the value of `dctdecode`.
     * @private
     */
    readonly dctdecode: string;
    /**
     * Specifies the value of `Columns`.
     * @private
     */
    readonly columns: string;
    /**
     * Specifies the value of `BlackIs1`.
     * @private
     */
    readonly blackIs1: string;
    /**
     * Specifies the value of `K`.
     * @private
     */
    readonly k: string;
    /**
     * Specifies the value of `S`.
     * @private
     */
    readonly s: string;
    /**
     * Specifies the value of `Predictor`.
     * @private
     */
    readonly predictor: string;
    /**
     * Specifies the value of `DeviceRGB`.
     * @private
     */
    readonly deviceRgb: string;
    /**
     * Specifies the value of `Next`.
     * @private
     */
    readonly next: string;
    /**
     * Specifies the value of `Action`.
     * @private
     */
    readonly action: string;
    /**
     * Specifies the value of `Link`.
     * @private
     */
    readonly link: string;
    /**
     *
     * Specifies the value of `A`.
     * @private
     */
    readonly a: string;
    /**
     * Specifies the value of `Annot`.
     * @private
     */
    readonly annot: string;
    /**
     * Specifies the value of `P`.
     * @private
     */
    readonly p: string;
    /**
     * Specifies the value of `C`.
     * @private
     */
    readonly c: string;
    /**
     * Specifies the value of `Rect`.
     * @private
     */
    readonly rect: string;
    /**
     * Specifies the value of `URI`.
     * @private
     */
    readonly uri: string;
    /**
     * Specifies the value of `Annots`.
     * @private
     */
    readonly annots: string;
    /**
     * Specifies the value of `ca`.
     * @private
     */
    readonly ca: string;
    /**
     * Specifies the value of `CA`.
     * @private
     */
    readonly CA: string;
    /**
     * Specifies the value of `XYZ`.
     * @private
     */
    readonly xyz: string;
    /**
     * Specifies the value of `Fit`.
     * @private
     */
    readonly fit: string;
    /**
     * Specifies the value of `Dest`.
     * @private
     */
    readonly dest: string;
    /**
     * Specifies the value of `BM`.
     * @private
     */
    readonly BM: string;
    /**
     * Specifies the value of `flatedecode`.
     * @private
     */
    readonly flatedecode: string;
    /**
     * Specifies the value of `Rotate`.
     * @private
     */
    readonly rotate: string;
    /**
     * Specifies the value of 'bBox'.
     * @private
     */
    readonly bBox: string;
    /**
     * Specifies the value of 'form'.
     * @private
     */
    readonly form: string;
    /**
     * Initialize an instance for `PdfDictionaryProperties` class.
     * @private
     */
    constructor();
}
/**
 * PdfMainObjectCollection.ts class for EJ2-PDF
 */
/**
 * The collection of all `objects` within a PDF document.
 * @private
 */
export  class PdfMainObjectCollection {
    /**
     * The collection of the `indirect objects`.
     * @default []
     * @private
     */
    objectCollections: ObjectInfo[];
    /**
     * The collection of the `Indirect objects`.
     * @default new Dictionary<number, ObjectInfo>()
     * @private
     */
    mainObjectCollection: Dictionary<number, ObjectInfo>;
    /**
     * The collection of `primitive objects`.
     * @private
     */
    primitiveObjectCollection: Dictionary<IPdfPrimitive, number>;
    /**
     * Holds the `index of the object`.
     * @private
     */
    private index;
    /**
     * Stores the value of `IsNew`.
     * @private
     */
    private isNew;
    /**
     * Gets the `count`.
     * @private
     */
    readonly count: number;
    /**
     * Gets the value of `ObjectInfo` from object collection.
     * @private
     */
    items(index: number): ObjectInfo;
    /**
     * Specifies the value of `IsNew`.
     * @private
     */
    readonly outIsNew: boolean;
    /**
     * `Adds` the specified element.
     * @private
     */
    add(element: IPdfPrimitive): void;
    /**
     * `Looks` through the collection for the object specified.
     * @private
     */
    private lookFor(obj);
    /**
     * Gets the `reference of the object`.
     * @private
     */
    getReference(index: IPdfPrimitive, isNew: boolean): {
        reference: PdfReference;
        wasNew: boolean;
    };
    /**
     * Tries to set the `reference to the object`.
     * @private
     */
    trySetReference(obj: IPdfPrimitive, reference: PdfReference, found: boolean): boolean;
    destroy(): void;
}
export  class ObjectInfo {
    /**
     * The `PDF object`.
     * @private
     */
    pdfObject: IPdfPrimitive;
    /**
     * `Object number and generation number` of the object.
     * @private
     */
    private pdfReference;
    /**
     * Initializes a new instance of the `ObjectInfo` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `ObjectInfo` class.
     * @private
     */
    constructor(obj: IPdfPrimitive);
    /**
     * Initializes a new instance of the `ObjectInfo` class.
     * @private
     */
    constructor(obj: IPdfPrimitive, reference: PdfReference);
    /**
     * Gets the `object`.
     * @private
     */
    object: IPdfPrimitive;
    /**
     * Gets the `reference`.
     * @private
     */
    readonly reference: PdfReference;
    /**
     * Sets the `reference`.
     * @private
     */
    setReference(reference: PdfReference): void;
}
/**
 * PdfOperators.ts class for EJ2-PDF
 * Class of string PDF common operators.
 * @private
 */
export  class Operators {
    /**
     * Specifies the value of `obj`.
     * @private
     */
    static readonly obj: string;
    /**
     * Specifies the value of `endObj`.
     * @private
     */
    static readonly endObj: string;
    /**
     * Specifies the value of `R`.
     * @private
     */
    static readonly r: string;
    /**
     * Specifies the value of ` `.
     * @private
     */
    static readonly whiteSpace: string;
    /**
     * Specifies the value of `/`.
     * @private
     */
    static readonly slash: string;
    /**
     * Specifies the value of `\r\n`.
     * @private
     */
    static readonly newLine: string;
    /**
     * Specifies the value of `stream`.
     * @private
     */
    static readonly stream: string;
    /**
     * Specifies the value of `endStream`.
     * @private
     */
    static readonly endStream: string;
    /**
     * Specifies the value of `xref`.
     * @private
     */
    static readonly xref: string;
    /**
     * Specifies the value of `f`.
     * @private
     */
    static readonly f: string;
    /**
     * Specifies the value of `n`.
     * @private
     */
    static readonly n: string;
    /**
     * Specifies the value of `trailer`.
     * @private
     */
    static readonly trailer: string;
    /**
     * Specifies the value of `startxref`.
     * @private
     */
    static readonly startxref: string;
    /**
     * Specifies the value of `eof`.
     * @private
     */
    static readonly eof: string;
    /**
     * Specifies the value of `header`.
     * @private
     */
    static readonly header: string;
    /**
     * Specifies the value of `beginText`.
     * @private
     */
    static readonly beginText: string;
    /**
     * Specifies the value of `endText`.
     * @private
     */
    static readonly endText: string;
    /**
     * Specifies the value of `m`.
     * @private
     */
    static readonly beginPath: string;
    /**
     * Specifies the value of `l`.
     * @private
     */
    static readonly appendLineSegment: string;
    /**
     * Specifies the value of `S`.
     * @private
     */
    static readonly stroke: string;
    /**
     * Specifies the value of `f`.
     * @private
     */
    static readonly fill: string;
    /**
     * Specifies the value of `f*`.
     * @private
     */
    static readonly fillEvenOdd: string;
    /**
     * Specifies the value of `B`.
     * @private
     */
    static readonly fillStroke: string;
    /**
     * Specifies the value of `B*`.
     * @private
     */
    static readonly fillStrokeEvenOdd: string;
    /**
     * Specifies the value of `c`.
     * @private
     */
    static readonly appendbeziercurve: string;
    /**
     * Specifies the value of `re`.
     * @private
     */
    static readonly appendRectangle: string;
    /**
     * Specifies the value of `q`.
     * @private
     */
    static readonly saveState: string;
    /**
     * Specifies the value of `Q`.
     * @private
     */
    static readonly restoreState: string;
    /**
     * Specifies the value of `Do`.
     * @private
     */
    static readonly paintXObject: string;
    /**
     * Specifies the value of `cm`.
     * @private
     */
    static readonly modifyCtm: string;
    /**
     * Specifies the value of `Tm`.
     * @private
     */
    static readonly modifyTM: string;
    /**
     * Specifies the value of `w`.
     * @private
     */
    static readonly setLineWidth: string;
    /**
     * Specifies the value of `J`.
     * @private
     */
    static readonly setLineCapStyle: string;
    /**
     * Specifies the value of `j`.
     * @private
     */
    static readonly setLineJoinStyle: string;
    /**
     * Specifies the value of `d`.
     * @private
     */
    static readonly setDashPattern: string;
    /**
     * Specifies the value of `i`.
     * @private
     */
    static readonly setFlatnessTolerance: string;
    /**
     * Specifies the value of `h`.
     * @private
     */
    static readonly closePath: string;
    /**
     * Specifies the value of `s`.
     * @private
     */
    static readonly closeStrokePath: string;
    /**
     * Specifies the value of `b`.
     * @private
     */
    static readonly closeFillStrokePath: string;
    /**
     * Specifies the value of `setCharacterSpace`.
     * @private
     */
    static readonly setCharacterSpace: string;
    /**
     * Specifies the value of `setWordSpace`.
     * @private
     */
    static readonly setWordSpace: string;
    /**
     * Specifies the value of `setHorizontalScaling`.
     * @private
     */
    static readonly setHorizontalScaling: string;
    /**
     * Specifies the value of `setTextLeading`.
     * @private
     */
    static readonly setTextLeading: string;
    /**
     * Specifies the value of `setFont`.
     * @private
     */
    static readonly setFont: string;
    /**
     * Specifies the value of `setRenderingMode`.
     * @private
     */
    static readonly setRenderingMode: string;
    /**
     * Specifies the value of `setTextRise`.
     * @private
     */
    static readonly setTextRise: string;
    /**
     * Specifies the value of `setTextScaling`.
     * @private
     */
    static readonly setTextScaling: string;
    /**
     * Specifies the value of `setCoords`.
     * @private
     */
    static readonly setCoords: string;
    /**
     * Specifies the value of `goToNextLine`.
     * @private
     */
    static readonly goToNextLine: string;
    /**
     * Specifies the value of `setText`.
     * @private
     */
    static readonly setText: string;
    /**
     * Specifies the value of `setTextWithFormatting`.
     * @private
     */
    static readonly setTextWithFormatting: string;
    /**
     * Specifies the value of `setTextOnNewLine`.
     * @private
     */
    static readonly setTextOnNewLine: string;
    /**
     * Specifies the value of `selectcolorspaceforstroking`.
     * @private
     */
    static readonly selectcolorspaceforstroking: string;
    /**
     * Specifies the value of `selectcolorspacefornonstroking`.
     * @private
     */
    static readonly selectcolorspacefornonstroking: string;
    /**
     * Specifies the value of `setrbgcolorforstroking`.
     * @private
     */
    static readonly setrbgcolorforstroking: string;
    /**
     * Specifies the value of `setrbgcolorfornonstroking`.
     * @private
     */
    static readonly setrbgcolorfornonstroking: string;
    /**
     * Specifies the value of `K`.
     * @private
     */
    static readonly setcmykcolorforstroking: string;
    /**
     * Specifies the value of `k`.
     * @private
     */
    static readonly setcmykcolorfornonstroking: string;
    /**
     * Specifies the value of `G`.
     * @private
     */
    static readonly setgraycolorforstroking: string;
    /**
     * Specifies the value of `g`.
     * @private
     */
    static readonly setgraycolorfornonstroking: string;
    /**
     * Specifies the value of `W`.
     * @private
     */
    static readonly clipPath: string;
    /**
     * Specifies the value of `clipPathEvenOdd`.
     * @private
     */
    static readonly clipPathEvenOdd: string;
    /**
     * Specifies the value of `n`.
     * @private
     */
    static readonly endPath: string;
    /**
     * Specifies the value of `setGraphicsState`.
     * @private
     */
    static readonly setGraphicsState: string;
    /**
     * Specifies the value of `%`.
     * @private
     */
    static readonly comment: string;
    /**
     * Specifies the value of `*`.
     * @private
     */
    static readonly evenOdd: string;
    /**
     * Specifies the value of `M`.
     * @private
     */
    static readonly setMiterLimit: string;
    /**
     * Specifies the value of `test`.
     * @private
     */
    private forTest;
    /**
     * Create an instance of `PdfOperator` class.
     * @private
     */
    constructor();
}
/**
 * PdfStreamWriter.ts class for EJ2-PDF
 */
/**
 * Helper class to `write PDF graphic streams` easily.
 * @private
 */
export  class PdfStreamWriter implements IPdfWriter {
    /**
     * The PDF `stream` where the data should be write into.
     * @private
     */
    private stream;
    /**
     * Initialize an instance of `PdfStreamWriter` class.
     * @private
     */
    constructor(stream: PdfStream);
    /**
     * `Clear` the stream.
     * @public
     */
    clear(): void;
    /**
     * Sets the `graphics state`.
     * @private
     */
    setGraphicsState(dictionaryName: PdfName): void;
    /**
     * Sets the `graphics state`.
     * @private
     */
    setGraphicsState(dictionaryName: string): void;
    /**
     * `Executes the XObject`.
     * @private
     */
    executeObject(name: PdfName): void;
    /**
     * `Closes path object`.
     * @private
     */
    closePath(): void;
    /**
     * `Clips the path`.
     * @private
     */
    clipPath(useEvenOddRule: boolean): void;
    /**
     * `Closes, then fills and strokes the path`.
     * @private
     */
    closeFillStrokePath(useEvenOddRule: boolean): void;
    /**
     * `Fills and strokes path`.
     * @private
     */
    fillStrokePath(useEvenOddRule: boolean): void;
    /**
     * `Fills path`.
     * @private
     */
    fillPath(useEvenOddRule: boolean): void;
    /**
     * `Ends the path`.
     * @private
     */
    endPath(): void;
    /**
     * `Closes and fills the path`.
     * @private
     */
    closeFillPath(useEvenOddRule: boolean): void;
    /**
     * `Closes and strokes the path`.
     * @private
     */
    closeStrokePath(): void;
    /**
     * `Sets the text scaling`.
     * @private
     */
    setTextScaling(textScaling: number): void;
    /**
     * `Strokes path`.
     * @private
     */
    strokePath(): void;
    /**
     * `Restores` the graphics state.
     * @private
     */
    restoreGraphicsState(): void;
    /**
     * `Saves` the graphics state.
     * @private
     */
    saveGraphicsState(): void;
    /**
     * `Shifts the text to the point`.
     * @private
     */
    startNextLine(): void;
    /**
     * `Shifts the text to the point`.
     * @private
     */
    startNextLine(point: PointF): void;
    /**
     * `Shifts the text to the point`.
     * @private
     */
    startNextLine(x: number, y: number): void;
    /**
     * Sets `text leading`.
     * @private
     */
    setLeading(leading: number): void;
    /**
     * `Begins the path`.
     * @private
     */
    beginPath(x: number, y: number): void;
    /**
     * `Begins text`.
     * @private
     */
    beginText(): void;
    /**
     * `Ends text`.
     * @private
     */
    endText(): void;
    /**
     * `Appends the rectangle`.
     * @private
     */
    appendRectangle(rectangle: RectangleF): void;
    /**
     * `Appends the rectangle`.
     * @private
     */
    appendRectangle(x: number, y: number, width: number, height: number): void;
    /**
     * `Appends a line segment`.
     * @private
     */
    appendLineSegment(point: PointF): void;
    /**
     * `Appends a line segment`.
     * @private
     */
    appendLineSegment(x: number, y: number): void;
    /**
     * Sets the `text rendering mode`.
     * @private
     */
    setTextRenderingMode(renderingMode: TextRenderingMode): void;
    /**
     * Sets the `character spacing`.
     * @private
     */
    setCharacterSpacing(charSpacing: number): void;
    /**
     * Sets the `word spacing`.
     * @private
     */
    setWordSpacing(wordSpacing: number): void;
    /**
     * Shows the `next line text`.
     * @private
     */
    showNextLineText(text: string, hex: boolean): void;
    /**
     * Shows the `next line text`.
     * @private
     */
    showNextLineText(text: PdfString): void;
    /**
     * Set the `color space`.
     * @private
     */
    setColorSpace(name: string, forStroking: boolean): void;
    /**
     * Set the `color space`.
     * @private
     */
    setColorSpace(name: PdfName, forStroking: boolean): void;
    /**
     * Modifies current `transformation matrix`.
     * @private
     */
    modifyCtm(matrix: PdfTransformationMatrix): void;
    /**
     * Sets `font`.
     * @private
     */
    setFont(font: PdfFont, name: string, size: number): void;
    /**
     * Sets `font`.
     * @private
     */
    setFont(font: PdfFont, name: PdfName, size: number): void;
    /**
     * `Writes the operator`.
     * @private
     */
    private writeOperator(opcode);
    /**
     * Checks the `text param`.
     * @private
     */
    private checkTextParam(text);
    /**
     * Checks the `text param`.
     * @private
     */
    private checkTextParam(text);
    /**
     * `Writes the text`.
     * @private
     */
    private writeText(text, hex);
    /**
     * `Writes the text`.
     * @private
     */
    private writeText(text);
    /**
     * `Writes the point`.
     * @private
     */
    private writePoint(point);
    /**
     * `Writes the point`.
     * @private
     */
    private writePoint(x, y);
    /**
     * `Updates y` co-ordinate.
     * @private
     */
    updateY(arg: number): number;
    /**
     * `Writes string` to the file.
     * @private
     */
    write(string: string): void;
    /**
     * `Writes comment` to the file.
     * @private
     */
    writeComment(comment: string): void;
    /**
     * Sets the `color and space`.
     * @private
     */
    setColorAndSpace(color: PdfColor, colorSpace: PdfColorSpace, forStroking: boolean): void;
    /**
     * Sets the `line dash pattern`.
     * @private
     */
    setLineDashPattern(pattern: number[], patternOffset: number): void;
    /**
     * Sets the `line dash pattern`.
     * @private
     */
    private setLineDashPatternHelper(pattern, patternOffset);
    /**
     * Sets the `miter limit`.
     * @private
     */
    setMiterLimit(miterLimit: number): void;
    /**
     * Sets the `width of the line`.
     * @private
     */
    setLineWidth(width: number): void;
    /**
     * Sets the `line cap`.
     * @private
     */
    setLineCap(lineCapStyle: PdfLineCap): void;
    /**
     * Sets the `line join`.
     * @private
     */
    setLineJoin(lineJoinStyle: PdfLineJoin): void;
    /**
     * Gets or sets the current `position` within the stream.
     * @private
     */
    readonly position: number;
    /**
     * Gets `stream length`.
     * @private
     */
    readonly length: number;
    /**
     * Gets and Sets the `current document`.
     * @private
     */
    readonly document: PdfDocument;
}
/**
 * PdfWriter.ts class for EJ2-PDF
 */
/**
 * Used to `write a string` into output file.
 * @private
 */
export  class PdfWriter implements IPdfWriter {
    /**
     * Specifies the current `position`.
     * @private
     */
    private currentPosition;
    /**
     * Specifies the `length` of the stream.
     * @private
     */
    private streamLength;
    /**
     * Check wheather the stream `can seek` or not.
     * @private
     */
    private cannotSeek;
    /**
     * Specifies the parent `document`.
     * @private
     */
    private pdfDocument;
    /**
     * Specifies the `stream`.
     * @private
     */
    private streamWriter;
    /**
     * Initialize an instance of `PdfWriter` class.
     * @private
     */
    constructor(stream: fileutils.StreamWriter);
    /**
     * Gets and Sets the `document`.
     * @private
     */
    document: PdfDocumentBase;
    /**
     * Gets the `position`.
     * @private
     */
    readonly position: number;
    /**
     * Gets  the `length` of the stream'.
     * @private
     */
    readonly length: number;
    /**
     * Gets the `stream`.
     * @private
     */
    readonly stream: fileutils.StreamWriter;
    /**
     * `Writes the specified data`.
     * @private
     */
    write(overload: IPdfPrimitive | number | string | number[]): void;
}
/**
 * public Enum for `PdfPageOrientation`.
 * @private
 */
export  enum PdfPageOrientation {
    /**
     * Specifies the type of `Portrait`.
     * @private
     */
    Portrait = 0,
    /**
     * Specifies the type of `Landscape`.
     * @private
     */
    Landscape = 1,
}
/**
 * public Enum for `PdfPageRotateAngle`.
 * @private
 */
export  enum PdfPageRotateAngle {
    /**
     * Specifies the type of `RotateAngle0`.
     * @private
     */
    RotateAngle0 = 0,
    /**
     * Specifies the type of `RotateAngle90`.
     * @private
     */
    RotateAngle90 = 1,
    /**
     * Specifies the type of `RotateAngle180`.
     * @private
     */
    RotateAngle180 = 2,
    /**
     * Specifies the type of `RotateAngle270`.
     * @private
     */
    RotateAngle270 = 3,
}
/**
 * public Enum for `PdfNumberStyle`.
 * @private
 */
export  enum PdfNumberStyle {
    /**
     * Specifies the type of `None`.
     * @private
     */
    None = 0,
    /**
     * Specifies the type of `Numeric`.
     * @private
     */
    Numeric = 1,
    /**
     * Specifies the type of `LowerLatin`.
     * @private
     */
    LowerLatin = 2,
    /**
     * Specifies the type of `LowerRoman`.
     * @private
     */
    LowerRoman = 3,
    /**
     * Specifies the type of `UpperLatin`.
     * @private
     */
    UpperLatin = 4,
    /**
     * Specifies the type of `UpperRoman`.
     * @private
     */
    UpperRoman = 5,
}
/**
 * public Enum for `PdfDockStyle`.
 * @private
 */
export  enum PdfDockStyle {
    /**
     * Specifies the type of `None`.
     * @private
     */
    None = 0,
    /**
     * Specifies the type of `Bottom`.
     * @private
     */
    Bottom = 1,
    /**
     * Specifies the type of `Top`.
     * @private
     */
    Top = 2,
    /**
     * Specifies the type of `Left`.
     * @private
     */
    Left = 3,
    /**
     * Specifies the type of `Right`.
     * @private
     */
    Right = 4,
    /**
     * Specifies the type of `Fill`.
     * @private
     */
    Fill = 5,
}
/**
 * public Enum for `PdfAlignmentStyle`.
 * @private
 */
export  enum PdfAlignmentStyle {
    /**
     * Specifies the type of `None`.
     * @private
     */
    None = 0,
    /**
     * Specifies the type of `TopLeft`.
     * @private
     */
    TopLeft = 1,
    /**
     * Specifies the type of `TopCenter`.
     * @private
     */
    TopCenter = 2,
    /**
     * Specifies the type of `TopRight`.
     * @private
     */
    TopRight = 3,
    /**
     * Specifies the type of `MiddleLeft`.
     * @private
     */
    MiddleLeft = 4,
    /**
     * Specifies the type of `MiddleCenter`.
     * @private
     */
    MiddleCenter = 5,
    /**
     * Specifies the type of `MiddleRight`.
     * @private
     */
    MiddleRight = 6,
    /**
     * Specifies the type of `BottomLeft`.
     * @private
     */
    BottomLeft = 7,
    /**
     * Specifies the type of `BottomCenter`.
     * @private
     */
    BottomCenter = 8,
    /**
     * Specifies the type of `BottomRight`.
     * @private
     */
    BottomRight = 9,
}
/**
 * public Enum for `TemplateType`.
 * @private
 */
export  enum TemplateType {
    /**
     * Specifies the type of `None`.
     * @private
     */
    None = 0,
    /**
     * Specifies the type of `Top`.
     * @private
     */
    Top = 1,
    /**
     * Specifies the type of `Bottom`.
     * @private
     */
    Bottom = 2,
    /**
     * Specifies the type of `Left`.
     * @private
     */
    Left = 3,
    /**
     * Specifies the type of `Right`.
     * @private
     */
    Right = 4,
}
/**
 * Pages classes
 * @hidden
 */
/**
 * PageAddedEventArguments.ts class for EJ2-PDF
 */
/**
 * Provides data for `PageAddedEventHandler` event.
 * This event raises when adding the new PDF page to the PDF document.
 */
export  class PageAddedEventArgs {
    /**
     * Represents added `page`.
     * @private
     */
    private pdfPage;
    /**
     * Gets the `newly added page`.
     * @private
     */
    readonly page: PdfPage;
    /**
     * Initializes a new instance of the `PageAddedEventArgs` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `PageAddedEventArgs` class with 'PdfPage'.
     * @private
     */
    constructor(page: PdfPage);
}
/**
 * Represents a virtual collection of all the pages in the document.
 * @private
 */
export  class PdfDocumentPageCollection {
    /**
     * Parent `document`.
     * @private
     */
    private document;
    /**
     * It holds the page collection with the `index`.
     * @private
     */
    private pdfPageCollectionIndex;
    /**
     * Stores the previous pages's `orientation`.
     * @default PdfPageOrientation.Portrait
     * @private
     */
    private previousPageOrientation;
    /**
     * Internal variable for `page added event`.
     * @private
     */
    pageAdded: PageAddedEventArgs;
    /**
     * Gets the total `number of the pages`.
     * @private
     */
    readonly count: number;
    /**
     * Gets a `page index` from the document.
     * @private
     */
    readonly pageCollectionIndex: Dictionary<PdfPage, number>;
    /**
     * Initializes a new instance of the `PdfPageCollection` class.
     * @private
     */
    constructor(document: PdfDocument);
    /**
     * Creates a page and `adds` it to the last section in the document.
     * @private
     */
    add(): PdfPage;
    /**
     * Creates a page and `adds` it to the last section in the document.
     * @private
     */
    add(page: PdfPage): void;
    /**
     * Returns `last section` in the document.
     * @private
     */
    private getLastSection();
    /**
     * Called when `new page has been added`.
     * @private
     */
    onPageAdded(args: PageAddedEventArgs): void;
    /**
     * Gets the `total number of pages`.
     * @private
     */
    private countPages();
    /**
     * Gets the `page object` from page index.
     * @private
     */
    getPageByIndex(index: number): PdfPage;
    /**
     * Gets a page by its `index` in the document.
     * @private
     */
    private getPage(index);
    /**
     * Gets the `index of` the page in the document.
     * @private
     */
    indexOf(page: PdfPage): number;
    /**
     * `Removes` the specified page.
     * @private
     */
    remove(page: PdfPage): PdfSection;
}
/**
 * The abstract base class for all pages,
 * `PdfPageBase` class provides methods and properties to create PDF pages and its elements.
 * @private
 */
export  abstract class PdfPageBase implements IPdfWrapper {
    /**
     * Collection of the `layers` of the page.
     * @private
     */
    private layerCollection;
    /**
     * Stores the instance of `PdfDictionary` class.
     * @private
     */
    private pageDictionary;
    /**
     * `Index` of the default layer.
     * @default -1.
     * @private
     */
    private defLayerIndex;
    /**
     * Local variable to store if page `updated`.
     * @default false.
     * @private
     */
    private modified;
    /**
     * Stores the instance of `PdfResources`.
     * @hidden
     * @private
     */
    private resources;
    /**
     * Instance of `DictionaryProperties` class.
     * @hidden
     * @private
     */
    protected dictionaryProperties: DictionaryProperties;
    /**
     * Specifies the current `section`.
     * @hidden
     * @private
     */
    private pdfSection;
    /**
     * Gets the `section` of a page.
     * @private
     */
    section: PdfSection;
    /**
     * Gets the page `dictionary`.
     * @private
     */
    readonly dictionary: PdfDictionary;
    /**
     * Gets the wrapped `element`.
     * @private
     */
    readonly element: IPdfPrimitive;
    /**
     * Gets the `default layer` of the page (Read only).
     * @private
     */
    readonly defaultLayer: PdfPageLayer;
    /**
     * Gets or sets `index of the default layer`.
     * @private
     */
    /**
     * Gets or sets` index of the default layer`.
     * @private
     */
    defaultLayerIndex: number;
    /**
     * Gets the collection of the page's `layers` (Read only).
     * @private
     */
    readonly layers: PdfPageLayerCollection;
    /**
     * Return an instance of `PdfResources` class.
     * @private
     */
    getResources(): PdfResources;
    /**
     * Gets `array of page's content`.
     * @private
     */
    readonly contents: PdfArray;
    /**
     * Sets the `resources`.
     * @private
     */
    setResources(res: PdfResources): void;
    /**
     * Gets the `size of the page` (Read only).
     * @private
     */
    readonly abstract size: SizeF;
    /**
     * Gets the `origin of the page`.
     * @private
     */
    readonly abstract origin: PointF;
    /**
     * Initializes a new instance of the `PdfPageBase` class.
     * @private
     */
    constructor(dictionary: PdfDictionary);
}
/**
 * PdfPageLayerCollection.ts class for EJ2-PDF
 */
/**
 * The class provides methods and properties to handle the collections of `PdfPageLayer`.
 */
export  class PdfPageLayerCollection extends PdfCollection {
    /**
     * Parent `page`.
     * @private
     */
    private page;
    /**
     * Stores the `number of first level layers` in the document.
     * @default 0
     * @private
     */
    private parentLayerCount;
    /**
     * Indicates if `Sublayer` is present.
     * @default false
     * @private
     */
    sublayer: boolean;
    /**
     * Stores the `optional content dictionary`.
     * @private
     */
    optionalContent: PdfDictionary;
    /**
     * Return the `PdfLayer` from the layer collection by index.
     * @private
     */
    items(index: number): PdfPageLayer;
    /**
     * Stores the `layer` into layer collection with specified index.
     * @private
     */
    items(index: number, value: PdfPageLayer): void;
    /**
     * Initializes a new instance of the `PdfPageLayerCollection` class
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `PdfPageLayerCollection` class
     * @private
     */
    constructor(page: PdfPageBase);
    /**
     * Creates a new `PdfPageLayer` and adds it to the end of the collection.
     * @private
     */
    add(): PdfPageLayer;
    /**
     * Creates a new `PdfPageLayer` and adds it to the end of the collection.
     * @private
     */
    add(layerName: string, visible: boolean): PdfPageLayer;
    /**
     * Creates a new `PdfPageLayer` and adds it to the end of the collection.
     * @private
     */
    add(layerName: string): PdfPageLayer;
    /**
     * Creates a new `PdfPageLayer` and adds it to the end of the collection.
     * @private
     */
    add(layer: PdfPageLayer): number;
    /**
     * Registers `layer` at the page.
     * @private
     */
    private addLayer(index, layer);
    /**
     * Inserts `PdfPageLayer` into the collection at specified index.
     * @private
     */
    insert(index: number, layer: PdfPageLayer): void;
    /**
     * Registers layer at the page.
     * @private
     */
    private insertLayer(index, layer);
    /**
     * `Parses the layers`.
     * @private
     */
    private parseLayers(loadedPage);
    /**
     * Returns `index of` the `PdfPageLayer` in the collection if exists, -1 otherwise.
     * @private
     */
    indexOf(layer: PdfPageLayer): number;
}
/**
 * PdfPageLayer.ts class for EJ2-PDF
 */
/**
 * The `PdfPageLayer` used to create layers in PDF document.
 * @private
 */
export  class PdfPageLayer implements IPdfWrapper {
    /**
     * Parent `page` of the layer.
     * @private
     */
    private pdfPage;
    /**
     * `Graphics context` of the layer.
     * @private
     */
    private pdfGraphics;
    /**
     * `Content` of the object.
     * @private
     */
    private content;
    /**
     * Indicates whether the layer should `clip page template` dimensions or not.
     * @private
     */
    private clipPageTemplates;
    /**
     * Local Variable to store the `color space` of the document.
     * @private
     */
    private pdfColorSpace;
    /**
     * Local Variable to store the `layer id`.
     * @private
     */
    private layerid;
    /**
     * Local Variable to store the `name`.
     * @private
     */
    private layerName;
    /**
     * Local Variable to set `visibility`.
     * @default true
     * @private
     */
    private isVisible;
    /**
     * Collection of the `layers` of the page.
     * @private
     */
    private layer;
    /**
     * Indicates if `Sublayer` is present.
     * @default false
     * @private
     */
    sublayer: boolean;
    /**
     * Local variable to store `length` of the graphics.
     * @default 0
     * @private
     */
    contentLength: number;
    /**
     * Stores the `print Option` dictionary.
     * @private
     */
    printOption: PdfDictionary;
    /**
     * Stores the `usage` dictionary.
     * @private
     */
    usage: PdfDictionary;
    /**
     * Instance for `PdfDictionaryProperties` Class.
     * @private
     */
    private dictionaryProperties;
    /**
     * Get or set the `color space`.
     * @private
     */
    colorSpace: PdfColorSpace;
    /**
     * Gets parent `page` of the layer.
     * @private
     */
    readonly page: PdfPageBase;
    /**
     * Gets and Sets the `id of the layer`.
     * @private
     */
    layerId: string;
    /**
     * Gets or sets the `name` of the layer.
     * @private
     */
    name: string;
    /**
     * Gets or sets the `visibility` of the layer.
     * @private
     */
    visible: boolean;
    /**
     * Gets `Graphics` context of the layer, used to draw various graphical content on layer.
     * @private
     */
    readonly graphics: PdfGraphics;
    /**
     * Gets the collection of `PdfPageLayer`, this collection handle by the class 'PdfPageLayerCollection'.
     * @private
     */
    readonly layers: PdfPageLayerCollection;
    /**
     * Initializes a new instance of the `PdfPageLayer` class with specified PDF page.
     * @private
     */
    constructor(page: PdfPageBase);
    /**
     * Initializes a new instance of the `PdfPageLayer` class with specified PDF page and PDF stream.
     * @private
     */
    constructor(page: PdfPageBase, stream: PdfStream);
    /**
     * Initializes a new instance of the `PdfPageLayer` class.
     * @private
     */
    constructor(page: PdfPageBase, clipPageTemplates: boolean);
    /**
     * `Adds` a new PDF Page layer.
     * @private
     */
    add(): PdfPageLayer;
    /**
     * Returns a value indicating the `sign` of a single-precision floating-point number.
     * @private
     */
    private sign(number);
    /**
     * `Initializes Graphics context` of the layer.
     * @private
     */
    private initializeGraphics(page);
    /**
     * Gets the wrapped `element`.
     * @private
     */
    readonly element: IPdfPrimitive;
}
/**
 * PdfPageSettings.ts class for EJ2-PDF
 */
/**
 * The class provides various `setting` related with PDF pages.
 */
export  class PdfPageSettings {
    /**
     * The page `margins`.
     * @private
     */
    private pageMargins;
    /**
     * The page `size`.
     * @default a4
     * @private
     */
    private pageSize;
    /**
     * The page `rotation angle`.
     * @default PdfPageRotateAngle.RotateAngle0
     * @private
     */
    private rotateAngle;
    /**
     * The page `orientation`.
     * @default PdfPageOrientation.Portrait
     * @private
     */
    private pageOrientation;
    /**
     * The page `origin`.
     * @default 0,0
     * @private
     */
    private pageOrigin;
    /**
     * Checks the Whether the `rotation` is applied or not.
     * @default false
     * @private
     */
    isRotation: boolean;
    /**
     * Initializes a new instance of the `PdfPageSettings` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `PdfPageSettings` class.
     * @private
     */
    constructor(margins: number);
    /**
     * Gets or sets the `size` of the page.
     * @private
     */
    size: SizeF;
    /**
     * Gets or sets the page `orientation`.
     * @private
     */
    orientation: PdfPageOrientation;
    /**
     * Gets or sets the `margins` of the page.
     * @private
     */
    margins: PdfMargins;
    /**
     * Gets or sets the `width` of the page.
     * @private
     */
    width: number;
    /**
     * Gets or sets the `height` of the page.
     * @private
     */
    height: number;
    /**
     * Gets or sets the `origin` of the page.
     * @private
     */
    origin: PointF;
    /**
     * Gets or sets the number of degrees by which the page should be `rotated` clockwise when displayed or printed.
     * @private
     */
    rotate: PdfPageRotateAngle;
    /**
     * `Update page size` depending on orientation.
     * @private
     */
    private updateSize(orientation);
    /**
     * Creates a `clone` of the object.
     * @private
     */
    clone(): PdfPageSettings;
    /**
     * Returns `size`, shrinked by the margins.
     * @private
     */
    getActualSize(): SizeF;
    /**
     * Sets `size` to the page aaccording to the orientation.
     * @private
     */
    private setSize(size);
}
/**
 * PdfPageSize.ts class for EJ2-PDF
 */
/**
 * Represents information about various predefined `page sizes`.
 */
export  class PdfPageSize {
    /**
     * Specifies the size of `letter`.
     * @private
     */
    static readonly letter: SizeF;
    /**
     * Specifies the size of `note`.
     * @private
     */
    static readonly note: SizeF;
    /**
     * Specifies the size of `legal`.
     * @private
     */
    static readonly legal: SizeF;
    /**
     * Specifies the size of `a0`.
     * @private
     */
    static readonly a0: SizeF;
    /**
     * Specifies the size of `a1`.
     * @private
     */
    static readonly a1: SizeF;
    /**
     * Specifies the size of `a2`.
     * @private
     */
    static readonly a2: SizeF;
    /**
     * Specifies the size of `a3`.
     * @private
     */
    static readonly a3: SizeF;
    /**
     * Specifies the size of `a4`.
     * @private
     */
    static readonly a4: SizeF;
    /**
     * Specifies the size of `a5`.
     * @private
     */
    static readonly a5: SizeF;
    /**
     * Specifies the size of `a6`.
     * @private
     */
    static readonly a6: SizeF;
    /**
     * Specifies the size of `a7`.
     * @private
     */
    static readonly a7: SizeF;
    /**
     * Specifies the size of `a8`.
     * @private
     */
    static readonly a8: SizeF;
    /**
     * Specifies the size of `a9`.
     * @private
     */
    static readonly a9: SizeF;
    /**
     * Specifies the size of `a10`.
     * @private
     */
    static readonly a10: SizeF;
    /**
     * Specifies the size of `b0`.
     * @private
     */
    static readonly b0: SizeF;
    /**
     * Specifies the size of `b1`.
     * @private
     */
    static readonly b1: SizeF;
    /**
     * Specifies the size of `b2`.
     * @private
     */
    static readonly b2: SizeF;
    /**
     * Specifies the size of `b3`.
     * @private
     */
    static readonly b3: SizeF;
    /**
     * Specifies the size of `b4`.
     * @private
     */
    static readonly b4: SizeF;
    /**
     * Specifies the size of `b5`.
     * @private
     */
    static readonly b5: SizeF;
    /**
     * Specifies the size of `archE`.
     * @private
     */
    static readonly archE: SizeF;
    /**
     * Specifies the size of `archD`.
     * @private
     */
    static readonly archD: SizeF;
    /**
     * Specifies the size of `archC`.
     * @private
     */
    static readonly archC: SizeF;
    /**
     * Specifies the size of `archB`.
     * @private
     */
    static readonly archB: SizeF;
    /**
     * Specifies the size of `archA`.
     * @private
     */
    static readonly archA: SizeF;
    /**
     * Specifies the size of `flsa`.
     * @private
     */
    static readonly flsa: SizeF;
    /**
     * Specifies the size of `halfLetter`.
     * @private
     */
    static readonly halfLetter: SizeF;
    /**
     * Specifies the size of `letter11x17`.
     * @private
     */
    static readonly letter11x17: SizeF;
    /**
     * Specifies the size of `ledger`.
     * @private
     */
    static readonly ledger: SizeF;
    /**
     * Initialize an instance for `PdfPageSize` class.
     * @private
     */
    constructor();
}
/**
 * PdfPageTemplateElement.ts class for EJ2-Pdf
 */
/**
 * Describes a `page template` object that can be used as header/footer, watermark or stamp.
 */
export  class PdfPageTemplateElement {
    /**
     * `Layer type` of the template.
     * @private
     */
    private isForeground;
    /**
     * `Docking style`.
     * @private
     */
    private dockStyle;
    /**
     * `Alignment style`.
     * @private
     */
    private alignmentStyle;
    /**
     * `PdfTemplate` object.
     * @private
     */
    private pdfTemplate;
    /**
     * Usage `type` of this template.
     * @private
     */
    private templateType;
    /**
     * `Location` of the template on the page.
     * @private
     */
    private currentLocation;
    /**
     * Gets or sets the `dock style` of the page template element.
     * @private
     */
    dock: PdfDockStyle;
    /**
     * Gets or sets `alignment` of the page template element.
     * @private
     */
    alignment: PdfAlignmentStyle;
    /**
     * Indicates whether the page template is located `in front of the page layers or behind of it`.
     * @private
     */
    foreground: boolean;
    /**
     * Indicates whether the page template is located `behind of the page layers or in front of it`.
     * @private
     */
    background: boolean;
    /**
     * Gets or sets `location` of the page template element.
     * @private
     */
    location: PointF;
    /**
     * Gets or sets `X` co-ordinate of the template element on the page.
     * @private
     */
    x: number;
    /**
     * Gets or sets `Y` co-ordinate of the template element on the page.
     * @private
     */
    y: number;
    /**
     * Gets or sets `size` of the page template element.
     * @private
     */
    size: SizeF;
    /**
     * Gets or sets `width` of the page template element.
     * @private
     */
    width: number;
    /**
     * Gets or sets `height` of the page template element.
     * @private
     */
    height: number;
    /**
     * Gets `graphics` context of the page template element.
     * @private
     */
    readonly graphics: PdfGraphics;
    /**
     * Gets Pdf `template` object.
     * @private
     */
    readonly template: PdfTemplate;
    /**
     * Gets or sets `type` of the usage of this page template.
     * @private
     */
    type: TemplateType;
    /**
     * Gets or sets `bounds` of the page template.
     * @public
     */
    bounds: RectangleF;
    /**
     * Creates a new page template.
     * @param bounds Bounds of the template.
     */
    constructor(bounds: RectangleF);
    /**
     * Creates a new page template.
     * @param bounds Bounds of the template.
     * @param page Page of the template.
     */
    constructor(bounds: RectangleF, page: PdfPage);
    /**
     * Creates a new page template.
     * @param location Location of the template.
     * @param size Size of the template.
     */
    constructor(location: PointF, size: SizeF);
    /**
     * Creates a new page template.
     * @param location Location of the template.
     * @param size Size of the template.
     * @param page Page of the template.
     */
    constructor(location: PointF, size: SizeF, page: PdfPage);
    /**
     * Creates a new page template.
     * @param size Size of the template.
     */
    constructor(size: SizeF);
    /**
     * Creates a new page template.
     * @param width Width of the template.
     * @param height Height of the template.
     */
    constructor(width: number, height: number);
    /**
     * Creates a new page template.
     * @param width Width of the template.
     * @param height Height of the template.
     * @param page The Current Page object.
     */
    constructor(width: number, height: number, page: PdfPage);
    /**
     * Creates a new page template.
     * @param x X co-ordinate of the template.
     * @param y Y co-ordinate of the template.
     * @param width Width of the template.
     * @param height Height of the template.
     */
    constructor(x: number, y: number, width: number, height: number);
    /**
     * Creates a new page template.
     * @param x X co-ordinate of the template.
     * @param y Y co-ordinate of the template.
     * @param width Width of the template.
     * @param height Height of the template.
     * @param page The Current Page object.
     */
    constructor(x: number, y: number, width: number, height: number, page: PdfPage);
    /**
     * `Updates Dock` property if template is used as header/footer.
     * @private
     */
    private updateDocking(type);
    /**
     * `Resets alignment` of the template.
     * @private
     */
    private resetAlignment();
    /**
     * `Sets alignment` of the template.
     * @private
     */
    private setAlignment(alignment);
    /**
     * Draws the template.
     * @private
     */
    draw(layer: PdfPageLayer, document: PdfDocument): void;
    /**
     * Calculates bounds of the page template.
     * @private
     */
    private calculateBounds(page, document);
    /**
     * Calculates bounds according to the alignment.
     * @private
     */
    private getAlignmentBounds(page, document);
    /**
     * Calculates bounds according to the alignment.
     * @private
     */
    private getSimpleAlignmentBounds(page, document);
    /**
     * Calculates bounds according to the alignment.
     * @private
     */
    private getTemplateAlignmentBounds(page, document);
    /**
     * Calculates bounds according to the docking.
     * @private
     */
    private getDockBounds(page, document);
    /**
     * Calculates bounds according to the docking.
     * @private
     */
    private getSimpleDockBounds(page, document);
    /**
     * Calculates template bounds basing on docking if template is a page template.
     * @private
     */
    private getTemplateDockBounds(page, document);
}
/**
 * Provides methods and properties to create pages and its elements.
 * `PdfPage` class inherited from the `PdfPageBase` class.
 * ```typescript
 * // create a new PDF document
 * let document : PdfDocument = new PdfDocument();
 * //
 * // add a new page to the document
 * let page1 : PdfPage = document.pages.add();
 * //
 * // set the font
 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
 * // create black brush
 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
 * // draw the text
 * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
 * // save the document
 * document.save('output.pdf');
 * // destroy the document
 * document.destroy();
 * ```
 */
export  class PdfPage extends PdfPageBase {
    /**
     * Checks whether the `progress is on`.
     * @hidden
     * @private
     */
    private isProgressOn;
    /**
     * Stores the instance of `PdfAnnotationCollection` class.
     * @hidden
     * @default null
     * @private
     */
    private annotationCollection;
    /**
     * Stores the instance of `PageBeginSave` event for Page Number Field.
     * @default null
     * @private
     */
    beginSave: Function;
    /**
     * Initialize the new instance for `PdfPage` class.
     * @private
     */
    constructor();
    /**
     * Gets current `document`.
     * @private
     */
    readonly document: PdfDocument;
    /**
     * Get the current `graphics`.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a new page to the document
     * let page1 : PdfPage = document.pages.add();
     * //
     * // get graphics
     * let graphics : PdfGraphics = page1.graphics;
     * //
     * // set the font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // create black brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * // draw the text
     * graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    readonly graphics: PdfGraphics;
    /**
     * Gets the `cross table`.
     * @private
     */
    readonly crossTable: PdfCrossTable;
    /**
     * Gets the size of the PDF page- Read only.
     * @public
     */
    readonly size: SizeF;
    /**
     * Gets the `origin` of the page.
     * @private
     */
    readonly origin: PointF;
    /**
     * Gets a collection of the `annotations` of the page- Read only.
     * @private
     */
    readonly annotations: PdfAnnotationCollection;
    /**
     * `Initializes` a page.
     * @private
     */
    private initialize();
    /**
     * Sets parent `section` to the page.
     * @private
     */
    setSection(section: PdfSection): void;
    /**
     * `Resets the progress`.
     * @private
     */
    resetProgress(): void;
    /**
     * Get the page size reduced by page margins and page template dimensions.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a pages to the document
     * let page1 : PdfPage = document.pages.add();
     * // create new standard font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // set brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * //
     * // set the specified point using `getClientSize` method
     * let point : PointF = new PointF(page1.getClientSize().width - 200, page1.getClientSize().height - 200);
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, point);
     * //
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    getClientSize(): SizeF;
    /**
     * Helper method to retrive the instance of `PageBeginSave` event for header and footer elements.
     * @private
     */
    pageBeginSave(): void;
    /**
     * Helper method to draw template elements.
     * @private
     */
    private drawPageTemplates(document);
}
/**
 * PdfSectionCollection.ts class for EJ2-PDF
 */
/**
 * Represents the `collection of the sections`.
 * @private
 */
export  class PdfSectionCollection implements IPdfWrapper {
    /**
     * Rotate factor for page `rotation`.
     * @default 90
     * @private
     */
    static readonly rotateFactor: number;
    /**
     * the current `document`.
     * @private
     */
    private pdfDocument;
    /**
     * `count` of the sections.
     * @private
     */
    private sectionCount;
    /**
     * @hidden
     * @private
     */
    private sections;
    /**
     * @hidden
     * @private
     */
    private sectionCollection;
    /**
     * @hidden
     * @private
     */
    private pages;
    /**
     * @hidden
     * @private
     */
    private dictionaryProperties;
    /**
     * Initializes a new instance of the `PdfSectionCollection` class.
     * @private
     */
    constructor(document: PdfDocument);
    /**
     * Gets the `Section` collection.
     */
    readonly section: PdfSection[];
    /**
     * Gets a parent `document`.
     * @private
     */
    readonly document: PdfDocument;
    /**
     * Gets the `number of sections` in a document.
     * @private
     */
    readonly count: number;
    /**
     * Gets the wrapped `element`.
     * @private
     */
    readonly element: IPdfPrimitive;
    /**
     * `Initializes the object`.
     * @private
     */
    private initialize();
    /**
     * Initializes a new instance of the `PdfSectionCollection` class.
     * @private
     */
    pdfSectionCollection(index: number): PdfSection;
    /**
     * In fills dictionary by the data from `Page settings`.
     * @private
     */
    private setPageSettings(container, pageSettings);
    /**
     * `Adds` the specified section.
     * @private
     */
    add(section?: PdfSection): number | PdfSection;
    /**
     * `Checks` if the section is within the collection.
     * @private
     */
    private checkSection(section);
    /**
     * Catches the Save event of the dictionary to `count the pages`.
     * @private
     */
    countPages(): number;
    /**
     * Catches the Save event of the dictionary to `count the pages`.
     * @hidden
     * @private
     */
    beginSave(): void;
}
/**
 * PdfSectionPageCollection.ts class for EJ2-PDF
 */
/**
 * Represents the `collection of pages in a section`.
 * @private
 */
export  class PdfSectionPageCollection {
    /**
     * @hidden
     * @private
     */
    private pdfSection;
    /**
     * Gets the `PdfPage` at the specified index.
     * @private
     */
    section: PdfSection;
    /**
     * Initializes a new instance of the `PdfSectionPageCollection` class.
     * @private
     */
    constructor(section: PdfSection);
    /**
     * `Determines` whether the specified page is within the collection.
     * @private
     */
    contains(page: PdfPage): boolean;
    /**
     * `Removes` the specified page from collection.
     * @private
     */
    remove(page: PdfPage): void;
    /**
     * `Adds` a new page from collection.
     * @private
     */
    add(): PdfPage;
}
/**
 * PdfSectionTemplate.ts class for EJ2-PDF
 */
/**
 * Represents a `page template` for all the pages in the section.
 */
export  class PdfSectionTemplate extends PdfDocumentTemplate {
    /**
     * `Left` settings.
     * @private
     */
    private leftValue;
    /**
     * `Top` settings.
     * @private
     */
    private topValue;
    /**
     * `Right` settings.
     * @private
     */
    private rightValue;
    /**
     * `Bottom` settings.
     * @private
     */
    private bottomValue;
    /**
     * `Other templates settings`.
     * @private
     */
    private stampValue;
    /**
     * Gets or sets value indicating whether parent `Left page template should be used or not`.
     * @private
     */
    applyDocumentLeftTemplate: boolean;
    /**
     * Gets or sets value indicating whether parent `Top page template should be used or not`.
     * @private
     */
    applyDocumentTopTemplate: boolean;
    /**
     * Gets or sets value indicating whether parent `Right page template should be used or not`.
     * @private
     */
    applyDocumentRightTemplate: boolean;
    /**
     * Gets or sets value indicating whether parent `Bottom page template should be used or not`.
     * @private
     */
    applyDocumentBottomTemplate: boolean;
    /**
     * Gets or sets value indicating whether the `stamp value` is true or not.
     * @private
     */
    applyDocumentStamps: boolean;
    /**
     * `Creates a new object`.
     * @private
     */
    constructor();
}
/**
 * PdfSection.ts class for EJ2-PDF
 */
/**
 * Represents a `section` entity. A section it's a set of the pages with similar page settings.
 */
export  class PdfSection implements IPdfWrapper {
    /**
     * @hidden
     * @private
     */
    private pageAdded;
    /**
     * the parent `document`.
     * @private
     */
    private pdfDocument;
    /**
     * Page `settings` of the pages in the section.
     * @private
     */
    private settings;
    /**
     * Internal variable to store `initial page settings`.
     * @private
     */
    initialSettings: PdfPageSettings;
    /**
     * @hidden
     * @private
     */
    pagesReferences: PdfArray;
    /**
     * @hidden
     * @private
     */
    private section;
    /**
     * @hidden
     * @private
     */
    private pageCount;
    /**
     * @hidden
     * @private
     */
    private sectionCollection;
    /**
     * @hidden
     * @private
     */
    private pdfPages;
    /**
     * Indicates if the `progress is turned on`.
     * @private
     */
    private isProgressOn;
    /**
     * Page `template` for the section.
     * @private
     */
    private pageTemplate;
    /**
     * @hidden
     * @private
     */
    private dictionaryProperties;
    /**
     * A virtual `collection of pages`.
     * @private
     */
    private pagesCollection;
    /**
     * Stores the information about the page settings of the current section.
     * @private
     */
    private state;
    /**
     * Initializes a new instance of the `PdfSection` class.
     * @private
     */
    constructor(document: PdfDocument);
    /**
     * Initializes a new instance of the `PdfSection` class.
     * @private
     */
    constructor(document: PdfDocument, pageSettings: PdfPageSettings);
    /**
     * Gets or sets the `parent`.
     * @private
     */
    parent: PdfSectionCollection;
    /**
     * Gets the `parent document`.
     * @private
     */
    readonly parentDocument: PdfDocumentBase;
    /**
     * Gets or sets the `page settings` of the section.
     * @private
     */
    pageSettings: PdfPageSettings;
    /**
     * Gets the wrapped `element`.
     * @private
     */
    readonly element: IPdfPrimitive;
    /**
     * Gets the `count` of the pages in the section.
     * @private
     */
    readonly count: number;
    /**
     * Gets or sets a `template` for the pages in the section.
     * @private
     */
    template: PdfSectionTemplate;
    /**
     * Gets the `document`.
     * @private
     */
    readonly document: PdfDocument;
    /**
     * Gets the collection of `pages` in a section (Read only)
     * @private
     */
    readonly pages: PdfSectionPageCollection;
    /**
     * `Return the page collection` of current section.
     * @private
     */
    getPages(): PdfPageBase[];
    /**
     * `Translates` point into native coordinates of the page.
     * @private
     */
    pointToNativePdf(page: PdfPage, point: PointF): PointF;
    /**
     * Sets the page setting of the current section.
     * @public
     * @param settings Instance of `PdfPageSettings`
     */
    setPageSettings(settings: PdfPageSettings): void;
    /**
     * `Initializes` the object.
     * @private
     */
    private initialize();
    /**
     * Checks whether any template should be printed on this layer.
     * @private
     * @param document The parent document.
     * @param page The parent page.
     * @param foreground Layer z-order.
     * @returns True - if some content should be printed on the layer, False otherwise.
     */
    containsTemplates(document: PdfDocument, page: PdfPage, foreground: boolean): boolean;
    /**
     * Returns array of the document templates.
     * @private
     * @param document The parent document.
     * @param page The parent page.
     * @param headers If true - return headers/footers, if false - return simple templates.
     * @param foreground If true - return foreground templates, if false - return background templates.
     * @returns Returns array of the document templates.
     */
    private getDocumentTemplates(document, page, headers, foreground);
    /**
     * `Adds` the specified page.
     * @private
     */
    add(page?: PdfPage): void | PdfPage;
    /**
     * `Checks the presence`.
     * @private
     */
    private checkPresence(page);
    /**
     * `Determines` whether the page in within the section.
     * @private
     */
    contains(page: PdfPage): boolean;
    /**
     * Get the `index of` the page.
     * @private
     */
    indexOf(page: PdfPage): number;
    /**
     * Call two event's methods.
     * @hidden
     * @private
     */
    private pageAddedMethod(page);
    /**
     * Called when the page has been added.
     * @hidden
     * @private
     */
    protected onPageAdded(args: PageAddedEventArgs): void;
    /**
     * Calculates actual `bounds` of the page.
     * @private
     */
    getActualBounds(page: PdfPage, includeMargins: boolean): RectangleF;
    /**
     * Calculates actual `bounds` of the page.
     * @private
     */
    getActualBounds(document: PdfDocument, page: PdfPage, includeMargins: boolean): RectangleF;
    /**
     * Calculates width of the `left indent`.
     * @private
     */
    getLeftIndentWidth(document: PdfDocument, page: PdfPage, includeMargins: boolean): number;
    /**
     * Calculates `Height` of the top indent.
     * @private
     */
    getTopIndentHeight(document: PdfDocument, page: PdfPage, includeMargins: boolean): number;
    /**
     * Calculates `width` of the right indent.
     * @private
     */
    getRightIndentWidth(document: PdfDocument, page: PdfPage, includeMargins: boolean): number;
    /**
     * Calculates `Height` of the bottom indent.
     * @private
     */
    getBottomIndentHeight(document: PdfDocument, page: PdfPage, includeMargins: boolean): number;
    /**
     * `Removes` the page from the section.
     * @private
     */
    remove(page: PdfPage): void;
    /**
     * In fills dictionary by the data from `Page settings`.
     * @private
     */
    private applyPageSettings(container, parentSettings, state);
    /**
     * Catches the Save event of the dictionary.
     * @hidden
     * @private
     */
    beginSave(state: PageSettingsState, writer: IPdfWriter): void;
    /**
     * Draws page templates on the page.
     * @private
     */
    drawTemplates(page: PdfPage, layer: PdfPageLayer, document: PdfDocument, foreground: boolean): void;
    /**
     * Draws page templates on the page.
     * @private
     */
    private drawTemplatesHelper(layer, document, templates);
}
export  class PageSettingsState {
    /**
     * @hidden
     * @private
     */
    private pageOrientation;
    /**
     * @hidden
     * @private
     */
    private pageRotate;
    /**
     * @hidden
     * @private
     */
    private pageSize;
    /**
     * @hidden
     * @private
     */
    private pageOrigin;
    /**
     * @hidden
     * @private
     */
    orientation: PdfPageOrientation;
    /**
     * @hidden
     * @private
     */
    rotate: PdfPageRotateAngle;
    /**
     * @hidden
     * @private
     */
    size: SizeF;
    /**
     * @hidden
     * @private
     */
    origin: PointF;
    /**
     * New instance to store the `PageSettings`.
     * @private
     */
    constructor(document: PdfDocument);
}
/**
 * Primitives classes
 * @hidden
 */
/**
 * PdfArray.ts class for EJ2-PDF
 */
/**
 * `PdfArray` class is used to perform array related primitive operations.
 * @private
 */
export  class PdfArray implements IPdfPrimitive {
    /**
     * `startMark` - '['
     * @private
     */
    startMark: string;
    /**
     * `endMark` - ']'.
     * @private
     */
    endMark: string;
    /**
     * The `elements` of the PDF array.
     * @private
     */
    private internalElements;
    /**
     * Indicates if the array `was changed`.
     * @private
     */
    private bChanged;
    /**
     * Shows the type of object `status` whether it is object registered or other status;
     * @private
     */
    private status9;
    /**
     * Indicates if the object is currently in `saving state` or not.
     * @private
     */
    private isSaving9;
    /**
     * Holds the `index` number of the object.
     * @private
     */
    private index9;
    /**
     * Internal variable to store the `position`.
     * @default -1
     * @private
     */
    private position9;
    /**
     * Internal variable to hold `PdfCrossTable` reference.
     * @private
     */
    private pdfCrossTable;
    /**
     * Internal variable to hold `cloned object`.
     * @default null
     * @private
     */
    private clonedObject9;
    /**
     * Gets the `IPdfSavable` at the specified index.
     * @private
     */
    items(index: number): IPdfPrimitive;
    /**
     * Gets the `count`.
     * @private
     */
    readonly count: number;
    /**
     * Gets or sets the `Status` of the specified object.
     * @private
     */
    status: ObjectStatus;
    /**
     * Gets or sets a value indicating whether this document `is saving` or not.
     * @private
     */
    isSaving: boolean;
    /**
     * Returns `cloned object`.
     * @private
     */
    readonly clonedObject: IPdfPrimitive;
    /**
     * Gets or sets the `position` of the object.
     * @private
     */
    position: number;
    /**
     * Gets or sets the `index` value of the specified object.
     * @private
     */
    objectCollectionIndex: number;
    /**
     * Returns `PdfCrossTable` associated with the object.
     * @private
     */
    readonly CrossTable: PdfCrossTable;
    /**
     * Gets the `elements` of the Pdf Array.
     * @private
     */
    readonly elements: IPdfPrimitive[];
    /**
     * Initializes a new instance of the `PdfArray` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `PdfArray` class.
     * @private
     */
    constructor(array: PdfArray | number[]);
    /**
     * `Adds` the specified element to the PDF array.
     * @private
     */
    add(element: IPdfPrimitive): void;
    /**
     * `Marks` the object changed.
     * @private
     */
    private markedChange();
    /**
     * `Determines` whether the specified element is within the array.
     * @private
     */
    contains(element: IPdfPrimitive): boolean;
    /**
     * Returns the `primitive object` of input index.
     * @private
     */
    getItems(index: number): IPdfPrimitive;
    /**
     * `Saves` the object using the specified writer.
     * @private
     */
    save(writer: IPdfWriter): void;
    /**
     * Creates a `copy of PdfArray`.
     * @private
     */
    clone(crossTable: PdfCrossTable): IPdfPrimitive;
    /**
     * Creates filled PDF array `from the rectangle`.
     * @private
     */
    static fromRectangle(bounds: RectangleF): PdfArray;
    /**
     * `Inserts` the element into the array.
     * @private
     */
    insert(index: number, element: IPdfPrimitive): void;
    /**
     * `Checks whether array contains the element`.
     * @private
     */
    indexOf(element: IPdfPrimitive): number;
    /**
     * `Removes` element from the array.
     * @private
     */
    remove(element: IPdfPrimitive): void;
    /**
     * `Remove` the element from the array by its index.
     * @private
     */
    removeAt(index: number): void;
    /**
     * `Clear` the array.
     * @private
     */
    clear(): void;
    /**
     * `Marks` the object changed.
     * @private
     */
    markChanged(): void;
}
/**
 * PdfBoolean.ts class for EJ2-PDF
 */
/**
 * `PdfBoolean` class is used to perform boolean related primitive operations.
 * @private
 */
export  class PdfBoolean implements IPdfPrimitive {
    /**
     * Shows the type of object `status` whether it is object registered or other status;
     * @private
     */
    private objectStatus;
    /**
     * Indicates if the object `is currently in saving state` or not.
     * @private
     */
    private saving;
    /**
     * Holds the `index` number of the object.
     * @private
     */
    private index;
    /**
     * The `value` of the PDF boolean.
     * @private
     */
    private value;
    /**
     * Internal variable to store the `position`.
     * @default -1
     * @private
     */
    private currentPosition;
    /**
     * Initializes a new instance of the `PdfBoolean` class.
     * @private
     */
    constructor(value: boolean);
    /**
     * Gets or sets the `Status` of the specified object.
     * @private
     */
    status: ObjectStatus;
    /**
     * Gets or sets a value indicating whether this document `is saving` or not.
     * @private
     */
    isSaving: boolean;
    /**
     * Gets or sets the `index` value of the specified object.
     * @private
     */
    objectCollectionIndex: number;
    /**
     * Gets or sets the `position` of the object.
     * @private
     */
    position: number;
    /**
     * Returns `cloned object`.
     * @private
     */
    readonly clonedObject: IPdfPrimitive;
    /**
     * `Saves` the object using the specified writer.
     * @private
     */
    save(writer: IPdfWriter): void;
    /**
     * Creates a `copy of PdfBoolean`.
     * @private
     */
    clone(crossTable: PdfCrossTable): IPdfPrimitive;
    /**
     * Converts `boolean to string` - 0/1 'true'/'false'.
     * @private
     */
    private boolToStr(value);
}
/**
 * PdfDictionary.ts class for EJ2-PDF
 */
/**
 * `PdfDictionary` class is used to perform primitive operations.
 * @private
 */
export  class PdfDictionary implements IPdfPrimitive {
    /**
     * Indicates if the object was `changed`.
     * @private
     */
    private bChanged;
    /**
     * Internal variable to store the `position`.
     * @default -1
     * @private
     */
    private position7;
    /**
     * Flag is dictionary need to `encrypt`.
     * @private
     */
    private encrypt;
    /**
     * The `IPdfSavable` with the specified key.
     * @private
     */
    private primitiveItems;
    /**
     * `Start marker` for dictionary.
     * @private
     */
    private readonly prefix;
    /**
     * `End marker` for dictionary.
     * @private
     */
    private readonly suffix;
    /**
     * @hidden
     * @private
     */
    private resources;
    /**
     * Shows the type of object `status` whether it is object registered or other status.
     * @private
     */
    private status7;
    /**
     * Indicates if the object `is currently in saving state` or not.
     * @private
     */
    private isSaving7;
    /**
     * Holds the `index` number of the object.
     * @private
     */
    private index7;
    /**
     * Internal variable to hold `cloned object`.
     * @default null
     * @private
     */
    private readonly object;
    /**
     * Flag for PDF file formar 1.5 is dictionary `archiving` needed.
     * @default true
     * @private
     */
    private archive;
    /**
     * @hidden
     * @private
     */
    private tempPageCount;
    /**
     * @hidden
     * @private
     */
    protected dictionaryProperties: DictionaryProperties;
    /**
     * Event. Raise before the object saves.
     * @public
     */
    pageBeginDrawTemplate: SaveTemplateEventHandler;
    /**
     * Event. Raise `before the object saves`.
     * @private
     */
    beginSave: SaveSectionCollectionEventHandler;
    /**
     * Event. Raise `after the object saved`.
     * @private
     */
    endSave: SaveSectionCollectionEventHandler;
    /**
     * @hidden
     * @private
     */
    sectionBeginSave: SaveSectionEventHandler;
    /**
     * @hidden
     * @private
     */
    annotationBeginSave: SaveAnnotationEventHandler;
    /**
     * @hidden
     * @private
     */
    annotationEndSave: SaveAnnotationEventHandler;
    /**
     * Gets or sets the `IPdfSavable` with the specified key.
     * @private
     */
    readonly items: Dictionary<string, IPdfPrimitive>;
    /**
     * Gets or sets the `Status` of the specified object.
     * @private
     */
    status: ObjectStatus;
    /**
     * Gets or sets a value indicating whether this document `is saving` or not.
     * @private
     */
    isSaving: boolean;
    /**
     * Gets or sets the `index` value of the specified object.
     * @private
     */
    objectCollectionIndex: number;
    /**
     * Returns `cloned object`.
     * @private
     */
    readonly clonedObject: IPdfPrimitive;
    /**
     * Gets or sets the `position` of the object.
     * @private
     */
    position: number;
    /**
     * Gets the `count`.
     * @private
     */
    readonly Count: number;
    /**
     * Collection of `items` in the object.
     * @private
     */
    readonly Dictionary: PdfDictionary;
    /**
     * Get flag if need to `archive` dictionary.
     * @private
     */
    getArchive(): boolean;
    /**
     * Set flag if need to `archive` dictionary.
     * @private
     */
    setArchive(value: boolean): void;
    /**
     * Sets flag if `encryption` is needed.
     * @private
     */
    setEncrypt(value: boolean): void;
    /**
     * Gets flag if `encryption` is needed.
     * @private
     */
    getEncrypt(): boolean;
    /**
     * Initializes a new empty instance of the `PdfDictionary` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new empty instance of the `PdfDictionary` class.
     * @private
     */
    constructor(dictionary: PdfDictionary);
    /**
     * `Freezes` the changes.
     * @private
     */
    freezeChanges(freezer: Object): void;
    /**
     * Creates a `copy of PdfDictionary`.
     * @private
     */
    clone(crossTable: PdfCrossTable): IPdfPrimitive;
    /**
     * `Mark` this instance modified.
     * @private
     */
    modify(): void;
    /**
     * `Removes` the specified key.
     * @private
     */
    remove(key: PdfName | string): void;
    /**
     * `Determines` whether the dictionary contains the key.
     * @private
     */
    containsKey(key: string | PdfName): boolean;
    /**
     * Raises event `BeginSave`.
     * @private
     */
    protected onBeginSave(): void;
    /**
     * Raises event 'BeginSave'.
     * @private
     */
    protected onTemplateBeginSave(): void;
    /**
     * Raises event `BeginSave`.
     * @private
     */
    protected onBeginAnnotationSave(): void;
    /**
     * Raises event `BeginSave`.
     * @private
     */
    protected onSectionBeginSave(writer: IPdfWriter): void;
    /**
     * `Saves` the object using the specified writer.
     * @private
     */
    save(writer: IPdfWriter): void;
    /**
     * `Saves` the object using the specified writer.
     * @private
     */
    save(writer: IPdfWriter, bRaiseEvent: boolean): void;
    /**
     * `Save dictionary items`.
     * @private
     */
    private saveItems(writer);
}
export  class SaveSectionCollectionEventHandler {
    /**
     * @hidden
     * @private
     */
    sender: PdfSectionCollection;
    /**
     * New instance for `save section collection event handler` class.
     * @private
     */
    constructor(sender: PdfSectionCollection);
}
export  class SaveAnnotationEventHandler {
    /**
     * @hidden
     * @private
     */
    sender: PdfAnnotation;
    /**
     * New instance for `save annotation event handler` class.
     * @private
     */
    constructor(sender: PdfAnnotation);
}
export  class SaveSectionEventHandler {
    /**
     * @hidden
     * @private
     */
    sender: PdfSection;
    /**
     * @hidden
     * @private
     */
    state: PageSettingsState;
    /**
     * New instance for `save section event handler` class.
     * @private
     */
    constructor(sender: PdfSection, state: PageSettingsState);
}
/**
 * SaveTemplateEventHandler class used to store information about template elements.
 * @private
 * @hidden
 */
export  class SaveTemplateEventHandler {
    /**
     * @public
     * @hidden
     */
    sender: PdfPage;
    /**
     * New instance for save section collection event handler class.
     * @public
     */
    constructor(sender: PdfPage);
}
/**
 * PdfName.ts class for EJ2-PDF
 */
/**
 * `PdfName` class is used to perform name (element names) related primitive operations.
 * @private
 */
export  class PdfName implements IPdfPrimitive {
    /**
     * `Start symbol` of the name object.
     * @default /
     * @private
     */
    readonly stringStartMark: string;
    /**
     * PDF `special characters`.
     * @private
     */
    static delimiters: string;
    /**
     * The symbols that are not allowed in PDF names and `should be replaced`.
     * @private
     */
    private static readonly replacements;
    /**
     * `Value` of the element.
     * @private
     */
    private internalValue;
    /**
     * Shows the type of object `status` whether it is object registered or other status;
     * @private
     */
    private status6;
    /**
     * Indicates if the object is currently in `saving state or not`.
     * @default false
     * @private
     */
    private isSaving6;
    /**
     * Holds the `index` number of the object.
     * @private
     */
    private index6;
    /**
     * Internal variable to store the `position`.
     * @default -1
     * @private
     */
    private position6;
    /**
     * Initializes a new instance of the `PdfName` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `PdfName` class.
     * @private
     */
    constructor(value: string);
    /**
     * Gets or sets the `Status` of the specified object.
     * @private
     */
    status: ObjectStatus;
    /**
     * Gets or sets a value indicating whether this document `is saving` or not.
     * @private
     */
    isSaving: boolean;
    /**
     * Gets or sets the `index` value of the specified object.
     * @private
     */
    objectCollectionIndex: number;
    /**
     * Gets or sets the `position` of the object.
     * @private
     */
    position: number;
    /**
     * Returns `cloned object`.
     * @private
     */
    readonly clonedObject: IPdfPrimitive;
    /**
     * Gets or sets the `value` of the object.
     * @private
     */
    value: string;
    /**
     * `Saves` the name using the specified writer.
     * @private
     */
    save(writer: IPdfWriter): void;
    /**
     * Gets `string` representation of the primitive.
     * @private
     */
    toString(): string;
    /**
     * Creates a `copy of PdfName`.
     * @private
     */
    clone(crossTable: PdfCrossTable): IPdfPrimitive;
    /**
     * Replace some characters with its `escape sequences`.
     * @private
     */
    escapeString(stringValue: string): string;
    /**
     * Replace a symbol with its code with the precedence of the `sharp sign`.
     * @private
     */
    private normalizeValue(value, c?);
}
/**
 * PdfNumber.ts class for EJ2-PDF
 */
/**
 * `PdfNumber` class is used to perform number related primitive operations.
 * @private
 */
export  class PdfNumber implements IPdfPrimitive {
    /**
     * Shows the type of object `status` whether it is object registered or other status;
     * @private
     */
    private status5;
    /**
     * Indicates if the object is currently in `saving state or not`.
     * @private
     */
    private isSaving5;
    /**
     * Holds the `index` number of the object.
     * @private
     */
    private index5;
    /**
     * Stores the `int` value.
     * @private
     */
    private value;
    /**
     * Sotres the `position`.
     * @default -1
     * @private
     */
    private position5;
    /**
     * The `integer` value.
     * @private
     */
    private integer;
    /**
     * Initializes a new instance of the `PdfNumber` class.
     * @private
     */
    constructor(value: number);
    /**
     * Gets or sets the `integer` value.
     * @private
     */
    intValue: number;
    /**
     * Gets or sets a value indicating whether this instance `is integer`.
     * @private
     */
    isInteger: boolean;
    /**
     * Gets or sets the `Status` of the specified object.
     * @private
     */
    status: ObjectStatus;
    /**
     * Gets or sets a value indicating whether this document `is saving` or not.
     * @private
     */
    isSaving: boolean;
    /**
     * Gets or sets the `index` value of the specified object.
     * @private
     */
    objectCollectionIndex: number;
    /**
     * Gets or sets the `position` of the object.
     * @private
     */
    position: number;
    /**
     * Returns `cloned object`.
     * @private
     */
    readonly clonedObject: IPdfPrimitive;
    /**
     * `Saves the object`.
     * @private
     */
    save(writer: IPdfWriter): void;
    /**
     * Creates a `copy of PdfNumber`.
     * @private
     */
    clone(crossTable: PdfCrossTable): IPdfPrimitive;
    /**
     * Converts a `float value to a string` using Adobe PDF rules.
     * @private
     */
    static floatToString(number: number): string;
    /**
     * Determines the `minimum of the three values`.
     * @private
     */
    static min(x: number, y: number, z: number): number;
}
/**
 * PdfReference.ts and PdfReferenceHolder.ts class for EJ2-PDF
 */
/**
 * `PdfReference` class is used to perform reference related primitive operations.
 * @private
 */
export  class PdfReference implements IPdfPrimitive {
    /**
     * Indicates if the object is currently in `saving stat`e or not.
     * @private
     */
    private isSaving3;
    /**
     * Shows the type of object `status` whether it is object registered or other status;
     * @private
     */
    private status3;
    /**
     * Holds the `index` number of the object.
     * @default -1
     * @private
     */
    private index3;
    /**
     * Internal variable to store the `position`.
     * @default -1
     * @private
     */
    private position3;
    /**
     * Holds the `object number`.
     * @default 0
     * @private
     */
    readonly objNumber: number;
    /**
     * Holds the `generation number` of the object.
     * @default 0
     * @private
     */
    readonly genNumber: number;
    /**
     * Gets or sets the `Status` of the specified object.
     * @private
     */
    status: ObjectStatus;
    /**
     * Gets or sets a value indicating whether this document `is saving` or not.
     * @private
     */
    isSaving: boolean;
    /**
     * Gets or sets the `index` value of the specified object.
     * @private
     */
    objectCollectionIndex: number;
    /**
     * Gets or sets the `position` of the object.
     * @private
     */
    position: number;
    /**
     * Returns `cloned object`.
     * @private
     */
    readonly clonedObject: IPdfPrimitive;
    /**
     * `Saves` the object.
     * @private
     */
    save(writer: IPdfWriter): void;
    /**
     * Initialize the `PdfReference` class.
     * @private
     */
    constructor(objNumber: number, genNumber: number);
    /**
     * Initialize the `PdfReference` class.
     * @private
     */
    constructor(objNumber: string, genNumber: string);
    /**
     * Returns a `string` representing the object.
     * @private
     */
    toString(): string;
    /**
     * Creates a `deep copy` of the IPdfPrimitive object.
     * @private
     */
    clone(crossTable: PdfCrossTable): IPdfPrimitive;
}
/**
 * `PdfReferenceHolder` class is used to perform reference holder related primitive operations.
 * @private
 */
export  class PdfReferenceHolder implements IPdfPrimitive, IPdfWrapper {
    /**
     * Indicates if the object is currently in `saving state or not`.
     * @private
     */
    private isSaving4;
    /**
     * Shows the type of object `status` whether it is object registered or other status;
     * @private
     */
    private status4;
    /**
     * Holds the `index` number of the object.
     * @default -1
     * @private
     */
    private index4;
    /**
     * Internal variable to store the `position`.
     * @default -1
     * @private
     */
    private position4;
    /**
     * The `object` which the reference is of.
     * @private
     */
    private primitiveObject;
    /**
     * The `reference` to the object, which was read from the PDF document.
     * @private
     */
    private pdfReference;
    /**
     * The `cross-reference table`, which the object is within.
     * @private
     */
    private crossTable;
    /**
     * The `index` of the object within the object collection.
     * @default -1
     * @private
     */
    private objectIndex;
    /**
     * @hidden
     * @private
     */
    private dictionaryProperties;
    /**
     * Gets or sets the `Status` of the specified object.
     * @private
     */
    status: ObjectStatus;
    /**
     * Gets or sets a value indicating whether this document `is saving` or not.
     * @private
     */
    isSaving: boolean;
    /**
     * Gets or sets the `index` value of the specified object.
     * @private
     */
    objectCollectionIndex: number;
    /**
     * Gets or sets the `position` of the object.
     * @private
     */
    position: number;
    /**
     * Returns `cloned object`.
     * @private
     */
    readonly clonedObject: IPdfPrimitive;
    /**
     * Gets the `object` the reference is of.
     * @private
     */
    readonly object: IPdfPrimitive;
    /**
     * Gets the `reference`.
     * @private
     */
    readonly reference: PdfReference;
    /**
     * Gets the `index` of the object.
     * @private
     */
    readonly index: number;
    /**
     * Gets the `element`.
     * @private
     */
    readonly element: IPdfPrimitive;
    /**
     * Initializes the `PdfReferenceHolder` class instance with an object.
     * @private
     */
    constructor(obj1: IPdfWrapper);
    /**
     * Initializes the `PdfReferenceHolder` class instance with an object.
     * @private
     */
    constructor(obj1: IPdfPrimitive);
    /**
     * Initializes the `PdfReferenceHolder` class instance with an object.
     * @private
     */
    constructor(obj1: PdfReference, obj2: PdfCrossTable);
    /**
     * `Writes` a reference into a PDF document.
     * @private
     */
    save(writer: IPdfWriter): void;
    /**
     * Creates a `copy of PdfReferenceHolder`.
     * @private
     */
    clone(crossTable: PdfCrossTable): IPdfPrimitive;
}
/**
 * PdfStream.ts class for EJ2-PDF
 */
/**
 * `PdfStream` class is used to perform stream related primitive operations.
 * @private
 */
export  class PdfStream extends PdfDictionary {
    /**
     * @hidden
     * @private
     */
    private readonly dicPrefix;
    /**
     * @hidden
     * @private
     */
    private readonly dicSuffix;
    /**
     * @hidden
     * @private
     */
    private dataStream2;
    /**
     * @hidden
     * @private
     */
    private blockEncryption2;
    /**
     * @hidden
     * @private
     */
    private bDecrypted2;
    /**
     * @hidden
     * @private
     */
    private bCompress2;
    /**
     * @hidden
     * @private
     */
    private bEncrypted2;
    /**
     * Internal variable to hold `cloned object`.
     * @private
     */
    private clonedObject2;
    /**
     * @hidden
     * @private
     */
    private bCompress;
    /**
     * @hidden
     * @private
     */
    private isImageStream;
    /**
     * Initialize an instance for `PdfStream` class.
     * @private
     */
    constructor();
    /**
     * Initialize an instance for `PdfStream` class.
     * @private
     */
    constructor(dictionary: PdfDictionary, data: string[]);
    /**
     * Gets the `internal` stream.
     * @private
     */
    internalStream: string[];
    /**
     * Gets or sets 'is image' flag.
     * @private
     */
    isImage: boolean;
    /**
     * Gets or sets `compression` flag.
     * @private
     */
    compress: boolean;
    /**
     * Gets or sets the `data`.
     * @private
     */
    data: string[];
    /**
     * `Clear` the internal stream.
     * @private
     */
    clearStream(): void;
    /**
     * `Writes` the specified string.
     * @private
     */
    write(text: string): void;
    /**
     * `Compresses the content` if it's required.
     * @private
     */
    private compressContent(data, writer);
    /**
     * `Adds a filter` to the filter array.
     * @private
     */
    addFilter(filterName: string): void;
    /**
     * `Saves` the object using the specified writer.
     * @private
     */
    save(writer: IPdfWriter): void;
    /**
     * Converts `bytes to string`.
     * @private
     */
    static bytesToString(byteArray: number[]): string;
}
/**
 * PdfString.ts class for EJ2-PDF
 */
/**
 * `PdfString` class is used to perform string related primitive operations.
 * @private
 */
export  namespace InternalEnum {
    /**
     * public Enum for `ForceEncoding`.
     * @private
     */
    enum ForceEncoding {
        /**
         * Specifies the type of `None`.
         * @private
         */
        None = 0,
        /**
         * Specifies the type of `Ascii`.
         * @private
         */
        Ascii = 1,
        /**
         * Specifies the type of `Unicode`.
         * @private
         */
        Unicode = 2,
    }
}
export  class PdfString implements IPdfPrimitive {
    /**
     * `General markers` for string.
     * @private
     */
    static readonly stringMark: string;
    /**
     * `Hex markers` for string.
     * @private
     */
    static readonly hexStringMark: string;
    /**
     * Format of password data.
     * @private
     */
    private static readonly hexFormatPattern;
    /**
     * Value of the object.
     * @private
     */
    private stringValue;
    /**
     * The byte data of the string.
     * @private
     */
    private data;
    /**
     * Value indicating whether the string was converted to hex.
     * @default false
     * @private
     */
    private bHex;
    /**
     * Shows the type of object `status` whether it is object registered or other status;
     * @private
     */
    private status1;
    /**
     * Indicates if the object is currently in `saving state or not`.
     * @private
     */
    private isSaving1;
    /**
     * Internal variable to store the `position`.
     * @default -1
     * @private
     */
    private position1;
    /**
     * Internal variable to hold `PdfCrossTable` reference.
     * @private
     */
    private crossTable;
    /**
     * Internal variable to hold `cloned object`.
     * @default null
     * @private
     */
    private clonedObject1;
    /**
     * Indicates whether to check if the value `has unicode characters`.
     * @private
     */
    private bConverted;
    /**
     * Indicates whether we should convert `data to Unicode`.
     * @private
     */
    private bForceEncoding;
    /**
     * `Shows` if the data of the stream was decrypted.
     * @default false
     * @private
     */
    private bDecrypted;
    /**
     * Holds the `index` number of the object.
     * @private
     */
    private index1;
    /**
     * Shows if the data of the stream `was decrypted`.
     * @default false
     * @private
     */
    private isParentDecrypted;
    /**
     * Gets a value indicating whether the object is `packed or not`.
     * @default false
     * @private
     */
    private isPacked;
    /**
     * @hidden
     * @private
     */
    isFormField: boolean;
    /**
     * @hidden
     * @private
     */
    isColorSpace: boolean;
    /**
     * @hidden
     * @private
     */
    isHexString: boolean;
    /**
     * @hidden
     * @private
     */
    private encodedBytes;
    /**
     * Initializes a new instance of the `PdfString` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `PdfString` class.
     * @private
     */
    constructor(value: string);
    /**
     * Gets a value indicating whether string is in `hex`.
     * @private
     */
    readonly hex: boolean;
    /**
     * Gets or sets string `value` of the object.
     * @private
     */
    value: string;
    /**
     * Gets or sets the `Status` of the specified object.
     * @private
     */
    status: ObjectStatus;
    /**
     * Gets or sets a value indicating whether this document `is saving` or not.
     * @private
     */
    isSaving: boolean;
    /**
     * Gets or sets the `index` value of the specified object.
     * @private
     */
    objectCollectionIndex: number;
    /**
     * Returns `cloned object`.
     * @private
     */
    readonly clonedObject: IPdfPrimitive;
    /**
     * Gets or sets the `position` of the object.
     * @private
     */
    position: number;
    /**
     * Returns `PdfCrossTable` associated with the object.
     * @private
     */
    readonly CrossTable: PdfCrossTable;
    /**
     * Converts `bytes to string using hex format` for representing string.
     * @private
     */
    static bytesToHex(bytes: number[]): string;
    /**
     * `Saves` the object using the specified writer.
     * @private
     */
    save(writer: IPdfWriter): void;
    /**
     * Creates a `copy of PdfString`.
     * @private
     */
    clone(crossTable: PdfCrossTable): IPdfPrimitive;
}

/**
 * `PdfGridCell.ts` class for EJ2-PDF
 */
/**
 * `PdfGridCell` class represents the schema of a cell in a 'PdfGrid'.
 */
export  class PdfGridCell {
    /**
     * The `row span`.
     * @private
     */
    private gridRowSpan;
    /**
     * The `column span`.
     * @private
     */
    private colSpan;
    /**
     * Specifies the current `row`.
     * @private
     */
    private gridRow;
    /**
     * The actual `value` of the cell.
     * @private
     */
    private objectValue;
    /**
     * Current cell `style`.
     * @private
     */
    private cellStyle;
    /**
     * `Width` of the cell.
     * @default 0
     * @private
     */
    private cellWidth;
    /**
     * `Height` of the cell.
     * @default 0
     * @private
     */
    private cellHeight;
    /**
     * The `remaining string`.
     * @private
     */
    private remaining;
    /**
     * Specifies weather the `cell is drawn`.
     * @default true
     * @private
     */
    private finsh;
    /**
     * `StringFormat` of the cell.
     * @private
     */
    private format;
    /**
     * The `remaining height` of row span.
     * @default 0
     * @private
     */
    rowSpanRemainingHeight: number;
    private internalIsCellMergeContinue;
    private internalIsRowMergeContinue;
    private internalIsCellMergeStart;
    private internalIsRowMergeStart;
    /**
     * Initializes a new instance of the `PdfGridCell` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `PdfGridCell` class.
     * @private
     */
    constructor(row: PdfGridRow);
    isCellMergeContinue: boolean;
    isRowMergeContinue: boolean;
    isCellMergeStart: boolean;
    isRowMergeStart: boolean;
    /**
     * Gets or sets the `remaining string` after the row split between pages.
     * @private
     */
    remainingString: string;
    /**
     * Gets or sets the `string format`.
     * @private
     */
    stringFormat: PdfStringFormat;
    /**
     * Gets or sets the parent `row`.
     * @private
     */
    row: PdfGridRow;
    /**
     * Gets or sets the `value` of the cell.
     * @private
     */
    value: Object;
    /**
     * Gets or sets a value that indicates the total number of rows that cell `spans` within a PdfGrid.
     * @private
     */
    rowSpan: number;
    /**
     * Gets or sets the cell `style`.
     * @private
     */
    style: PdfGridCellStyle;
    /**
     * Gets the `height` of the PdfGrid cell.[Read-Only].
     * @private
     */
    height: number;
    /**
     * Gets or sets a value that indicates the total number of columns that cell `spans` within a PdfGrid.
     * @private
     */
    columnSpan: number;
    /**
     * Gets the `width` of the PdfGrid cell.[Read-Only].
     * @private
     */
    width: number;
    /**
     * `Calculates the width`.
     * @private
     */
    private measureWidth();
    /**
     * Draw the `cell background`.
     * @private
     */
    drawCellBackground(graphics: PdfGraphics, bounds: RectangleF): void;
    /**
     * `Adjusts the text layout area`.
     * @private
     */
    private adjustContentLayoutArea(bounds);
    /**
     * `Draws` the specified graphics.
     * @private
     */
    draw(graphics: PdfGraphics, bounds: RectangleF, cancelSubsequentSpans: boolean): PdfStringLayoutResult;
    /**
     * Draws the `cell border` constructed by drawing lines.
     * @private
     */
    drawCellBorders(graphics: PdfGraphics, bounds: RectangleF): void;
    /**
     * `Adjusts the outer layout area`.
     * @private
     */
    private adjustOuterLayoutArea(bounds, g);
    /**
     * Gets the `text font`.
     * @private
     */
    private getTextFont();
    /**
     * Gets the `text brush`.
     * @private
     */
    private getTextBrush();
    /**
     * Gets the `text pen`.
     * @private
     */
    private getTextPen();
    /**
     * Gets the `background brush`.
     * @private
     */
    private getBackgroundBrush();
    /**
     * Gets the current `StringFormat`.
     * @private
     */
    private getStringFormat();
    /**
     * Calculates the `height`.
     * @private
     */
    measureHeight(): number;
    /**
     * return the calculated `width` of the cell.
     * @private
     */
    private calculateWidth();
}
/**
 * `PdfGridCellCollection` class provides access to an ordered,
 * strongly typed collection of 'PdfGridCell' objects.
 * @private
 */
export  class PdfGridCellCollection {
    /**
     * @hidden
     * @private
     */
    private gridRow;
    /**
     * @hidden
     * @private
     */
    private cells;
    /**
     * Initializes a new instance of the `PdfGridCellCollection` class with the row.
     * @private
     */
    constructor(row: PdfGridRow);
    /**
     * Gets the current `cell`.
     * @private
     */
    getCell(index: number): PdfGridCell;
    /**
     * Gets the cells `count`.[Read-Only].
     * @private
     */
    readonly count: number;
    /**
     * `Adds` this instance.
     * @private
     */
    add(): PdfGridCell;
    /**
     * `Adds` this instance.
     * @private
     */
    add(cell: PdfGridCell): void;
    /**
     * Returns the `index of` a particular cell in the collection.
     * @private
     */
    indexOf(cell: PdfGridCell): number;
}
/**
 * `PdfGridColumn.ts` class for EJ2-PDF
 */
/**
 * `PdfGridColumn` class represents the schema of a column in a 'PdfGrid'.
 */
export  class PdfGridColumn {
    /**
     * The current `grid`.
     * @private
     */
    private grid;
    /**
     * The `width` of the column.
     * @default 0
     * @private
     */
    columnWidth: number;
    /**
     * Represent the `custom width` of the column.
     * @private
     */
    isCustomWidth: boolean;
    /**
     * The `string format` of the column.
     * @private
     */
    private stringFormat;
    /**
     * Initializes a new instance of the `PdfGridColumn` class with the parent grid.
     * @private
     */
    constructor(grid: PdfGrid);
    /**
     * Gets or sets the `width` of the 'PdfGridColumn'.
     * @private
     */
    width: number;
    /**
     * Gets or sets the information about the text `formatting`.
     * @private
     */
    format: PdfStringFormat;
}
/**
 * `PdfGridColumnCollection` class provides access to an ordered,
 * strongly typed collection of 'PdfGridColumn' objects.
 * @private
 */
export  class PdfGridColumnCollection {
    /**
     * @hidden
     * @private
     */
    private grid;
    /**
     * @hidden
     * @private
     */
    private internalColumns;
    /**
     * @hidden
     * @private
     */
    private columnWidth;
    /**
     * Initializes a new instance of the `PdfGridColumnCollection` class with the parent grid.
     * @private
     */
    constructor(grid: PdfGrid);
    /**
     * `Add` a new column to the 'PdfGrid'.
     * @private
     */
    add(count: number): void;
    /**
     * Gets the `number of columns` in the 'PdfGrid'.[Read-Only].
     * @private
     */
    readonly count: number;
    /**
     * Gets the `widths`.
     * @private
     */
    readonly width: number;
    /**
     * Gets the `array of PdfGridColumn`.[Read-Only]
     * @private
     */
    readonly columns: PdfGridColumn[];
    /**
     * Gets the `PdfGridColumn` from the specified index.[Read-Only]
     * @private
     */
    getColumn(index: number): PdfGridColumn;
    /**
     * `Calculates the column widths`.
     * @private
     */
    measureColumnsWidth(): number;
    /**
     * Gets the `widths of the columns`.
     * @private
     */
    getDefaultWidths(totalWidth: number): number[];
}
/**
 * PdfGridRow.ts class for EJ2-PDF
 */
/**
 * `PdfGridRow` class provides customization of the settings for the particular row.
 */
export  class PdfGridRow {
    /**
     * `Cell collecton` of the current row..
     * @private
     */
    private gridCells;
    /**
     * Stores the current `grid`.
     * @private
     */
    private pdfGrid;
    /**
     * The grid row `style`.
     * @private
     */
    private rowStyle;
    /**
     * Stores the row `break height`.
     * @private
     */
    private gridRowBreakHeight;
    /**
     * Stores the index of the overflowing row.
     * @private
     */
    private gridRowOverflowIndex;
    /**
     * The `height` of the row.
     * @private
     */
    private rowHeight;
    /**
     * Check whether the row height `is set explicitly`.
     * @default false
     * @private
     */
    isRowHeightSet: boolean;
    /**
     * Checks whether the `columns span is exist or not`.
     * @private
     */
    private bColumnSpanExists;
    /**
     * Check weather the row merge `is completed` or not.
     * @default true
     * @private
     */
    private isRowMergeComplete;
    /**
     * Checks whether the `row span is exist or not`.
     * @private
     */
    private bRowSpanExists;
    /**
     * Initializes a new instance of the `PdfGridRow` class with the parent grid.
     * @private
     */
    constructor(grid: PdfGrid);
    /**
     * Gets or sets a value indicating [`row span exists`].
     * @private
     */
    rowSpanExists: boolean;
    /**
     * Gets the `cells` from the selected row.[Read-Only].
     * @private
     */
    readonly cells: PdfGridCellCollection;
    /**
     * Gets or sets the parent `grid`.
     * @private
     */
    grid: PdfGrid;
    /**
     * Gets or sets the row `style`.
     * @private
     */
    style: PdfGridRowStyle;
    /**
     * `Height` of the row yet to be drawn after split.
     * @private
     */
    rowBreakHeight: number;
    rowOverflowIndex: number;
    /**
     * Gets or sets the `height` of the row.
     * @private
     */
    height: number;
    /**
     * Gets or sets a value indicating [`column span exists`].
     * @private
     */
    columnSpanExists: boolean;
    /**
     * Check whether the Row `has row span or row merge continue`.
     * @private
     */
    rowMergeComplete: boolean;
    /**
     * Returns `index` of the row.
     * @private
     */
    readonly rowIndex: number;
    /**
     * `Calculates the height`.
     * @private
     */
    private measureHeight();
}
/**
 * `PdfGridRowCollection` class provides access to an ordered, strongly typed collection of 'PdfGridRow' objects.
 * @private
 */
export  class PdfGridRowCollection {
    /**
     * @hidden
     * @private
     */
    private grid;
    /**
     * The row collection of the `grid`.
     * @private
     */
    private rows;
    /**
     * Initializes a new instance of the `PdfGridRowCollection` class with the parent grid.
     * @private
     */
    constructor(grid: PdfGrid);
    /**
     * Gets the number of header in the `PdfGrid`.[Read-Only].
     * @private
     */
    readonly count: number;
    /**
     * Return the row collection of the `grid`.
     * @private
     */
    readonly rowCollection: PdfGridRow[];
    /**
     * `Adds` the specified row.
     * @private
     */
    addRow(): PdfGridRow;
    /**
     * `Adds` the specified row.
     * @private
     */
    addRow(row: PdfGridRow): void;
    /**
     * Return the row by index.
     * @private
     */
    getRow(index: number): PdfGridRow;
}
/**
 * `PdfGridHeaderCollection` class provides customization of the settings for the header.
 * @private
 */
export  class PdfGridHeaderCollection {
    /**
     * The `grid`.
     * @private
     */
    private grid;
    /**
     * The array to store the `rows` of the grid header.
     * @private
     */
    private rows;
    /**
     * Initializes a new instance of the `PdfGridHeaderCollection` class with the parent grid.
     * @private
     */
    constructor(grid: PdfGrid);
    /**
     * Gets a 'PdfGridRow' object that represents the `header` row in a 'PdfGridHeaderCollection' control.[Read-Only].
     * @private
     */
    getHeader(index: number): PdfGridRow;
    /**
     * Gets the `number of header` in the 'PdfGrid'.[Read-Only]
     * @private
     */
    readonly count: number;
    /**
     * `Adds` the specified row.
     * @private
     */
    add(row: PdfGridRow): void;
    /**
     * `Adds` the specified row.
     * @private
     */
    add(count: number): PdfGridRow[];
    indexOf(row: PdfGridRow): number;
}
/**
 * PdfGrid.ts class for EJ2-PDF
 */
/**
 * `PdfGridLayoutFormat` class represents a flexible grid that consists of columns and rows.
 */
export  class PdfGridLayoutFormat extends PdfLayoutFormat {
    /**
     * Initializes a new instance of the `PdfGridLayoutFormat` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `PdfGridLayoutFormat` class.
     * @private
     */
    constructor(baseFormat: PdfLayoutFormat);
}
export  class PdfGrid extends PdfLayoutElement {
    /**
     * @hidden
     * @private
     */
    private gridColumns;
    /**
     * @hidden
     * @private
     */
    private gridRows;
    /**
     * @hidden
     * @private
     */
    private gridHeaders;
    /**
     * @hidden
     * @private
     */
    private gridInitialWidth;
    /**
     * @hidden
     * @private
     */
    isComplete: boolean;
    /**
     * @hidden
     * @private
     */
    private gridSize;
    /**
     * @hidden
     * @private
     */
    private layoutFormat;
    /**
     * @hidden
     * @private
     */
    private gridLocation;
    /**
     * @hidden
     * @private
     */
    private gridStyle;
    /**
     * @hidden
     * @private
     */
    private pageWidth;
    /**
     * Check weather it is `child grid or not`.
     * @private
     */
    private childGrid;
    /**
     * @hidden
     * @private
     */
    rowLayoutBoundsWidth: number;
    /**
     * @hidden
     * @private
     */
    isRearranged: boolean;
    /**
     * @hidden
     * @private
     */
    private bRepeatHeader;
    /**
     * @hidden
     * @private
     */
    private pageBounds;
    /**
     * @hidden
     * @private
     */
    private currentPage;
    /**
     * @hidden
     * @private
     */
    private currentPageBounds;
    /**
     * @hidden
     * @private
     */
    private currentBounds;
    /**
     * @hidden
     * @private
     */
    private currentGraphics;
    /**
     * @hidden
     * @private
     */
    private listOfNavigatePages;
    /**
     * @hidden
     * @private
     */
    private startLocation;
    /**
     * @hidden
     * @private
     */
    private hType;
    /**
     * @hidden
     * @private
     */
    private flag;
    /**
     * @hidden
     * @private
     */
    private columnRanges;
    /**
     * @hidden
     * @private
     */
    private cellStartIndex;
    /**
     * @hidden
     * @private
     */
    private cellEndIndex;
    /**
     * @hidden
     * @private
     */
    private currentRowIndex;
    /**
     * @hidden
     * @private
     */
    static repeatRowIndex: number;
    /**
     * @hidden
     * @private
     */
    private isChanged;
    /**
     * @hidden
     * @private
     */
    private currentLocation;
    /**
     * @hidden
     * @private
     */
    private breakRow;
    /**
     * @hidden
     * @private
     */
    private rowBreakPageHeightCellIndex;
    /**
     * The event raised on `starting cell drawing`.
     * @event
     * @private
     */
    beginCellDraw: Function;
    /**
     * The event raised on `ending cell drawing`.
     * @event
     * @private
     */
    endCellDraw: Function;
    /**
     * The event raised on `begin cell lay outing`.
     * @event
     * @private
     */
    beginPageLayout: Function;
    /**
     * The event raised on `end cell lay outing`.
     * @event
     * @private
     */
    endPageLayout: Function;
    /**
     * Initialize a new instance for `PdfGrid` class.
     * @private
     */
    constructor();
    /**
     * Gets a value indicating whether the `start cell layout event` should be raised.
     * @private
     */
    readonly raiseBeginCellDraw: boolean;
    /**
     * Gets a value indicating whether the `end cell layout event` should be raised.
     * @private
     */
    readonly raiseEndCellDraw: boolean;
    /**
     * Gets a value indicating whether the `start page layout event` should be raised.
     * @private
     */
    readonly raiseBeginPageLayout: boolean;
    /**
     * Gets a value indicating whether the `ending page layout event` should be raised.
     * @private
     */
    readonly raiseEndPageLayout: boolean;
    /**
     * Gets or sets a value indicating whether to `repeat header`.
     * @private
     */
    repeatHeader: boolean;
    /**
     * Gets or sets a value indicating whether to split or cut rows that `overflow a page`.
     * @private
     */
    allowRowBreakAcrossPages: boolean;
    /**
     * Gets the `column` collection of the PdfGrid.[Read-Only]
     * @private
     */
    readonly columns: PdfGridColumnCollection;
    /**
     * Gets the `row` collection from the PdfGrid.[Read-Only]
     * @private
     */
    readonly rows: PdfGridRowCollection;
    /**
     * Gets the `headers` collection from the PdfGrid.[Read-Only]
     * @private
     */
    readonly headers: PdfGridHeaderCollection;
    /**
     * Indicating `initial width` of the page.
     * @private
     */
    initialWidth: number;
    /**
     * Gets or sets the `grid style`.
     * @private
     */
    style: PdfGridStyle;
    /**
     * Gets a value indicating whether the grid column width is considered to be `page width`.
     * @private
     */
    isPageWidth: boolean;
    /**
     * Gets or set if grid `is nested grid`.
     * @private
     */
    isChildGrid: boolean;
    /**
     * Gets the `size`.
     * @private
     */
    size: SizeF;
    /**
     * `Draws` the element on the page with the specified page and 'PointF' class
     * @private
     */
    draw(page: PdfPage, location: PointF): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page and pair of coordinates
     * @private
     */
    draw(page: PdfPage, x: number, y: number): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page and 'RectangleF' class
     * @private
     */
    draw(page: PdfPage, layoutRectangle: RectangleF): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page, 'PointF' class and layout format
     * @private
     */
    draw(page: PdfPage, location: PointF, format: PdfLayoutFormat): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page, pair of coordinates and layout format
     * @private
     */
    draw(page: PdfPage, x: number, y: number, format: PdfLayoutFormat): PdfLayoutResult;
    /**
     * `Draws` the element on the page.
     * @private
     */
    draw(page: PdfPage, layoutRectangle: RectangleF, embedFonts: boolean): PdfLayoutResult;
    /**
     * `Draws` the element on the page with the specified page, 'RectangleF' class and layout format
     * @private
     */
    draw(page: PdfPage, layoutRectangle: RectangleF, format: PdfLayoutFormat): PdfLayoutResult;
    /**
     * `measures` this instance.
     * @private
     */
    private measure();
    /**
     * `Layouts` the specified graphics.
     * @private
     */
    protected layout(param: PdfLayoutParams): PdfLayoutResult;
    /**
     * `Layouts` the specified graphics.
     * @private
     */
    protected layout(param: PdfLayoutParams, isGridLayouter: boolean): PdfLayoutResult;
    setSpan(): void;
    /**
     * Gets the `format`.
     * @private
     */
    private getFormat(format);
    /**
     * `Layouts` the element.
     * @private
     */
    private layoutInternal(param);
    /**
     * Calculates the `width` of the columns.
     * @private
     */
    measureColumnsWidth(): void;
    /**
     * Calculates the `width` of the columns.
     * @private
     */
    measureColumnsWidth(bounds: RectangleF): void;
    /**
     * `Determines the column draw ranges`.
     * @private
     */
    private determineColumnDrawRanges();
    /**
     * `Layouts the on page`.
     * @private
     */
    private layoutOnPage(param);
    /**
     * Gets the `next page`.
     * @private
     */
    getNextPage(format: PdfLayoutFormat): PdfPage;
    /**
     * Gets the `layout result`.
     * @private
     */
    private getLayoutResult();
    /**
     * `Recalculate row height` for the split cell to be drawn.
     * @private
     */
    private ReCalculateHeight(row, height);
    /**
     * `Raises BeforePageLayout event`.
     * @private
     */
    private raiseBeforePageLayout(currentPage, currentBounds, currentRow);
    /**
     * `Raises PageLayout event` if needed.
     * @private
     */
    private raisePageLayouted(result);
    /**
     * `Draws row`
     * @private
     */
    private drawRow(row);
    /**
     * `Draws row`
     * @private
     */
    private drawRow(row, result, height);
    /**
     * Checks if the given format `is default format` or not.
     * @private
     */
    private CheckIfDefaultFormat(format);
    /**
     * `Raises BeforeCellDraw event`.
     * @private
     */
    private RaiseBeforeCellDraw(graphics, rowIndex, cellIndex, bounds, value, style);
    /**
     * `Raises AfterCellDraw event`.
     * @private
     */
    private RaiseAfterCellDraw(graphics, rowIndex, cellIndex, bounds, value, cellstyle);
    /**
     * `Rearranges the pages`.
     * @private
     */
    private reArrangePages(layoutedPages);
}
/**
 * `GridCellEventArgs` class is alternate for grid events.
 */
export  abstract class GridCellEventArgs {
    /**
     * @hidden
     * @private
     */
    private gridRowIndex;
    /**
     * @hidden
     * @private
     */
    private gridCellIndex;
    /**
     * @hidden
     * @private
     */
    private internalValue;
    /**
     * @hidden
     * @private
     */
    private gridBounds;
    /**
     * @hidden
     * @private
     */
    private pdfGraphics;
    /**
     * Gets the value of current `row index`.
     * @private
     */
    readonly rowIndex: number;
    /**
     * Gets the value of current `cell index`.
     * @private
     */
    readonly cellIndex: number;
    /**
     * Gets the actual `value` of current cell.
     * @private
     */
    readonly value: string;
    /**
     * Gets the `bounds` of current cell.
     * @private
     */
    readonly bounds: RectangleF;
    /**
     * Gets the instance of `current graphics`.
     * @private
     */
    readonly graphics: PdfGraphics;
    /**
     * Initialize a new instance for `GridCellEventArgs` class.
     * @private
     */
    constructor(graphics: PdfGraphics, rowIndex: number, cellIndex: number, bounds: RectangleF, value: string);
}
/**
 * `PdfGridBeginCellDrawEventArgs` class is alternate for begin cell draw events.
 */
export  class PdfGridBeginCellDrawEventArgs extends GridCellEventArgs {
    /**
     * @hidden
     * @private
     */
    private bSkip;
    /**
     * @hidden
     * @private
     */
    private cellStyle;
    /**
     * Gets or sets a value indicating whether the value of this cell should be `skipped`.
     * @private
     */
    skip: boolean;
    /**
     * Gets or sets a `style` value of the cell.
     * @private
     */
    style: PdfGridCellStyle;
    /**
     * Initializes a new instance of the `StartCellLayoutEventArgs` class.
     * @private
     */
    constructor(graphics: PdfGraphics, rowIndex: number, cellIndex: number, bounds: RectangleF, value: string, style: PdfGridCellStyle);
}
/**
 * `PdfGridEndCellDrawEventArgs` class is alternate for end cell draw events.
 */
export  class PdfGridEndCellDrawEventArgs extends GridCellEventArgs {
    /**
     * @hidden
     * @private
     */
    private cellStyle;
    /**
     * Get the `PdfGridCellStyle`.
     * @private
     */
    readonly style: PdfGridCellStyle;
    /**
     * Initializes a new instance of the `PdfGridEndCellLayoutEventArgs` class.
     * @private
     */
    constructor(graphics: PdfGraphics, rowIndex: number, cellIndex: number, bounds: RectangleF, value: string, style: PdfGridCellStyle);
}
/**
 * `PdfGridCancelEventArgs` class is alternate for cancel events.
 */
export  class PdfCancelEventArgs {
    /**
     * @hidden
     * @private
     */
    private isCancel;
    /**
     * Gets and Sets the value of `cancel`.
     * @private
     */
    cancel: boolean;
}
/**
 * `BeginPageLayoutEventArgs` class is alternate for begin page layout events.
 */
export  class BeginPageLayoutEventArgs extends PdfCancelEventArgs {
    /**
     * The `bounds` of the lay outing on the page.
     * @private
     */
    private cellBounds;
    /**
     * `Page` where the lay outing should start.
     * @private
     */
    private pdfPage;
    /**
     * Gets or sets value that indicates the lay outing `bounds` on the page.
     * @private
     */
    bounds: RectangleF;
    /**
     * Gets the `page` where the lay outing should start.
     * @private
     */
    readonly page: PdfPage;
    /**
     * Initializes a new instance of the `BeginPageLayoutEventArgs` class with the specified rectangle and page.
     * @private
     */
    constructor(bounds: RectangleF, page: PdfPage);
}
/**
 * `EndPageLayoutEventArgs` class is alternate for end page layout events.
 */
export  class EndPageLayoutEventArgs extends PdfCancelEventArgs {
    /**
     * `Layout result`.
     * @private
     */
    private layoutResult;
    /**
     * The `next page` for lay outing.
     * @private
     */
    private nextPdfPage;
    /**
     * Gets the lay outing `result` of the page.
     * @private
     */
    readonly result: PdfLayoutResult;
    /**
     * Gets or sets a value indicating the `next page` where the element should be layout.
     * @private
     */
    nextPage: PdfPage;
    /**
     * Initializes a new instance of the `EndPageLayoutEventArgs` class. with the specified 'PdfLayoutResult'.
     * @private
     */
    constructor(result: PdfLayoutResult);
}
/**
 * `PdfGridBeginPageLayoutEventArgs` class is alternate for begin page layout events.
 */
export  class PdfGridBeginPageLayoutEventArgs extends BeginPageLayoutEventArgs {
    /**
     * @hidden
     * @private
     */
    private startRow;
    /**
     * Gets the `start row index`.
     * @private
     */
    readonly startRowIndex: number;
    /**
     * Initialize a new instance of `PdfGridBeginPageLayoutEventArgs` class.
     * @private
     */
    constructor(bounds: RectangleF, page: PdfPage, startRow: number);
}
/**
 * `PdfGridEndPageLayoutEventArgs` class is alternate for begin page layout events.
 */
export  class PdfGridEndPageLayoutEventArgs extends EndPageLayoutEventArgs {
    /**
     * Initialize a new instance of `PdfGridEndPageLayoutEventArgs` class.
     * @private
     */
    constructor(result: PdfLayoutResult);
}
/**
 * `RowLayoutResult` class to store layout result of rows.
 */
export  class RowLayoutResult {
    /**
     * @hidden
     * @private
     */
    private bIsFinished;
    /**
     * @hidden
     * @private
     */
    private layoutedBounds;
    /**
     * Gets or sets a value indicating whether this instance `is finish`.
     * @private
     */
    isFinish: boolean;
    /**
     * Gets or sets the `bounds`.
     * @private
     */
    bounds: RectangleF;
    /**
     * Initializes a new instance of the `RowLayoutResult` class.
     * @private
     */
    constructor();
}
/**
 * `PdfGridLayoutResult` class represents the results of the PdfGrid including bounds and resultant page.
 */
export  class PdfGridLayoutResult extends PdfLayoutResult {
    /**
     * Initializes a new instance of the `PdfGridLayoutResult` class with the current page and bounds.
     * @private
     */
    constructor(page: PdfPage, bounds: RectangleF);
}
/**
 * Grid styles classes
 */
/**
 * PdfBorders.ts class for EJ2-PDF
 */
/**
 * `PdfBorders` class used represents the cell border of the PDF grid.
 */
export  class PdfBorders {
    /**
     * The `left` border.
     * @private
     */
    private leftPen;
    /**
     * The `right` border.
     * @private
     */
    private rightPen;
    /**
     * The `top` border.
     * @private
     */
    private topPen;
    /**
     * The `bottom` border.
     * @private
     */
    private bottomPen;
    /**
     * Gets or sets the `Left`.
     * @private
     */
    left: PdfPen;
    /**
     * Gets or sets the `Right`.
     * @private
     */
    right: PdfPen;
    /**
     * Gets or sets the `Top`.
     * @private
     */
    top: PdfPen;
    /**
     * Gets or sets the `Bottom`.
     * @private
     */
    bottom: PdfPen;
    /**
     * sets the `All`.
     * @private
     */
    all: PdfPen;
    /**
     * Gets a value indicating whether this instance `is all`.
     * @private
     */
    readonly isAll: boolean;
    /**
     * Gets the `default`.
     * @private
     */
    static readonly default: PdfBorders;
    /**
     * Create a new instance for `PdfBorders` class.
     * @private
     */
    constructor();
}
export  class PdfPaddings {
    /**
     * The `left` padding.
     * @private
     */
    private leftPad;
    /**
     * The `right` padding.
     * @private
     */
    private rightPad;
    /**
     * The `top` padding.
     * @private
     */
    private topPad;
    /**
     * The `bottom` padding.
     * @private
     */
    private bottomPad;
    /**
     * Gets or sets the `left` value of the edge
     * @private
     */
    left: number;
    /**
     * Gets or sets the `right` value of the edge.
     * @private
     */
    right: number;
    /**
     * Gets or sets the `top` value of the edge
     * @private
     */
    top: number;
    /**
     * Gets or sets the `bottom` value of the edge.
     * @private
     */
    bottom: number;
    /**
     * Sets value to all sides `left,right,top and bottom`.s
     * @private
     */
    all: number;
    /**
     * Initializes a new instance of the `PdfPaddings` class.
     * @private
     */
    constructor();
    /**
     * Initializes a new instance of the `PdfPaddings` class.
     * @private
     */
    constructor(left: number, right: number, top: number, bottom: number);
}
/**
 * PdfGridStyleBase.ts class for EJ2-PDF
 */
/**
 * Base class for the `grid style`,
 */
export  abstract class PdfGridStyleBase {
    /**
     * @hidden
     * @private
     */
    private gridBackgroundBrush;
    /**
     * @hidden
     * @private
     */
    private gridTextBrush;
    /**
     * @hidden
     * @private
     */
    private gridTextPen;
    /**
     * @hidden
     * @private
     */
    private gridFont;
    /**
     * Gets or sets the `background brush`.
     * @private
     */
    backgroundBrush: PdfBrush;
    /**
     * Gets or sets the `text brush`.
     * @private
     */
    textBrush: PdfBrush;
    /**
     * Gets or sets the `text pen`.
     * @private
     */
    textPen: PdfPen;
    /**
     * Gets or sets the `font`.
     * @private
     */
    font: PdfFont;
}
/**
 * `PdfGridStyle` class provides customization of the appearance for the 'PdfGrid'.
 */
export  class PdfGridStyle extends PdfGridStyleBase {
    /**
     * @hidden
     * @private
     */
    private gridBorderOverlapStyle;
    /**
     * @hidden
     * @private
     */
    private gridHorizontalOverflowType;
    /**
     * @hidden
     * @private
     */
    private bAllowHorizontalOverflow;
    /**
     * @hidden
     * @private
     */
    private gridCellPadding;
    /**
     * @hidden
     * @private
     */
    private gridCellSpacing;
    /**
     * Initialize a new instance for `PdfGridStyle` class.
     * @private
     */
    constructor();
    /**
     * Gets or sets the `cell spacing` of the 'PdfGrid'.
     * @private
     */
    cellSpacing: number;
    /**
     * Gets or sets the type of the `horizontal overflow` of the 'PdfGrid'.
     * @private
     */
    horizontalOverflowType: PdfHorizontalOverflowType;
    /**
     * Gets or sets a value indicating whether to `allow horizontal overflow`.
     * @private
     */
    allowHorizontalOverflow: boolean;
    /**
     * Gets or sets the `cell padding`.
     * @private
     */
    cellPadding: PdfPaddings;
    /**
     * Gets or sets the `border overlap style` of the 'PdfGrid'.
     * @private
     */
    borderOverlapStyle: PdfBorderOverlapStyle;
}
/**
 * `PdfGridCellStyle` class provides customization of the appearance for the 'PdfGridCell'.
 */
export  class PdfGridCellStyle extends PdfGridStyleBase {
    /**
     * @hidden
     * @private
     */
    private gridCellBorders;
    /**
     * @hidden
     * @private
     */
    private gridCellPadding;
    /**
     * @hidden
     * @private
     */
    private format;
    /**
     * Gets the `string format` of the 'PdfGridCell'.
     * @private
     */
    stringFormat: PdfStringFormat;
    /**
     * Gets or sets the `border` of the 'PdfGridCell'.
     * @private
     */
    borders: PdfBorders;
    /**
     * Gets or sets the `cell padding`.
     * @private
     */
    cellPadding: PdfPaddings;
    /**
     * Initializes a new instance of the `PdfGridCellStyle` class.
     * @private
     */
    constructor();
}
/**
 * `PdfGridRowStyle` class provides customization of the appearance for the `PdfGridRow`.
 */
export  class PdfGridRowStyle {
    /**
     * @hidden
     * @private
     */
    private gridRowBackgroundBrush;
    /**
     * @hidden
     * @private
     */
    private gridRowTextBrush;
    /**
     * @hidden
     * @private
     */
    private gridRowTextPen;
    /**
     * @hidden
     * @private
     */
    private gridRowFont;
    /**
     * Specifies the `border` value of the current row.
     * @private
     */
    private gridRowBorder;
    /**
     * Specifies the `parent row` of the current object.
     * @private
     */
    private parent;
    /**
     * Determine the value of the border is changed or not.
     * @private
     */
    /**
     * Gets or sets the `background brush`.
     * @private
     */
    readonly backgroundBrush: PdfBrush;
    setBackgroundBrush(value: PdfBrush): void;
    /**
     * Gets or sets the `text brush`.
     * @private
     */
    readonly textBrush: PdfBrush;
    setTextBrush(value: PdfBrush): void;
    /**
     * Gets or sets the `text pen`.
     * @private
     */
    readonly textPen: PdfPen;
    setTextPen(value: PdfPen): void;
    /**
     * Gets or sets the `font`.
     * @private
     */
    readonly font: PdfFont;
    setFont(value: PdfFont): void;
    /**
     * Gets or sets the `border` of the current row.
     * @private
     */
    readonly border: PdfBorders;
    setBorder(value: PdfBorders): void;
    /**
     * sets the `parent row` of the current object.
     * @private
     */
    setParent(parent: PdfGridRow): void;
    /**
     * Initializes a new instance of the `PdfGridRowStyle` class.
     * @private
     */
    constructor();
}
/**
 * public Enum for `PdfHorizontalOverflowType`.
 * @private
 */
export  enum PdfHorizontalOverflowType {
    /**
     * Specifies the type of `NextPage`.
     * @private
     */
    NextPage = 0,
    /**
     * Specifies the type of `LastPage`.
     * @private
     */
    LastPage = 1,
}

/**
 * public Enum for `PdfBorderOverlapStyle`.
 * @private
 */
export  enum PdfBorderOverlapStyle {
    /**
     * Specifies the type of `Overlap`.
     * @private
     */
    Overlap = 0,
    /**
     * Specifies the type of `Inside`.
     * @private
     */
    Inside = 1,
}
/**
 * Pdf all modules
 * @hidden
 */
/**
 * `IPdfCache.ts` interface for EJ2-PDF
 * Interface of the objects that support caching of their internals.
 * @private
 */
export interface IPdfCache {
    /**
     * Checks whether the object `is similar to another object`.
     * @private
     */
    equalsTo(obj: IPdfCache): boolean;
    /**
     * Returns `internals of the object`.
     * @private
     */
    getInternals(): IPdfPrimitive;
    /**
     * Sets `internals of the object`.
     * @private
     */
    setInternals(internals: IPdfPrimitive): void;
}
/**
 * `IPdfChangable.ts` interface for EJ2-PDF
 * Interface of the objects that support Changable of their internals.
 * @private
 */
export interface IPdfChangable {
    /**
     * Gets a value indicating whether this 'IPdfChangable' `is changed`.
     * @private
     */
    changed(): boolean;
    /**
     * `Freezes the changes`.
     * @private
     */
    freezeChanges(freezer: Object): void;
}
/**
 * `IPdfPrimitive.ts` interface for EJ2-PDF
 * Defines the basic interace of the various Primitive.
 * @private
 */
export interface IPdfPrimitive {
    /**
     * Specifies the `status` of the IPdfPrimitive. Status is registered if it has a reference or else none.
     * @private
     */
    status: ObjectStatus;
    /**
     * Gets or sets a value indicating whether this document `is saving` or not.
     * @private
     */
    isSaving: boolean;
    /**
     * Gets or sets the `index` value of the specified object.
     * @private
     */
    objectCollectionIndex: number;
    /**
     * Stores the `cloned object` for future use.
     * @private
     */
    clonedObject: IPdfPrimitive;
    /**
     * `Saves` the object using the specified writer.
     * @private
     */
    save(writer: IPdfWriter): void;
    /**
     * Creates a `deep copy` of the IPdfPrimitive object.
     * @private
     */
    clone(crossTable: PdfCrossTable): IPdfPrimitive;
    /**
     * Gets or sets the `position` of the object.
     * @private
     */
    position: number;
}
/**
 * `IPdfWrapper.ts` interface for EJ2-PDF
 * Defines the basic interace of the various Wrapper.
 * @private
 */
export interface IPdfWrapper {
    /**
     * Gets the `element`.
     * @private
     */
    element: IPdfPrimitive;
}
/**
 * `IPdfWriter.ts` interface for EJ2-PDF
 * Defines the basic interace of the various writers.
 * @private
 */
export interface IPdfWriter {
    /**
     * Gets or sets the current `position` within the stream.
     * @private
     */
    position: number;
    /**
     * Stream `length`.
     * @private
     */
    length: number;
    /**
     * The `document` required for saving process.
     * @private
     */
    document: PdfDocumentBase;
    /**
     * `Writes` the specified data.
     * @private
     */
    write(overload: IPdfPrimitive | number | string | GLbyte[]): void;
}
/**
 * Interfaces
 * @hidden
 */
 }
export namespace pivotview { 

/**
 * PivotEngine is used to manipulate the relational or Multi-Dimensional data as pivoting values.
 */
/** @hidden */
export  class PivotEngine {
    /** @hidden */
    globalize: base.Internationalization;
    /** @hidden */
    fieldList: IFieldListOptions;
    /** @hidden */
    pivotValues: IPivotValues;
    /** @hidden */
    headerContent: IGridValues;
    /** @hidden */
    valueContent: IGridValues;
    /** @hidden */
    fields: string[];
    /** @hidden */
    rows: IFieldOptions[];
    /** @hidden */
    columns: IFieldOptions[];
    /** @hidden */
    values: IFieldOptions[];
    /** @hidden */
    filters: IFieldOptions[];
    /** @hidden */
    isMutiMeasures: boolean;
    /** @hidden */
    drilledMembers: IDrillOptions[];
    /** @hidden */
    formats: IFormatSettings[];
    /** @hidden */
    isExpandAll: boolean;
    /** @hidden */
    enableSort: boolean;
    /** @hidden */
    pageSettings: IPageSettings;
    /** @hidden */
    filterMembers: number[];
    /** @hidden */
    formatFields: {
        [key: string]: IFormatSettings;
    };
    /** @hidden */
    calculatedFieldSettings: ICalculatedFieldSettings[];
    /** @hidden */
    calculatedFields: {
        [key: string]: ICalculatedFields;
    };
    /** @hidden */
    calculatedFormulas: {
        [key: string]: Object;
    };
    /** @hidden */
    valueSortSettings: IValueSortSettings;
    /** @hidden */
    isEngineUpdated: boolean;
    /** @hidden */
    savedFieldList: IFieldListOptions;
    private valueSortData;
    private valueMatrix;
    private indexMatrix;
    /**
     * Constructor for PivotEngine class
     * @param  {DataOptions} dataSource?
     * @param  {string} mode?
     * @hidden
     */
    constructor(dataSource?: IDataOptions, mode?: string, savedFieldList?: IFieldListOptions);
    private sortByValue(valueSort, sortOrder, columnIndex);
    private iterateValueSortData(valueSort, data);
    private getFormattedFields(fields);
    private getFieldList(fields, isSort);
    private updateTreeViewData(fields);
    private getCalculatedField(keys);
    private fillFieldMembers(data, indMat);
    private fillDrilledInfo();
    private generateValueMatrix(data);
    private updateSortSettings(sortSettings, isSort);
    private updateFilterMembers(source);
    private getFilters(source, ilist);
    private frameFilterList(filter, name, list, type, isInclude?);
    /** @hidden */
    applyValueSorting(): void;
    /** @hidden */
    generateGridData(dataSource: IDataOptions): void;
    private insertSubTotals();
    private getIndexedHeaders(keys, data, keyInd?, position?, axis?, parentMember?);
    private insertAllMember(set, filter, customText?, axis?);
    private getTableData(rows, reformAxis, columns, tnum, data, vlt, valueSort);
    private getHeaderData(axis, reformAxis, data, tnum, vcnt);
    private getAggregateValue(rowIndex, columnIndex, value, type);
    private getFormattedValue(value, fieldName);
    private powerFunction(formula);
    private evaluate(obj);
}
/** @hidden */
export interface IDataOptions {
    data?: IDataSet[];
    rows?: IFieldOptions[];
    columns?: IFieldOptions[];
    values?: IFieldOptions[];
    filters?: IFieldOptions[];
    expandAll?: boolean;
    filterSettings?: IFilter[];
    sortSettings?: ISort[];
    enableSorting?: boolean;
    formatSettings?: IFormatSettings[];
    pageSettings?: IPageSettings;
    drilledMembers?: IDrillOptions[];
    valueSortSettings?: IValueSortSettings;
    calculatedFieldSettings?: ICalculatedFieldSettings[];
}
/**
 * @hidden
 */
export interface IValueSortSettings {
    headerText?: string;
    headerDelimiter?: string;
    sortOrder?: Sorting;
    columnIndex?: number;
}
/**
 * @hidden
 */
export interface IPageSettings {
    columnSize?: number;
    rowSize?: number;
    columnCurrentPage?: number;
    rowCurrentPage?: number;
}
/**
 * @hidden
 */
export interface IIterator {
    [key: string]: {
        index: number[];
        indexObject: INumberIndex;
    };
}
/**
 * @hidden
 */
export interface INumberIndex {
    [key: string]: number;
}
/**
 * @hidden
 */
export interface IPivotValues {
    [key: number]: {
        [key: number]: number | string | Object | IAxisSet;
        length: number;
    };
    length: number;
}
/**
 * @hidden
 */
export interface IGridValues {
    [key: number]: IAxisSet[];
    length: number;
}
/**
 * @hidden
 */
export interface IDataSet {
    [key: string]: string | number | Date;
}
/**
 * @hidden
 */
export interface IFieldOptions {
    name?: string;
    caption?: string;
    type?: SummaryTypes;
    axis?: string;
}
/**
 * @hidden
 */
export interface ISort {
    name?: string;
    order?: Sorting;
}
/**
 * @hidden
 */
export interface IFilter {
    name?: string;
    type?: string;
    items?: string[];
}
/**
 * @hidden
 */
export interface IDrillOptions {
    name?: string;
    items?: string[];
}
/**
 * @hidden
 */
export interface ICalculatedFieldSettings {
    name?: string;
    formula?: string;
}
/**
 * @hidden
 */
export interface ICalculatedFields extends ICalculatedFieldSettings {
    actualFormula?: string;
}
/**
 * @hidden
 */
export interface IFormatSettings extends base.NumberFormatOptions, base.DateFormatOptions {
    name?: string;
}
/**
 * @hidden
 */
export interface IMembers {
    [index: string]: {
        ordinal?: number;
        index?: number[];
        name?: string;
        isDrilled?: boolean;
    };
}
/**
 * @hidden
 */
export interface IFieldListOptions {
    [index: string]: IField;
}
/**
 * @hidden
 */
export interface IField {
    id?: string;
    caption?: string;
    type?: string;
    formatString?: string;
    index?: number;
    members?: IMembers;
    formattedMembers?: IMembers;
    dateMember?: IAxisSet[];
    filter: string[];
    sort: string;
    aggregateType?: string;
    format?: string;
    formula?: string;
    isSelected?: boolean;
}
/**
 * @hidden
 */
export interface IAxisSet {
    formattedText?: string;
    actualText?: number | string;
    type?: string;
    isDrilled?: boolean;
    hasChild?: boolean;
    members?: this[];
    index?: number[];
    indexObject?: INumberIndex;
    ordinal?: number;
    level?: number;
    axis?: string;
    value?: number;
    colSpan?: number;
    rowSpan?: number;
    valueSort?: IDataSet;
    colIndex?: number;
    rowIndex?: number;
    isSum?: boolean;
}
/**
 * Data modules
 */
/** @hidden */
/** @hidden */
/** @hidden */
/**
 * types
 */
export  type Sorting = 'Ascending' | 'Descending' | 'None';
export  type SummaryTypes = 'Sum' | 'Count' | 'Min' | 'Max' | 'Avg' | 'CalculatedField';
/**
 * This is a file to perform common utility for OLAP and Relational datasource
 * @hidden
 */
export  class PivotUtil {
    static getType(value: Date): string;
}
/**
 * Module for PivotCommon rendering
 */
/** @hidden */
export  class Common implements IAction {
    /**
     * Module declarations
     */
    private parent;
    private handlers;
    /** Constructor for Common module */
    constructor(parent: PivotView);
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    private initiateCommonModule();
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    /**
     * To destroy the groupingbar
     * @return {void}
     * @hidden
     */
    destroy(): void;
}
/**
 * `DataSourceUpdate` module is used to update the dataSource.
 */
/** @hidden */
export  class DataSourceUpdate {
    parent: PivotCommon;
    /**
     * Constructor for the dialog action.
     * @hidden
     */
    constructor(parent?: PivotCommon);
    /**
     * Updates the dataSource by adding the given field along with field dropped position to the dataSource.
     * @param  {string} fieldName - Defines dropped field name to update dataSource.
     * @param  {string} droppedClass -  Defines dropped field axis name to update dataSource.
     * @param  {number} fieldCaption - Defines dropped position to the axis based on field position.
     * @method updateDataSource
     * @return {void}
     * @hidden
     */
    updateDataSource(fieldName: string, droppedClass: string, droppedPosition: number): void;
    /**
     * Updates the dataSource by removing the given field from the dataSource.
     * @param  {string} fieldName - Defines dropped field name to remove dataSource.
     * @method removeFieldFromReport
     * @return {void}
     * @hidden
     */
    removeFieldFromReport(fieldName: string): IFieldOptions;
    /**
     * Creates new field object given field name from the field list data.
     * @param  {string} fieldName - Defines dropped field name to add dataSource.
     * @method getNewField
     * @return {void}
     * @hidden
     */
    getNewField(fieldName: string): IFieldOptions;
}
/**
 * `EventBase` for active fields action.
 */
/** @hidden */
export  class EventBase {
    parent: PivotCommon;
    /**
     * Constructor for the dialog action.
     * @hidden
     */
    constructor(parent?: PivotCommon);
    /**
     * Updates sorting order for the selected field.
     * @method updateSorting
     * @param  {Event} args - Contains clicked element information to update dataSource.
     * @return {void}
     * @hidden
     */
    updateSorting(args: Event): void;
    /**
     * Updates sorting order for the selected field.
     * @method updateFiltering
     * @param  {Event} args - Contains clicked element information to update dataSource.
     * @return {void}
     * @hidden
     */
    updateFiltering(args: Event): void;
    /**
     * Gets sort object for the given field name from the dataSource.
     * @method getSortItemByName
     * @param  {string} fieldName - Gets sort settings for the given field name.
     * @return {Sort}
     * @hidden
     */
    getSortItemByName(fieldName: string): ISort;
    /**
     * Gets filter object for the given field name from the dataSource.
     * @method getFilterItemByName
     * @param  {string} fieldName - Gets filter settings for the given field name.
     * @return {Sort}
     * @hidden
     */
    getFilterItemByName(fieldName: string): IFilter;
    /**
     * show tree nodes using search text.
     * @hidden
     */
    searchTreeNodes(args: inputs.MaskChangeEventArgs, treeObj: navigations.TreeView): void;
    private getTreeData(isInclude, members, filterItems);
}
/**
 * Module for Field List rendering
 */
/** @hidden */
export  class FieldList implements IAction {
    /**
     * Module declarations
     */
    private parent;
    private element;
    private handlers;
    private timeOutObj;
    /** Constructor for Field List module */
    constructor(parent: PivotView);
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    private initiateModule();
    private updateControl();
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    /**
     * To destroy the Field List
     * @return {void}
     * @hidden
     */
    destroy(): void;
}
/**
 * Keyboard interaction
 */
/** @hidden */
export  class CommonKeyboardInteraction {
    private parent;
    private keyConfigs;
    private keyboardModule;
    /**
     * Constructor
     */
    constructor(parent: PivotCommon);
    private keyActionHandler(e);
    private processSort(e);
    private processFilter(e);
    private processDelete(e);
    /**
     * To destroy the keyboard module.
     * @return {void}
     * @private
     */
    destroy(): void;
}
/**
 * `DialogAction` module is used to handle field list dialog related behaviour.
 */
/** @hidden */
export  class NodeStateModified {
    parent: PivotCommon;
    /**
     * Constructor for the dialog action.
     * @hidden
     */
    constructor(parent?: PivotCommon);
    /**
     * Updates the dataSource by drag and drop the selected field from either field list or axis table with dropped target position.
     * @method onStateModified
     * @param  {base.DragEventArgs & navigations.DragAndDropEventArgs} args -  Contains both pivot button and field list drag and drop information.
     * @param  {string} fieldName - Defines dropped field name to update dataSource.
     * @return {void}
     * @hidden
     */
    onStateModified(args: base.DragEventArgs & navigations.DragAndDropEventArgs, fieldName: string): boolean;
    private getButtonPosition(target, droppedClass);
}
/**
 * Module to render Pivot button
 */
/** @hidden */
export  class PivotButton implements IAction {
    parent: PivotView | PivotFieldList;
    private parentElement;
    private dialogPopUp;
    private memberTreeView;
    private draggable;
    private handlers;
    /** Constructor for render module */
    constructor(parent: PivotView | PivotFieldList);
    private renderPivotButton(args);
    private createDraggable(target);
    private createButtonDragIcon(pivotButton);
    private createSortOption(pivotButton, fieldName);
    private createFilterOption(pivotButton, fieldName);
    private createDragClone(args);
    private onDragStart(e);
    private onDragging(e);
    private onDragStop(args);
    private isButtonDropped(dropTarget, target);
    private updateSorting(args);
    private updateFiltering(args);
    private removeButton(args);
    private nodeStateModified(args);
    private updateFilterState(fieldName, args);
    private refreshPivotButtonState(fieldName, isFiltered);
    private removeDataSourceSettings(fieldName);
    private updateDropIndicator(e);
    private wireEvent(element, axis);
    private unWireEvent(element, axis);
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    /**
     * To destroy the pivot button event listener
     * @return {void}
     * @hidden
     */
    destroy(): void;
}
/**
 * Specifies pivot external events
 * @hidden
 */
/** @hidden */
export  const load: string;
/** @hidden */
export  const enginePopulating: string;
/** @hidden */
export  const enginePopulated: string;
/** @hidden */
export  const beforePivotTableRender: string;
/** @hidden */
export  const afterPivotTableRender: string;
/** @hidden */
export  const beforeExport: string;
/** @hidden */
export  const excelHeaderQueryCellInfo: string;
/** @hidden */
export  const pdfHeaderQueryCellInfo: string;
/** @hidden */
export  const excelQueryCellInfo: string;
/** @hidden */
export  const pdfQueryCellInfo: string;
/** @hidden */
export  const dataBound: string;
/** @hidden */
export  const queryCellInfo: string;
/** @hidden */
export  const headerCellInfo: string;
/** @hidden */
export  const resizing: string;
/** @hidden */
export  const resizeStop: string;
/** @hidden */
export  const cellClick: string;
/**
 * Specifies pivot internal events
 */
/** @hidden */
export  const initialLoad: string;
/** @hidden */
export  const uiUpdate: string;
/** @hidden */
export  const scroll: string;
/** @hidden */
export  const contentReady: string;
/** @hidden */
export  const dataReady: string;
/** @hidden */
export  const initSubComponent: string;
/** @hidden */
export  const treeViewUpdate: string;
/** @hidden */
export  const pivotButtonUpdate: string;
/** @hidden */
export  const initCalculatedField: string;
/** @hidden */
export  const click: string;
/**
 * CSS Constants
 * @hidden
 */
/** @hidden */
export  const ROOT: string;
/** @hidden */
export  const RTL: string;
/** @hidden */
export  const DEVICE: string;
/** @hidden */
export  const ICON: string;
/** @hidden */
export  const ICON_DISABLE: string;
/** @hidden */
export  const ICON_HIDDEN: string;
/** @hidden */
export  const WRAPPER_CLASS: string;
/** @hidden */
export  const CONTAINER_CLASS: string;
/** @hidden */
export  const TOGGLE_FIELD_LIST_CLASS: string;
/** @hidden */
export  const STATIC_FIELD_LIST_CLASS: string;
/** @hidden */
export  const TOGGLE_SELECT_CLASS: string;
/** @hidden */
export  const FIELD_TABLE_CLASS: string;
/** @hidden */
export  const FIELD_LIST_CLASS: string;
/** @hidden */
export  const FIELD_LIST_TREE_CLASS: string;
/** @hidden */
export  const FIELD_HEADER_CLASS: string;
/** @hidden */
export  const FIELD_LIST_TITLE_CLASS: string;
/** @hidden */
export  const FIELD_LIST_TITLE_CONTENT_CLASS: string;
/** @hidden */
export  const FIELD_LIST_FOOTER_CLASS: string;
/** @hidden */
export  const CALCULATED_FIELD_CLASS: string;
/** @hidden */
export  const FLAT_CLASS: string;
/** @hidden */
export  const OUTLINE_CLASS: string;
/** @hidden */
export  const AXIS_TABLE_CLASS: string;
/** @hidden */
export  const LEFT_AXIS_PANEL_CLASS: string;
/** @hidden */
export  const RIGHT_AXIS_PANEL_CLASS: string;
/** @hidden */
export  const AXIS_HEADER_CLASS: string;
/** @hidden */
export  const AXIS_CONTENT_CLASS: string;
/** @hidden */
export  const AXIS_PROMPT_CLASS: string;
/** @hidden */
export  const PIVOT_BUTTON_WRAPPER_CLASS: string;
/** @hidden */
export  const PIVOT_BUTTON_CLASS: string;
/** @hidden */
export  const PIVOT_BUTTON_CONTENT_CLASS: string;
/** @hidden */
export  const DRAG_CLONE_CLASS: string;
/** @hidden */
export  const SORT_CLASS: string;
/** @hidden */
export  const SORT_DESCEND_CLASS: string;
/** @hidden */
export  const FILTER_COMMON_CLASS: string;
/** @hidden */
export  const FILTER_CLASS: string;
/** @hidden */
export  const FILTERED_CLASS: string;
/** @hidden */
export  const REMOVE_CLASS: string;
/** @hidden */
export  const DRAG_CLASS: string;
/** @hidden */
export  const DROP_INDICATOR_CLASS: string;
/** @hidden */
export  const INDICATOR_HOVER_CLASS: string;
/** @hidden */
export  const MEMBER_EDITOR_DIALOG_CLASS: string;
/** @hidden */
export  const EDITOR_TREE_WRAPPER_CLASS: string;
/** @hidden */
export  const EDITOR_TREE_CONTAINER_CLASS: string;
/** @hidden */
export  const CHECK_BOX_FRAME_CLASS: string;
/** @hidden */
export  const NODE_CHECK_CLASS: string;
/** @hidden */
export  const NODE_STOP_CLASS: string;
/** @hidden */
export  const OK_BUTTON_CLASS: string;
/** @hidden */
export  const CANCEL_BUTTON_CLASS: string;
/** @hidden */
export  const ERROR_DIALOG_CLASS: string;
/** @hidden */
export  const DROPPABLE_CLASS: string;
/** @hidden */
export  const ROW_AXIS_CLASS: string;
/** @hidden */
export  const COLUMN_AXIS_CLASS: string;
/** @hidden */
export  const VALUE_AXIS_CLASS: string;
/** @hidden */
export  const FILTER_AXIS_CLASS: string;
/** @hidden */
export  const GROUPING_BAR_CLASS: string;
/** @hidden */
export  const VALUE_COLUMN_CLASS: string;
/** @hidden */
export  const GROUP_ROW_CLASS: string;
/** @hidden */
export  const GROUP_COLUMN_CLASS: string;
/** @hidden */
export  const GROUP_FLEX_CLASS: string;
/** @hidden */
export  const GROUP_VALUE_CLASS: string;
/** @hidden */
export  const GROUP_FILTER_CLASS: string;
/** @hidden */
export  const DIALOG_CLOSE_ICON_CLASS: string;
/** @hidden */
export  const NO_DRAG_CLASS: string;
/** @hidden */
export  const SELECTED_NODE_CLASS: string;
/** @hidden */
export  const TITLE_HEADER_CLASS: string;
/** @hidden */
export  const TITLE_CONTENT_CLASS: string;
/** @hidden */
export  const TEXT_CONTENT_CLASS: string;
/** @hidden */
export  const FOOTER_CONTENT_CLASS: string;
/** @hidden */
export  const ADAPTIVE_CONTAINER_CLASS: string;
/** @hidden */
export  const ADAPTIVE_FIELD_LIST_BUTTON_CLASS: string;
/** @hidden */
export  const ADAPTIVE_CALCULATED_FIELD_BUTTON_CLASS: string;
/** @hidden */
export  const BUTTON_SMALL_CLASS: string;
/** @hidden */
export  const BUTTON_ROUND_CLASS: string;
/** @hidden */
export  const ADD_ICON_CLASS: string;
/** @hidden */
export  const BUTTON_FLAT_CLASS: string;
/** @hidden */
export  const STATIC_CENTER_DIV_CLASS: string;
/** @hidden */
export  const STATIC_CENTER_HEADER_CLASS: string;
/** @hidden */
export  const ADAPTIVE_FIELD_LIST_DIALOG_CLASS: string;
/** @hidden */
export  const LIST_TEXT_CLASS: string;
/** @hidden */
export  const LIST_SELECT_CLASS: string;
/** @hidden */
export  const LIST_FRAME_CLASS: string;
/** @hidden */
export  const COLLAPSE: string;
/** @hidden */
export  const EXPAND: string;
/** @hidden */
export  const TABLE: string;
/** @hidden */
export  const BODY: string;
/** @hidden */
export  const PIVOTBODY: string;
/** @hidden */
export  const COLUMNSHEADER: string;
/** @hidden */
export  const ROWSHEADER: string;
/** @hidden */
export  const VALUESCONTENT: string;
/** @hidden */
export  const VALUECELL: string;
/** @hidden */
export  const PIVOTHEADER: string;
/** @hidden */
export  const PGHEADERS: string;
/** @hidden */
export  const TOPHEADER: string;
/** @hidden */
export  const HEADERCELL: string;
/** @hidden */
export  const SUMMARY: string;
/** @hidden */
export  const CELLVALUE: string;
/** @hidden */
export  const ROW: string;
/** @hidden */
export  const PIVOTTOOLTIP: string;
/** @hidden */
export  const TOOLTIP_HEADER: string;
/** @hidden */
export  const TOOLTIP_CONTENT: string;
/** @hidden */
export  const NEXTSPAN: string;
/** @hidden */
export  const LASTSPAN: string;
/** @hidden */
export  const EDITOR_SEARCH_WRAPPER_CLASS: string;
/** @hidden */
export  const EDITOR_SEARCH_CLASS: string;
/** @hidden */
export  const SELECT_ALL_WRAPPER_CLASS: string;
/** @hidden */
export  const SELECT_ALL_CLASS: string;
/** @hidden */
export  const PIVOTCALC: string;
/** @hidden */
export  const CALCDIALOG: string;
/** @hidden */
export  const CALCRADIO: string;
/** @hidden */
export  const CALCCHECK: string;
/** @hidden */
export  const CALCINPUT: string;
/** @hidden */
export  const CALCINPUTDIV: string;
/** @hidden */
export  const CALCOUTERDIV: string;
/** @hidden */
export  const FLAT: string;
/** @hidden */
export  const FORMAT: string;
/** @hidden */
export  const FORMULA: string;
/** @hidden */
export  const TREEVIEW: string;
/** @hidden */
export  const TREEVIEWOUTER: string;
/** @hidden */
export  const CALCCANCELBTN: string;
/** @hidden */
export  const CALCADDBTN: string;
/** @hidden */
export  const CALCOKBTN: string;
/** @hidden */
export  const CALCACCORD: string;
/** @hidden */
export  const CALCBUTTONDIV: string;
/** @hidden */
export  const AXIS_ICON_CLASS: string;
/** @hidden */
export  const AXIS_ROW_CLASS: string;
/** @hidden */
export  const AXIS_COLUMN_CLASS: string;
/** @hidden */
export  const AXIS_VALUE_CLASS: string;
/** @hidden */
export  const AXIS_FILTER_CLASS: string;
/** @hidden */
export  const AXIS_NAVIGATE_WRAPPER_CLASS: string;
/** @hidden */
export  const LEFT_NAVIGATE_WRAPPER_CLASS: string;
/** @hidden */
export  const RIGHT_NAVIGATE_WRAPPER_CLASS: string;
/** @hidden */
export  const LEFT_NAVIGATE_CLASS: string;
/** @hidden */
export  const RIGHT_NAVIGATE_CLASS: string;
/** @hidden */
export  const GRID_CLASS: string;
/** @hidden */
export  const PIVOT_VIEW_CLASS: string;
/** @hidden */
export  const PIVOT_ALL_FIELD_TITLE_CLASS: string;
/** @hidden */
export  const PIVOT_FORMULA_TITLE_CLASS: string;
/** @hidden */
export  const PIVOT_CONTEXT_MENU_CLASS: string;
/** @hidden */
export  const MENU_DISABLE: string;
/** @hidden */
export  const EMPTY_MEMBER_CLASS: string;
/** @hidden */
export  const CALC_EDIT: string;
/** @hidden */
export  const CALC_EDITED: string;
/** @hidden */
export  const EMPTY_FIELD: string;
/**
 * Specifies common enumerations
 */
/**
 * types
 */
export  type Mode = 'Fixed' | 'Popup';
/**
 * Interface
 */
export interface LoadEventArgs {
    /** Defines current dataSource */
    dataSource?: IDataOptions;
}
export interface EnginePopulatingEventArgs {
    /** Defines current dataSource */
    dataSource?: IDataOptions;
}
export interface EnginePopulatedEventArgs {
    /** Defines populated pivotvalues */
    dataSource?: IDataOptions;
    pivotFieldList?: IFieldListOptions;
    pivotValues?: IPivotValues;
}
export interface BeforeExportEventArgs {
    /** Defines exported file name */
    fileName?: string;
    /** Defines header text */
    header?: string;
    /** Defines footer text */
    footer?: string;
    /** Defines pivotValues collections */
    dataCollections?: IPivotValues[];
}
export interface CellClickEventArgs {
    currentCell: Element;
    data: Object;
}
export interface CommonArgs {
    pivotEngine: PivotEngine;
    dataSource: IDataOptions;
    element: HTMLElement;
    id: string;
    moduleName: string;
    enableRtl: boolean;
    isAdaptive: boolean;
    renderMode: Mode;
    localeObj: base.L10n;
}
export interface PivotButtonArgs {
    field: IFieldOptions[];
    axis: string;
}
/**
 * IAction interface
 * @hidden
 */
export interface IAction {
    updateModel?(): void;
    onActionBegin?(args?: Object, type?: string): void;
    onActionComplete?(args?: Object, type?: string): void;
    addEventListener?(): void;
    removeEventListener?(): void;
}
export interface ExcelRow {
    /**  Defines the index for cells */
    index?: number;
    /**  Defines the cells in a row */
    cells?: ExcelCell[];
}
export interface ExcelColumn {
    /**  Defines the index for cells */
    index?: number;
    /**  Defines the width of each column */
    width: number;
}
export interface ExcelStyles extends grids.ExcelStyle {
    /** Defines the cell number format */
    numberFormat?: string;
}
export interface ExcelCell {
    /** Defines the index for the cell */
    index?: number;
    /** Defines the column span for the cell  */
    colSpan?: number;
    /** Defines the column span for the cell  */
    rowSpan?: number;
    /** Defines the value of the cell */
    value?: string | boolean | number | Date;
    /** Defines the style of the cell */
    style?: ExcelStyles;
}
/**
 * PivotCommon is used to manipulate the relational or Multi-Dimensional public methods by using their dataSource
 * @hidden
 */
/** @hidden */
export  class PivotCommon {
    /** @hidden */
    globalize: base.Internationalization;
    /** @hidden */
    localeObj: base.L10n;
    /** @hidden */
    engineModule: PivotEngine;
    /** @hidden */
    dataSource: IDataOptions;
    /** @hidden */
    element: HTMLElement;
    /** @hidden */
    moduleName: string;
    /** @hidden */
    enableRtl: boolean;
    /** @hidden */
    isAdaptive: boolean;
    /** @hidden */
    renderMode: Mode;
    /** @hidden */
    parentID: string;
    /** @hidden */
    nodeStateModified: NodeStateModified;
    /** @hidden */
    dataSourceUpdate: DataSourceUpdate;
    /** @hidden */
    eventBase: EventBase;
    /** @hidden */
    errorDialog: ErrorDialog;
    /** @hidden */
    filterDialog: FilterDialog;
    /** @hidden */
    keyboardModule: CommonKeyboardInteraction;
    /**
     * Constructor for PivotEngine class
     * @param  {PivotEngine} pivotEngine?
     * @param  {DataOptions} dataSource?
     * @param  {string} element?
     * @hidden
     */
    constructor(control: CommonArgs);
    /**
     * To destroy the groupingbar
     * @return {void}
     * @hidden
     */
    destroy(): void;
}
/** @hidden */
export  class CalculatedField implements IAction {
    parent: PivotView | PivotFieldList;
    /**
     * Internal variables.
     */
    private dialog;
    private treeObj;
    private inputObj;
    private droppable;
    private menuObj;
    private newFields;
    private curMenu;
    private isFieldExist;
    private parentID;
    private existingReport;
    private formulaText;
    private fieldText;
    private keyboardEvents;
    private isEdit;
    private currentFieldName;
    private confirmPopUp;
    /** Constructor for calculatedfield module */
    constructor(parent: PivotView | PivotFieldList);
    /**
     * To get module name.
     * @returns string
     */
    protected getModuleName(): string;
    private keyActionHandler(e);
    /**
     * Trigger while click treeview icon.
     * @param  {MouseEvent} e
     * @returns void
     */
    private fieldClickHandler(e);
    /**
     * To display context menu.
     * @param  {HTMLElement} node
     * @returns void
     */
    private displayMenu(node);
    /**
     * To set position for context menu.
     * @returns void
     */
    private openContextMenu();
    /**
     * Triggers while select menu.
     * @param  {MenuEventArgs} menu
     * @returns void
     */
    private selectContextMenu(menu);
    /**
     * To create context menu.
     * @returns void
     */
    private createMenu();
    /**
     * Triggers while click OK button.
     * @returns void
     */
    private applyFormula();
    private addFormula(report, field);
    /**
     * To get treeview data
     * @param  {PivotGrid|PivotFieldList} parent
     * @returns Object
     */
    private getFieldListData(parent);
    /**
     * Triggers before menu opens.
     * @param  {BeforeOpenCloseMenuEventArgs} args
     * @returns void
     */
    private beforeMenuOpen(args);
    /**
     * Trigger while drop node in formula field.
     * @param  {DragAndDropEventArgs} args
     * @returns void
     */
    private fieldDropped(args);
    /**
     * To create dialog.
     * @returns void
     */
    private createDialog();
    /**
     * To render dialog elements.
     * @returns void
     */
    private renderDialogElements();
    /**
     * To create calculated field adaptive layout.
     * @returns void
     */
    private renderAdaptiveLayout();
    /**
     * To create treeview.
     * @returns void
     */
    private createTreeView();
    /**
     * Trigger before treeview text append.
     * @param  {DrawNodeEventArgs} args
     * @returns void
     */
    private drawTreeNode(args);
    /**
     * To create radio buttons.
     * @param  {string} key
     * @returns HTMLElement
     */
    private createTypeContainer(key);
    /**
     * To get Accordion Data.
     * @param  {PivotView | PivotFieldList} parent
     * @returns AccordionItemModel
     */
    private getAccordionData(parent);
    /**
     * To render mobile layout.
     * @param  {Tab} tabObj
     * @returns void
     */
    private renderMobileLayout(tabObj?);
    /**
     * Trigger while click cancel button.
     * @returns void
     */
    private cancelBtnClick();
    /**
     * Trigger while click add button.
     * @returns void
     */
    private addBtnClick();
    /**
     * To create calculated field dialog elements.
     * @returns void
     * @hidden
     */
    createCalculatedFieldDialog(): void;
    /**
     * To create calculated field desktop layout.
     * @returns void
     */
    private renderDialogLayout();
    /**
     * Creates the error dialog for the unexpected action done.
     * @method createConfirmDialog
     * @return {void}
     * @hidden
     */
    private createConfirmDialog(title, description);
    private replaceFormula();
    private removeErrorDialog();
    /**
     * To add event listener.
     * @returns void
     * @hidden
     */
    addEventListener(): void;
    /**
     * To remove event listener.
     * @returns void
     * @hidden
     */
    removeEventListener(): void;
    /**
     * To destroy the calculated field dialog
     * @returns void
     * @hidden
     */
    destroy(): void;
}
/**
 * Module to render Axis Fields
 */
/** @hidden */
export  class AxisFields {
    parent: PivotView;
    private pivotButton;
    /** Constructor for render module */
    constructor(parent: PivotView);
    /**
     * Initialize the pivot button rendering
     * @returns void
     * @private
     */
    render(): void;
    private createPivotButtons();
}
/**
 * Module for GroupingBar rendering
 */
/** @hidden */
export  class GroupingBar implements IAction {
    /**
     * Internal variables
     */
    private groupingTable;
    private leftAxisPanel;
    private rightAxisPanel;
    private filterPanel;
    private rowPanel;
    private columnPanel;
    private valuePanel;
    private rowAxisPanel;
    private columnAxisPanel;
    private valueAxisPanel;
    private filterAxisPanel;
    private touchObj;
    private timeOutObj;
    /**
     * Module declarations
     */
    private parent;
    private handlers;
    /** Constructor for GroupingBar module */
    constructor(parent: PivotView);
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    private renderLayout();
    private appendToElement();
    /**
     * @hidden
     */
    refreshUI(): void;
    private wireEvent(element);
    private unWireEvent(element);
    private dropIndicatorUpdate(e);
    private tapHoldHandler(e);
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    /**
     * To destroy the groupingbar
     * @return {void}
     * @hidden
     */
    destroy(): void;
}
/**
 * common exported items
 */
/**
 * Module to render Pivot button
 */
/** @hidden */
export  class PivotContextMenu {
    parent: PivotView | PivotFieldList;
    /** @hidden */
    menuObj: navigations.ContextMenu;
    /** @hidden */
    fieldElement: HTMLElement;
    /** Constructor for render module */
    constructor(parent: PivotView | PivotFieldList);
    /**
     * Initialize the pivot table rendering
     * @returns void
     * @private
     */
    render(): void;
    private renderContextMenu();
    private onBeforeMenuOpen(args);
    private onSelectContextMenu(menu);
    /**
     * To destroy the pivot button event listener
     * @return {void}
     * @hidden
     */
    destroy(): void;
}
/**
 * `ErrorDialog` module to create error dialog.
 */
/** @hidden */
export  class ErrorDialog {
    parent: PivotCommon;
    /** @hidden */
    errorPopUp: popups.Dialog;
    /**
     * Constructor for the dialog action.
     * @hidden
     */
    constructor(parent: PivotCommon);
    /**
     * Creates the error dialog for the unexpected action done.
     * @method createErrorDialog
     * @return {void}
     * @hidden
     */
    createErrorDialog(title: string, description: string): void;
    private closeErrorDialog();
    private removeErrorDialog();
}
/**
 * `FilterDialog` module to create filter dialog.
 */
/** @hidden */
export  class FilterDialog {
    parent: PivotCommon;
    /** @hidden */
    memberTreeView: navigations.TreeView;
    /** @hidden */
    allMemberSelect: navigations.TreeView;
    /** @hidden */
    editorSearch: inputs.MaskedTextBox;
    /** @hidden */
    dialogPopUp: popups.Dialog;
    /**
     * Constructor for the dialog action.
     * @hidden
     */
    constructor(parent?: PivotCommon);
    /**
     * Creates the member filter dialog for the selected field.
     * @method createFilterDialog
     * @return {void}
     * @hidden
     */
    createFilterDialog(treeData: {
        [key: string]: Object;
    }[], fieldName: string, fieldCaption: string, target: HTMLElement): void;
    private createTreeView(treeData, fieldCaption);
    private validateTreeNode(e);
    /**
     * Update filter state while Member check/uncheck.
     * @hidden
     */
    updateCheckedState(): void;
    private getCheckedNodes(treeNodes);
    private getUnCheckedNodes(treeNodes);
    private closeFilterDialog();
    private removeFilterDialog();
}
/**
 * Base export
 */
/** @hidden */
/** @hidden */
/**
 * Interface for a class PivotFieldList
 */
export interface PivotFieldListModel extends base.ComponentModel{
    /**
     * It allows to feed raw data, dataSource and properties to customize the data source
     */
    dataSource?: DataSourceModel;
    /**
     * It allows to render Pivot Field List at fixed or popup mode.
     * The possible values are:
     * @default 'Popup'
     */
    renderMode?: Mode;
    /**
     * Specifies the `target` element where the Pivot Field List dialog should be displayed.
     * If the user set the specific `target` element for Pivot Field List, it will be positioned based on the `target`.
     * The targetID should works only when the Pivot Field List is in 'Dynamic' mode.
     * @default null
     */
    target?: HTMLElement | string;
    /**
     * Specifies the CSS class name to be added for Pivot Field List element.
     * User can add single or multiple CSS classes.
     * @default ''
     */
    cssClass?: string;
    /**
     * It allows to enable calculated field in Pivot Field List.
     * @default false
     */
    allowCalculatedField?: boolean;
    /**
     * This allows any customization of Pivot Field List properties before rendering.
     * @event
     */
    load?: base.EmitType<LoadEventArgs>;
    /**
     * This allows any customization of Pivot Field List properties before pivotengine populate.
     * @event
     */
    enginePopulating?: base.EmitType<EnginePopulatingEventArgs>;
    /**
     * This allows any customization of Pivot Field List properties before pivotengine populate.
     * @event
     */
    enginePopulated?: base.EmitType<EnginePopulatedEventArgs>;
    /**
     * Triggers when data source is populated in the Pivot Field List.
     * @event 
     */
    dataBound?: base.EmitType<Object>;
    /**
     * Triggers when data source is created in the Pivot Field List.
     * @event 
     */
    created?: base.EmitType<Object>;
    /**
     * Triggers when data source is destroyed in the Pivot Field List.
     * @event 
     */
    destroyed?: base.EmitType<Object>;
}
/**
 * Represents the PivotFieldList component.
 * ```html
 * <div id="pivotfieldlist"></div>
 * <script>
 *  var pivotfieldlistObj = new PivotFieldList({ });
 *  pivotfieldlistObj.appendTo("#pivotfieldlist");
 * </script>
 * ```
 */
export  class PivotFieldList extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /** @hidden */
    globalize: base.Internationalization;
    /** @hidden */
    localeObj: base.L10n;
    /** @hidden */
    isAdaptive: Boolean;
    /** @hidden */
    pivotFieldList: IFieldListOptions;
    /** @hidden */
    engineModule: PivotEngine;
    /** @hidden */
    isDragging: boolean;
    /** @hidden */
    fieldListSpinnerElement: Element;
    private defaultLocale;
    private captionData;
    /** @hidden */
    pivotGridModule: PivotView;
    /** @hidden */
    renderModule: Render;
    /** @hidden */
    dialogRenderer: DialogRenderer;
    /** @hidden */
    treeViewModule: TreeViewRenderer;
    /** @hidden */
    axisTableModule: AxisTableRenderer;
    /** @hidden */
    pivotCommon: PivotCommon;
    /** @hidden */
    axisFieldModule: AxisFieldRenderer;
    /** @hidden */
    pivotButtonModule: PivotButton;
    /** @hidden */
    calculatedFieldModule: CalculatedField;
    /** @hidden */
    contextMenuModule: PivotContextMenu;
    /**
     * It allows to feed raw data, dataSource and properties to customize the data source
     */
    dataSource: DataSourceModel;
    /**
     * It allows to render Pivot Field List at fixed or popup mode.
     * The possible values are:
     * @default 'Popup'
     */
    renderMode: Mode;
    /**
     * Specifies the `target` element where the Pivot Field List dialog should be displayed.
     * If the user set the specific `target` element for Pivot Field List, it will be positioned based on the `target`.
     * The targetID should works only when the Pivot Field List is in 'Dynamic' mode.
     * @default null
     */
    target: HTMLElement | string;
    /**
     * Specifies the CSS class name to be added for Pivot Field List element.
     * User can add single or multiple CSS classes.
     * @default ''
     */
    cssClass: string;
    /**
     * It allows to enable calculated field in Pivot Field List.
     * @default false
     */
    allowCalculatedField: boolean;
    /**
     * This allows any customization of Pivot Field List properties before rendering.
     * @event
     */
    load: base.EmitType<LoadEventArgs>;
    /**
     * This allows any customization of Pivot Field List properties before pivotengine populate.
     * @event
     */
    enginePopulating: base.EmitType<EnginePopulatingEventArgs>;
    /**
     * This allows any customization of Pivot Field List properties before pivotengine populate.
     * @event
     */
    enginePopulated: base.EmitType<EnginePopulatedEventArgs>;
    /**
     * Triggers when data source is populated in the Pivot Field List.
     * @event
     */
    dataBound: base.EmitType<Object>;
    /**
     * Triggers when data source is created in the Pivot Field List.
     * @event
     */
    created: base.EmitType<Object>;
    /**
     * Triggers when data source is destroyed in the Pivot Field List.
     * @event
     */
    destroyed: base.EmitType<Object>;
    /**
     * Constructor for creating the widget
     * @param  {PivotFieldListModel} options?
     * @param  {string|HTMLButtonElement} element?
     */
    constructor(options?: PivotFieldListModel, element?: string | HTMLElement);
    /**
     * To provide the array of modules needed for control rendering
     * @return {base.ModuleDeclaration[]}
     * @hidden
     */
    requiredModules(): base.ModuleDeclaration[];
    /**
     * For internal use only - Initialize the event handler;
     * @private
     */
    protected preRender(): void;
    /**
     * Initialize the control rendering
     * @returns void
     * @private
     */
    render(): void;
    /**
     * Binding events to the Pivot Field List element.
     * @hidden
     */
    private wireEvent();
    /**
     * Unbinding events from the element on widget destroy.
     * @hidden
     */
    private unWireEvent();
    /**
     * Get the properties to be maintained in the persisted state.
     * @return {string}
     * @hidden
     */
    getPersistData(): string;
    /**
     * Get component name.
     * @returns string
     * @private
     */
    getModuleName(): string;
    /**
     * Called internally if any of the property value changed.
     * @hidden
     */
    onPropertyChanged(newProp: PivotFieldListModel, oldProp: PivotFieldListModel): void;
    private generateData();
    private fieldListRender();
    private getFieldCaption(dataSource);
    private getFields(dataSource);
    /**
     * Updates the PivotEngine using dataSource from Pivot Field List component.
     * @method updateDataSource
     * @return {void}
     * @hidden
     */
    updateDataSource(isTreeViewRefresh?: boolean): void;
    /**
     * Updates the Pivot Field List component using dataSource from PivotView component.
     * @method updateControl
     * @return {void}
     * @hidden
     */
    update(control: PivotView): void;
    /**
     * Updates the PivotView component using dataSource from Pivot Field List component.
     * @method refreshTargetControl
     * @return {void}
     * @hidden
     */
    updateView(control: PivotView): void;
    /**
     * Destroys the Field Table component.
     * @method destroy
     * @return {void}
     */
    destroy(): void;
}
/**
 * PivotGrid component exported items
 */
/** @hidden */
/** @hidden */
/**
 * Models
 */
/** @hidden */
/** @hidden */
/** @hidden */
/** @hidden */
/**
 * Module to render Axis Fields
 */
/** @hidden */
export  class AxisFieldRenderer {
    parent: PivotFieldList;
    private pivotButton;
    /** Constructor for render module */
    constructor(parent: PivotFieldList);
    /**
     * Initialize the pivot button rendering
     * @returns void
     * @private
     */
    render(): void;
    private createPivotButtons();
}
/**
 * Module to render Axis Field Table
 */
/** @hidden */
export  class AxisTableRenderer {
    parent: PivotFieldList;
    /** @hidden */
    axisTable: Element;
    private leftAxisPanel;
    private rightAxisPanel;
    /** Constructor for render module */
    constructor(parent: PivotFieldList);
    /**
     * Initialize the axis table rendering
     * @returns void
     * @private
     */
    render(): void;
    private renderAxisTable();
    private getIconupdate(axis);
    private wireEvent(element);
    private unWireEvent(element);
    private updateDropIndicator(e);
}
/**
 * Module to render Pivot Field List popups.Dialog
 */
/** @hidden */
export  class DialogRenderer {
    parent: PivotFieldList;
    /** @hidden */
    parentElement: HTMLElement;
    /** @hidden */
    fieldListDialog: popups.Dialog;
    /** @hidden */
    adaptiveElement: navigations.Tab;
    /** Constructor for render module */
    constructor(parent: PivotFieldList);
    /**
     * Initialize the field list layout rendering
     * @returns void
     * @private
     */
    render(): void;
    private renderStaticLayout(fieldListWrappper);
    private renderFieldListDialog(fieldListWrappper);
    /**
     * Called internally if any of the field added to axis.
     * @hidden
     */
    updateDataSource(selectedNodes: string[]): void;
    private renderAdaptiveLayout(fieldListWrappper);
    private createCalculatedButton();
    private createAddButton();
    private createAxisTable(axis);
    private showCalculatedField(event);
    private showFieldListDialog(event);
    private onShowFieldList();
    private onCloseFieldList();
    private removeFieldListIcon();
    private keyPress(e);
    private wireDialogEvent(element);
    private unWireDialogEvent(element);
}
/**
 * Module to render Pivot Table component
 */
/** @hidden */
export  class Render1 {
    parent: PivotFieldList;
    /** Constructor for render module */
    constructor(parent: PivotFieldList);
    /**
     * Initialize the pivot table rendering
     * @returns void
     * @private
     */
    render(): void;
}
/**
 * Module to render Field List
 */
/** @hidden */
export  class TreeViewRenderer implements IAction {
    parent: PivotFieldList;
    /** @hidden */
    fieldTable: navigations.TreeView;
    private parentElement;
    private treeViewElement;
    private fieldDialog;
    private editorSearch;
    private selectedNodes;
    /** Constructor for render module */
    constructor(parent: PivotFieldList);
    /**
     * Initialize the field list tree rendering
     * @returns void
     * @private
     */
    render(axis?: number): void;
    private renderTreeView();
    private renderTreeDialog(axis?);
    private createTreeView(treeData);
    private dragStart(args);
    private dragStop(args);
    private isNodeDropped(args, targetID);
    private getButton(fieldName);
    private nodeStateChange(args);
    private addNode(args);
    private getTreeUpdate();
    private refreshTreeView();
    private getTreeData(axis?);
    private onFieldAdd(e);
    private closeTreeDialog();
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    /**
     * To destroy the tree view event listener
     * @return {void}
     * @hidden
     */
    destroy(): void;
}
/**
 * Export PivotGrid components
 */
/**
 * Action export
 */
/**
 * @hidden
 * `ExcelExport` module is used to handle the Excel export action.
 */
export  class ExcelExport {
    private parent;
    /**
     * Constructor for the PivotGrid Excel Export module.
     * @hidden
     */
    constructor(parent?: PivotView);
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    /**
     * Method to perform excel export.
     * @hidden
     */
    exportToExcel(type: string): void;
}
/**
 * PivotView Keyboard interaction
 */
/** @hidden */
export  class KeyboardInteraction {
    private parent;
    private keyConfigs;
    private pivotViewKeyboardModule;
    /**
     * Constructor
     */
    constructor(parent: PivotView);
    private keyActionHandler(e);
    private getNextButton(target);
    private processTab(e);
    private processEnter(e);
    /**
     * To destroy the keyboard module.
     * @return {void}
     * @private
     */
    destroy(): void;
}
/**
 * @hidden
 * `PDFExport` module is used to handle the PDF export action.
 */
export  class PDFExport {
    private parent;
    /**
     * Constructor for the PivotGrid PDF Export module.
     * @hidden
     */
    constructor(parent?: PivotView);
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    /**
     * Method to perform pdf export.
     * @hidden
     */
    exportToPDF(): void;
    private applyEvent();
}
/**
 * Base export
 */
/**
 * Interface for a class GroupingBarSettings
 */
export interface GroupingBarSettingsModel {
    /**
     * It allows to set the visibility of filter icon in base.GroupingBar button
     * @default true     
     */
    showFilterIcon?: boolean;
    /**
     * It allows to set the visibility of sort icon in base.GroupingBar button
     * @default true     
     */
    showSortIcon?: boolean;
    /**
     * It allows to set the visibility of remove icon in base.GroupingBar button
     * @default true     
     */
    showRemoveIcon?: boolean;
}
/**
 * Interface for a class PivotView
 */
export interface PivotViewModel extends base.ComponentModel{
    /**
     * Defines the currencyCode format of the Pivot widget columns
     * @private
     */
    currencyCode?: string;
    /**
     * It allows to render pivotfieldlist.
     * @default false
     */
    showFieldList?: boolean;
    /**
     * Configures the features settings of Pivot widget. 
     */
    gridSettings?: GridSettingsModel;
    /**
     * Configures the settings of base.GroupingBar. 
     */
    groupingBarSettings?: GroupingBarSettingsModel;
    /**
     * It allows the user to configure the pivot report as per the user need.
     */
    dataSource?: DataSourceModel;
    /**
     * It holds the pivot engine data which renders the Pivot widget.
     */
    pivotValues?: IPivotValues;
    /**
     * Enables the display of base.GroupingBar allowing you to filter, sort, and remove fields obtained from the datasource.
     * @default false
     */
    showGroupingBar?: boolean;
    /**
     * It allows to enable calculated field in PivotView.
     * @default false
     */
    allowCalculatedField?: boolean;
    /**
     * It allows to enable Value Sorting in PivotView.
     * @default false
     */
    enableValueSorting?: boolean;
    /**
     * Pivot widget. (Note change all occurrences) 
     * @default auto
     */
    height?: string | number;
    /**
     * It allows to set the width of Pivot widget. 
     * @default auto
     */
    width?: string | number;
    /**
     * If `allowExcelExport` is set to true, then it will allow the user to export pivotview to Excel file.
     * @default false    
     */
    allowExcelExport?: boolean;
    /**
     * If `allowPdfExport` is set to true, then it will allow the user to export pivotview to Pdf file.
     * @default false    
     */
    allowPdfExport?: boolean;
    queryCellInfo?: base.EmitType<any>;
    headerCellInfo?: base.EmitType<any>;
    resizing?: base.EmitType<any>;
    resizeStop?: base.EmitType<any>;
    pdfHeaderQueryCellInfo?: base.EmitType<any>;
    pdfQueryCellInfo?: base.EmitType<any>;
    excelHeaderQueryCellInfo?: base.EmitType<any>;
    excelQueryCellInfo?: base.EmitType<any>;
    columnDragStart?: base.EmitType<any>;
    columnDrag?: base.EmitType<any>;
    /**
    columnDrop?: base.EmitType<base.ColumnDragEventArgs>;
    /**
     * This allows any customization of PivotView properties on initial rendering.
     * @event
     */
    load?: base.EmitType<LoadEventArgs>;
    /**
     * Triggers before the pivot engine starts to populate and allows to customize the pivot datasource settings. 
     * @event
     */
    enginePopulating?: base.EmitType<EnginePopulatingEventArgs>;
    /**
     * Triggers after the pivot engine populated and allows to customize the pivot widget.
     * @event
     */
    enginePopulated?: base.EmitType<EnginePopulatedEventArgs>;
    /**
     * Triggers when data source is populated in the Pivot View.
     * @event
     */
    dataBound?: base.EmitType<Object>;
    /**
     * Triggers when data source is created in the Pivot View.
     * @event 
     */
    created?: base.EmitType<Object>;
    /**
     * Triggers when data source is destroyed in the Pivot View.
     * @event 
     */
    destroyed?: base.EmitType<Object>;
    /**
     * This allows to set properties for exporting.
     * @event 
     */
    beforeExport?: base.EmitType<BeforeExportEventArgs>;
    /**
     * Triggers when cell is clicked in the Pivot widget.
     * @event 
     */
    cellClick?: base.EmitType<CellClickEventArgs>;
}
/**
 * It holds the settings of Grouping Bar.
 */
export  class GroupingBarSettings extends base.ChildProperty<GroupingBarSettings> {
    /**
     * It allows to set the visibility of filter icon in GroupingBar button
     * @default true
     */
    showFilterIcon: boolean;
    /**
     * It allows to set the visibility of sort icon in GroupingBar button
     * @default true
     */
    showSortIcon: boolean;
    /**
     * It allows to set the visibility of remove icon in GroupingBar button
     * @default true
     */
    showRemoveIcon: boolean;
}
/**
 * Represents the PivotView component.
 * ```html
 * <div id="PivotView"></div>
 * <script>
 *  var pivotviewObj = new PivotView({ enableGroupingBar: true });
 *  pivotviewObj.appendTo("#pivotview");
 * </script>
 * ```
 */
export  class PivotView extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /** @hidden */
    globalize: base.Internationalization;
    /** @hidden */
    localeObj: base.L10n;
    /** @hidden */
    toolTip: popups.Tooltip;
    /** @hidden */
    grid: grids.Grid;
    /** @hidden */
    isDragging: boolean;
    /** @hidden */
    isAdaptive: Boolean;
    /** @hidden */
    fieldListSpinnerElement: HTMLElement;
    pivotView: PivotView;
    /** @hidden */
    renderModule: Render;
    /** @hidden */
    engineModule: PivotEngine;
    /** @hidden */
    pivotCommon: PivotCommon;
    /** @hidden */
    axisFieldModule: AxisFields;
    /** @hidden */
    groupingBarModule: GroupingBar;
    /** @hidden */
    pivotButtonModule: PivotButton;
    /** @hidden */
    commonModule: Common;
    /** @hidden */
    pivotFieldListModule: PivotFieldList;
    /** @hidden */
    excelExportModule: ExcelExport;
    /** @hidden */
    pdfExportModule: PDFExport;
    /** @hidden */
    calculatedFieldModule: CalculatedField;
    /** @hidden */
    keyboardModule: KeyboardInteraction;
    /** @hidden */
    contextMenuModule: PivotContextMenu;
    private defaultLocale;
    private timeOutObj;
    protected needsID: boolean;
    /**
     * Defines the currencyCode format of the Pivot widget columns
     * @private
     */
    private currencyCode;
    /**
     * It allows to render pivotfieldlist.
     * @default false
     */
    showFieldList: boolean;
    /**
     * Configures the features settings of Pivot widget.
     */
    gridSettings: GridSettingsModel;
    /**
     * Configures the settings of GroupingBar.
     */
    groupingBarSettings: GroupingBarSettingsModel;
    /**
     * It allows the user to configure the pivot report as per the user need.
     */
    dataSource: DataSourceModel;
    /**
     * It holds the pivot engine data which renders the Pivot widget.
     */
    pivotValues: IPivotValues;
    /**
     * Enables the display of GroupingBar allowing you to filter, sort, and remove fields obtained from the datasource.
     * @default false
     */
    showGroupingBar: boolean;
    /**
     * It allows to enable calculated field in PivotView.
     * @default false
     */
    allowCalculatedField: boolean;
    /**
     * It allows to enable Value Sorting in PivotView.
     * @default false
     */
    enableValueSorting: boolean;
    /**
     * Pivot widget. (Note change all occurrences)
     * @default auto
     */
    height: string | number;
    /**
     * It allows to set the width of Pivot widget.
     * @default auto
     */
    width: string | number;
    /**
     * If `allowExcelExport` is set to true, then it will allow the user to export pivotview to Excel file.
     * @default false
     */
    allowExcelExport: boolean;
    /**
     * If `allowPdfExport` is set to true, then it will allow the user to export pivotview to Pdf file.
     * @default false
     */
    allowPdfExport: boolean;
    /** @hidden */
    protected queryCellInfo: base.EmitType<grids.QueryCellInfoEventArgs>;
    /** @hidden */
    protected headerCellInfo: base.EmitType<any>;
    /** @hidden */
    protected resizing: base.EmitType<grids.ResizeArgs>;
    /** @hidden */
    protected resizeStop: base.EmitType<grids.ResizeArgs>;
    /** @hidden */
    protected pdfHeaderQueryCellInfo: base.EmitType<any>;
    /** @hidden */
    protected pdfQueryCellInfo: base.EmitType<grids.PdfQueryCellInfoEventArgs>;
    /** @hidden */
    protected excelHeaderQueryCellInfo: base.EmitType<any>;
    /** @hidden */
    protected excelQueryCellInfo: base.EmitType<grids.ExcelQueryCellInfoEventArgs>;
    /** @hidden */
    protected columnDragStart: base.EmitType<grids.ColumnDragEventArgs>;
    /** @hidden */
    protected columnDrag: base.EmitType<grids.ColumnDragEventArgs>;
    /** @hidden */
    protected columnDrop: base.EmitType<grids.ColumnDragEventArgs>;
    /**
     * This allows any customization of PivotView properties on initial rendering.
     * @event
     */
    load: base.EmitType<LoadEventArgs>;
    /**
     * Triggers before the pivot engine starts to populate and allows to customize the pivot datasource settings.
     * @event
     */
    enginePopulating: base.EmitType<EnginePopulatingEventArgs>;
    /**
     * Triggers after the pivot engine populated and allows to customize the pivot widget.
     * @event
     */
    enginePopulated: base.EmitType<EnginePopulatedEventArgs>;
    /**
     * Triggers when data source is populated in the Pivot View.
     * @event
     */
    dataBound: base.EmitType<Object>;
    /**
     * Triggers when data source is created in the Pivot View.
     * @event
     */
    created: base.EmitType<Object>;
    /**
     * Triggers when data source is destroyed in the Pivot View.
     * @event
     */
    destroyed: base.EmitType<Object>;
    /**
     * This allows to set properties for exporting.
     * @event
     */
    beforeExport: base.EmitType<BeforeExportEventArgs>;
    /**
     * Triggers when cell is clicked in the Pivot widget.
     * @event
     */
    cellClick: base.EmitType<CellClickEventArgs>;
    /**
     * Constructor for creating the widget
     * @param  {PivotViewModel} options?
     * @param  {string|HTMLElement} element?
     */
    constructor(options?: PivotViewModel, element?: string | HTMLElement);
    /**
     * To provide the array of modules needed for control rendering
     * @return {base.ModuleDeclaration[]}
     * @hidden
     */
    requiredModules(): base.ModuleDeclaration[];
    /**
     * For internal use only - Initializing internal properties;
     * @private
     */
    protected preRender(): void;
    private onBeforeTooltipOpen(args);
    private initProperties();
    /**
     * Initialize the control rendering
     * @returns void
     * @hidden
     */
    render(): void;
    /**
     * Register the internal events.
     * @returns void
     * @hidden
     */
    addInternalEvents(): void;
    /**
     * De-Register the internal events.
     * @returns void
     * @hidden
     */
    removeInternalEvents(): void;
    /**
     * Get the Pivot widget properties to be maintained in the persisted state.
     * @returns {string}
     * @hidden
     */
    getPersistData(): string;
    /**
     * It returns the Module name.
     * @returns string
     * @hidden
     */
    getModuleName(): string;
    /**
     * Copy the selected rows or cells data into clipboard.
     * @param {boolean} withHeader - Specifies whether the column header text needs to be copied along with rows or cells.
     * @returns {void}
     * @hidden
     */
    copy(withHeader?: boolean): void;
    /**
     * By default, prints all the pages of the grids.Grid and hides the pager.
     * > You can customize print options using the
     * [`printMode`](./api-pivotgrid.html#printmode-string).
     * @returns {void}
     * @hidden
     */
    /**
     * Called internally if any of the property value changed.
     * @returns void
     * @hidden
     */
    onPropertyChanged(newProp: PivotViewModel, oldProp: PivotViewModel): void;
    /**
     * Render the UI section of PivotView.
     * @returns void
     * @hidden
     */
    renderPivotGrid(): void;
    /**
     * Updates the PivotEngine using dataSource from Pivot View component.
     * @method updateDataSource
     * @return {void}
     * @hidden
     */
    updateDataSource(isRefreshGrid?: boolean): void;
    /**
     * To destroy the PivotView elements.
     * @returns void
     */
    destroy(): void;
    /**
     * Export Pivot widget data to Excel file(.xlsx).
     * @param  {grids.ExcelExportProperties} excelExportProperties - Defines the export properties of the grids.Grid.
     * @param  {boolean} isMultipleExport - Define to enable multiple export.
     * @param  {workbook} workbook - Defines the Workbook if multiple export is enabled.
     * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.
     * @returns void
     */
    excelExport(excelExportProperties?: grids.ExcelExportProperties, isMultipleExport?: boolean, workbook?: any, isBlob?: boolean): void;
    /**
     * Export PivotGrid data to CSV file.
     * @param  {grids.ExcelExportProperties} excelExportProperties - Defines the export properties of the grids.Grid.
     * @param  {boolean} isMultipleExport - Define to enable multiple export.
     * @param  {workbook} workbook - Defines the Workbook if multiple export is enabled.
     * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.
     * @returns void
     */
    csvExport(excelExportProperties?: grids.ExcelExportProperties, isMultipleExport?: boolean, workbook?: any, isBlob?: boolean): void;
    /**
     * Export Pivot widget data to PDF document.
     * @param  {pdfExportProperties} grids.PdfExportProperties - Defines the export properties of the grids.Grid.
     * @param  {isMultipleExport} isMultipleExport - Define to enable multiple export.
     * @param  {pdfDoc} pdfDoc - Defined the Pdf Document if multiple export is enabled.
     * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.
     * @returns void
     */
    pdfExport(pdfExportProperties?: grids.PdfExportProperties, isMultipleExport?: boolean, pdfDoc?: Object, isBlob?: boolean): void;
    private onDrill(target);
    private onContentReady();
    private setToolTip(args);
    private getRowText(rowIndex, colIndex);
    private getColText(rowIndex, colIndex, limit);
    private updateClass();
    private wireEvents();
    private mouseClickHandler(e);
    /** @hidden */
    onWindowResize(): void;
    private CellClicked(target);
    private unwireEvents();
    private generateData();
}
/**
 * PivotGrid component exported items
 */
/**
 * Interface for a class FieldOptions
 */
export interface FieldOptionsModel {
    /**
     * It allows to set field name.
     */
    name?: string;
    /**
     * It allows to set field caption.
     */
    caption?: string;
    /**
     * It allows to set the summary type of the field. The available types are,
     * * `Sum`: The summary cells calculated by the sum of its cells. 
     * * `Count`: The summary cells calculated by the count of its cells.
     * * `Min`: The summary cells shows the value which is the minimum value of its cells. 
     * * `Max`: The summary cells shows the value which is the maximum value of its cells.
     * * `Percentage`: The summary cells displays in percentage format.
     * * `Avg`: The summary cells calculated by the average of its cells.
     * * `CalculatedField`: It should set to include calculated fields.
     * @default Sum
     */
    type?: SummaryTypes;
    /**
     * It allows to set the axis to render the field in it.
     */
    axis?: string;
}
/**
 * Interface for a class FieldListFieldOptions
 */
export interface FieldListFieldOptionsModel extends FieldOptionsModel{
}
/**
 * Interface for a class Filter
 */
export interface FilterModel {
    /**
     * It allows to set the field name.
     */
    name?: string;
    /**
     * It allows to set the filter type.
     */
    type?: string;
    /**
     * It allows to set the filter items.
     */
    items?: string[];
}
/**
 * Interface for a class Sort
 */
export interface SortModel {
    /**
     * It allows to set the field name to sort.
     */
    name?: string;
    /**
     * It allows to set the sort order. The types are,
     * * `Ascending`: It allows to display the field members in ascending order. 
     * * `Descending`: It allows to display the field members in descending order.
     * @default Ascending
     */
    order?: Sorting;
}
/**
 * Interface for a class FormatSettings
 */
export interface FormatSettingsModel {
    /**
     * It allows to set the field name to apply format settings.
     */
    name?: string;
    /**
     * It allows to specify minimum fraction digits in formatted value.
     */
    minimumFractionDigits?: number;
    /**
     * It allows to specify maximum fraction digits in formatted value.
     */
    maximumFractionDigits?: number;
    /**
     * It allows to specify minimum significant digits in formatted value.
     */
    minimumSignificantDigits?: number;
    /**
     * It allows to specify maximum significant digits in formatted value.
     */
    maximumSignificantDigits?: number;
    /**
     * It allows to specify whether to use grouping or not in formatted value,
     */
    useGrouping?: boolean;
    /**
     * It allows to specify the skeleton for perform formatting.
     */
    skeleton?: string;
    /**
     * It allows to specify the type of date formatting either date, dateTime or time.
     */
    type?: string;
    /**
     * It allows to specify the currency code to be used for formatting.
     */
    currency?: string;
    /**
     * It allows to specify minimum integer digits in formatted value.
     */
    minimumIntegerDigits?: number;
    /**
     * It allows to specify custom number format for formatting.
     */
    format?: string;
}
/**
 * Interface for a class CalculatedFieldSettings
 */
export interface CalculatedFieldSettingsModel {
    /**
     * It allows to set the field name to sort.
     */
    name?: string;
    /**
     * It allows to set the formula for calculated fields. 
     */
    formula?: string;
}
/**
 * Interface for a class PageSettings
 */
export interface PageSettingsModel {
    /**
     * It allows to set the count of columns to be fit in one page.
     */
    columnSize?: number;
    /**
     * It allows to set the count of rows to be fit in one page.
     */
    rowSize?: number;
    /**
     * It allows to set the current display page in column-wise.
     */
    columnCurrentPage?: number;
    /**
     * It allows to set the current display page in row-wise.
     */
    rowCurrentPage?: number;
}
/**
 * Interface for a class DrillOptions
 */
export interface DrillOptionsModel {
    /**
     * It allows to set the field name whose members to be drilled.
     */
    name?: string;
    /**
     * It allows to set the members to be drilled.
     */
    items?: string[];
}
/**
 * Interface for a class ValueSortSettings
 */
export interface ValueSortSettingsModel {
    /**
     * It allows to set the members name to achieve value sorting based on this.
     */
    headerText?: string;
    /**
     * It allows to set the delimiters to separate the members.
     * @default '.'
     */
    headerDelimiter?: string;
    /**
     * It allows to set the sort order. The types are,
     * * `Ascending`: It allows to display the field members in ascending order. 
     * * `Descending`: It allows to display the field members in descending order.
     * @default None
     */
    sortOrder?: Sorting;
    /**
     * It allows to set the column index where the value sorting applied based on the position.
     * @default undefined
     * @aspDefaultValueIgnore
     */
    columnIndex?: number;
}
/**
 * Interface for a class DataSource
 */
export interface DataSourceModel {
    /**
     * It allows to set the data source.
     */
    data?: IDataSet[];
    /**
     * It allows to set the row fields.
     * @default []
     */
    rows?: FieldOptionsModel[];
    /**
     * It allows to set the column fields.
     * @default []
     */
    columns?: FieldOptionsModel[];
    /**
     * It allows to set the value fields.
     * @default []
     */
    values?: FieldOptionsModel[];
    /**
     * It allows to set the filter fields.
     * @default []
     */
    filters?: FieldOptionsModel[];
    /**
     * It allows to set the expanded state of headers.
     * @default true
     */
    expandAll?: boolean;
    /**
     * It allows to set the settings of filtering operation.
     * @default []
     */
    filterSettings?: FilterModel[];
    /**
     * It allows to set the settings of sorting operation.
     * @default []
     */
    sortSettings?: SortModel[];
    /**
     * It allows sorting operation UI.
     * @default true
     */
    enableSorting?: boolean;
    /**
     * It allows to set the settings of number formatting.
     * @default []
     */
    formatSettings?: FormatSettingsModel[];
    /**
    pageSettings?: PageSettingsModel;
    /**
     * It allows to set the drilled state for desired field members.
     * @default []
     */
    drilledMembers?: DrillOptionsModel[];
    /**
     * It allows to set the settings of value sorting operation.
     */
    valueSortSettings?: ValueSortSettingsModel;
    /**
     * It allows to set the settings of calculated field operation.
     * @default []
     */
    calculatedFieldSettings?: CalculatedFieldSettingsModel[];
}
/**
 * Configures the fields in dataSource.
 */
export  class FieldOptions extends base.ChildProperty<FieldOptions> implements IFieldOptions {
    /**
     * It allows to set field name.
     */
    name: string;
    /**
     * It allows to set field caption.
     */
    caption: string;
    /**
     * It allows to set the summary type of the field. The available types are,
     * * `Sum`: The summary cells calculated by the sum of its cells.
     * * `Count`: The summary cells calculated by the count of its cells.
     * * `Min`: The summary cells shows the value which is the minimum value of its cells.
     * * `Max`: The summary cells shows the value which is the maximum value of its cells.
     * * `Percentage`: The summary cells displays in percentage format.
     * * `Avg`: The summary cells calculated by the average of its cells.
     * * `CalculatedField`: It should set to include calculated fields.
     * @default Sum
     */
    type: SummaryTypes;
    /**
     * It allows to set the axis to render the field in it.
     */
    axis: string;
}
export  class FieldListFieldOptions extends FieldOptions {
}
/**
 * Configures the filter settings.
 */
export  class Filter extends base.ChildProperty<Filter> implements IFilter {
    /**
     * It allows to set the field name.
     */
    name: string;
    /**
     * It allows to set the filter type.
     */
    type: string;
    /**
     * It allows to set the filter items.
     */
    items: string[];
}
/**
 * Configures the sort settings.
 */
export  class Sort extends base.ChildProperty<Sort> implements ISort {
    /**
     * It allows to set the field name to sort.
     */
    name: string;
    /**
     * It allows to set the sort order. The types are,
     * * `Ascending`: It allows to display the field members in ascending order.
     * * `Descending`: It allows to display the field members in descending order.
     * @default Ascending
     */
    order: Sorting;
}
/**
 * Configures the format settings of value fields.
 */
export  class FormatSettings extends base.ChildProperty<FormatSettings> implements base.NumberFormatOptions, base.DateFormatOptions, IFormatSettings {
    /**
     * It allows to set the field name to apply format settings.
     */
    name: string;
    /**
     * It allows to specify minimum fraction digits in formatted value.
     */
    minimumFractionDigits: number;
    /**
     * It allows to specify maximum fraction digits in formatted value.
     */
    maximumFractionDigits: number;
    /**
     * It allows to specify minimum significant digits in formatted value.
     */
    minimumSignificantDigits: number;
    /**
     * It allows to specify maximum significant digits in formatted value.
     */
    maximumSignificantDigits: number;
    /**
     * It allows to specify whether to use grouping or not in formatted value,
     */
    useGrouping: boolean;
    /**
     * It allows to specify the skeleton for perform formatting.
     */
    skeleton: string;
    /**
     * It allows to specify the type of date formatting either date, dateTime or time.
     */
    type: string;
    /**
     * It allows to specify the currency code to be used for formatting.
     */
    currency: string;
    /**
     * It allows to specify minimum integer digits in formatted value.
     */
    minimumIntegerDigits: number;
    /**
     * It allows to specify custom number format for formatting.
     */
    format: string;
}
/**
 * Configures the calculatedfields settings.
 */
export  class CalculatedFieldSettings extends base.ChildProperty<CalculatedFieldSettings> implements ICalculatedFieldSettings {
    /**
     * It allows to set the field name to sort.
     */
    name: string;
    /**
     * It allows to set the formula for calculated fields.
     */
    formula: string;
}
/**
 * Configures the page settings.
 */
/** @hidden */
export  class PageSettings extends base.ChildProperty<PageSettings> implements IPageSettings {
    /**
     * It allows to set the count of columns to be fit in one page.
     */
    columnSize: number;
    /**
     * It allows to set the count of rows to be fit in one page.
     */
    rowSize: number;
    /**
     * It allows to set the current display page in column-wise.
     */
    columnCurrentPage: number;
    /**
     * It allows to set the current display page in row-wise.
     */
    rowCurrentPage: number;
}
/**
 * Configures drilled state of field members.
 */
export  class DrillOptions extends base.ChildProperty<DrillOptions> implements IDrillOptions {
    /**
     * It allows to set the field name whose members to be drilled.
     */
    name: string;
    /**
     * It allows to set the members to be drilled.
     */
    items: string[];
}
/**
 * Configures value sort settings.
 */
export  class ValueSortSettings extends base.ChildProperty<ValueSortSettings> implements IValueSortSettings {
    /**
     * It allows to set the members name to achieve value sorting based on this.
     */
    headerText: string;
    /**
     * It allows to set the delimiters to separate the members.
     * @default '.'
     */
    headerDelimiter: string;
    /**
     * It allows to set the sort order. The types are,
     * * `Ascending`: It allows to display the field members in ascending order.
     * * `Descending`: It allows to display the field members in descending order.
     * @default None
     */
    sortOrder: Sorting;
    /**
     * It allows to set the column index where the value sorting applied based on the position.
     * @default undefined
     * @aspDefaultValueIgnore
     */
    columnIndex: number;
}
/**
 * Configures the settings of dataSource.
 */
export  class DataSource extends base.ChildProperty<DataSource> implements IDataOptions {
    /**
     * It allows to set the data source.
     */
    data: IDataSet[];
    /**
     * It allows to set the row fields.
     * @default []
     */
    rows: FieldOptionsModel[];
    /**
     * It allows to set the column fields.
     * @default []
     */
    columns: FieldOptionsModel[];
    /**
     * It allows to set the value fields.
     * @default []
     */
    values: FieldOptionsModel[];
    /**
     * It allows to set the filter fields.
     * @default []
     */
    filters: FieldOptionsModel[];
    /**
     * It allows to set the expanded state of headers.
     * @default true
     */
    expandAll: boolean;
    /**
     * It allows to set the settings of filtering operation.
     * @default []
     */
    filterSettings: FilterModel[];
    /**
     * It allows to set the settings of sorting operation.
     * @default []
     */
    sortSettings: SortModel[];
    /**
     * It allows sorting operation UI.
     * @default true
     */
    enableSorting: boolean;
    /**
     * It allows to set the settings of number formatting.
     * @default []
     */
    formatSettings: FormatSettingsModel[];
    /**
     * It allows to set the settings of paging operation.
     */
    /** @hidden */
    pageSettings: PageSettingsModel;
    /**
     * It allows to set the drilled state for desired field members.
     * @default []
     */
    drilledMembers: DrillOptionsModel[];
    /**
     * It allows to set the settings of value sorting operation.
     */
    valueSortSettings: ValueSortSettingsModel;
    /**
     * It allows to set the settings of calculated field operation.
     * @default []
     */
    calculatedFieldSettings: CalculatedFieldSettingsModel[];
}
/**
 * Interface for a class GridSettings
 */
export interface GridSettingsModel {
    /**
     * Defines the mode of grid lines. The available modes are,
     * * `Both`: Displays both horizontal and vertical grid lines.
     * * `None`: No grid lines are displayed.
     * * `Horizontal`: Displays the horizontal grid lines only.
     * * `Vertical`: Displays the vertical grid lines only.
     * * `Default`: Displays grid lines based on the theme.
     * @default Both
     */
    gridLines?: any;
    /**
     * If `allowTextWrap` set to true,  
     * then text content will wrap to the next line when its text content exceeds the width of the Column Cells. 
     * @default false     
     */
    allowTextWrap?: boolean;
    /**
     * If `allowReordering` is set to true, Grid columns can be reordered.
     * Reordering can be done by drag and drop of a particular column from one index to another index.
     * > If Grid is rendered with stacked headers, reordering is allowed only at the same level as the column headers.
     * @default false
     */
    allowReordering?: boolean;
    /**
     * If `allowResizing` is set to true, Grid columns can be resized.
     * @default true
     */
    allowResizing?: boolean;
    /**
     * Defines the height of Grid rows.
     * @default null
     */
    rowHeight?: number;
    /**
     * Defines the height of Grid rows.
     * @default 110
     */
    columnWidth?: number;
    /**
     * Defines the cell content's overflow mode. The available modes are
     * * `Clip` -  Truncates the cell content when it overflows its area.
     * * `Ellipsis` -  Displays ellipsis when the cell content overflows its area.
     * * `EllipsisWithTooltip` - Displays ellipsis when the cell content overflows its area
     * also it will display tooltip while hover on ellipsis applied cell.
     * @default Ellipsis
     */
    clipMode?: any;
    /**
     * If `allowSelection` is set to true, it allows selection of (highlight row) Grid records by clicking it.
     * @default false
     */
    allowSelection?: boolean;
    /**
     * The `selectedRowIndex` allows you to select a row at initial rendering.
     * You can also get the currently selected row index.
     * @default -1
     */
    selectedRowIndex?: number;
    /**
     * Configures the selection settings.
     * @default {mode: 'Row', cellSelectionMode: 'Flow', type: 'Single'}
     */
    selectionSettings?: any;
    /**
     * Defines the print modes. The available print modes are
     * * `AllPages`: Prints all pages of the Grid.
     * * `CurrentPage`: Prints the current page of the Grid.
     * @default AllPages
     */
    printMode?: any;
    /**
     * `contextMenuItems` defines both built-in and custom context menu items.         
     * @default null
     */
    contextMenuItems?: any[];
    /**
     * Triggers before Grid copy action.
     * @event
     */
    beforeCopy?: base.EmitType<any>;
    /**
     * Triggers after print action is completed.
     * @event
     */
    printComplete?: base.EmitType<any>;
    /**
     * Triggers before the print action starts.
     * @event
     */
    beforePrint?: base.EmitType<any>;
    /**
     * Triggers before context menu opens.
     * @event
     */
    contextMenuOpen?: base.EmitType<any>;
    /**
     * Triggers when click on context menu.
     * @event
     */
    contextMenuClick?: base.EmitType<any>;
    /**
     * Triggered every time a request is made to access cell information, element, or data.
     * This will be triggered before the cell element is appended to the Grid element.
     * @event 
     */
    queryCellInfo?: base.EmitType<any>;
    /**
     * Triggered for column header.
     * This will be triggered before the cell element is appended to the Grid element.
     * @event 
     */
    headerCellInfo?: base.EmitType<any>;
    /**
     * Triggers before row selection occurs.
     * @event 
     */
    rowSelecting?: base.EmitType<any>;
    /**
     * Triggers after a row is selected.
     * @event 
     */
    rowSelected?: base.EmitType<any>;
    /**
     * Triggers before deselecting the selected row.
     * @event 
     */
    rowDeselecting?: base.EmitType<any>;
    /**
     * Triggers when a selected row is deselected.
     * @event 
     */
    rowDeselected?: base.EmitType<any>;
    /**
     * Triggers before any cell selection occurs.
     * @event 
     */
    cellSelecting?: base.EmitType<any>;
    /**
     * Triggers after a cell is selected.
     * @event 
     */
    cellSelected?: base.EmitType<any>;
    /**
     * Triggers before the selected cell is deselecting.
     * @event 
     */
    cellDeselecting?: base.EmitType<any>;
    /**
     * Triggers when a particular selected cell is deselected.
     * @event 
     */
    cellDeselected?: base.EmitType<any>;
    /**
     * Triggers when column resize starts.
     * @event
     */
    resizeStart?: base.EmitType<any>;
    /**
     * Triggers on column resizing.
     * @event
     */
    resizing?: base.EmitType<any>;
    /**
     * Triggers when column resize ends.
     * @event
     */
    resizeStop?: base.EmitType<any>;
    /**
     * Triggers before exporting each header cell to PDF document. You can also customize the PDF cells.
     * @event 
     */
    pdfHeaderQueryCellInfo?: base.EmitType<any>;
    /**
     * Triggers before exporting each cell to PDF document. You can also customize the PDF cells.
     * @event 
     */
    pdfQueryCellInfo?: base.EmitType<any>;
    /**
     * Triggers before exporting each header cell to Excel file.
     * You can also customize the Excel cells.
     * @event
     */
    excelHeaderQueryCellInfo?: base.EmitType<any>;
    /**
     * Triggers before exporting each cell to Excel file.
     * You can also customize the Excel cells.
     * @event
     */
    excelQueryCellInfo?: base.EmitType<any>;
    /**
     * Triggers when column header element drag (move) starts. 
     * @event  
     */
    columnDragStart?: base.EmitType<any>;
    /**
     * Triggers when column header element is dragged (moved) continuously. 
     * @event  
     */
    columnDrag?: base.EmitType<any>;
    /**
     * Triggers when a column header element is dropped on the target column. 
     * @event  
     */
    columnDrop?: base.EmitType<any>;
}
/**
 *  Represents Pivot widget model class.
 */
export  class GridSettings extends base.ChildProperty<GridSettings> {
    /**
     * Defines the mode of grid lines. The available modes are,
     * * `Both`: Displays both horizontal and vertical grid lines.
     * * `None`: No grid lines are displayed.
     * * `Horizontal`: Displays the horizontal grid lines only.
     * * `Vertical`: Displays the vertical grid lines only.
     * * `Default`: Displays grid lines based on the theme.
     * @default Both
     */
    gridLines: grids.GridLine;
    /**
     * If `allowTextWrap` set to true,
     * then text content will wrap to the next line when its text content exceeds the width of the Column Cells.
     * @default false
     */
    allowTextWrap: boolean;
    /**
     * If `allowReordering` is set to true, Grid columns can be reordered.
     * Reordering can be done by drag and drop of a particular column from one index to another index.
     * > If Grid is rendered with stacked headers, reordering is allowed only at the same level as the column headers.
     * @default false
     */
    allowReordering: boolean;
    /**
     * If `allowResizing` is set to true, Grid columns can be resized.
     * @default true
     */
    allowResizing: boolean;
    /**
     * Defines the height of Grid rows.
     * @default null
     */
    rowHeight: number;
    /**
     * Defines the height of Grid rows.
     * @default 110
     */
    columnWidth: number;
    /**
     * Defines the cell content's overflow mode. The available modes are
     * * `Clip` -  Truncates the cell content when it overflows its area.
     * * `Ellipsis` -  Displays ellipsis when the cell content overflows its area.
     * * `EllipsisWithTooltip` - Displays ellipsis when the cell content overflows its area
     * also it will display tooltip while hover on ellipsis applied cell.
     * @default Ellipsis
     */
    clipMode: grids.ClipMode;
    /**
     * If `allowSelection` is set to true, it allows selection of (highlight row) Grid records by clicking it.
     * @default false
     */
    allowSelection: boolean;
    /**
     * The `selectedRowIndex` allows you to select a row at initial rendering.
     * You can also get the currently selected row index.
     * @default -1
     */
    selectedRowIndex: number;
    /**
     * Configures the selection settings.
     * @default {mode: 'Row', cellSelectionMode: 'Flow', type: 'Single'}
     */
    selectionSettings: grids.SelectionSettingsModel;
    /**
     * Defines the print modes. The available print modes are
     * * `AllPages`: Prints all pages of the Grid.
     * * `CurrentPage`: Prints the current page of the Grid.
     * @default AllPages
     */
    printMode: grids.PrintMode;
    /**
     * `contextMenuItems` defines both built-in and custom context menu items.
     * @default null
     */
    contextMenuItems: grids.ContextMenuItemModel[];
    /**
     * Triggers before Grid copy action.
     * @event
     */
    beforeCopy: base.EmitType<grids.BeforeCopyEventArgs>;
    /**
     * Triggers after print action is completed.
     * @event
     */
    printComplete: base.EmitType<grids.PrintEventArgs>;
    /**
     * Triggers before the print action starts.
     * @event
     */
    beforePrint: base.EmitType<grids.PrintEventArgs>;
    /**
     * Triggers before context menu opens.
     * @event
     */
    contextMenuOpen: base.EmitType<navigations.BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers when click on context menu.
     * @event
     */
    contextMenuClick: base.EmitType<navigations.MenuEventArgs>;
    /**
     * Triggered every time a request is made to access cell information, element, or data.
     * This will be triggered before the cell element is appended to the Grid element.
     * @event
     */
    queryCellInfo: base.EmitType<grids.QueryCellInfoEventArgs>;
    /**
     * Triggered for column header.
     * This will be triggered before the cell element is appended to the Grid element.
     * @event
     */
    headerCellInfo: base.EmitType<any>;
    /**
     * Triggers before row selection occurs.
     * @event
     */
    rowSelecting: base.EmitType<any>;
    /**
     * Triggers after a row is selected.
     * @event
     */
    rowSelected: base.EmitType<any>;
    /**
     * Triggers before deselecting the selected row.
     * @event
     */
    rowDeselecting: base.EmitType<any>;
    /**
     * Triggers when a selected row is deselected.
     * @event
     */
    rowDeselected: base.EmitType<any>;
    /**
     * Triggers before any cell selection occurs.
     * @event
     */
    cellSelecting: base.EmitType<grids.CellSelectingEventArgs>;
    /**
     * Triggers after a cell is selected.
     * @event
     */
    cellSelected: base.EmitType<grids.CellSelectEventArgs>;
    /**
     * Triggers before the selected cell is deselecting.
     * @event
     */
    cellDeselecting: base.EmitType<grids.CellDeselectEventArgs>;
    /**
     * Triggers when a particular selected cell is deselected.
     * @event
     */
    cellDeselected: base.EmitType<grids.CellDeselectEventArgs>;
    /**
     * Triggers when column resize starts.
     * @event
     */
    resizeStart: base.EmitType<grids.ResizeArgs>;
    /**
     * Triggers on column resizing.
     * @event
     */
    resizing: base.EmitType<grids.ResizeArgs>;
    /**
     * Triggers when column resize ends.
     * @event
     */
    resizeStop: base.EmitType<grids.ResizeArgs>;
    /**
     * Triggers before exporting each header cell to PDF document. You can also customize the PDF cells.
     * @event
     */
    pdfHeaderQueryCellInfo: base.EmitType<any>;
    /**
     * Triggers before exporting each cell to PDF document. You can also customize the PDF cells.
     * @event
     */
    pdfQueryCellInfo: base.EmitType<grids.PdfQueryCellInfoEventArgs>;
    /**
     * Triggers before exporting each header cell to Excel file.
     * You can also customize the Excel cells.
     * @event
     */
    excelHeaderQueryCellInfo: base.EmitType<any>;
    /**
     * Triggers before exporting each cell to Excel file.
     * You can also customize the Excel cells.
     * @event
     */
    excelQueryCellInfo: base.EmitType<grids.ExcelQueryCellInfoEventArgs>;
    /**
     * Triggers when column header element drag (move) starts.
     * @event
     */
    columnDragStart: base.EmitType<grids.ColumnDragEventArgs>;
    /**
     * Triggers when column header element is dragged (moved) continuously.
     * @event
     */
    columnDrag: base.EmitType<grids.ColumnDragEventArgs>;
    /**
     * Triggers when a column header element is dropped on the target column.
     * @event
     */
    columnDrop: base.EmitType<grids.ColumnDragEventArgs>;
}
/**
 * Interface for a class AxisSet
 */
export interface AxisSetModel {
    /**
     * Specifies header name.
     */
    formattedText?: string;
    /**
     * Specifies header type.
     */
    type?: string;
    /**
     * Specifies the drilled state of the header.
     */
    isDrilled?: boolean;
    /**
     * Specifies the field whether it has child or not.
     */
    hasChild?: boolean;
    /**
     * Specifies its child members.
     */
    members?: this[];
    /**
     * Specifies its position collections in data source.
     */
    index?: number[];
    /**
     * Specifies its position collections in data source with indexed object.
     */
    indexObject?: INumberIndex;
    /**
     * Specifies its position in its field.
     */
    ordinal?: number;
    /**
     * Specifies its level.
     */
    level?: number;
    /**
     * Specifies its axis where it is plotted.
     */
    axis?: string;
    /**
     * Specifies its value.
     */
    value?: number;
    /**
     * Specifies its column span.
     */
    colSpan?: number;
    /**
     * Specifies its row span.
     */
    rowSpan?: number;
    /**
     * Specifies the data collection which is to be framed for value sorted members.
     */
    valueSort?: IDataSet;
    /**
     * Specifies whether the cell is summary or not.
     */
    isSum?: boolean;
}
/**
 * Configures the properties in pivotvalues fields.
 */
/** @hidden */
export  class AxisSet extends base.ChildProperty<AxisSet> implements IAxisSet {
    /**
     * Specifies header name.
     */
    formattedText: string;
    /**
     * Specifies header type.
     */
    type: string;
    /**
     * Specifies the drilled state of the header.
     */
    isDrilled: boolean;
    /**
     * Specifies the field whether it has child or not.
     */
    hasChild: boolean;
    /**
     * Specifies its child members.
     */
    members: this[];
    /**
     * Specifies its position collections in data source.
     */
    index: number[];
    /**
     * Specifies its position collections in data source with indexed object.
     */
    indexObject: INumberIndex;
    /**
     * Specifies its position in its field.
     */
    ordinal: number;
    /**
     * Specifies its level.
     */
    level: number;
    /**
     * Specifies its axis where it is plotted.
     */
    axis: string;
    /**
     * Specifies its value.
     */
    value: number;
    /**
     * Specifies its column span.
     */
    colSpan: number;
    /**
     * Specifies its row span.
     */
    rowSpan: number;
    /**
     * Specifies the data collection which is to be framed for value sorted members.
     */
    valueSort: IDataSet;
    /**
     * Specifies whether the cell is summary or not.
     */
    isSum: boolean;
}
/**
 * @hidden
 */
export interface PivotValues extends IPivotValues {
    [key: number]: {
        [key: number]: number | string | Object | AxisSetModel;
        length: number;
    };
    length: number;
}
/**
 * Renderer Export
 */
/**
 * Module to render PivotGrid control
 */
/** @hidden */
export  class Render {
    /** @hidden */
    parent: PivotView;
    /** @hidden */
    engine: PivotEngine;
    /** @hidden */
    gridSettings: GridSettingsModel;
    /** @hidden */
    rowStartPos: number;
    private formatList;
    private colPos;
    /** Constructor for render module */
    constructor(parent: PivotView);
    /** @hidden */
    render(): void;
    private bindGrid(parent);
    private injectGridModules(parent);
    /** @hidden */
    updateGridSettings(): void;
    private appendValueSortIcon(cell, tCell, rCnt, cCnt);
    private onResizeStop(args);
    private setGroupWidth(args);
    private rowCellBoundEvent(args);
    private columnCellBoundEvent(args);
    private getRowStartPos();
    private frameDataSource(type);
    private frameEmptyData();
    calculateColWidth(colCount: number): number;
    calculateGridWidth(): number | string;
    frameStackedHeaders(): grids.ColumnModel[];
    private frameEmptyColumns();
    /** @hidden */
    getFormatList(): string[];
    private excelColumnEvent(args);
    private pdfColumnEvent(args);
    private excelRowEvent(args);
    private pdfRowEvent(args);
    private exportHeaderEvent(args);
    private exportContentEvent(args);
}
 }
export namespace popups { 

/**
 * Collision module.
 */
export interface CollisionCoordinates {
    X: boolean;
    Y: boolean;
}
export  function fit(element: HTMLElement, viewPortElement?: HTMLElement, axis?: CollisionCoordinates, position?: OffsetPosition): OffsetPosition;
export  function isCollide(element: HTMLElement, viewPortElement?: HTMLElement, x?: number, y?: number): string[];
export  function flip(element: HTMLElement, target: HTMLElement, offsetX: number, offsetY: number, positionX: string, positionY: string, viewPortElement?: HTMLElement, axis?: CollisionCoordinates, fixedParent?: Boolean): void;
/**
 * Popup Components
 */
export  function calculateRelativeBasedPosition(anchor: HTMLElement, element: HTMLElement): OffsetPosition;
export  function calculatePosition(currentElement: Element, positionX?: string, positionY?: string, parentElement?: Boolean): OffsetPosition;
export interface OffsetPosition {
    left: number;
    top: number;
}
/**
 * Interface for a class ButtonProps
 */
export interface ButtonPropsModel {
    /**
     * Specifies the base.Button component properties to render the Dialog buttons.
     */
    buttonModel?: buttons.ButtonModel;
    /**
     * Event triggers when `click` the Dialog button.
     * @event
     */
    click?: base.EmitType<Object>;
}
/**
 * Interface for a class AnimationSettings
 */
export interface AnimationSettingsModel {
    /**
     * Specifies the effect to open and close the Dialog.  
     * If the user sets `Fade` effect then the Dialog will open with 'FadeIn' effect and close with 'FadeOut' effect.
     * Following list of effects will be available, you can use any of this.
     * 1. 'Fade'
     * 2. 'FadeZoom'
     * 3. 'FlipLeftDown'
     * 4. 'FlipLeftUp'
     * 5. 'FlipRightDown'
     * 6. 'FlipRightUp'
     * 7. 'FlipXDown'
     * 8. 'FlipXUp'
     * 9. 'FlipYLeft'
     * 10. 'FlipYRight'
     * 11. 'SlideBottom'
     * 12. 'SlideLeft'
     * 13. 'SlideRight'
     * 14. 'SlideTop'
     * 15. 'Zoom'
     * 16. 'None'
     */
    effect?: DialogEffect;
    /**
     * Specifies the animation `duration` to complete with one animation cycle.
     */
    duration?: number;
    /**
     * Specifies the `delay` value in milliseconds to wait before animation begins.
     */
    delay?: number;
}
/**
 * Interface for a class Dialog
 */
export interface DialogModel extends base.ComponentModel{
    /**
     * Specifies the `content` to be displayed in Dialog, it can be text or HTML element.
     * @default ''
     */
    content?: string | HTMLElement;
    /**
     * Specifies the value to either show or hide the close icon button.
     * @default false
     */
    showCloseIcon?: boolean;
    /**
     * Specifies the value to render the Dialog as modal or modeless.
     * @default false
     */
    isModal?: boolean;
    /**
     * Specifies the `header` content that defines how the Dialog `header` is rendered. 
     * @default ''
     */
    header?: string;
    /**
     * Specifies the value to either Dialog is opened or not.
     * @default true 
     */
    visible?: boolean;
    /**
     * Specifies the `height` of the Dialog. 
     * @default 'auto'
     */
    height?: string | number;
    /**
     * Specifies the `width` of the Dialog. 
     * @default '100%'
     */
    width?: string | number;
    /**
     * Specifies the CSS class name to be added for Dialog element.
     * User can add single or multiple CSS classes.
     * @default ''
     */
    cssClass?: string;
    /**
     * Specifies the z-index value for Dialog.
     */
    zIndex?: number;
    /**
     * Specifies the `target` element where the Dialog should be displayed.
     * If the user set the specific `target` element for Dialog, it will be positioned based on the `target`.
     * @default null
     */
    target?: HTMLElement | string;
    /**
     * Specifies the template content to defines how the Dialog footer is rendered. 
     * @default ''
     */
    footerTemplate?: string;
    /**
     * Specifies the value to either enable or disable draggable option in Dialog. 
     * @default false
     */
    allowDragging?: boolean;
    /**
     * Specifies the collection of Dialog `buttons` with click action and button component model.     
     * @default [{}]   
     */
    buttons?: ButtonPropsModel[];
    /**
     * Specifies the Dialog that is closed when user press the ESC key. 
     * @default true
     */
    closeOnEscape?: boolean;
    /**
     * Specifies the Dialog animation settings.
     * @default { effect: 'Fade', duration: 400, delay:0 }
     */
    animationSettings?: AnimationSettingsModel;
    /**
     * Specifies to `position` the Dialog on built-in 9 places or any custom location with
     * respect to the associated target elements.
     * For ex: {X:'left', Y:'top'} or { X: 100, Y: 100 }.
     * Following list of positions are available.
     * * for X is: left, center, right (or) any offset value
     * * for Y is: top, center, bottom (or) any offset value
     * @default {X:'center', Y:'center'}
     */
    position?: PositionDataModel;
    /**
     * Event triggers when the Dialog is `created`. 
     * @event
     */
    created?: base.EmitType<Object>;
    /**
     * Event triggers once Dialog is opened.
     * @event
     */
    open?: base.EmitType<Object>;
    /**
     * Event triggers before open the Dialog. 
     * @event
     */
    beforeOpen?: base.EmitType<BeforeOpenEventArgs>;
    /**
     * Event triggers once the Dialog is closed.
     * @event
     */
    close?: base.EmitType<Object>;
    /**
     * Event triggers before close the Dialog.
     * @event
     */
    beforeClose?: base.EmitType<BeforeCloseEventArgs>;
    /**
     * Event triggers when user starts to drag the Dialog. 
     * @event
     */
    dragStart?: base.EmitType<Object>;
    /**
     * Event triggers when the user stops dragging the Dialog.
     * @event
     */
    dragStop?: base.EmitType<Object>;
    /**
     * Event triggers when the user drags Dialog. 
     * @event
     */
    drag?: base.EmitType<Object>;
    /**
     * Event triggers when modal Dialog overlay is clicked. 
     * @event
     */
    overlayClick?: base.EmitType<Object>;
}
export  class ButtonProps extends base.ChildProperty<ButtonProps> {
    /**
     * Specifies the Button component properties to render the Dialog buttons.
     */
    buttonModel: buttons.ButtonModel;
    /**
     * Event triggers when `click` the Dialog button.
     * @event
     */
    click: base.EmitType<Object>;
}
/**
 * Specifies Dialog open and close animation settings.
 */
export  class AnimationSettings extends base.ChildProperty<AnimationSettings> {
    /**
     * Specifies the effect to open and close the Dialog.
     * If the user sets `Fade` effect then the Dialog will open with 'FadeIn' effect and close with 'FadeOut' effect.
     * Following list of effects will be available, you can use any of this.
     * 1. 'Fade'
     * 2. 'FadeZoom'
     * 3. 'FlipLeftDown'
     * 4. 'FlipLeftUp'
     * 5. 'FlipRightDown'
     * 6. 'FlipRightUp'
     * 7. 'FlipXDown'
     * 8. 'FlipXUp'
     * 9. 'FlipYLeft'
     * 10. 'FlipYRight'
     * 11. 'SlideBottom'
     * 12. 'SlideLeft'
     * 13. 'SlideRight'
     * 14. 'SlideTop'
     * 15. 'Zoom'
     * 16. 'None'
     */
    effect: DialogEffect;
    /**
     * Specifies the animation `duration` to complete with one animation cycle.
     */
    duration: number;
    /**
     * Specifies the `delay` value in milliseconds to wait before animation begins.
     */
    delay: number;
}
/**
 * Specifies the Dialog animation effects.
 */
export  type DialogEffect = 'Fade' | 'FadeZoom' | 'FlipLeftDown' | 'FlipLeftUp' | 'FlipRightDown' | 'FlipRightUp' | 'FlipXDown' | 'FlipXUp' | 'FlipYLeft' | 'FlipYRight' | 'SlideBottom' | 'SlideLeft' | 'SlideRight' | 'SlideTop' | 'Zoom' | 'None';
export interface BeforeOpenEventArgs {
    cancel: boolean;
    container: HTMLElement;
}
export interface BeforeCloseEventArgs {
    cancel: boolean;
    container: HTMLElement;
}
/**
 * Represents the Dialog component that displays information to the user, and used to get the user input.
 * ```html
 * <div id="dialog"></div>
 * ```
 * ```typescript
 * <script>
 *   var dialogObj = new Dialog({ header: 'Dialog' });
 *   dialogObj.appendTo("#dialog");
 * </script>
 * ```
 */
export  class Dialog extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    private closeIconClickEventHandler;
    private dlgOverlayClickEventHandler;
    private createEventHandler;
    private contentEle;
    private dlgOverlay;
    private dlgContainer;
    private headerEle;
    private buttonContent;
    private ftrTemplateContent;
    private headerContent;
    private closeIcon;
    private popupObj;
    private btnObj;
    private closeIconBtnObj;
    private dragObj;
    private primaryButtonEle;
    private targetEle;
    private dialogOpen;
    private storeActiveElement;
    private focusElements;
    private focusIndex;
    private closedFrom;
    private l10n;
    private clonedEle;
    /**
     * Specifies the `content` to be displayed in Dialog, it can be text or HTML element.
     * @default ''
     */
    content: string | HTMLElement;
    /**
     * Specifies the value to either show or hide the close icon button.
     * @default false
     */
    showCloseIcon: boolean;
    /**
     * Specifies the value to render the Dialog as modal or modeless.
     * @default false
     */
    isModal: boolean;
    /**
     * Specifies the `header` content that defines how the Dialog `header` is rendered.
     * @default ''
     */
    header: string;
    /**
     * Specifies the value to either Dialog is opened or not.
     * @default true
     */
    visible: boolean;
    /**
     * Specifies the `height` of the Dialog.
     * @default 'auto'
     */
    height: string | number;
    /**
     * Specifies the `width` of the Dialog.
     * @default '100%'
     */
    width: string | number;
    /**
     * Specifies the CSS class name to be added for Dialog element.
     * User can add single or multiple CSS classes.
     * @default ''
     */
    cssClass: string;
    /**
     * Specifies the z-index value for Dialog.
     */
    zIndex: number;
    /**
     * Specifies the `target` element where the Dialog should be displayed.
     * If the user set the specific `target` element for Dialog, it will be positioned based on the `target`.
     * @default null
     */
    target: HTMLElement | string;
    /**
     * Specifies the template content to defines how the Dialog footer is rendered.
     * @default ''
     */
    footerTemplate: string;
    /**
     * Specifies the value to either enable or disable draggable option in Dialog.
     * @default false
     */
    allowDragging: boolean;
    /**
     * Specifies the collection of Dialog `buttons` with click action and button component model.
     * @default [{}]
     */
    buttons: ButtonPropsModel[];
    /**
     * Specifies the Dialog that is closed when user press the ESC key.
     * @default true
     */
    closeOnEscape: boolean;
    /**
     * Specifies the Dialog animation settings.
     * @default { effect: 'Fade', duration: 400, delay:0 }
     */
    animationSettings: AnimationSettingsModel;
    /**
     * Specifies to `position` the Dialog on built-in 9 places or any custom location with
     * respect to the associated target elements.
     * For ex: {X:'left', Y:'top'} or { X: 100, Y: 100 }.
     * Following list of positions are available.
     * * for X is: left, center, right (or) any offset value
     * * for Y is: top, center, bottom (or) any offset value
     * @default {X:'center', Y:'center'}
     */
    position: PositionDataModel;
    /**
     * Event triggers when the Dialog is `created`.
     * @event
     */
    created: base.EmitType<Object>;
    /**
     * Event triggers once Dialog is opened.
     * @event
     */
    open: base.EmitType<Object>;
    /**
     * Event triggers before open the Dialog.
     * @event
     */
    beforeOpen: base.EmitType<BeforeOpenEventArgs>;
    /**
     * Event triggers once the Dialog is closed.
     * @event
     */
    close: base.EmitType<Object>;
    /**
     * Event triggers before close the Dialog.
     * @event
     */
    beforeClose: base.EmitType<BeforeCloseEventArgs>;
    /**
     * Event triggers when user starts to drag the Dialog.
     * @event
     */
    dragStart: base.EmitType<Object>;
    /**
     * Event triggers when the user stops dragging the Dialog.
     * @event
     */
    dragStop: base.EmitType<Object>;
    /**
     * Event triggers when the user drags Dialog.
     * @event
     */
    drag: base.EmitType<Object>;
    /**
     * Event triggers when modal Dialog overlay is clicked.
     * @event
     */
    overlayClick: base.EmitType<Object>;
    /**
     * Constructor for creating the widget
     * @hidden
     */
    constructor(options?: DialogModel, element?: string | HTMLElement);
    /**
     * Initialize the control rendering
     * @private
     */
    render(): void;
    /**
     * Initialize the event handler
     * @private
     */
    protected preRender(): void;
    private keyDown(event);
    /**
     * Initialize the control rendering
     * @private
     */
    private initialize();
    /**
     * Initialize the rendering
     * @private
     */
    private initRender();
    private setOverlayZindex();
    private positionChange();
    private setAllowDragging();
    private setButton();
    private setContent();
    private setMaxHeight();
    private setEnableRTL();
    private setTargetContent();
    private setHeader();
    private setFooterTemplate();
    private createHeaderContent();
    private renderCloseIcon();
    private closeIconTitle();
    private setCSSClass(oldCSSClass?);
    private setIsModal();
    private getValidFocusNode(items);
    private focusableElements(content);
    private getAutoFocusNode(container);
    private disableElement(element, t);
    private focusContent();
    private bindEvent(element);
    private unBindEvent(element);
    /**
     * Module required function
     * @private
     */
    protected getModuleName(): string;
    /**
     * Called internally if any of the property value changed
     * @private
     */
    onPropertyChanged(newProp: DialogModel, oldProp: DialogModel): void;
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    protected getPersistData(): string;
    /**
     * To destroy the widget
     * @method destroy
     * @return {void}
     * @private
     * @memberof dialog
     */
    destroy(): void;
    /**
     * Binding event to the element while widget creation
     * @hidden
     */
    private wireEvents();
    /**
     * Unbinding event to the element while widget destroy
     * @hidden
     */
    private unWireEvents();
    /**
     * Specifies dialog offset x and y position changed dynamically or
     * change the header,footer height or width dynamically, reposition the dialog as per the new changes.
     * @return {void}
     */
    refreshPosition(): void;
    /**
     * To show the Dialog element on screen.
     * To enable the fullScreen Dialog pass the parameter to 'true'.
     * @param { boolean } isFullScreen - Enable the fullScreen Dialog.
     * @return {void}
     */
    show(isFullScreen?: boolean): void;
    /**
     * To hide the Dialog element on screen.
     * @return {void}
     */
    hide(): void;
    /**
     * Specifies to view the Full screen Dialog.
     * @private
     */
    private fullScreen(args);
}
/**
 * Dialog Component
 */
/**
 * Popup Components
 */
/**
 * Popup Components
 */
/**
 * Interface for a class PositionData
 */
export interface PositionDataModel {
    /**
     * specify the offset left value
     */
    X?: string | number;
    /**
     * specify the offset top value.
     */
    Y?: string | number;
}
/**
 * Interface for a class Popup
 */
export interface PopupModel extends base.ComponentModel{
    /**
     * Specifies the height of the popup element. 
     * @default 'auto'
     */
    height?: string | number;
    /**
     * Specifies the height of the popup element.
     * @default 'auto'
     */
    width?: string | number;
    /**
     * Specifies the content of the popup element, it can be string or HTMLElement.
     * @default null
     */
    content?: string | HTMLElement;
    /**
     * Specifies the relative element type of the component.
     * @default 'container'
     */
    targetType?: TargetType;
    /**
     * Specifies the collision detectable container element of the component.
     * @default null
     */
    viewPortElement?: HTMLElement;
    /**
     * Specifies the collision handler settings of the component.
     * @default { X: 'none',Y: 'none' } 
     */
    collision?: CollisionAxis;
    /**
     * Specifies the relative container element of the popup element.Based on the relative element, popup element will be positioned.
     * 
     * @default 'body'
     */
    relateTo?: HTMLElement | string;
    /**
     * Specifies the popup element position, respective to the relative element.
     * @default {X:"left", Y:"top"}
     */
    position?: PositionDataModel;
    /**
     * specifies the popup element offset-x value, respective to the relative element.
     * @default 0
     */
    offsetX?: number;
    /**
     * specifies the popup element offset-y value, respective to the relative element.
     * @default 0
     */
    offsetY?: number;
    /**
     * specifies the z-index value of the popup element.
     * @default 1000
     */
    zIndex?: number;
    /**
     * specifies the rtl direction state of the popup element.
     * @default false
     */
    enableRtl?: boolean;
    /**
     * specifies the action that should happen when scroll the target-parent container.
     * This property should define either `reposition` or `hide`. 
     * when set `reposition` to this property, the popup position will refresh when scroll any parent container.
     * when set `hide` to this property, the popup will be closed when scroll any parent container. 
     * @default 'reposition'
     */
    actionOnScroll?: ActionOnScrollType;
    /**
     * specifies the animation that should happen when popup open.
     * @default 'null'
     */
    showAnimation?: base.AnimationModel;
    /**
     * specifies the animation that should happen when popup closes.
     * @default 'null'
     */
    hideAnimation?: base.AnimationModel;
    /**
     * Triggers the event once opened the popup.
     * @event
     */
    open?: base.EmitType<Object>;
    /**
     * Trigger the event once closed the popup.
     * @event
     */
    close?: base.EmitType<Object>;
    /**
     * Triggers the event when target element hide from view port on scroll.
     * @event
     */
    targetExitViewport?: base.EmitType<Object>;
}
/**
 * Specifies the offset position values.
 */
export  class PositionData extends base.ChildProperty<PositionData> {
    /**
     * specify the offset left value
     */
    X: string | number;
    /**
     * specify the offset top value.
     */
    Y: string | number;
}
export interface CollisionAxis {
    /**
     * specify the collision handler for a X-Axis.
     * @default : "none"
     */
    X?: CollisionType;
    /**
     * specify the collision handler for a Y-Axis.
     * @default : "none"
     */
    Y?: CollisionType;
}
/**
 * Collision type.
 */
export  type CollisionType = 'none' | 'flip' | 'fit';
/**
 * action on scroll type.
 */
export  type ActionOnScrollType = 'reposition' | 'hide' | 'none';
/**
 * Target element type.
 */
export  type TargetType = 'relative' | 'container';
/**
 * Represents the Popup base.Component
 * ```html
 * <div id="popup" style="position:absolute;height:100px;width:100px;">
 * <div style="margin:35px 25px;">Popup Content</div></div>
 * ```
 * ```typescript
 * <script>
 *   var popupObj = new Popup();
 *   popupObj.appendTo("#popup");
 * </script>
 * ```
 */
export  class Popup extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    private fixedParent;
    /**
     * Specifies the height of the popup element.
     * @default 'auto'
     */
    height: string | number;
    /**
     * Specifies the height of the popup element.
     * @default 'auto'
     */
    width: string | number;
    /**
     * Specifies the content of the popup element, it can be string or HTMLElement.
     * @default null
     */
    content: string | HTMLElement;
    /**
     * Specifies the relative element type of the component.
     * @default 'container'
     */
    targetType: TargetType;
    /**
     * Specifies the collision detectable container element of the component.
     * @default null
     */
    viewPortElement: HTMLElement;
    /**
     * Specifies the collision handler settings of the component.
     * @default { X: 'none',Y: 'none' }
     */
    collision: CollisionAxis;
    /**
     * Specifies the relative container element of the popup element.Based on the relative element, popup element will be positioned.
     *
     * @default 'body'
     */
    relateTo: HTMLElement | string;
    /**
     * Specifies the popup element position, respective to the relative element.
     * @default {X:"left", Y:"top"}
     */
    position: PositionDataModel;
    /**
     * specifies the popup element offset-x value, respective to the relative element.
     * @default 0
     */
    offsetX: number;
    /**
     * specifies the popup element offset-y value, respective to the relative element.
     * @default 0
     */
    offsetY: number;
    /**
     * specifies the z-index value of the popup element.
     * @default 1000
     */
    zIndex: number;
    /**
     * specifies the rtl direction state of the popup element.
     * @default false
     */
    enableRtl: boolean;
    /**
     * specifies the action that should happen when scroll the target-parent container.
     * This property should define either `reposition` or `hide`.
     * when set `reposition` to this property, the popup position will refresh when scroll any parent container.
     * when set `hide` to this property, the popup will be closed when scroll any parent container.
     * @default 'reposition'
     */
    actionOnScroll: ActionOnScrollType;
    /**
     * specifies the animation that should happen when popup open.
     * @default 'null'
     */
    showAnimation: base.AnimationModel;
    /**
     * specifies the animation that should happen when popup closes.
     * @default 'null'
     */
    hideAnimation: base.AnimationModel;
    /**
     * Triggers the event once opened the popup.
     * @event
     */
    open: base.EmitType<Object>;
    /**
     * Trigger the event once closed the popup.
     * @event
     */
    close: base.EmitType<Object>;
    /**
     * * Constructor for creating the widget
     */
    /**
     * Triggers the event when target element hide from view port on scroll.
     * @event
     */
    targetExitViewport: base.EmitType<Object>;
    private targetInvisibleStatus;
    constructor(element?: HTMLElement, options?: PopupModel);
    /**
     * Called internally if any of the property value changed.
     * @private
     */
    onPropertyChanged(newProp: PopupModel, oldProp: PopupModel): void;
    /**
     * gets the base.Component module name.
     * @private
     */
    getModuleName(): string;
    /**
     * gets the persisted state properties of the base.Component.
     */
    protected getPersistData(): string;
    /**
     * To destroy the control.
     */
    destroy(): void;
    /**
     * To Initialize the control rendering
     * @private
     */
    render(): void;
    private wireEvents();
    private wireScrollEvents();
    private unwireEvents();
    private unwireScrollEvents();
    private getRelateToElement();
    private scrollRefresh(e);
    /**
     * This method is to get the element visibility on viewport when scroll
     * the page. This method will returns true even though 1 px of element
     * part is in visible.
     */
    private isElementOnViewport(relateToElement, scrollElement);
    private isElementVisible(relateToElement, scrollElement);
    /**
     * Initialize the event handler
     * @private
     */
    protected preRender(): void;
    private setEnableRtl();
    private setContent();
    private orientationOnChange();
    /**
     * Based on the `relative` element and `offset` values, `Popup` element position will refreshed.
     */
    refreshPosition(target?: HTMLElement): void;
    private reposition();
    private getAnchorPosition(anchorEle, ele, position, offsetX, offsetY);
    private callFlip(param);
    private callFit(param);
    private checkCollision();
    /**
     * Shows the popup element from screen.
     * @param { base.AnimationModel | Function } collisionOrAnimationOptions? - To pass animation options or collision function.
     * @param { Function } collision? - To pass the collision function.
     */
    show(animationOptions?: base.AnimationModel): void;
    /**
     * Hides the popup element from screen.
     * @param { base.AnimationModel } animationOptions? - To give the animation options.
     */
    hide(animationOptions?: base.AnimationModel): void;
    /**
     * Gets scrollable parent elements for the given element.
     * @param { HTMLElement } element - Specify the element to get the scrollable parents of it.
     */
    getScrollableParent(element: HTMLElement): HTMLElement[];
    private checkFixedParent(element);
}
/**
 * Gets scrollable parent elements for the given element.
 * @param { HTMLElement } element - Specify the element to get the scrollable parents of it.
 * @private
 */
export  function getScrollableParent(element: HTMLElement, fixedParent?: Boolean): HTMLElement[];
/**
 * Gets the maximum z-index of the given element.
 * @param { HTMLElement } element - Specify the element to get the maximum z-index of it.
 * @private
 */
export  function getZindexPartial(element: HTMLElement): number;
/**
 * spinner modules
 */
/**
 * Defines the type of spinner.
 */
export  type SpinnerType = 'Material' | 'Fabric' | 'Bootstrap' | 'HighContrast';
/**
 * Create a spinner for the specified target element.
 * ```
 * E.g : createSpinner({ target: targetElement, width: '34px', label: 'Loading..' });
 * ```
 * @param args
 * @private
 */
export  function createSpinner(args: SpinnerArgs): void;
/**
 * Function to show the Spinner.
 * @param container - Specify the target of the Spinner.
 * @private
 */
export  function showSpinner(container: HTMLElement): void;
/**
 * Function to hide the Spinner.
 * @param container - Specify the target of the Spinner.
 * @private
 */
export  function hideSpinner(container: HTMLElement): void;
/**
 * Function to change the Spinners in a page globally from application end.
 * ```
 * E.g : setSpinner({ cssClass: 'custom-css'; type: 'Material' });
 * ```
 * @param args
 * @private
 */
export  function setSpinner(args: SetSpinnerArgs): void;
/**
 * Arguments to create a spinner for the target.These properties are optional.
 */
export interface SpinnerArgs {
    /**
     * Target element to the Spinner.
     * ```
     * E.g : createSpinner({ target: element });
     * ```
     */
    target: HTMLElement;
    /**
     *  To set the width of the Spinner.
     */
    width?: string | number;
    /**
     *  To set the label to the Spinner element.
     */
    label?: string;
    /**
     *  Sets the CSS classes to root element of the Spinner which helps to customize the complete UI styles.
     */
    cssClass?: string;
    /**
     *  Specify the template content to be displayed in the Spinner.
     */
    template?: string;
    /**
     *  Specify the type of the Spinner.
     */
    type?: SpinnerType;
}
/**
 * Arguments to change the Spinners in a page globally from application end.
 */
export interface SetSpinnerArgs {
    /**
     *  Specify the template content to be displayed in the Spinner.
     */
    template?: string;
    /**
     *  Sets the CSS classes to root element of the Spinner which helps to customize the complete UI styles.
     */
    cssClass?: string;
    /**
     *  Specify the type of the Spinner.
     */
    type?: SpinnerType;
}
/**
 * Tooltip modules
 */
/**
 * Interface for a class Animation
 */
export interface AnimationModel {
    /**
     * Animation settings to be applied on the Tooltip, while it is being shown over the target.
     */
    open?: TooltipAnimationSettings;
    /**
     * Animation settings to be applied on the Tooltip, when it is closed.
     */
    close?: TooltipAnimationSettings;
}
/**
 * Interface for a class Tooltip
 */
export interface TooltipModel extends base.ComponentModel{
    /**
     * It is used to set the width of Tooltip component which accepts both string and number values.
     * When set to auto, the Tooltip width gets auto adjusted to display its content within the viewable screen.
     * @default 'auto'
     */
    width?: string | number;
    /**
     * It is used to set the height of Tooltip component which accepts both string and number values.
     * When Tooltip content gets overflow due to height value then the scroll mode will be enabled.     
     * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/setting-dimension.html?lang=typescript here} 
     *  to know more about this property with demo.
     * @default 'auto'
     */
    height?: string | number;
    /**
     * It is used to display the content of Tooltip which can be both string and HTML Elements.
     * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/content.html?lang=typescript here} 
     *  to know more about this property with demo.
     */
    content?: string | HTMLElement;
    /**
     * It is used to denote the target selector where the Tooltip need to be displayed. 
     * The target element is considered as parent container.
     */
    target?: string;
    /**
     * It is used to set the position of Tooltip element, with respect to Target element.
     * @default 'TopCenter'
     */
    position?: Position;
    /**
     * It sets the space between the target and Tooltip element in X axis.
     * @default 0
     */
    offsetX?: number;
    /**
     * It sets the space between the target and Tooltip element in Y axis.
     * @default 0
     */
    offsetY?: number;
    /**
     * It is used to show or hide the tip pointer of Tooltip.
     * @default true
     */
    showTipPointer?: boolean;
    /**
     * It is used to set the position of tip pointer on tooltip.
     * When it sets to auto, the tip pointer auto adjusts within the space of target's length
     *  and does not point outside.     
     * Refer the documentation 
     *  {@link http://ej2.syncfusion.com/documentation/tooltip/position.html?lang=typescript#tip-pointer-positioning here} 
     *  to know more about this property with demo.
     * @default 'Auto'
     */
    tipPointerPosition?: TipPointerPosition;
    /**
     * It is used to determine the device mode to display the Tooltip content.
     * If it is in desktop, it will show the Tooltip content when hovering on the target element.
     * If it is in touch device, it will show the Tooltip content when tap and holding on the target element.
     * @default 'Auto'
     */
    opensOn?: string;
    /**
     * It allows the Tooltip to follow the mouse pointer movement over the specified target element.     
     * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/position.html?lang=typescript#mouse-trailing here} 
     *  to know more about this property with demo.
     * @default false
     */
    mouseTrail?: boolean;
    /**
     * It is used to display the Tooltip in an open state until closed by manually.     
     * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/open-mode.html?lang=typescript#sticky-mode here} 
     *  to know more about this property with demo.
     * @default false
     */
    isSticky?: Boolean;
    /**
     * We can set the same or different animation option to Tooltip while it is in open or close state.     
     * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/animation.html?lang=typescript here} 
     *  to know more about this property with demo.
     * @default { open: { effect: 'FadeIn', duration: 150, delay: 0 }, close: { effect: 'FadeOut', duration: 150, delay: 0 } }
     */
    animation?: AnimationModel;
    /**
     * It is used to open the Tooltip after the specified delay in milliseconds.
     * @default 0
     */
    openDelay?: number;
    /**
     * It is used to close the Tooltip after a specified delay in milliseconds.
     * @default 0
     */
    closeDelay?: number;
    /**
     * It is used to customize the Tooltip which accepts custom CSS class names that
     *  defines specific user-defined styles and themes to be applied on the Tooltip element.
     * @default null
     */
    cssClass?: string;
    /**
     * It is used to display the Tooltip and content of Tooltip from right to left direction.
     * @default false
     */
    enableRtl?: boolean;
    /**
     * We can trigger `beforeRender` event before the Tooltip and its contents are added to the DOM.
     * When one of its arguments `cancel` is set to true, the Tooltip can be prevented from rendering on the page.
     * This event is mainly used for the purpose of customizing the Tooltip before it shows up on the screen.
     * For example, to load the AJAX content or to set new animation effects on the Tooltip, this event can be opted.
     * Refer the documentation 
     *  {@link http://ej2.syncfusion.com/documentation/tooltip/content.html?lang=typescript#dynamic-content-via-ajax here} 
     *  to know more about this property with demo.
     * @event
     */
    beforeRender?: base.EmitType<TooltipEventArgs>;
    /**
     * We can trigger `beforeOpen` event before the Tooltip is displayed over the target element. 
     * When one of its arguments `cancel` is set to true, the Tooltip display can be prevented.
     * This event is mainly used for the purpose of refreshing the Tooltip positions dynamically or to
     *  set customized styles in it and so on.
     * @event
     */
    beforeOpen?: base.EmitType<TooltipEventArgs>;
    /**
     * We can trigger `afterOpen` event after the Tooltip base.Component gets opened.
     * @event
     */
    afterOpen?: base.EmitType<TooltipEventArgs>;
    /**
     * We can trigger `beforeClose` event before the Tooltip hides from the screen. If returned false, then the Tooltip is no more hidden.
     * @event
     */
    beforeClose?: base.EmitType<TooltipEventArgs>;
    /**
     * We can trigger `afterClose` event when the Tooltip base.Component gets closed.
     * @event
     */
    afterClose?: base.EmitType<TooltipEventArgs>;
    /**
     * We can trigger `beforeCollision` event for every collision base.fit calculation.
     * @event
     */
    beforeCollision?: base.EmitType<TooltipEventArgs>;
    /**
     * We can trigger `created` event after the Tooltip component is created.
     * @event
     */
    created?: base.EmitType<Object>;
    /**
     * We can trigger `destroyed` event when the Tooltip component is destroyed.
     * @event
     */
    destroyed?: base.EmitType<Object>;
}
/**
 * Set of open modes available for Tooltip.
 */
export  type OpenMode = 'Auto' | 'Hover' | 'Click' | 'Focus' | 'Custom';
/**
 * Applicable positions where the Tooltip can be displayed over specific target elements.
 */
export  type Position = 'TopLeft' | 'TopCenter' | 'TopRight' | 'BottomLeft' | 'BottomCenter' | 'BottomRight' | 'LeftTop' | 'LeftCenter' | 'LeftBottom' | 'RightTop' | 'RightCenter' | 'RightBottom';
/**
 * Applicable tip positions attached to the Tooltip.
 */
export  type TipPointerPosition = 'Auto' | 'Start' | 'Middle' | 'End';
/**
 * Animation effects that are applicable for Tooltip.
 */
export  type Effect = 'FadeIn' | 'FadeOut' | 'FadeZoomIn' | 'FadeZoomOut' | 'FlipXDownIn' | 'FlipXDownOut' | 'FlipXUpIn' | 'FlipXUpOut' | 'FlipYLeftIn' | 'FlipYLeftOut' | 'FlipYRightIn' | 'FlipYRightOut' | 'ZoomIn' | 'ZoomOut' | 'None';
/**
 * Interface for Tooltip event arguments.
 */
export interface TooltipEventArgs extends base.BaseEventArgs {
    /**
     * It is used to denote the type of the triggered event.
     */
    type: String;
    /**
     * It illustrates whether the current action needs to be prevented or not.
     */
    cancel: Boolean;
    /**
     * It is used to specify the current event object.
     */
    event: Event;
    /**
     * It is used to denote the current target element where the Tooltip is to be displayed.
     */
    target: HTMLElement;
    /**
     * It is used to denote the Tooltip element
     */
    element: HTMLElement;
    /**
     * It is used to denote the Collided Tooltip position
     */
    collidedPosition?: string;
}
/**
 * Animation options that are common for both open and close actions of the Tooltip.
 */
export interface TooltipAnimationSettings {
    /**
     * It is used to apply the Animation effect on the Tooltip, during open and close actions.
     */
    effect?: Effect;
    /**
     * It is used to denote the duration of the animation that is completed per animation cycle.
     */
    duration?: number;
    /**
     * It is used to denote the delay value in milliseconds and indicating the waiting time before animation begins.
     */
    delay?: number;
}
export  class Animation extends base.ChildProperty<Animation> {
    /**
     * Animation settings to be applied on the Tooltip, while it is being shown over the target.
     */
    open: TooltipAnimationSettings;
    /**
     * Animation settings to be applied on the Tooltip, when it is closed.
     */
    close: TooltipAnimationSettings;
}
/**
 * Represents the Tooltip component that displays a piece of information about the target element on mouse hover.
 * ```html
 * <div id="tooltip">Show Tooltip</div>
 * ```
 * ```typescript
 * <script>
 *   var tooltipObj = new Tooltip({ content: 'Tooltip text' });
 *   tooltipObj.appendTo("#tooltip");
 * </script>
 * ```
 */
export  class Tooltip extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    private popupObj;
    private tooltipEle;
    private ctrlId;
    private tipClass;
    private tooltipPositionX;
    private tooltipPositionY;
    private tooltipEventArgs;
    private isHidden;
    private showTimer;
    private hideTimer;
    private tipWidth;
    private tipHeight;
    private touchModule;
    private autoCloseTimer;
    /**
     * It is used to set the width of Tooltip component which accepts both string and number values.
     * When set to auto, the Tooltip width gets auto adjusted to display its content within the viewable screen.
     * @default 'auto'
     */
    width: string | number;
    /**
     * It is used to set the height of Tooltip component which accepts both string and number values.
     * When Tooltip content gets overflow due to height value then the scroll mode will be enabled.
     * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/setting-dimension.html?lang=typescript here}
     *  to know more about this property with demo.
     * @default 'auto'
     */
    height: string | number;
    /**
     * It is used to display the content of Tooltip which can be both string and HTML Elements.
     * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/content.html?lang=typescript here}
     *  to know more about this property with demo.
     */
    content: string | HTMLElement;
    /**
     * It is used to denote the target selector where the Tooltip need to be displayed.
     * The target element is considered as parent container.
     */
    target: string;
    /**
     * It is used to set the position of Tooltip element, with respect to Target element.
     * @default 'TopCenter'
     */
    position: Position;
    /**
     * It sets the space between the target and Tooltip element in X axis.
     * @default 0
     */
    offsetX: number;
    /**
     * It sets the space between the target and Tooltip element in Y axis.
     * @default 0
     */
    offsetY: number;
    /**
     * It is used to show or hide the tip pointer of Tooltip.
     * @default true
     */
    showTipPointer: boolean;
    /**
     * It is used to set the position of tip pointer on tooltip.
     * When it sets to auto, the tip pointer auto adjusts within the space of target's length
     *  and does not point outside.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/tooltip/position.html?lang=typescript#tip-pointer-positioning here}
     *  to know more about this property with demo.
     * @default 'Auto'
     */
    tipPointerPosition: TipPointerPosition;
    /**
     * It is used to determine the device mode to display the Tooltip content.
     * If it is in desktop, it will show the Tooltip content when hovering on the target element.
     * If it is in touch device, it will show the Tooltip content when tap and holding on the target element.
     * @default 'Auto'
     */
    opensOn: string;
    /**
     * It allows the Tooltip to follow the mouse pointer movement over the specified target element.
     * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/position.html?lang=typescript#mouse-trailing here}
     *  to know more about this property with demo.
     * @default false
     */
    mouseTrail: boolean;
    /**
     * It is used to display the Tooltip in an open state until closed by manually.
     * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/open-mode.html?lang=typescript#sticky-mode here}
     *  to know more about this property with demo.
     * @default false
     */
    isSticky: Boolean;
    /**
     * We can set the same or different animation option to Tooltip while it is in open or close state.
     * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/animation.html?lang=typescript here}
     *  to know more about this property with demo.
     * @default { open: { effect: 'FadeIn', duration: 150, delay: 0 }, close: { effect: 'FadeOut', duration: 150, delay: 0 } }
     */
    animation: AnimationModel;
    /**
     * It is used to open the Tooltip after the specified delay in milliseconds.
     * @default 0
     */
    openDelay: number;
    /**
     * It is used to close the Tooltip after a specified delay in milliseconds.
     * @default 0
     */
    closeDelay: number;
    /**
     * It is used to customize the Tooltip which accepts custom CSS class names that
     *  defines specific user-defined styles and themes to be applied on the Tooltip element.
     * @default null
     */
    cssClass: string;
    /**
     * It is used to display the Tooltip and content of Tooltip from right to left direction.
     * @default false
     */
    enableRtl: boolean;
    /**
     * We can trigger `beforeRender` event before the Tooltip and its contents are added to the DOM.
     * When one of its arguments `cancel` is set to true, the Tooltip can be prevented from rendering on the page.
     * This event is mainly used for the purpose of customizing the Tooltip before it shows up on the screen.
     * For example, to load the AJAX content or to set new animation effects on the Tooltip, this event can be opted.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/tooltip/content.html?lang=typescript#dynamic-content-via-ajax here}
     *  to know more about this property with demo.
     * @event
     */
    beforeRender: base.EmitType<TooltipEventArgs>;
    /**
     * We can trigger `beforeOpen` event before the Tooltip is displayed over the target element.
     * When one of its arguments `cancel` is set to true, the Tooltip display can be prevented.
     * This event is mainly used for the purpose of refreshing the Tooltip positions dynamically or to
     *  set customized styles in it and so on.
     * @event
     */
    beforeOpen: base.EmitType<TooltipEventArgs>;
    /**
     * We can trigger `afterOpen` event after the Tooltip base.Component gets opened.
     * @event
     */
    afterOpen: base.EmitType<TooltipEventArgs>;
    /**
     * We can trigger `beforeClose` event before the Tooltip hides from the screen. If returned false, then the Tooltip is no more hidden.
     * @event
     */
    beforeClose: base.EmitType<TooltipEventArgs>;
    /**
     * We can trigger `afterClose` event when the Tooltip base.Component gets closed.
     * @event
     */
    afterClose: base.EmitType<TooltipEventArgs>;
    /**
     * We can trigger `beforeCollision` event for every collision fit calculation.
     * @event
     */
    beforeCollision: base.EmitType<TooltipEventArgs>;
    /**
     * We can trigger `created` event after the Tooltip component is created.
     * @event
     */
    created: base.EmitType<Object>;
    /**
     * We can trigger `destroyed` event when the Tooltip component is destroyed.
     * @event
     */
    destroyed: base.EmitType<Object>;
    /**
     * Constructor for creating the Tooltip base.Component
     */
    constructor(options?: TooltipModel, element?: string | HTMLElement);
    private initialize();
    private formatPosition();
    private renderArrow();
    private setTipClass(position);
    private renderPopup(target);
    private getTooltipPosition(target);
    private reposition(target);
    private openPopupHandler();
    private closePopupHandler();
    private calculateTooltipOffset(position);
    private updateTipPosition(position);
    private adjustArrow(target, position, tooltipPositionX, tooltipPositionY);
    private renderContent(target?);
    private renderCloseIcon();
    private addDescribedBy(target, id);
    private removeDescribedBy(target);
    private tapHoldHandler(evt);
    private touchEndHandler(e);
    private targetClick(e);
    private targetHover(e);
    private showTooltip(target, showAnimation, e?);
    private checkCollision(target, x, y);
    private collisionFlipFit(target, x, y);
    private hideTooltip(hideAnimation, e?, targetElement?);
    private restoreElement(target);
    private clear();
    private onMouseOut(e);
    private onStickyClose(e);
    private onMouseMove(event);
    private keyDown(event);
    private touchEnd(e);
    private scrollHandler(e);
    /**
     * Core method that initializes the control rendering.
     * @private
     */
    render(): void;
    /**
     * Initializes the values of private members.
     * @private
     */
    protected preRender(): void;
    /**
     * Binding events to the Tooltip element.
     * @hidden
     */
    private wireEvents(trigger);
    private getTriggerList(trigger);
    private wireFocusEvents();
    private wireMouseEvents(e, target);
    /**
     * Unbinding events from the element on widget destroy.
     * @hidden
     */
    private unwireEvents(trigger);
    private unwireFocusEvents();
    private unwireMouseEvents(target);
    /**
     * Core method to return the component name.
     * @private
     */
    getModuleName(): string;
    /**
     * Returns the properties to be maintained in the persisted state.
     * @private
     */
    protected getPersistData(): string;
    /**
     * Called internally, if any of the property value changed.
     * @private
     */
    onPropertyChanged(newProp: TooltipModel, oldProp: TooltipModel): void;
    /**
     * It is used to show the Tooltip on the specified target with specific animation settings.
     * @param element Target element where the Tooltip is to be displayed.
     * @param animation Sets the specific animation, while showing the Tooltip on the screen.
     * @return {void}
     */
    open(element: HTMLElement, animation?: TooltipAnimationSettings): void;
    /**
     * It is used to hide the Tooltip with specific animation effect.
     * @param animation Sets the specific animation when hiding Tooltip from the screen.
     * @return {void}
     */
    close(animation?: TooltipAnimationSettings): void;
    /**
     * It is used to refresh the Tooltip content and its position.
     * @param target Target element where the Tooltip content or position needs to be refreshed.
     * @return {void}
     */
    refresh(target?: HTMLElement): void;
    /**
     * It is used to destroy the Tooltip component.
     * @method destroy
     * @return {void}
     * @memberof Tooltip
     */
    destroy(): void;
}
 }
export namespace richtexteditor { 

/**
 * Default Markdown formats config for adapter
 */
export  const markdownFormatTags: {
    [key: string]: string;
};
/**
 * Default selection formats config for adapter
 */
export  const markdownSelectionTags: {
    [key: string]: string;
};
/**
 * Default Markdown lists config for adapter
 */
export  const markdownListsTags: {
    [key: string]: string;
};
/**
 * Default html key config for adapter
 */
export  const htmlKeyConfig: {
    [key: string]: string;
};
/**
 * Default  markdown key config for adapter
 */
export  const markdownKeyConfig: {
    [key: string]: string;
};
/**
 * Constant values for Common
 */
export  const KEY_DOWN: string;
export  const ACTION: string;
export  const FORMAT_TYPE: string;
export  const KEY_DOWN_HANDLER: string;
export  const LIST_TYPE: string;
export  const KEY_UP_HANDLER: string;
export  const KEY_UP: string;
/**
 * Export the common module
 */
/**
 * Specifies  common models interfaces.
 * @hidden
 */
export interface IMarkdownFormatterCallBack {
    selectedText?: string;
    editorMode?: EditorMode;
    action?: string;
    event?: KeyboardEvent | MouseEvent;
    requestType?: string;
}
export interface IHtmlFormatterCallBack {
    selectedNode?: Element;
    requestType?: string;
    range?: Range;
    editorMode?: EditorMode;
    action?: string;
    elements?: Element | Element[];
    event?: KeyboardEvent | MouseEvent;
}
export interface IMarkdownToolbarStatus {
    OrderedList: boolean;
    UnorderedList: boolean;
    Formats: string;
}
export interface IUndoCallBack {
    callBack?: Function;
    event?: Object;
}
export interface IToolbarStatus {
    bold?: boolean;
    italic?: boolean;
    underline?: boolean;
    strikethrough?: boolean;
    superscript?: boolean;
    subscript?: boolean;
    fontcolor?: string;
    fontname?: string;
    fontsize?: string;
    backgroundcolor?: string;
    formats?: string;
    alignments?: string;
    orderedlist?: boolean;
    unorderedlist?: boolean;
    inlinecode?: boolean;
    uppercase?: boolean;
    createlink?: boolean;
}
/**
 * Exports types used by RichTextEditor.
 */
export  type EditorMode = 'HTML' | 'Markdown';
/**
 * RichTextEditor component exported items
 */
/**
 * Base export
 */
/**
 * Constant values for EditorManager
 */
export  const IMAGE: string;
export  const LINK: string;
export  const ALIGNMENT_TYPE: string;
export  const INDENT_TYPE: string;
/** @hidden */
export  const DEFAULT_TAG: string;
/** @hidden */
export  const BLOCK_TAGS: string[];
export  const SELECTION_TYPE: string;
export  const INSERTHTML_TYPE: string;
export  const CLEAR_TYPE: string;
/**
 * EditorManager internal component
 * @hidden
 */
export  class EditorManager {
    currentDocument: HTMLDocument;
    observer: base.Observer;
    listObj: Lists;
    nodeSelection: NodeSelection;
    domNode: DOMNode;
    formatObj: Formats;
    linkObj: LinkCommand;
    alignmentObj: Alignments;
    indentsObj: Indents;
    imgObj: ImageCommand;
    selectionObj: SelectionBasedExec;
    inserthtmlObj: InsertHtmlExec;
    clearObj: ClearFormatExec;
    undoRedoManager: UndoRedoManager;
    editableElement: Element;
    /**
     * Constructor for creating the component
     * @hidden
     */
    constructor(options: ICommandModel);
    private wireEvents();
    private editorKeyDown(e);
    private editorKeyUp(e);
    execCommand<T>(command: any, value: T, event?: Event, callBack?: Function, text?: string | Node, exeValue?: T): void;
}

/**
 * Specifies  Command models interfaces.
 * @hidden
 */
export interface ICommandModel {
    /**
     * Specifies the current document.
     */
    document: HTMLDocument;
    /**
     * Specifies the current window.
     */
    editableElement: Element;
    options?: {
        [key: string]: number;
    };
}
/**
 * Specifies IHtmlSubCommands interfaces.
 * @hidden
 */
export interface IHtmlSubCommands {
    /**
     * Specifies the subCommand.
     */
    subCommand: string;
    /**
     * Specifies the callBack.
     */
    callBack(args: IHtmlFormatterCallBack): () => void;
    /**
     * Specifies the callBack.
     */
    value?: string | Node;
    /**
     * Specifies the originalEvent.
     */
    event?: MouseEvent;
}
/**
 * Specifies  IKeyboardActionArgs interfaces for command line.
 * @hidden
 */
export interface IKeyboardActionArgs extends KeyboardEvent {
    /**
     * action of the KeyboardEvent
     */
    action: string;
}
export interface IHtmlItem {
    module?: string;
    event?: KeyboardEvent | MouseEvent;
    selection?: NodeSelection;
    link?: HTMLInputElement;
    selectNode?: Node[];
    selectParent?: Node[];
    item: IHtmlItemArgs;
    subCommand: string;
    callBack(args: IHtmlFormatterCallBack): () => void;
}
export interface IHtmlItemArgs {
    selection?: NodeSelection;
    selectNode?: Node[];
    selectParent?: Node[];
    url?: string;
    text?: string;
    title?: string;
    target?: string;
    width?: number | string;
    height?: number | string;
    altText?: string;
}
export interface IHtmlUndoRedoData {
    text?: string;
    range?: NodeSelection;
}
/**
 * Specifies IHtmlKeyboardEvent interfaces.
 * @hidden
 */
export interface IHtmlKeyboardEvent {
    /**
     * Specifies the callBack.
     */
    callBack(args?: IHtmlFormatterCallBack): () => void;
    /**
     * Specifies the event.
     */
    event: base.KeyboardEventArgs;
    /**
     * Specifies the ignoreDefault.
     */
    ignoreDefault?: boolean;
}
/**
 * Types type for EditorManager
 */
export  type EditorExecCommand = 'Indents' | 'Lists' | 'Formats' | 'Alignments' | 'Links' | 'Images' | 'Font' | 'Style' | 'Clear' | 'Effects' | 'Casing' | 'InsertHtml' | 'Actions';
/**
 * Base export
 */
/**
 * Base export
 */
/**
 * Formats internal component
 * @hidden
 */
export  class Alignments {
    private parent;
    private alignments;
    /**
     * Constructor for creating the Formats plugin
     * @hidden
     */
    constructor(parent: EditorManager);
    private addEventListener();
    private onKeyDown(e);
    private applyAlignment(e);
}
/**
 * Clear Format EXEC internal component
 * @hidden
 */
export  class ClearFormatExec {
    private parent;
    /**
     * Constructor for creating the Formats plugin
     * @hidden
     */
    constructor(parent: EditorManager);
    private addEventListener();
    private onKeyDown(e);
    private applyClear(e);
}
export  class ClearFormats {
    private static BLOCK_TAGS;
    private static NONVALID_PARENT_TAGS;
    private static NONVALID_TAGS;
    static clear(docElement: Document, endNode: Node): void;
    private static reSelection(docElement, save, exactNodes);
    private static clearBlocks(docElement, nodes, endNode, nodeCutter, nodeSelection);
    private static spliceParent(parentNodes, nodes);
    private static removeChild(parentNodes, parentNode);
    private static removeParent(parentNodes);
    private static unWrap(docElement, parentNodes, nodeCutter, nodeSelection);
    private static clearInlines(textNodes, nodes, range, nodeCutter, endNode);
    private static removeInlineParent(textNodes);
}
export  const markerClassName: {
    [key: string]: string;
};
/**
 * DOMNode internal plugin
 * @hidden
 */
export  class DOMNode {
    private parent;
    private currentDocument;
    private nodeSelection;
    /**
     * Constructor for creating the DOMNode plugin
     * @hidden
     */
    constructor(parent: Element, currentDocument: Document);
    contents(element: Element): Node[];
    isBlockNode(element: Element): boolean;
    isLink(element: Element): boolean;
    blockParentNode(element: Element): Element;
    rawAttributes(element: Element): {
        [key: string]: string;
    };
    attributes(element?: Element): string;
    clearAttributes(element: Element): void;
    openTagString(element: Element): string;
    closeTagString(element: Element): string;
    createTagString(tagName: string, relativeElement: Element, innerHTML: string): string;
    isList(element: Element): boolean;
    isElement(element: Element): boolean;
    isEditable(element: Element): boolean;
    hasClass(element: Element, className: string): boolean;
    replaceWith(element: Element, value: string): void;
    parseHTMLFragment(value: string): Element;
    wrap(element: Element, wrapper: DocumentFragment): Element;
    insertAfter(newNode: Element, referenceNode: Element): void;
    wrapInner(parent: Element, wrapper: Element): Element;
    unWrap(element: Element): Element[];
    getSelectedNode(element: Element, index: number): Element;
    nodeFinds(element: Element, elements: Element[]): Element[];
    isEditorArea(): boolean;
    getRangePoint(point?: number): Range | Range[];
    getSelection(): Selection;
    getPreviousNode(element: Element): Element;
    encode(value: string): string;
    saveMarker(save: NodeSelection): NodeSelection;
    private marker(className, textContent);
    setMarker(save: NodeSelection): void;
    blockNodes(): Node[];
}
/**
 * Formats internal component
 * @hidden
 */
export  class Formats {
    private parent;
    /**
     * Constructor for creating the Formats plugin
     * @hidden
     */
    constructor(parent: EditorManager);
    private addEventListener();
    private getParentNode(node);
    private applyFormats(e);
    private cleanFormats(element, tagName);
}
/**
 * Link internal component
 * @hidden
 */
export  class ImageCommand {
    private parent;
    /**
     * Constructor for creating the Formats plugin
     * @hidden
     */
    constructor(parent: EditorManager);
    private addEventListener();
    private createImage(e);
}
/**
 * Indents internal component
 * @hidden
 */
export  class Indents {
    private parent;
    private indentValue;
    /**
     * Constructor for creating the Formats plugin
     * @hidden
     */
    constructor(parent: EditorManager);
    private addEventListener();
    private onKeyDown(e);
    private applyIndents(e);
}
/**
 * Node appending methods.
 * @hidden
 */
export  class InsertMethods {
    static WrapBefore(textNode: Text, parentNode: HTMLElement, isAfter?: boolean): Text;
    static Wrap(childNode: HTMLElement, parentNode: HTMLElement): HTMLElement;
    static unwrap(node: Node | HTMLElement): Node[];
    static AppendBefore(textNode: HTMLElement | Text | DocumentFragment, parentNode: HTMLElement | Text | DocumentFragment, isAfter?: boolean): HTMLElement | Text | DocumentFragment;
}
/**
 * Selection EXEC internal component
 * @hidden
 */
export  class InsertHtmlExec {
    private parent;
    /**
     * Constructor for creating the Formats plugin
     * @hidden
     */
    constructor(parent: EditorManager);
    private addEventListener();
    private applyHtml(e);
}
/**
 * Insert a HTML Node or Text
 * @hidden
 */
export  class InsertHtml {
    static Insert(docElement: Document, insertNode: Node | string): void;
}
/**
 * Is formatted or not.
 * @hidden
 */
export  class IsFormatted {
    static inlineTags: string[];
    getFormattedNode(node: Node, format: string, endNode: Node): Node;
    private getFormatParent(node, format, endNode);
    private isFormattedNode(node, format);
    static isBold(node: Node): boolean;
    static isItalic(node: Node): boolean;
    static isUnderline(node: Node): boolean;
    static isStrikethrough(node: Node): boolean;
    static isSuperscript(node: Node): boolean;
    static isSubscript(node: Node): boolean;
    private isFontColor(node);
    private isBackgroundColor(node);
    private isFontSize(node);
    private isFontName(node);
}
/**
 * Link internal component
 * @hidden
 */
export  class LinkCommand {
    private parent;
    /**
     * Constructor for creating the Formats plugin
     * @hidden
     */
    constructor(parent: EditorManager);
    private addEventListener();
    private createLink(e);
}
/**
 * Lists internal component
 * @hidden
 */
export  class Lists {
    private parent;
    private startContainer;
    private endContainer;
    private saveSelection;
    private domNode;
    private currentAction;
    /**
     * Constructor for creating the Lists plugin
     * @hidden
     */
    constructor(parent: EditorManager);
    private addEventListener();
    private keyDownHandler(e);
    private getAction(element);
    private revertClean();
    private nestedList(elements);
    private applyListsHandler(e);
    private applyLists(elements, type);
    private isRevert(nodes, tagName);
    private checkLists(nodes, tagName);
    private cleanNode();
    private revertList(elements);
    private openTag(type);
    private closeTag(type);
}
/**
 * Split the Node based on selection
 * @hidden
 */
export  class NodeCutter {
    position: number;
    private nodeSelection;
    GetSpliceNode(range: Range, node: HTMLElement): Node;
    private SplitNode(range, node, isCollapsed);
    private spliceEmptyNode(fragment, isStart);
    private GetCursorStart(indexes, index, isStart);
    GetCursorRange(docElement: Document, range: Range, node: Node): Range;
    GetCursorNode(docElement: Document, range: Range, node: Node): Node;
    TrimLineBreak(line: string): string;
}
export  class SelectionCommands {
    static applyFormat(docElement: Document, format: string, endNode: Node, value?: string): void;
    private static insertCursorNode(domSelection, range, isFormatted, nodeCutter, format, value, endNode);
    private static removeFormat(nodes, index, formatNode, isCursor, isFormat, isFontStyle, range, nodeCutter, format, value, domSelection);
    private static insertFormat(nodes, index, formatNode, isCursor, isFormat, isFontStyle, range, nodeCutter, format, value);
    private static getInsertNode(range, format, value);
    private static getChildNode(node, element);
    private static applySelection(nodes, domSelection, nodeCutter, index, isCollapsed);
    private static GetFormatNode(format, value?);
}
/**
 * Selection EXEC internal component
 * @hidden
 */
export  class SelectionBasedExec {
    private parent;
    /**
     * Constructor for creating the Formats plugin
     * @hidden
     */
    constructor(parent: EditorManager);
    private addEventListener();
    private keyDownHandler(e);
    private applySelection(e);
    private callBack(event, action);
}
/**
 * Update Toolbar Status
 * @hidden
 */
export  const statusCollection: IToolbarStatus;
export  class ToolbarStatus {
    static get(docElement: Document, targetNode: Node, formatNode?: string[], fontSize?: string[], fontName?: string[]): IToolbarStatus;
    private static getFormatParent(docElement, formatCollection, node, targetNode, formatNode?, fontSize?, fontName?);
    private static isFormattedNode(docElement, formatCollection, node, formatNode?, fontSize?, fontName?);
    private static isFontColor(docElement, node);
    private static isLink(node);
    private static isBackgroundColor(node);
    private static isFontSize(node, fontSize?);
    private static isFontName(docElement, node, fontName?);
    private static isOrderedList(node);
    private static isUnorderedList(node);
    private static isAlignment(node);
    private static isFormats(node, formatNode?);
    private static getComputedStyle(docElement, node, prop);
}
/**
 * `Undo` module is used to handle undo actions.
 */
export  class UndoRedoManager {
    element: HTMLElement;
    private parent;
    steps: number;
    undoRedoStack: IHtmlUndoRedoData[];
    undoRedoSteps: number;
    undoRedoTimer: number;
    constructor(parent?: EditorManager, options?: {
        [key: string]: number;
    });
    protected addEventListener(): void;
    protected removeEventListener(): void;
    onAction(e: IHtmlSubCommands): void;
    /**
     * Destroys the ToolBar.
     * @method destroy
     * @return {void}
     */
    destroy(): void;
    private keyDown(e);
    private keyUp(e);
    /**
     * RTE collection stored html format.
     * @method saveData
     * @return {void}
     */
    saveData(e?: KeyboardEvent | MouseEvent | IUndoCallBack): void;
    /**
     * Undo the editable text.
     * @method undo
     * @return {void}
     */
    undo(e?: IHtmlSubCommands | IHtmlKeyboardEvent): void;
    /**
     * Redo the editable text.
     * @method redo
     * @return {void}
     */
    redo(e?: IHtmlSubCommands | IHtmlKeyboardEvent): void;
    getUndoStatus(): {
        [key: string]: boolean;
    };
}
/**
 * RichTextEditor component exported items
 */
/**
 * Base export
 */
/**
 * Constant values for Markdown Parser
 */
export  const LISTS_COMMAND: string;
export  const selectionCommand: string;
export  const LINK_COMMAND: string;
export  const CLEAR_COMMAND: string;
/**
 * Specifies IMDFormats interfaces.
 * @hidden
 */
export interface IMDFormats {
    /**
     * Specifies the formatTags.
     */
    syntax?: {
        [key: string]: string;
    };
    /**
     * Specifies the parent.
     */
    parent?: MarkdownParser;
}
/**
 * Specifies ISelectedLines interfaces.
 * @hidden
 */
export interface ISelectedLines {
    /**
     * Specifies the parentLinePoints.
     */
    parentLinePoints: {
        [key: string]: string | number;
    }[];
    /**
     * Specifies the textarea selection start point.
     */
    start: number;
    /**
     * Specifies the textarea selection end point.
     */
    end: number;
}
/**
 * Specifies MarkdownParserModel interfaces.
 * @hidden
 */
export interface IMarkdownParserModel {
    /**
     * Specifies the element.
     */
    element: Element;
    /**
     * Specifies the formatTags.
     */
    formatTags?: {
        [key: string]: string;
    };
    /**
     * Specifies the formatTags.
     */
    listTags?: {
        [key: string]: string;
    };
    /**
     * Specifies the selectionTags.
     */
    selectionTags?: {
        [key: string]: string;
    };
    /**
     * Specifies the options.
     */
    options?: {
        [key: string]: number;
    };
}
/**
 * Specifies ISubCommands interfaces.
 * @hidden
 */
export interface IMarkdownSubCommands {
    /**
     * Specifies the subCommand.
     */
    subCommand: string;
    /**
     * Specifies the callBack.
     */
    callBack(args?: IMarkdownFormatterCallBack): () => void;
    /**
     * Specifies the originalEvent.
     */
    event?: MouseEvent;
}
export interface MarkdownUndoRedoData {
    text?: string;
    start?: number;
    end?: number;
}
export interface IMarkdownItem {
    module?: string;
    event?: KeyboardEvent | MouseEvent;
    item: IMarkdownItemArgs;
    subCommand: string;
    callBack(args: IMarkdownFormatterCallBack): () => void;
}
export interface IMarkdownItemArgs {
    url?: string;
    text?: string;
    target?: string;
    width?: number | string;
    height?: number | string;
}
/**
 * Specifies IMDKeyboardEvent interfaces.
 * @hidden
 */
export interface IMDKeyboardEvent {
    /**
     * Specifies the callBack.
     */
    callBack(args?: IMarkdownFormatterCallBack): () => void;
    /**
     * Specifies the event.
     */
    event: base.KeyboardEventArgs;
}
/**
 * MarkdownParser internal component
 * @hidden
 */
export  class MarkdownParser {
    observer: base.Observer;
    listObj: MDLists;
    formatObj: MDFormats;
    formatTags: {
        [key: string]: string;
    };
    listTags: {
        [key: string]: string;
    };
    selectionTags: {
        [key: string]: string;
    };
    element: Element;
    undoRedoManager: UndoRedoCommands;
    mdSelectionFormats: MDSelectionFormats;
    markdownSelection: MarkdownSelection;
    linkObj: MDLink;
    clearObj: ClearFormat;
    /**
     * Constructor for creating the component
     * @hidden
     */
    constructor(options: IMarkdownParserModel);
    private initialize();
    private wireEvents();
    private editorKeyDown(e);
    private editorKeyUp(e);
    execCommand<T>(command: MarkdownExecCommand, value: T, event?: Event, callBack?: Function, text?: string, exeValue?: T): void;
}
/**
 * Types type for Markdown parser
 */
export  type MarkdownExecCommand = 'Indents' | 'Lists' | 'Formats' | 'Alignments' | 'Style' | 'Effects' | 'Casing' | 'Actions' | 'Links' | 'Images' | 'Clear';
/**
 * Base export
 */
/**
 * Export all markdown plugins
 */
/**
 * Link internal component
 * @hidden
 */
export  class ClearFormat {
    private parent;
    private selection;
    /**
     * Constructor for creating the clear format plugin
     * @hidden
     */
    constructor(parent: MarkdownParser);
    private addEventListener();
    private replaceRegex(data);
    private clearSelectionTags(text);
    private clearFormatTags(text);
    private clear(e);
    private restore(textArea, start, end, event?);
}
/**
 * MDFormats internal plugin
 * @hidden
 */
export  class MDFormats {
    private parent;
    private selection;
    syntax: {
        [key: string]: string;
    };
    /**
     * Constructor for creating the Formats plugin
     * @hidden
     */
    constructor(options: IMDFormats);
    private addEventListener();
    private applyFormats(e);
    private clearRegex();
    private cleanFormat(textArea, command?);
    private applyCodeBlock(textArea, event, parents);
    private restore(textArea, start, end, event?);
}
/**
 * Link internal component
 * @hidden
 */
export  class MDLink {
    private parent;
    private selection;
    /**
     * Constructor for creating the Formats plugin
     * @hidden
     */
    constructor(parent: MarkdownParser);
    private addEventListener();
    private createLink(e);
    private restore(textArea, start, end, event?);
}
/**
 * Lists internal component
 * @hidden
 */
export  class MDLists {
    private parent;
    private startContainer;
    private endContainer;
    private selection;
    private syntax;
    private currentAction;
    /**
     * Constructor for creating the Lists plugin
     * @hidden
     */
    constructor(options: IMDFormats);
    private addEventListener();
    private keyDownHandler(event);
    private keyUpHandler(event);
    private tabKey(event);
    private getTabSpace(line);
    private isNotFirstLine(textArea, points);
    private getAction(line);
    private enterKey(event);
    private applyListsHandler(e);
    private appliedLine(line);
    private restore(textArea, start, end, event?);
    private getListRegex();
}
/**
 * MarkdownSelection internal module
 * @hidden
 */
export  class MarkdownSelection {
    selectionStart: number;
    selectionEnd: number;
    getLineNumber(textarea: HTMLTextAreaElement, point: number): number;
    getSelectedText(textarea: HTMLTextAreaElement): string;
    getAllParents(value: string): string[];
    getSelectedLine(textarea: HTMLTextAreaElement): string;
    getLine(textarea: HTMLTextAreaElement, index: number): string;
    getSelectedParentPoints(textarea: HTMLTextAreaElement): {
        [key: string]: string | number;
    }[];
    setSelection(textarea: HTMLTextAreaElement, start: number, end: number): void;
    save(start: number, end: number): void;
    restore(textArea: HTMLTextAreaElement): void;
    isStartWith(line: string, command: string): boolean;
    replaceSpecialChar(value: string): string;
    isClear(parents: {
        [key: string]: string | number;
    }[], regex: string): boolean;
    getRegex(syntax: string): RegExp;
    getSelectedInlinePoints(textarea: HTMLTextAreaElement): {
        [key: string]: string | number;
    };
}
/**
 * SelectionCommands internal component
 * @hidden
 */
export  class MDSelectionFormats {
    private parent;
    private selection;
    syntax: {
        [key: string]: string;
    };
    private currentAction;
    constructor(parent: IMDFormats);
    private addEventListener();
    private keyDownHandler(e);
    private isBold(text, cmd);
    private isItalic(text, cmd);
    private isMatch(text, cmd);
    private multiCharRegx(cmd);
    private singleCharRegx(cmd);
    isAppliedCommand(cmd?: string): boolean;
    private applyCommands(e);
    private replaceAt(input, search, replace, start, end);
    private restore(textArea, start, end, event?);
    private textReplace(text, command);
    private isApplied(line, command);
}
/**
 * `Undo` module is used to handle undo actions.
 */
export  class UndoRedoCommands {
    steps: number;
    undoRedoStack: MarkdownUndoRedoData[];
    private parent;
    private selection;
    private currentAction;
    undoRedoSteps: number;
    undoRedoTimer: number;
    constructor(parent?: MarkdownParser, options?: {
        [key: string]: number;
    });
    protected addEventListener(): void;
    protected removeEventListener(): void;
    /**
     * Destroys the ToolBar.
     * @method destroy
     * @return {void}
     */
    destroy(): void;
    onAction(e: IMarkdownSubCommands): void;
    private keyDown(e);
    private keyUp(e);
    /**
     * MD collection stored string format.
     * @method saveData
     * @return {void}
     */
    saveData(e?: KeyboardEvent | MouseEvent | IUndoCallBack): void;
    /**
     * Undo the editable text.
     * @method undo
     * @return {void}
     */
    undo(e?: IMarkdownSubCommands | IMDKeyboardEvent): void;
    /**
     * Redo the editable text.
     * @method redo
     * @return {void}
     */
    redo(e?: IMarkdownSubCommands | IMDKeyboardEvent): void;
    private restore(textArea, start, end, event?);
    getUndoStatus(): {
        [key: string]: boolean;
    };
}
/**
 * RichTextEditor component exported items
 */
/**
 * Action export
 */
/**
 * `Quick toolbar` module is used to handle Quick toolbar actions.
 */
export  class BaseQuickToolbar {
    popupObj: popups.Popup;
    element: HTMLElement;
    private isDOMElement;
    quickTBarObj: BaseToolbar;
    private stringItems;
    private dropDownButtons;
    private locator;
    private parent;
    private contentRenderer;
    private popupRenderer;
    toolbarElement: HTMLElement;
    private renderFactory;
    constructor(parent?: IRichTextEditor, locator?: ServiceLocator);
    private appendPopupContent();
    render(args: IQuickToolbarOptions): void;
    private createToolbar(items, mode);
    private setPosition(e);
    private checkCollision(e, viewPort, type);
    showPopup(x: number, y: number, target: Element): void;
    hidePopup(): void;
    /**
     * @hidden
     */
    addQTBarItem(item: (string | IToolbarItems)[], index: number): void;
    /**
     * @hidden
     */
    removeQTBarItem(index: number | HTMLElement[] | Element[]): void;
    private removeEleFromDOM();
    private updateStatus(args);
    /**
     * Destroys the Quick toolbar.
     * @method destroy
     * @return {void}
     */
    destroy(): void;
    addEventListener(): void;
    removeEventListener(): void;
}
/**
 * `Toolbar` module is used to handle Toolbar actions.
 */
export  class BaseToolbar {
    toolbarObj: navigations.Toolbar;
    protected parent: IRichTextEditor;
    protected locator: ServiceLocator;
    protected toolbarRenderer: IRenderer;
    protected renderFactory: RendererFactory;
    constructor(parent?: IRichTextEditor, serviceLocator?: ServiceLocator);
    private getTemplateObject(itemStr, container);
    getObject(item: string, container: string): IToolbarItemModel;
    /**
     * @hidden
     */
    getItems(tbItems: (string | IToolbarItems)[], container: string): navigations.ItemModel[];
    private getToolbarOptions(args);
    render(args: IToolbarRenderOptions): void;
}
/**
 * `Color Picker` module is used to handle ColorPicker actions.
 */
export  class ColorPickerInput {
    private fontColorPicker;
    private backgroundColorPicker;
    private fontColorDropDown;
    private backgroundColorDropDown;
    protected parent: IRichTextEditor;
    protected locator: ServiceLocator;
    protected toolbarRenderer: IRenderer;
    protected renderFactory: RendererFactory;
    constructor(parent?: IRichTextEditor, serviceLocator?: ServiceLocator);
    private initializeInstance();
    renderColorPickerInput(args: IColorPickerRenderArgs): void;
    private destroy();
    private destroyColorPicker();
    protected addEventListener(): void;
    protected removeEventListener(): void;
}
/**
 * `Count` module is used to handle Count actions.
 */
export  class Count {
    protected parent: IRichTextEditor;
    protected maxLength: number;
    protected htmlLength: number;
    protected locator: ServiceLocator;
    protected renderFactory: RendererFactory;
    private editPanel;
    private contentModule;
    private contentRenderer;
    private args;
    private element;
    constructor(parent?: IRichTextEditor, serviceLocator?: ServiceLocator);
    private initializeInstance();
    renderCount(): void;
    private appendCount();
    private charCountBackground(htmlLength);
    private refresh();
    private restrict(e);
    /**
     * Destroys the Count.
     * @method destroy
     * @return {void}
     */
    destroy(): void;
    private toggle(e);
    protected addEventListener(): void;
    protected removeEventListener(): void;
    /**
     * For internal use only - Get the module name.
     */
    private getModuleName();
}
/**
 * `Toolbar` module is used to handle Toolbar actions.
 */
export  class DropDownButtons {
    formatDropDown: splitbuttons.DropDownButton;
    fontNameDropDown: splitbuttons.DropDownButton;
    fontSizeDropDown: splitbuttons.DropDownButton;
    alignDropDown: splitbuttons.DropDownButton;
    imageAlignDropDown: splitbuttons.DropDownButton;
    displayDropDown: splitbuttons.DropDownButton;
    protected parent: IRichTextEditor;
    protected locator: ServiceLocator;
    protected toolbarRenderer: IRenderer;
    protected renderFactory: RendererFactory;
    constructor(parent?: IRichTextEditor, serviceLocator?: ServiceLocator);
    private initializeInstance();
    private beforeRender(args);
    private dropdownContent(width, type, content);
    renderDropDowns(args: IDropDownRenderArgs): void;
    private removeDropDownClasses(target);
    destroyDropDowns(): void;
    protected addEventListener(): void;
    private onIframeMouseDown();
    protected removeEventListener(): void;
}
/**
 * `ExecCommandCallBack` module is used to run the editor manager command
 */
export  class ExecCommandCallBack {
    protected parent: IRichTextEditor;
    constructor(parent?: IRichTextEditor);
    private addEventListener();
    private commandCallBack(args);
    private removeEventListener();
}
/**
 * `FullScreen` module is used to maximize and minimize screen
 */
export  class FullScreen {
    private overflowData;
    protected parent: IRichTextEditor;
    private scrollableParent;
    constructor(parent?: IRichTextEditor);
    showFullScreen(event?: MouseEvent | base.KeyboardEventArgs): void;
    hideFullScreen(event?: MouseEvent | base.KeyboardEventArgs): void;
    private toggleParentOverflow(isAdd);
    private onKeyDown(event);
    protected addEventListener(): void;
    protected removeEventListener(): void;
    destroy(): void;
}
/**
 * Used to set the HTML Attributes for RTE container
 */
export  function setAttributes(htmlAttributes: {
    [key: string]: string;
}, rte: IRichTextEditor, isFrame: boolean): void;
/**
 * `HtmlEditor` module is used to HTML editor
 */
export  class HtmlEditor {
    private parent;
    private locator;
    private contentRenderer;
    private renderFactory;
    private toolbarUpdate;
    private colorPickerModule;
    private nodeSelectionObj;
    private rangeCollection;
    private saveSelection;
    constructor(parent?: IRichTextEditor, serviceLocator?: ServiceLocator);
    /**
     * Destroys the Markdown.
     * @method destroy
     * @return {void}
     */
    destroy(): void;
    private addEventListener();
    private onSelectionSave();
    private onSelectionRestore(e);
    private onKeyDown(e);
    private spaceLink(e?);
    private removeText(text, val);
    private onToolbarClick(args);
    private renderColorPicker(args);
    private instantiateRenderer();
    private removeEventListener();
    private render();
    /**
     * Called internally if any of the property value changed.
     * @hidden
     */
    protected onPropertyChanged(e: NotifyArgs): void;
    /**
     * For internal use only - Get the module name.
     */
    private getModuleName();
    /**
     * For selecting all content in RTE
     * @private
     */
    private selectAll();
    /**
     * For selecting all content in RTE
     * @private
     */
    private selectRange(e);
    /**
     * For get a selected text in RTE
     * @private
     */
    private getSelectedHtml(e);
}
/**
 * HtmlToolbarStatus module for refresh the toolbar status
 */
export  class HtmlToolbarStatus {
    parent: IRichTextEditor;
    toolbarStatus: IToolbarStatus;
    constructor(parent: IRichTextEditor);
    private addEventListener();
    private removeEventListener();
    private onRefreshHandler(args);
}
/**
 * Interface for a class KeyboardEvents
 */
export interface KeyboardEventsModel {
    /**
     * Specifies key combination and it respective action name.
     * @default null
     */
    keyConfigs?: { [key: string]: string };
    /**
     * Specifies on which event keyboardEvents class should listen for key press. For ex., `keyup`, `keydown` or `keypress`
     * @default keyup
     */
    eventName?: string;
    /**
     * Specifies the listener when keyboard actions is performed. 
     * @event
     */
    keyAction?: base.EmitType<KeyboardEventArgs>;
}
/**
 * KeyboardEvents
 */
export interface KeyboardEventArgs extends KeyboardEvent {
    /**
     * action of the KeyboardEvent
     */
    action: string;
}
/**
 * KeyboardEvents class enables you to bind key action desired key combinations for ex., Ctrl+A, Delete, Alt+Space etc.
 * ```html
 * <div id='testEle'>  </div>;
 * <script>
 *   let node: HTMLElement = document.querySelector('#testEle');
 *   let kbInstance = new KeyboardEvents({
 *       element: node,
 *       keyConfigs:{ selectAll : 'ctrl+a' },
 *       keyAction: function (e:KeyboardEvent, action:string) {
 *           // handler function code
 *       }
 *   });
 * </script>
 * ```
 */
export  class KeyboardEvents extends base.Base<HTMLElement> implements base.INotifyPropertyChanged {
    /**
     * Specifies key combination and it respective action name.
     * @default null
     */
    keyConfigs: {
        [key: string]: string;
    };
    /**
     * Specifies on which event keyboardEvents class should listen for key press. For ex., `keyup`, `keydown` or `keypress`
     * @default keyup
     */
    eventName: string;
    /**
     * Specifies the listener when keyboard actions is performed.
     * @event
     */
    keyAction: base.EmitType<KeyboardEventArgs>;
    /**
     * Initializes the KeyboardEvents
     * @param {HTMLElement} element
     * @param {base.KeyboardEventsModel} options
     */
    constructor(element: HTMLElement, options?: base.KeyboardEventsModel);
    /**
     * Unwire bound events and destroy the instance.
     * @return {void}
     */
    destroy(): void;
    /**
     * Function can be used to specify certain action if a property is changed
     * @param newProp
     * @param oldProp
     * @returns {void}
     * @private
     */
    onPropertyChanged(newProp: base.KeyboardEventsModel, oldProp?: base.KeyboardEventsModel): void;
    protected bind(): void;
    /**
     * To get the module name, returns 'keyboard'.
     * @private
     */
    getModuleName(): string;
    /**
     * Wiring event handlers to events
     */
    private wireEvents();
    /**
     * Unwiring event handlers to events
     */
    private unwireEvents();
    /**
     * To handle a key press event returns null
     */
    private keyPressHandler;
    private static configCache;
    /**
     * To get the key configuration data
     * @param {string} config - configuration data
     * returns {KeyData}
     */
    private static getKeyConfigData(config);
    private static getKeyCode(keyVal);
}
/**
 * `MarkdownEditor` module is used to markdown editor
 */
export  class MarkdownEditor {
    private parent;
    private locator;
    private contentRenderer;
    private renderFactory;
    private toolbarUpdate;
    private saveSelection;
    private mdSelection;
    constructor(parent?: IRichTextEditor, serviceLocator?: ServiceLocator);
    /**
     * Destroys the Markdown.
     * @method destroy
     * @return {void}
     */
    destroy(): void;
    private addEventListener();
    private onSelectionSave();
    private onSelectionRestore(e);
    private onToolbarClick(args);
    private instantiateRenderer();
    private removeEventListener();
    private render();
    /**
     * Called internally if any of the property value changed.
     * @hidden
     */
    protected onPropertyChanged(e: NotifyArgs): void;
    /**
     * For internal use only - Get the module name.
     */
    private getModuleName();
    /**
     * For selecting all content in RTE
     * @private
     */
    private selectAll();
    /**
     * For get a selected text in RTE
     * @private
     */
    private getSelectedHtml(e);
}
/**
 * MarkdownToolbarStatus module for refresh the toolbar status
 */
export  class MarkdownToolbarStatus {
    selection: MarkdownSelection;
    parent: IRichTextEditor;
    element: HTMLTextAreaElement;
    toolbarStatus: IToolbarStatus;
    constructor(parent: IRichTextEditor);
    private addEventListener();
    private removeEventListener();
    private onRefreshHandler(args);
    private isListsApplied(lines, type);
    private currentFormat(lines);
}
export interface ITextAreaElement extends HTMLTextAreaElement {
    selectionDirection?: string;
}
/**
 * `Quick toolbar` module is used to handle Quick toolbar actions.
 */
export  class QuickToolbar {
    private offsetX;
    private offsetY;
    private deBouncer;
    private target;
    private locator;
    private parent;
    private contentRenderer;
    linkQTBar: BaseQuickToolbar;
    textQTBar: BaseQuickToolbar;
    imageQTBar: BaseQuickToolbar;
    inlineQTBar: BaseQuickToolbar;
    private renderFactory;
    constructor(parent?: IRichTextEditor, locator?: ServiceLocator);
    private formatItems(items);
    private getQTBarOptions(popType, mode, items, type);
    createQTBar(popupType: string, mode: string, items: (string | IToolbarItems)[], type: RenderType): BaseQuickToolbar;
    private initializeQuickToolbars();
    private onMouseDown(e);
    private renderQuickToolbars();
    private renderInlineQuickToolbar();
    private showInlineQTBar(x, y, target);
    private hideInlineQTBar();
    private hideQuickToolbars();
    private deBounce(x, y, target);
    private mouseUpHandler(e);
    private keyDownHandler();
    private inlineQTBarMouseDownHandler();
    private keyUpHandler(e);
    getInlineBaseToolbar(): BaseToolbar;
    /**
     * Destroys the ToolBar.
     * @method destroy
     * @return {void}
     */
    destroy(): void;
    private wireInlineQTBarEvents();
    private unWireInlineQTBarEvents();
    private toolbarUpdated(args);
    addEventListener(): void;
    private onKeyDown(e);
    private onIframeMouseDown();
    removeEventListener(): void;
    /**
     * Called internally if any of the property value changed.
     * @hidden
     */
    protected onPropertyChanged(e: NotifyArgs): void;
    /**
     * For internal use only - Get the module name.
     */
    private getModuleName();
}
/**
 * `ToolbarAction` module is used to toolbar click action
 */
export  class ToolbarAction {
    protected parent: IRichTextEditor;
    private serviceLocator;
    constructor(parent?: IRichTextEditor);
    private addEventListener();
    private toolbarClick(args);
    private dropDownSelect(e);
    private renderSelection(args);
    private removeEventListener();
}
/**
 * `Toolbar` module is used to handle Toolbar actions.
 */
export  class Toolbar {
    toolbarObj: navigations.Toolbar;
    private editPanel;
    private isToolbar;
    private editableElement;
    private tbItems;
    baseToolbar: BaseToolbar;
    private tbElement;
    private tbWrapper;
    protected parent: IRichTextEditor;
    protected locator: ServiceLocator;
    private contentRenderer;
    protected toolbarRenderer: IRenderer;
    private dropDownModule;
    private toolbarActionModule;
    protected renderFactory: RendererFactory;
    private keyBoardModule;
    constructor(parent?: IRichTextEditor, serviceLocator?: ServiceLocator);
    private initializeInstance();
    private toolbarBindEvent();
    private toolBarKeyDown(e);
    private createToolbarElement();
    private getToolbarMode();
    private checkToolbarResponsive(ele);
    private toggleFloatTBarOffset(action, top);
    private toggleFloatClass(e?);
    private renderToolbar();
    addFixedTBarClass(): void;
    removeFixedTBarClass(): void;
    private showFixedTBar();
    private hideFixedTBar();
    updateItem(args: IUpdateItemsModel): void;
    private updateToolbarStatus(args);
    private fullScreen(e?);
    private hideScreen(e?);
    getBaseToolbar(): BaseToolbar;
    addTBarItem(args: IUpdateItemsModel, index: number): void;
    enableTBarItems(baseToolbar: BaseToolbar, items: string | string[], isEnable: boolean): void;
    removeTBarItems(items: string | string[]): void;
    getExpandTBarPopHeight(): number;
    getToolbarHeight(): number;
    getToolbarElement(): Element;
    refreshToolbarOverflow(): void;
    private isToolbarDestroyed();
    private destroyToolbar();
    /**
     * Destroys the ToolBar.
     * @method destroy
     * @return {void}
     */
    destroy(): void;
    private scrollHandler(e);
    private mouseDownHandler();
    private focusChangeHandler();
    private dropDownBeforeOpenHandler();
    private toolbarMouseDownHandler(e);
    protected wireEvents(): void;
    protected unWireEvents(): void;
    protected addEventListener(): void;
    protected removeEventListener(): void;
    /**
     * Called internally if any of the property value changed.
     * @hidden
     */
    protected onPropertyChanged(e: NotifyArgs): void;
    /**
     * For internal use only - Get the module name.
     */
    private getModuleName();
}
/**
 * Base export
 */
/**
 * RichTextEditor classes defined here.
 */
/** @hidden */
export  const CLS_RTE: string;
/** @hidden */
export  const CLS_RTL: string;
/** @hidden */
export  const CLS_CONTENT: string;
/** @hidden */
export  const CLS_DISABLED: string;
/** @hidden */
export  const CLS_SCRIPT_SHEET: string;
/** @hidden */
export  const CLS_STYLE_SHEET: string;
/** @hidden */
export  const CLS_TOOLBAR: string;
/** @hidden */
export  const CLS_TB_FIXED: string;
/** @hidden */
export  const CLS_TB_FLOAT: string;
/** @hidden */
export  const CLS_INLINE: string;
/** @hidden */
export  const CLS_TB_INLINE: string;
/** @hidden */
export  const CLS_RTE_EXPAND_TB: string;
/** @hidden */
export  const CLS_FULL_SCREEN: string;
/** @hidden */
export  const CLS_QUICK_TB: string;
/** @hidden */
export  const CLS_POP: string;
/** @hidden */
export  const CLS_QUICK_POP: string;
/** @hidden */
export  const CLS_QUICK_DROPDOWN: string;
/** @hidden */
export  const CLS_IMAGE_POP: string;
/** @hidden */
export  const CLS_INLINE_POP: string;
/** @hidden */
export  const CLS_INLINE_DROPDOWN: string;
/** @hidden */
export  const CLS_DROPDOWN_POPUP: string;
/** @hidden */
export  const CLS_DROPDOWN_ICONS: string;
/** @hidden */
export  const CLS_DROPDOWN_ITEMS: string;
/** @hidden */
export  const CLS_DROPDOWN_BTN: string;
/** @hidden */
export  const CLS_RTE_CONTENT: string;
/** @hidden */
export  const CLS_TB_ITEM: string;
/** @hidden */
export  const CLS_TB_EXTENDED: string;
/** @hidden */
export  const CLS_TB_WRAP: string;
/** @hidden */
export  const CLS_POPUP: string;
/** @hidden */
export  const CLS_SEPARATOR: string;
/** @hidden */
export  const CLS_MINIMIZE: string;
/** @hidden */
export  const CLS_MAXIMIZE: string;
/** @hidden */
export  const CLS_BACK: string;
/** @hidden */
export  const CLS_SHOW: string;
/** @hidden */
export  const CLS_HIDE: string;
/** @hidden */
export  const CLS_VISIBLE: string;
/** @hidden */
export  const CLS_FOCUS: string;
/** @hidden */
export  const CLS_RM_WHITE_SPACE: string;
/** @hidden */
export  const CLS_IMGRIGHT: string;
/** @hidden */
export  const CLS_IMGLEFT: string;
/** @hidden */
export  const CLS_IMGCENTER: string;
/** @hidden */
export  const CLS_IMGBREAK: string;
/** @hidden */
export  const CLS_CAPTION: string;
/** @hidden */
export  const CLS_CAPINLINE: string;
/** @hidden */
export  const CLS_IMGINLINE: string;
/** @hidden */
export  const CLS_COUNT: string;
/** @hidden */
export  const CLS_WARNING: string;
/** @hidden */
export  const CLS_ERROR: string;
/** @hidden */
export  const CLS_ICONS: string;
/** @hidden */
export  const CLS_ACTIVE: string;
/** @hidden */
export  const CLS_EXPAND_OPEN: string;
/** @hidden */
export  const CLS_RTE_ELEMENTS: string;
/** @hidden */
export  const CLS_TB_BTN: string;
/** @hidden */
export  const CLS_HR_SEPARATOR: string;
/** @hidden */
export  const CLS_TB_IOS_FIX: string;
/** @hidden */
export  const CLS_TB_STATIC: string;
/** @hidden */
export  const CLS_FORMATS_TB_BTN: string;
/** @hidden */
export  const CLS_FONT_NAME_TB_BTN: string;
/** @hidden */
export  const CLS_FONT_SIZE_TB_BTN: string;
/** @hidden */
export  const CLS_FONT_COLOR_TARGET: string;
/** @hidden */
export  const CLS_BACKGROUND_COLOR_TARGET: string;
/** @hidden */
export  const CLS_COLOR_CONTENT: string;
/** @hidden */
export  const CLS_FONT_COLOR_DROPDOWN: string;
/** @hidden */
export  const CLS_BACKGROUND_COLOR_DROPDOWN: string;
/** @hidden */
export  const CLS_COLOR_PALETTE: string;
/** @hidden */
export  const CLS_FONT_COLOR_PICKER: string;
/** @hidden */
export  const CLS_BACKGROUND_COLOR_PICKER: string;
/** @hidden */
export  const CLS_RTE_READONLY: string;
/** @hidden */
export  const created: string;
/** @hidden */
export  const destroyed: string;
/** @hidden */
export  const load: string;
/**
 * Specifies RichTextEditor internal events
 */
/** @hidden */
export  const initialLoad: string;
/** @hidden */
export  const initialEnd: string;
/** @hidden */
export  const iframeMouseDown: string;
/** @hidden */
export  const destroy: string;
/** @hidden */
export  const toolbarClick: string;
/** @hidden */
export  const toolbarRefresh: string;
/** @hidden */
export  const toolbarUpdated: string;
/** @hidden */
export  const bindOnEnd: string;
/** @hidden */
export  const renderColorPicker: string;
/** @hidden */
export  const htmlToolbarClick: string;
/** @hidden */
export  const markdownToolbarClick: string;
/** @hidden */
export  const destroyColorPicker: string;
/** @hidden */
export  const modelChanged: string;
/** @hidden */
export  const keyUp: string;
/** @hidden */
export  const keyDown: string;
/** @hidden */
export  const mouseUp: string;
/** @hidden */
export  const toolbarCreated: string;
/** @hidden */
export  const toolbarRenderComplete: string;
/** @hidden */
export  const enableFullScreen: string;
/** @hidden */
export  const disableFullScreen: string;
/** @hidden */
export  const dropDownSelect: string;
/** @hidden */
export  const beforeDropDownItemRender: string;
/** @hidden */
export  const execCommandCallBack: string;
/** @hidden */
export  const imageToolbarAction: string;
/** @hidden */
export  const linkToolbarAction: string;
/** @hidden */
export  const undo: string;
/** @hidden */
export  const redo: string;
/** @hidden */
export  const insertLink: string;
/** @hidden */
export  const unLink: string;
/** @hidden */
export  const editLink: string;
/** @hidden */
export  const openLink: string;
/** @hidden */
export  const actionBegin: string;
/** @hidden */
export  const actionComplete: string;
/** @hidden */
export  const actionSuccess: string;
/** @hidden */
export  const popupOpen: string;
/** @hidden */
export  const updateToolbarItem: string;
/** @hidden */
export  const insertImage: string;
/** @hidden */
export  const insertCompleted: string;
/** @hidden */
export  const imageLeft: string;
/** @hidden */
export  const imageRight: string;
/** @hidden */
export  const imageCenter: string;
/** @hidden */
export  const imageBreak: string;
/** @hidden */
export  const imageInline: string;
/** @hidden */
export  const imageLink: string;
/** @hidden */
export  const imageAlt: string;
/** @hidden */
export  const imageDelete: string;
/** @hidden */
export  const imageCaption: string;
/** @hidden */
export  const imageSize: string;
/** @hidden */
export  const sourceCode: string;
/** @hidden */
export  const updateSource: string;
/** @hidden */
export  const toolbarOpen: string;
/** @hidden */
export  const beforeDropDownOpen: string;
/** @hidden */
export  const selectionSave: string;
/** @hidden */
export  const selectionRestore: string;
/** @hidden */
export  const expandPopupClick: string;
/** @hidden */
export  const count: string;
/** @hidden */
export  const contentFocus: string;
/** @hidden */
export  const contentBlur: string;
/** @hidden */
export  const mouseDown: string;
/** @hidden */
export  const sourceCodeMouseDown: string;
/** @hidden */
export  const editAreaClick: string;
/** @hidden */
export  const scroll: string;
/** @hidden */
export  const colorPickerChanged: string;
/** @hidden */
export  const focusChange: string;
/** @hidden */
export  const selectAll: string;
/** @hidden */
export  const selectRange: string;
/** @hidden */
export  const getSelectedHtml: string;
/** @hidden */
export  const renderInlineToolbar: string;
/**
 * Defines types of Render
 * @hidden
 */
export  enum RenderType {
    /**  Defines RenderType as Toolbar */
    Toolbar = 0,
    /**  Defines RenderType as Content */
    Content = 1,
    /**  Defines RenderType as Content */
    Popup = 2,
    /**  Defines RenderType as LinkToolbar */
    LinkToolbar = 3,
    /**  Defines RenderType as TextToolbar */
    TextToolbar = 4,
    /**  Defines RenderType as ImageToolbar */
    ImageToolbar = 5,
    /**  Defines RenderType as ImageToolbar */
    InlineToolbar = 6,
}
export  type Action = 'refresh' | 'print' | 'Undo' | 'Redo';
export  type ActionOnScroll = 'hide' | 'none';
export  enum ToolbarType {
    /**  Defines ToolbarType as Standard */
    Expand = "Expand",
    /**  Defines ToolbarType as MultiRow */
    MultiRow = "MultiRow",
}
/**
 * Specifies RichTextEditor interfaces.
 * @hidden
 */
export interface IRichTextEditor extends base.Component<HTMLElement> {
    toolbarSettings?: ToolbarSettingsModel;
    quickToolbarSettings?: QuickToolbarSettingsModel;
    iframeSettings?: IFrameSettingsModel;
    /**
     * Configures the image settings of the RTE.
     * @default
     * {
     *  allowedTypes: ['jpeg', 'jpg', 'png'],
     * display: 'inline', width: '200px',
     * height: '200px', saveUrl:null, path: null, resize: false
     * }
     */
    insertImageSettings: ImageSettingsModel;
    floatingToolbarOffset?: number;
    showCharCount?: boolean;
    enableTabKey?: boolean;
    maxLength?: number;
    inlineMode?: InlineModeModel;
    width?: string | number;
    fontFamily?: IFontProperties;
    fontSize?: IFontProperties;
    fontColor?: IColorProperties;
    backgroundColor?: IColorProperties;
    format?: IFormatProperties;
    value?: string;
    isBlur?: boolean;
    isRTE?: boolean;
    contentModule?: IRenderer;
    enabled?: boolean;
    readonly?: boolean;
    placeholder?: string;
    valueContainer?: HTMLTextAreaElement;
    editorMode?: EditorMode;
    formatter?: IFormatter;
    toolbarModule?: Toolbar;
    getToolbarElement?(): Element;
    fullScreenModule?: FullScreen;
    undoRedoModule?: UndoRedoManager;
    quickToolbarModule?: QuickToolbar;
    undoRedoSteps?: number;
    markdownEditorModule: MarkdownEditor;
    htmlEditorModule: HtmlEditor;
    countModule?: Count;
    serviceLocator?: ServiceLocator;
    setEnable?(): void;
    setReadOnly?(): void;
    setPlaceHolder?(): void;
    updateValue?(): void;
    print(): void;
    getContent?(): Element;
    setRTEContent?(value: Element): void;
    ensureModuleInjected(module: Function): Boolean;
    getToolbar(): HTMLElement;
    getTBarItemsIndex?(items: string[]): number[];
    getCollection?(items: string | string[]): string[];
    getRange(): Range;
    getID(): string;
    updateValueData?(): void;
    getBaseToolbarObject(): BaseToolbar;
    setContentHeight(target?: string, isExpand?: boolean): void;
    keyConfig?: {
        [key: string]: string;
    };
    undoRedoTimer?: number;
    sourceCode?(): void;
    enableToolbarItem?(items: string | string[]): void;
    disableToolbarItem?(items: string | string[]): void;
    wireScrollElementsEvents?(): void;
    unWireScrollElementsEvents?(): void;
    keyDown?(e?: KeyboardEvent): void;
    keyboardModule?: KeyboardEvents;
    onCopy?(): void;
    onCut?(): void;
    onPaste?(): void;
    localeObj?: base.L10n;
    invokeChangeEvent?(): void;
}
export interface IRenderer {
    linkQTBar?: BaseQuickToolbar;
    imageQTBar?: BaseQuickToolbar;
    textQTBar?: BaseQuickToolbar;
    inlineQTBar?: BaseQuickToolbar;
    renderPanel?(): void;
    setPanel?(panel: Element): void;
    getPanel?(): Element;
    getEditPanel?(): Element;
    getDocument?(): Document;
    addEventListener?(): void;
    removeEventListener?(): void;
    renderToolbar?(args: IToolbarOptions): void;
    renderPopup?(args: BaseQuickToolbar): void;
    renderDropDownButton?(args: splitbuttons.ItemModel): splitbuttons.DropDownButton;
    renderColorPicker?(args: IColorPickerModel, item?: string): inputs.ColorPicker;
    renderColorPickerDropDown?(args?: IColorPickerModel, item?: string, colorPicker?: inputs.ColorPicker): splitbuttons.DropDownButton;
}
export interface NotifyArgs {
    module?: string;
    args?: KeyboardEvent | MouseEvent | navigations.ClickEventArgs;
    cancel?: boolean;
    requestType?: Action;
    enable?: boolean;
    properties?: Object;
    selection?: NodeSelection;
    selfLink?: Link;
    link?: HTMLInputElement;
    selectNode?: Node[];
    selectParent?: Node[];
    url?: string;
    text?: string;
    title?: string;
    target?: string;
    member?: string;
    name?: string;
    range?: Range;
    action?: string;
    callBack?(args?: string): void;
}
export interface IColorPickerModel extends inputs.ColorPickerModel {
    element?: HTMLElement;
    value?: string;
    command?: string;
    subCommand?: string;
    target?: string;
    iconCss?: string;
}
export interface IColorPickerEventArgs extends inputs.ColorPickerEventArgs {
    item?: IColorPickerModel;
    originalEvent: string;
    cancel?: boolean;
}
export interface IDropDownItem extends navigations.ItemModel {
    command?: string;
    subCommand?: string;
}
export interface IDropDownClickArgs extends navigations.ClickEventArgs {
    item: IDropDownItem;
}
export interface IColorPickerRenderArgs {
    items?: string[];
    containerType?: string;
    container?: HTMLElement;
}
export interface IImageNotifyArgs {
    module?: string;
    args?: KeyboardEvent | MouseEvent | navigations.ClickEventArgs | IToolbarItemModel;
    cancel?: boolean;
    requestType?: Action;
    enable?: boolean;
    properties?: Object;
    selection?: NodeSelection;
    selfImage?: Image;
    link?: HTMLInputElement | HTMLElement;
    selectNode?: Node[];
    selectParent?: Node[];
    target?: string;
    alt?: HTMLInputElement | HTMLElement;
    text?: string;
    member?: string;
    name?: string;
}
export interface IImageCommandsArgs {
    url?: string;
    selection?: NodeSelection;
    width?: number | string;
    height?: number | string;
    altText?: string;
    selectParent?: Node[];
}
export interface IEditorModel {
    execCommand?: Function;
    observer?: base.Observer;
    markdownSelection?: MarkdownSelection;
    undoRedoManager?: UndoRedoManager | UndoRedoCommands;
    nodeSelection?: NodeSelection;
    mdSelectionFormats?: MDSelectionFormats;
}
export interface IToolbarItems {
    template?: string;
    tooltipText?: string;
}
export interface IToolbarItemModel extends navigations.ItemModel {
    command?: string;
    subCommand?: string;
}
export interface IToolbarOptions {
    enableRtl: boolean;
    target: HTMLElement;
    items?: navigations.ItemModel[];
    rteToolbarObj: BaseToolbar;
    enablePersistence: boolean;
    overflowMode?: navigations.OverflowMode;
}
export interface IToolbarSettings {
    enable?: boolean;
    items?: (string | IToolbarItems)[];
    target?: HTMLElement;
    type?: ToolbarType;
}
export interface IToolbarRenderOptions {
    target: HTMLElement;
    items?: (string | IToolbarItems)[];
    mode?: navigations.OverflowMode;
    container?: string;
}
export interface IDropDownModel {
    content?: string;
    items: IDropDownItemModel[];
    iconCss?: string;
    itemName: string;
    cssClass: string;
    element: HTMLElement;
}
export interface IToolsItems {
    id: string;
    icon: string;
    tooltip: string;
    command: string;
    subCommand: string;
    value?: string;
}
export interface IDropDownItemModel extends splitbuttons.ItemModel {
    class?: string;
    command?: string;
    subCommand?: string;
    value?: string;
    text?: string;
}
export interface ActionCompleteEventArgs {
    /** Defines the current action. */
    requestType?: Action;
    /** Defines the event name. */
    name?: string;
    /** Defines the editor mode. */
    editorMode?: string;
    /** Defines the selected elements. */
    elements?: Node[];
    /** Defines the event item. */
    event?: MouseEvent | KeyboardEvent;
    /** Defines the selected range. */
    range?: Range;
}
export interface ActionBeginEventArgs {
    /** Defines the current action. */
    requestType?: Action;
    /** Cancel the print action */
    cancel?: boolean;
    /** Defines the current item. */
    item?: IToolbarItemModel | IDropDownItemModel;
    /** Defines the current item. */
    originalEvent?: MouseEvent | KeyboardEvent;
    /** Defines the event name. */
    name?: string;
}
export interface PrintEventArgs extends ActionBeginEventArgs {
    /** Defines the RTE element. */
    element?: Element;
}
export interface IShowPopupArgs {
    args?: MouseEvent | TouchEvent;
    type?: string;
    isNotify: boolean;
    elements?: Element | Element[];
}
export interface IUpdateItemsModel {
    targetItem: string;
    updateItem: string;
    baseToolbar: BaseToolbar;
}
export interface IDropDownRenderArgs {
    items?: string[];
    containerType?: string;
    container?: HTMLElement;
}
export interface IShowQuickTBarOptions {
    x: number;
    y: number;
    target: HTMLElement;
    editTop: number;
    editHeight: number;
    popup: HTMLElement;
    parentElement: HTMLElement;
    tBarElementHeight: number;
    parentData: ClientRect;
    windowY: number;
    windowHeight: number;
    windowWidth: number;
    popWidth: number;
    popHeight: number;
    bodyRightSpace: number;
}
export interface IQuickToolbarOptions {
    popupType: string;
    mode: navigations.OverflowMode;
    renderType: RenderType;
    toolbarItems: (string | IToolbarItems)[];
}
export interface IAdapterProcess {
    text: string;
    range: Range;
    actionName: string;
}
export interface IFormatter {
    formatTags?: {
        [key: string]: string;
    };
    listTags?: {
        [key: string]: string;
    };
    keyConfig?: {
        [key: string]: string;
    };
    process?: Function;
    onKeyHandler?: Function;
    editorManager?: IEditorModel;
    getUndoRedoStack?: Function;
    onSuccess?: Function;
    saveData?: Function;
    enableUndo?: Function;
    setDocument?: Function;
    getDocument?: Function;
    setEditPanel?: Function;
    getEditPanel?: Function;
    updateFormatter?: Function;
    initializePlugin?: Function;
    isAppliedCommand?(e?: MouseEvent): string;
    mdSelectionFormat?: MDSelectionFormats;
}
export interface IHtmlFormatterModel {
    currentDocument?: Document;
    element?: Element;
    keyConfig?: {
        [key: string]: string;
    };
    options?: {
        [key: string]: number;
    };
}
export interface IMarkdownFormatterModel {
    element?: Element;
    formatTags?: {
        [key: string]: string;
    };
    listTags?: {
        [key: string]: string;
    };
    keyConfig?: {
        [key: string]: string;
    };
    options?: {
        [key: string]: number;
    };
    selectionTags?: {
        [key: string]: string;
    };
}
export interface IFontProperties {
    default?: string;
    items?: IDropDownItemModel[];
    width?: string;
}
export interface IFormatProperties {
    default?: string;
    types?: IDropDownItemModel[];
    width?: string;
}
export interface ISetToolbarStatusArgs {
    args: IToolbarStatus;
    parent: IRichTextEditor;
    tbElements: HTMLElement[];
    tbItems: IToolbarItemModel[];
    dropDownModule: DropDownButtons;
}
export  type ColorModeType = 'Picker' | 'Palette';
export interface IColorProperties {
    default?: string;
    mode?: ColorModeType;
    columns?: number;
    colorCode?: {
        [key: string]: string[];
    };
    modeSwitcher?: boolean;
}
export interface IExecutionGroup {
    command: string;
    subCommand?: string;
    value?: string;
}
/** @hidden  */
export  const executeGroup: {
    [key: string]: IExecutionGroup;
};
export  type CommandName = 'bold' | 'italic' | 'underline' | 'strikeThrough' | 'superscript' | 'subscript' | 'uppercase' | 'lowercase' | 'fontColor' | 'fontName' | 'fontSize' | 'backColor' | 'justifyCenter' | 'justifyFull' | 'justifyLeft' | 'justifyRight' | 'undo' | 'createLink' | 'formatBlock' | 'heading' | 'indent' | 'insertHTML' | 'insertOrderedList' | 'insertUnorderedList' | 'insertParagraph' | 'outdent' | 'redo' | 'removeFormat' | 'insertText' | 'insertImage' | 'insertHorizontalRule' | 'insertBrOnReturn';
/**
 * Interface for a class RichTextEditor
 */
export interface RichTextEditorModel extends base.ComponentModel{
    /**
     * Specifies the group of items aligned horizontally in the toolbar as well as defined the toolbar rendering type.
     * By default, toolbar is float at the top of the RichTextEditor.
     * When you scroll down, the toolbar will scroll along with the page on RichTextEditor with the specified offset value.
     * * enable: set boolean value to show or hide the toolbar.
     * * enableFloating: Set Boolean value to enable or disable the floating toolbar. 
     * Preserves the toolbar at top of the RichTextEditor on scrolling.
     * * type: it has two possible options
     *      1. Expand: Hide the overflowing toolbar items in the next row. Click the expand arrow to view overflowing toolbar items
     *      2. MultiRow: The toolbar overflowing items wrapped in the next row.
     * * items: Specifies the array of items aligned horizontally in the toolbar.
     * > | and - can insert a vertical and horizontal separator lines in the toolbar.
     * @default
     * {
     *  enable: true,
     *  enableFloating: true,
     *  type: ToolbarType.Expand,
     *  items: ['Bold', 'Italic', 'Underline', '|', 'Formats', 'Alignments', 'OrderedList',
     *  'UnorderedList', '|', 'CreateLink', 'base.Image', '|', 'SourceCode', 'Undo', 'Redo']
     * }
     */
    toolbarSettings?: ToolbarSettingsModel;
    /**
     * Specifies the items to be rendered in quick toolbar based on the target element.
     * * It has following fields:
     * * enable - set boolean value to show or hide the quick toolbar
     * * actionOnScroll - it has two possible options
     *     1. hide: The quickToolbar is closed when the parent element is scrolled. 
     *     2. none: The quickToolbar cannot be closed even the parent element is scrolled.
     * * link  - Specifies the items to be rendered in quick toolbar based on link element such as `Open`, `Edit`, and `UnLink`.
     * * image - Specifies the items to be rendered in quick toolbar based on image element such as 'Replace',
     * 'Align', 'Caption', 'Remove', 'InsertLink', 'Display', 'AltText', 'Dimension'.
     * * text	 - Specifies the items to be rendered in quick toolbar based on text element such as 'Cut', 'Copy', 'Paste'.
     * @default
     * {
     *  enable: true,
     *  actionOnScroll: 'hide',
     *  link: ['Open', 'Edit', 'UnLink'],
     *  image: ['Replace', 'Align', 'Caption', 'Remove', '-', 'InsertLink', 'Display', 'AltText', 'Dimension'],
     *  text: ['Cut', 'Copy', 'Paste']
     * }
     */
    quickToolbarSettings?: QuickToolbarSettingsModel;
    /**
     * Specifies the items to be rendered in an iframe mode, and it has the following properties.
     * * enable - Set Boolean value to enable, the editors content is placed in an iframe and isolated from the rest of the page.
     * * base.attributes - Custom style to be used inside the iframe to display content. This style is added to the iframe body.
     * * resources - we can add both styles and scripts to the iframe.
     *    1. styles[] - An array of CSS style files to inject inside the iframe to display content
     *    2. scripts[] - An array of JS script files to inject inside the iframe
     * @default
     * {
     *  enable: false,
     *  base.attributes: null,
     *  resources: { styles: [], scripts: [] }
     * }
     */
    iframeSettings?: IFrameSettingsModel;
    /**
     * Specifies the image insert options in RichTextEditor component and control with the following properties.
     * * allowedTypes - Specifies the extensions of the image types allowed to insert on bowering and 
     * passing the extensions with comma separators. For example, pass allowedTypes as .jpg and .png.
     * * display - Sets the default display for an image when it is inserted in to the RichTextEditor. 
     * Possible options are: 'inline' and 'block'.
     * * width - Sets the default width of the image when it is inserted in the RichTextEditor.
     * * height - Sets the default height of the image when it is inserted in the RichTextEditor.
     * * saveUrl - Provides URL to map the action result method to save the image.
     * * path - Specifies the location to store the image.
     * @default 
     * {
     *  allowedTypes: ['.jpeg', '.jpg', '.png'],
     *  display: 'inline',
     *  width: 'auto', 
     *  height: 'auto', 
     *  saveUrl: null, 
     *  path: null,
     * }
     */
    insertImageSettings?: ImageSettingsModel;
    /**
     * Preserves the toolbar at the top of the RichTextEditor on scrolling and 
     * specifies the offset of the floating toolbar from documents top position
     * @default 0
     */
    floatingToolbarOffset?: number;
    /**
     * Enable or disable the inline edit mode.
     * * enable -  set boolean value to enable or disable the inline edit mode.
     * * onSelection - If its set to true, upon selecting the text, the toolbar is opened in inline. 
     * If its set to false, upon clicking to the target element, the toolbar is opened.
     * @default
     * {
     *  enable: false,
     *  onSelection: true
     * }
     */
    inlineMode?: InlineModeModel;
    /**
     * Specifies the width of the RichTextEditor.
     * @default '100%'
     */
    width?: string | number;
    /**
     * Enables or disables the persisting component's state between page reloads. 
     * If enabled, the value of RichTextEditor is persisted
     * @default false.
     */
    enablePersistence?: boolean;
    /**
     * Specifies the direction of the RichTextEditor component.
     * For cultures like Arabic, Hebrew, etc. direction can be switched to right to left
     * @default false.
     */
    enableRtl?: boolean;
    /**
     * Allows additional HTML base.attributes such as title, name, etc., and 
     * It will be accepts n number of base.attributes in a key-value pair format.
     * @default {}.
     */
    htmlAttributes?: { [key: string]: string; };
    /**
     * Specifies the placeholder for the RichTextEditor’s content used when the RichTextEditor body is empty.
     * @default null.
     */
    placeholder?: string;
    /**
     * The user interactions on the component are disabled, when set to true.
     * @default false.
     */
    readonly?: boolean;
    /**
     * Specifies a value that indicates whether the component is enabled or not.
     * @default true.
     */
    enabled?: boolean;
    /**
     * specifies the value whether the source code is displayed with encoded format. 
     * @default false.
     */
    enableHtmlEncode?: boolean;
    /**
     * Specifies the height of the RichTextEditor component.    
     * @default auto    
     */
    height?: string | number;
    /**
     * Specifies the CSS class name appended with the root element of the RichTextEditor.
     * One or more custom CSS classes can be added to a RichTextEditor.
     * @default null  
     */
    cssClass?: string;
    /**
     * Specifies the value displayed in the RichTextEditor's content area and it should be string. 
     * The content of RichTextEditor can be loaded with dynamic data such as database, AJAX content, and more.
     * @default null 
     */
    value?: string;
    /**
     * Specifies the count of undo history which is stored in undoRedoManager. 
     * @default 30 
     */
    undoRedoSteps?: number;
    /**
     * Specifies the interval value in milliseconds that store actions in undoRedoManager. The minimum value is 300 milliseconds. 
     * @default 300 
     */
    undoRedoTimer?: number;
    /**
     * Specifies the editing mode of the RichTextEditor.
     * 
     *   - `HTML` - base.Render RichTextEditor as HTML editor using <iframe> element or content editable <div> element or <textarea> element.
     * 
     *   - `Markdown` - base.Render RichTextEditor as markdown editor using <textarea>.
     * 
     * @default 'HTML'
     */
    editorMode?: EditorMode;
    /**
     * Customizes the key actions in RichTextEditor.
     * For example, when using German keyboard, the key actions can be customized using these shortcuts.
     * @default null 
     */
    keyConfig?: { [key: string]: string };
    /**
     * Sets Boolean value to enable or disable the display of the character counter. 
     * @default false 
     */
    showCharCount?: boolean;
    /**
     * Allows the tab key action in the RichTextEditor content. 
     * @default false 
     */
    enableTabKey?: boolean;
    /**
     * Specifies the maximum number of characters allowed in the RichTextEditor component.
     * @default -1
     */
    maxLength?: number;
    /**
     * Predefine the collection of paragraph styles along with quote and code style that populate in format dropdown from the toolbar.
     * @default
     * {
     *  default: 'Paragraph',
     *  width: '65px',
     *  types: [
     *      { text: 'Paragraph' },
     *      { text: 'Code' },
     *      { text: 'Quotation' },
     *      { text: 'Heading 1' },
     *      { text: 'Heading 2' },
     *      { text: 'Heading 3' },
     *      { text: 'Heading 4' },
     *      { text: 'Heading 5' },
     *      { text: 'Heading 6' }
     *  ]
     * }
     */
    format?: IFormatProperties;
    /**
     * Predefine the font families that populate in font family dropdown list from the toolbar.
     * @default 
     * {
     *  default: 'Segoe UI',
     *  width: '65px',
     *  items: [
     *      { text: 'Segoe UI', value: 'Segoe UI' },
     *      { text: 'Arial',  value: 'Arial,Helvetica,sans-serif' },
     *      { text: 'Courier New', value: 'Courier New,Courier,monospace' },
     *      { text: 'Georgia', value: 'Georgia,serif' },
     *      { text: 'Impact', value: 'Impact,Charcoal,sans-serif' },
     *      { text: 'Lucida Console', value: 'Lucida Console,Monaco,monospace' },
     *      { text: 'Tahoma', value: 'Tahoma,Geneva,sans-serif' },
     *      { text: 'Times New Roman', value: 'Times New Roman,Times,serif' },
     *      { text: 'Trebuchet MS', value: 'Trebuchet MS,Helvetica,sans-serif' },
     *      { text: 'Verdana', value: 'Verdana,Geneva,sans-serif' }
     *     ]
     * }
     */
    fontFamily?: IFontProperties;
    /**
     * Predefine the font sizes that populate in font size dropdown list from the toolbar.
     * @default 
     * {
     *  default: '10',
     *  width: '35px',
     *  items: [
     *      { text: '8', value: '8pt' },
     *      { text: '10', value: '10pt' },
     *      { text: '12', value: '12pt' },
     *      { text: '14', value: '14pt' },
     *      { text: '18', value: '18pt' },
     *      { text: '24', value: '24pt' },
     *      { text: '36', value: '36pt' }
     *    ]
     * }
     */
    fontSize?: IFontProperties;
    /**
     * Predefine the color palette that can be rendered for font color toolbar command .
     * @default 
     * {
     *  columns: 10,
     *  colorCode: {
     *      'Custom': [
     *          '', '#000000', '#e7e6e6', '#44546a', '#4472c4', '#ed7d31', '#a5a5a5', '#ffc000', '#70ad47', '#ff0000',
     *          '#f2f2f2', '#808080', '#cfcdcd', '#d5dce4', '#d9e2f3', '#fbe4d5', '#ededed', '#fff2cc', '#e2efd9', '#ffcccc',
     *          '#d9d9d9', '#595959', '#aeaaaa', '#acb9ca', '#b4c6e7', '#f7caac', '#dbdbdb', '#ffe599', '#c5e0b3', '#ff8080',
     *          '#bfbfbf', '#404040', '#747070', '#8496b0', '#8eaadb', '#f4b083', '#c9c9c9', '#ffd966', '#a8d08d', '#ff3333',
     *          '#a6a6a6', '#262626', '#3b3838', '#323e4f', '#2f5496', '#c45911', '#7b7b7b', '#bf8f00', '#538135', '#b30000',
     *          '#7f7f7f', '#0d0d0d', '#161616', '#212934', '#1f3763', '#823b0b', '#525252', '#7f5f00', '#375623', '#660000']
     *    }
     *  }
     */
    fontColor?: IColorProperties;
    /**
     * Predefine the color palette that can be rendered for background color (text highlighted color) toolbar command.
     * @default 
     * {
     *  columns: 5,
     *  colorCode: {
     *          'Custom': ['#ffff00', '#00ff00', '#00ffff', '#ff00ff', '#0000ff', '#ff0000',
     *              '#000080', '#008080', '#008000', '#800080', '#800000', '#808000',
     *              '#c0c0c0', '#000000', '']
     *   }
     * }
     */
    backgroundColor?: IColorProperties;
    /**
     * Accepts the template design and assigns it as RichTextEditor’s content. 
     * For more details about the available template options refer to [`Template`](./templates.html) documentation. 
     * The built-in template engine which provides options to base.compile template string into a executable function. 
     * For EX: We have expression evolution as like ES6 expression string literals
     * @default null
     */
    valueTemplate?: string;
    /**
     * Triggers before command execution using toolbar items or executeCommand method. 
     * If you cancel this event, the command cannot be executed. 
     * Set the cancel argument to true to cancel the command execution.
     * @event
     */
    actionBegin?: base.EmitType<ActionBeginEventArgs>;
    /**
     * Triggers after command execution using toolbar items or executeCommand method.
     * @event
     */
    actionComplete?: base.EmitType<ActionCompleteEventArgs>;
    /**
     * Triggers when the RichTextEditor is rendered.
     * @event 
     */
    created?: base.EmitType<Object>;
    /**
     * Triggers when the RichTextEditor is destroyed.
     * @event 
     */
    destroyed?: base.EmitType<Object>;
    /**
     * Triggers when RichTextEditor is focused out.
     * @event
     */
    blur?: base.EmitType<Object>;
    /**
     * Triggers when RichTextEditor base.Toolbar items is clicked.
     * @event
     */
    toolbarClick?: base.EmitType<Object>;
    /**
     * Triggers when RichTextEditor is focused in
     * @event
     */
    focus?: base.EmitType<Object>;
    /**
     * Triggers only when RichTextEditor is blurred and changes are done to the content.
     * @event 
     */
    change?: base.EmitType<ChangeEventArgs>;
    /**
     * Customize keyCode to change the key value. 
     * @default null 
     */
    formatter?: IFormatter;
}
export interface ChangeEventArgs {
    /**
     * Returns value of RichTextEditor
     */
    value: string;
    /** Defines the event name. */
    name?: string;
}
/**
 * Represents the RichTextEditor component.
 * ```html
 * <textarea id="rte"></textarea>
 * <script>
 *  var rteObj = new RichTextEditor();
 *  rteObj.appendTo("#rte");
 * </script>
 * ```
 */
export  class RichTextEditor extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    private inputElement;
    private placeHolderWrapper;
    private scrollParentElements;
    private cloneValue;
    /**
     * @hidden
     */
    isFocusOut: boolean;
    /**
     * @hidden
     */
    isRTE: boolean;
    /**
     * @hidden
     */
    isBlur: boolean;
    /**
     * @hidden
     */
    renderModule: Render;
    /**
     * @hidden
     */
    contentModule: IRenderer;
    /**
     * @hidden
     */
    serviceLocator: ServiceLocator;
    /**
     * The `toolbarModule` is used to manipulate ToolBar items and its action in the RichTextEditor.
     * @hidden
     */
    toolbarModule: Toolbar;
    /**
     * @hidden
     */
    imageModule: Image;
    /**
     * @hidden
     */
    fullScreenModule: FullScreen;
    /**
     * @hidden
     */
    sourceCodeModule: ViewSource;
    /**
     * @hidden
     */
    linkModule: Link;
    /**
     * @hidden
     */
    markdownEditorModule: MarkdownEditor;
    /**
     * @hidden
     */
    htmlEditorModule: HtmlEditor;
    /**
     * @hidden
     */
    quickToolbarModule: QuickToolbar;
    /**
     * @hidden
     */
    countModule: Count;
    needsID: boolean;
    /**
     * Specifies the group of items aligned horizontally in the toolbar as well as defined the toolbar rendering type.
     * By default, toolbar is float at the top of the RichTextEditor.
     * When you scroll down, the toolbar will scroll along with the page on RichTextEditor with the specified offset value.
     * * enable: set boolean value to show or hide the toolbar.
     * * enableFloating: Set Boolean value to enable or disable the floating toolbar.
     * Preserves the toolbar at top of the RichTextEditor on scrolling.
     * * type: it has two possible options
     *      1. Expand: Hide the overflowing toolbar items in the next row. Click the expand arrow to view overflowing toolbar items
     *      2. MultiRow: The toolbar overflowing items wrapped in the next row.
     * * items: Specifies the array of items aligned horizontally in the toolbar.
     * > | and - can insert a vertical and horizontal separator lines in the toolbar.
     * @default
     * {
     *  enable: true,
     *  enableFloating: true,
     *  type: ToolbarType.Expand,
     *  items: ['Bold', 'Italic', 'Underline', '|', 'Formats', 'Alignments', 'OrderedList',
     *  'UnorderedList', '|', 'CreateLink', 'Image', '|', 'SourceCode', 'Undo', 'Redo']
     * }
     */
    toolbarSettings: ToolbarSettingsModel;
    /**
     * Specifies the items to be rendered in quick toolbar based on the target element.
     * * It has following fields:
     * * enable - set boolean value to show or hide the quick toolbar
     * * actionOnScroll - it has two possible options
     *     1. hide: The quickToolbar is closed when the parent element is scrolled.
     *     2. none: The quickToolbar cannot be closed even the parent element is scrolled.
     * * link  - Specifies the items to be rendered in quick toolbar based on link element such as `Open`, `Edit`, and `UnLink`.
     * * image - Specifies the items to be rendered in quick toolbar based on image element such as 'Replace',
     * 'Align', 'Caption', 'Remove', 'InsertLink', 'Display', 'AltText', 'Dimension'.
     * * text	 - Specifies the items to be rendered in quick toolbar based on text element such as 'Cut', 'Copy', 'Paste'.
     * @default
     * {
     *  enable: true,
     *  actionOnScroll: 'hide',
     *  link: ['Open', 'Edit', 'UnLink'],
     *  image: ['Replace', 'Align', 'Caption', 'Remove', '-', 'InsertLink', 'Display', 'AltText', 'Dimension'],
     *  text: ['Cut', 'Copy', 'Paste']
     * }
     */
    quickToolbarSettings: QuickToolbarSettingsModel;
    /**
     * Specifies the items to be rendered in an iframe mode, and it has the following properties.
     * * enable - Set Boolean value to enable, the editors content is placed in an iframe and isolated from the rest of the page.
     * * attributes - Custom style to be used inside the iframe to display content. This style is added to the iframe body.
     * * resources - we can add both styles and scripts to the iframe.
     *    1. styles[] - An array of CSS style files to inject inside the iframe to display content
     *    2. scripts[] - An array of JS script files to inject inside the iframe
     * @default
     * {
     *  enable: false,
     *  attributes: null,
     *  resources: { styles: [], scripts: [] }
     * }
     */
    iframeSettings: IFrameSettingsModel;
    /**
     * Specifies the image insert options in RichTextEditor component and control with the following properties.
     * * allowedTypes - Specifies the extensions of the image types allowed to insert on bowering and
     * passing the extensions with comma separators. For example, pass allowedTypes as .jpg and .png.
     * * display - Sets the default display for an image when it is inserted in to the RichTextEditor.
     * Possible options are: 'inline' and 'block'.
     * * width - Sets the default width of the image when it is inserted in the RichTextEditor.
     * * height - Sets the default height of the image when it is inserted in the RichTextEditor.
     * * saveUrl - Provides URL to map the action result method to save the image.
     * * path - Specifies the location to store the image.
     * @default
     * {
     *  allowedTypes: ['.jpeg', '.jpg', '.png'],
     *  display: 'inline',
     *  width: 'auto',
     *  height: 'auto',
     *  saveUrl: null,
     *  path: null,
     * }
     */
    insertImageSettings: ImageSettingsModel;
    /**
     * Preserves the toolbar at the top of the RichTextEditor on scrolling and
     * specifies the offset of the floating toolbar from documents top position
     * @default 0
     */
    floatingToolbarOffset: number;
    /**
     * Enable or disable the inline edit mode.
     * * enable -  set boolean value to enable or disable the inline edit mode.
     * * onSelection - If its set to true, upon selecting the text, the toolbar is opened in inline.
     * If its set to false, upon clicking to the target element, the toolbar is opened.
     * @default
     * {
     *  enable: false,
     *  onSelection: true
     * }
     */
    inlineMode: InlineModeModel;
    /**
     * Specifies the width of the RichTextEditor.
     * @default '100%'
     */
    width: string | number;
    /**
     * Enables or disables the persisting component's state between page reloads.
     * If enabled, the value of RichTextEditor is persisted
     * @default false.
     */
    enablePersistence: boolean;
    /**
     * Specifies the direction of the RichTextEditor component.
     * For cultures like Arabic, Hebrew, etc. direction can be switched to right to left
     * @default false.
     */
    enableRtl: boolean;
    /**
     * Allows additional HTML attributes such as title, name, etc., and
     * It will be accepts n number of attributes in a key-value pair format.
     * @default {}.
     */
    htmlAttributes: {
        [key: string]: string;
    };
    /**
     * Specifies the placeholder for the RichTextEditor’s content used when the RichTextEditor body is empty.
     * @default null.
     */
    placeholder: string;
    /**
     * The user interactions on the component are disabled, when set to true.
     * @default false.
     */
    readonly: boolean;
    /**
     * Specifies a value that indicates whether the component is enabled or not.
     * @default true.
     */
    enabled: boolean;
    /**
     * specifies the value whether the source code is displayed with encoded format.
     * @default false.
     */
    enableHtmlEncode: boolean;
    /**
     * Specifies the height of the RichTextEditor component.
     * @default auto
     */
    height: string | number;
    /**
     * Specifies the CSS class name appended with the root element of the RichTextEditor.
     * One or more custom CSS classes can be added to a RichTextEditor.
     * @default null
     */
    cssClass: string;
    /**
     * Specifies the value displayed in the RichTextEditor's content area and it should be string.
     * The content of RichTextEditor can be loaded with dynamic data such as database, AJAX content, and more.
     * @default null
     */
    value: string;
    /**
     * Specifies the count of undo history which is stored in undoRedoManager.
     * @default 30
     */
    undoRedoSteps: number;
    /**
     * Specifies the interval value in milliseconds that store actions in undoRedoManager. The minimum value is 300 milliseconds.
     * @default 300
     */
    undoRedoTimer: number;
    /**
     * Specifies the editing mode of the RichTextEditor.
     *
     *   - `HTML` - Render RichTextEditor as HTML editor using <iframe> element or content editable <div> element or <textarea> element.
     *
     *   - `Markdown` - Render RichTextEditor as markdown editor using <textarea>.
     *
     * @default 'HTML'
     */
    editorMode: EditorMode;
    /**
     * Customizes the key actions in RichTextEditor.
     * For example, when using German keyboard, the key actions can be customized using these shortcuts.
     * @default null
     */
    keyConfig: {
        [key: string]: string;
    };
    /**
     * Sets Boolean value to enable or disable the display of the character counter.
     * @default false
     */
    showCharCount: boolean;
    /**
     * Allows the tab key action in the RichTextEditor content.
     * @default false
     */
    enableTabKey: boolean;
    /**
     * Specifies the maximum number of characters allowed in the RichTextEditor component.
     * @default -1
     */
    maxLength: number;
    /**
     * Predefine the collection of paragraph styles along with quote and code style that populate in format dropdown from the toolbar.
     * @default
     * {
     *  default: 'Paragraph',
     *  width: '65px',
     *  types: [
     *      { text: 'Paragraph' },
     *      { text: 'Code' },
     *      { text: 'Quotation' },
     *      { text: 'Heading 1' },
     *      { text: 'Heading 2' },
     *      { text: 'Heading 3' },
     *      { text: 'Heading 4' },
     *      { text: 'Heading 5' },
     *      { text: 'Heading 6' }
     *  ]
     * }
     */
    format: IFormatProperties;
    /**
     * Predefine the font families that populate in font family dropdown list from the toolbar.
     * @default
     * {
     *  default: 'Segoe UI',
     *  width: '65px',
     *  items: [
     *      { text: 'Segoe UI', value: 'Segoe UI' },
     *      { text: 'Arial',  value: 'Arial,Helvetica,sans-serif' },
     *      { text: 'Courier New', value: 'Courier New,Courier,monospace' },
     *      { text: 'Georgia', value: 'Georgia,serif' },
     *      { text: 'Impact', value: 'Impact,Charcoal,sans-serif' },
     *      { text: 'Lucida Console', value: 'Lucida Console,Monaco,monospace' },
     *      { text: 'Tahoma', value: 'Tahoma,Geneva,sans-serif' },
     *      { text: 'Times New Roman', value: 'Times New Roman,Times,serif' },
     *      { text: 'Trebuchet MS', value: 'Trebuchet MS,Helvetica,sans-serif' },
     *      { text: 'Verdana', value: 'Verdana,Geneva,sans-serif' }
     *     ]
     * }
     */
    fontFamily: IFontProperties;
    /**
     * Predefine the font sizes that populate in font size dropdown list from the toolbar.
     * @default
     * {
     *  default: '10',
     *  width: '35px',
     *  items: [
     *      { text: '8', value: '8pt' },
     *      { text: '10', value: '10pt' },
     *      { text: '12', value: '12pt' },
     *      { text: '14', value: '14pt' },
     *      { text: '18', value: '18pt' },
     *      { text: '24', value: '24pt' },
     *      { text: '36', value: '36pt' }
     *    ]
     * }
     */
    fontSize: IFontProperties;
    /**
     * Predefine the color palette that can be rendered for font color toolbar command .
     * @default
     * {
     *  columns: 10,
     *  colorCode: {
     *      'Custom': [
     *          '', '#000000', '#e7e6e6', '#44546a', '#4472c4', '#ed7d31', '#a5a5a5', '#ffc000', '#70ad47', '#ff0000',
     *          '#f2f2f2', '#808080', '#cfcdcd', '#d5dce4', '#d9e2f3', '#fbe4d5', '#ededed', '#fff2cc', '#e2efd9', '#ffcccc',
     *          '#d9d9d9', '#595959', '#aeaaaa', '#acb9ca', '#b4c6e7', '#f7caac', '#dbdbdb', '#ffe599', '#c5e0b3', '#ff8080',
     *          '#bfbfbf', '#404040', '#747070', '#8496b0', '#8eaadb', '#f4b083', '#c9c9c9', '#ffd966', '#a8d08d', '#ff3333',
     *          '#a6a6a6', '#262626', '#3b3838', '#323e4f', '#2f5496', '#c45911', '#7b7b7b', '#bf8f00', '#538135', '#b30000',
     *          '#7f7f7f', '#0d0d0d', '#161616', '#212934', '#1f3763', '#823b0b', '#525252', '#7f5f00', '#375623', '#660000']
     *    }
     *  }
     */
    fontColor: IColorProperties;
    /**
     * Predefine the color palette that can be rendered for background color (text highlighted color) toolbar command.
     * @default
     * {
     *  columns: 5,
     *  colorCode: {
     *          'Custom': ['#ffff00', '#00ff00', '#00ffff', '#ff00ff', '#0000ff', '#ff0000',
     *              '#000080', '#008080', '#008000', '#800080', '#800000', '#808000',
     *              '#c0c0c0', '#000000', '']
     *   }
     * }
     */
    backgroundColor: IColorProperties;
    /**
     * Accepts the template design and assigns it as RichTextEditor’s content.
     * For more details about the available template options refer to [`Template`](./templates.html) documentation.
     * The built-in template engine which provides options to compile template string into a executable function.
     * For EX: We have expression evolution as like ES6 expression string literals
     * @default null
     */
    valueTemplate: string;
    /**
     * Triggers before command execution using toolbar items or executeCommand method.
     * If you cancel this event, the command cannot be executed.
     * Set the cancel argument to true to cancel the command execution.
     * @event
     */
    actionBegin: base.EmitType<ActionBeginEventArgs>;
    /**
     * Triggers after command execution using toolbar items or executeCommand method.
     * @event
     */
    actionComplete: base.EmitType<ActionCompleteEventArgs>;
    /**
     * Triggers when the RichTextEditor is rendered.
     * @event
     */
    created: base.EmitType<Object>;
    /**
     * Triggers when the RichTextEditor is destroyed.
     * @event
     */
    destroyed: base.EmitType<Object>;
    /**
     * Triggers when RichTextEditor is focused out.
     * @event
     */
    blur: base.EmitType<Object>;
    /**
     * Triggers when RichTextEditor Toolbar items is clicked.
     * @event
     */
    toolbarClick: base.EmitType<Object>;
    /**
     * Triggers when RichTextEditor is focused in
     * @event
     */
    focus: base.EmitType<Object>;
    /**
     * Triggers only when RichTextEditor is blurred and changes are done to the content.
     * @event
     */
    change: base.EmitType<ChangeEventArgs>;
    /**
     * Customize keyCode to change the key value.
     * @default null
     */
    formatter: IFormatter;
    keyboardModule: KeyboardEvents;
    localeObj: base.L10n;
    valueContainer: HTMLTextAreaElement;
    private originalElement;
    constructor(options?: RichTextEditorModel, element?: string | HTMLElement);
    /**
     * To provide the array of modules needed for component rendering
     * @return {base.ModuleDeclaration[]}
     * @hidden
     */
    requiredModules(): base.ModuleDeclaration[];
    private updateEnable();
    setEnable(): void;
    /**
     * For internal use only - Initialize the event handler;
     * @private
     */
    protected preRender(): void;
    private setContainer();
    getPersistData(): string;
    /**
     * Focuses the RichTextEditor component
     * @public
     */
    focusIn(): void;
    /**
     * Blurs the RichTextEditor component
     * @public
     */
    focusOut(): void;
    /**
     * Selects all the content in RichTextEditor
     * @public
     */
    selectAll(): void;
    /**
     * Selects a content range or an element
     * @public
     */
    selectRange(range: Range): void;
    /**
     * Retrieves the HTML markup content from currently selected content of RichTextEditor.
     * @public
     */
    getSelection(): string;
    executeCommand(commandName: CommandName, value?: string | HTMLElement): void;
    private encode(value);
    private decode(value);
    /**
     * For internal use only - To Initialize the component rendering.
     * @private
     */
    protected render(): void;
    /**
     * For internal use only - Initialize the event handler
     * @private
     */
    protected eventInitializer(): void;
    /**
     * For internal use only - keydown the event handler;
     * @private
     */
    keyDown(e: KeyboardEvent): void;
    private keyUp(e);
    updateValue(value?: string): void;
    private mouseUp(e);
    /**
     * @hidden
     */
    ensureModuleInjected(module: Function): boolean;
    onCopy(): void;
    onCut(): void;
    onPaste(e?: KeyboardEvent): void;
    /**
     * Destroys the component (detaches/removes all event handlers, attributes, classes, and empties the component element).
     * @method destroy
     * @return {void}
     */
    destroy(): void;
    private destroyDependentModules();
    /**
     * Returns the HTML or Text inside the RichTextEditor.
     * @return {Element}
     */
    getContent(): Element;
    /**
     * Sets the new HTML or text inside the RichTextEditor.
     * @param  {Element} element - Specifies the RichTextEditor content.
     * @return {void}
     */
    setContent(element: Element): void;
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    /**
     * Called internally if any of the property value changed.
     * @hidden
     */
    onPropertyChanged(newProp: RichTextEditorModel, oldProp: RichTextEditorModel): void;
    /**
     * @hidden
     */
    updateValueData(): void;
    private removeSheets(srcList);
    private updatePanelValue();
    private setHeight(height);
    setPlaceHolder(): void;
    private setWidth(width);
    private setCssClass(cssClass);
    private updateRTL();
    private updateReadOnly();
    setReadOnly(): void;
    /**
     * By default, prints all the pages of the RichTextEditor.
     * @return {void}
     */
    print(): void;
    /**
     * Applies all the pending property changes and render the component again.
     * @public
     */
    refresh(): void;
    /**
     * Shows the RichTextEditor component in full-screen mode.
     */
    showFullScreen(): void;
    /**
     * Enables the give toolbar items in the RichTextEditor component.
     * @public
     */
    enableToolbarItem(items: string | string[]): void;
    /**
     * Disables the given toolbar items in the RichTextEditor component.
     * @public
     */
    disableToolbarItem(items: string | string[]): void;
    /**
     * Removes the give toolbar items from the RichTextEditor component.
     * @public
     */
    removeToolbarItem(items: string | string[]): void;
    /**
     * Get the selected range from the RichTextEditor's content.
     * @public
     */
    getRange(): Range;
    private initializeServices();
    private RTERender();
    private setIframeSettings();
    private InjectSheet(scriptSheet, srcList);
    private createScriptElement();
    private createStyleElement();
    private setValue();
    setContentHeight(target?: string, isExpand?: boolean): void;
    /**
     * Retrieves the HTML from RichTextEditor.
     * @public
     */
    getHtml(): string;
    /**
     * Shows the source HTML/MD markup.
     * @public
     */
    showSourceCode(): void;
    /**
     * @hidden
     */
    getBaseToolbarObject(): BaseToolbar;
    /**
     * @hidden
     */
    getToolbar(): HTMLElement;
    /**
     * @hidden
     */
    getToolbarElement(): Element;
    getID(): string;
    private mouseDownHandler(e);
    private preventImgResize(e);
    private preventDefaultResize(e);
    private defaultResize(e);
    private resizeHandler();
    private scrollHandler(e);
    private editAreaClickHandler(e);
    private focusHandler(e);
    private onDocumentClick(e);
    private blurHandler(e);
    invokeChangeEvent(): void;
    /**
     * @hidden
     */
    wireScrollElementsEvents(): void;
    /**
     * @hidden
     */
    unWireScrollElementsEvents(): void;
    private resetHandler();
    private wireEvents();
    private onIframeMouseDown(e);
    private editorKeyDown(e);
    private unWireEvents();
}
export  function getIndex(val: string, items: (string | IToolbarItems)[]): number;
export  function hasClass(element: Element | HTMLElement, className: string): boolean;
export  function getDropDownValue(items: IDropDownItemModel[], value: string, type: string, returnType: string): string;
export  function isIDevice(): boolean;
export  function getFormattedFontSize(value: string): string;
export  function pageYOffset(e: MouseEvent, parentElement: HTMLElement, isIFrame: boolean): number;
export  function getTooltipText(item: string, serviceLocator: ServiceLocator): string;
export  function setToolbarStatus(e: ISetToolbarStatusArgs, isPopToolbar: boolean): void;
export  function getCollection(items: string | string[]): string[];
export  function getTBarItemsIndex(items: string[], toolbarItems: IToolbarItemModel[]): number[];
export  function updateUndoRedoStatus(baseToolbar: BaseToolbar, undoRedoStatus: {
    [key: string]: boolean;
}): void;
/**
 * To dispatch the event manually
 */
export  function dispatchEvent(element: Element | HTMLDocument, type: string): void;
/**
 * Formatter
 */
/**
 * Formatter
 * @hidden
 */
export  class Formatter {
    editorManager: IEditorModel;
    /**
     * To execute the command
     * @param  {IRichTextEditor} self
     * @param  {ActionBeginEventArgs} args
     * @param  {MouseEvent|KeyboardEvent} event
     * @param  {NotifyArgs} value
     */
    process(self: IRichTextEditor, args: ActionBeginEventArgs, event: MouseEvent | KeyboardEvent, value: NotifyArgs): void;
    private getAncestorNode(node);
    onKeyHandler(self: IRichTextEditor, e: KeyboardEvent): void;
    onSuccess(self: IRichTextEditor, events: IMarkdownFormatterCallBack | IHtmlFormatterCallBack): void;
    /**
     * Save the data for undo and redo action.
     */
    saveData(e?: KeyboardEvent | MouseEvent | IUndoCallBack): void;
    getUndoStatus(): {
        [key: string]: boolean;
    };
    getUndoRedoStack(): IHtmlUndoRedoData[] | MarkdownUndoRedoData[];
    enableUndo(self: IRichTextEditor): void;
}
/**
 * HTML adapter
 * @hidden
 */
export  class HTMLFormatter extends Formatter {
    keyConfig: {
        [key: string]: string;
    };
    currentDocument: Document;
    element: Element;
    editorManager: IEditorModel;
    private toolbarUpdate;
    constructor(options?: IHtmlFormatterModel);
    private initialize();
    /**
     * Update the formatter of RichTextEditor
     * @param  {Element} editElement
     * @param  {Document} doc
     */
    updateFormatter(editElement: Element, doc?: Document, options?: {
        [key: string]: number;
    }): void;
}
/**
 * Markdown adapter
 * @hidden
 */
export  class MarkdownFormatter extends Formatter {
    keyConfig: {
        [key: string]: string;
    };
    formatTags: {
        [key: string]: string;
    };
    listTags: {
        [key: string]: string;
    };
    selectionTags: {
        [key: string]: string;
    };
    editorManager: IEditorModel;
    private element;
    constructor(options?: IMarkdownFormatterModel);
    private initialize();
    /**
     * Update the formatter of RichTextEditor
     * @param  {Element} editElement
     * @param  {Document} doc
     */
    updateFormatter(editElement: Element, doc?: Document, options?: {
        [key: string]: number;
    }): void;
}
/**
 * HtmlEditor
 */
/**
 * Image
 */
/**
 * RichTextEditor component exported items
 */
/**
 * Link
 */
/**
 * MarkdownEditor
 */
/**
 * Export default locale
 */
export  let defaultLocale: {
    [key: string]: string;
};
export  let toolsLocale: {
    [key: string]: string;
};
/**
 * Interface for a class Resources
 */
export interface ResourcesModel {
    /**
     * Specifies styles that inject into iframe.
     * @default []
     */
    styles?: string[];
    /**
     * Specifies scripts that inject into iframe.
     * @default []
     */
    scripts?: string[];
}
/**
 * Interface for a class IFrameSettings
 */
export interface IFrameSettingsModel {
    /**
     * Specifies whether to render iframe based editable element in RTE.
     * @default false
     */
    enable?: boolean;
    /**
     * Defines additional attributes to render iframe.
     * @default 'null'
     */
    attributes?: { [key: string]: string; };
    /**
     * The object used for inject styles and scripts.
     * @default {}
     */
    resources?: ResourcesModel;
}
/**
 * Objects used for configuring the iframe resources properties.
 */
export  class Resources extends base.ChildProperty<Resources> {
    /**
     * Specifies styles that inject into iframe.
     * @default []
     */
    styles: string[];
    /**
     * Specifies scripts that inject into iframe.
     * @default []
     */
    scripts: string[];
}
/**
 * Configures the iframe settings of the RTE.
 */
export  class IFrameSettings extends base.ChildProperty<IFrameSettings> {
    /**
     * Specifies whether to render iframe based editable element in RTE.
     * @default false
     */
    enable: boolean;
    /**
     * Defines additional attributes to render iframe.
     * @default 'null'
     */
    attributes: {
        [key: string]: string;
    };
    /**
     * The object used for inject styles and scripts.
     * @default {}
     */
    resources: ResourcesModel;
}
/**
 * Interface for a class InlineMode
 */
export interface InlineModeModel {
    /**
     * Specifies whether enable/disable inline toolbar in RTE.
     * @default false
     */
    enable?: boolean;
    /**
     * Specifies the inline toolbar render based on with or without selection.
     * @default true
     */
    onSelection?: boolean;
}
/**
 * Configures the inlineMode property of the RTE.
 */
export  class InlineMode extends base.ChildProperty<InlineMode> {
    /**
     * Specifies whether enable/disable inline toolbar in RTE.
     * @default false
     */
    enable: boolean;
    /**
     * Specifies the inline toolbar render based on with or without selection.
     * @default true
     */
    onSelection: boolean;
}
/**
 * Export items model
 */
export  let templateItems: string[];
export  let tools: {
    [key: string]: IToolsItems;
};
export  let alignmentItems: IDropDownItemModel[];
export  let imageAlignItems: IDropDownItemModel[];
export  let imageDisplayItems: IDropDownItemModel[];
/**
 * Export model files
 */
/**
 * Interface for a class ToolbarSettings
 */
export interface ToolbarSettingsModel {
    /**
     * Specifies whether to render toolbar in RTE.
     * @default true
     */
    enable?: boolean;
    /**
     * Specifies whether to enable/disable floating toolbar.
     * @default true
     */
    enableFloating?: boolean;
    /**
     * Specifies the Toolbar display types.
     * The possible types are:
     * - Expand: Toolbar items placed within the available space and rest of the items are placed to the extended menu section.
     * - MultiRow: Toolbar which placed at top of RTE editing area.
     * @default Expand
     */
    type?: ToolbarType;
    /**
     * An array of string or object that is used to configure items.
     * @default predefinedItems
     */
    items?: (string | IToolbarItems)[];
}
/**
 * Interface for a class ImageSettings
 */
export interface ImageSettingsModel {
    /**
     * Specifies whether to allowType based file select
     * @default ['.jpeg', '.jpg', '.png']
     */
    allowedTypes?: string[];
    /**
     * Specifies whether insert image inline or break
     * @default 'inline'
     */
    display?: string;
    /**
     * Specifies whether image width
     * @default 'auto'
     */
    width?: string;
    /**
     * Specifies whether image height
     * @default 'auto'
     */
    height?: string;
    /**
     * Specifies the URL of save action that will receive the upload files and save in the server.
     * @default 'null'
     */
    saveUrl?: string;
    /**
     * Specifies the URL of save action that will receive the upload files and save in the server.
     * @default 'null'
     */
    path?: string;
}
/**
 * Interface for a class QuickToolbarSettings
 */
export interface QuickToolbarSettingsModel {
    /**
     * Specifies whether to enable quick toolbar in RTE.
     * @default true
     */
    enable?: boolean;
    /**
     * specifies the action that should happen when scroll the target-parent container.
     * @default 'hide'
     */
    actionOnScroll?: ActionOnScroll;
    /**
     * Specifies the items to render in quick toolbar, when link selected.
     * @default ['Open', 'Edit', 'UnLink']
     */
    link?: (string | IToolbarItems)[];
    /**
     * Specifies the items to render in quick toolbar, when image selected.
     * @default ['Replace', 'Align', 'Caption', 'Remove', '-', 'InsertLink','OpenImageLink', 'EditImageLink', 'RemoveImageLink', 'Display', 'AltText', 'Dimension']
     */
    // tslint:disable
    image?: (string | IToolbarItems)[];
    /**
     * Specifies the items to render in quick toolbar, when text selected.
     * @default ['Cut', 'Copy', 'Paste']
     */
    text?: (string | IToolbarItems)[];
}
/**
 * Interface for a class FontFamily
 */
export interface FontFamilyModel {
    /**
     * Specifies default font family selection
     * @default 0
     */
    default?: string;
    /**
     * Specifies content width
     * @default '65px'
     */
    width?: string;
    /**
     * Specifies default font family items
     * @default fontFamily
     */
    items?: IDropDownItemModel[];
}
/**
 * Interface for a class FontSize
 */
export interface FontSizeModel {
    /**
     * Specifies default font size selection
     * @default 0
     */
    default?: string;
    /**
     * Specifies content width
     * @default '35px'
     */
    width?: string;
    /**
     * Specifies default font size items
     * @default fontSize
     */
    items?: IDropDownItemModel[];
}
/**
 * Interface for a class Format
 */
export interface FormatModel {
    /**
     * Specifies default format
     * @default 'Paragraph'
     */
    default?: string;
    /**
     * Specifies content width
     * @default '65px'
     */
    width?: string;
    /**
     * Specifies default font size items
     * @default formatItems
     */
    types?: IDropDownItemModel[];
}
/**
 * Interface for a class FontColor
 */
export interface FontColorModel {
    /**
     * Specifies default font color
     * @default '#ff0000'
     */
    default?: string;
    /**
     * Specifies mode
     * @default 'Palette'
     */
    mode?: ColorModeType;
    /**
     * Specifies columns
     * @default 10
     */
    columns?: number;
    /**
     * Specifies color code customization
     * @default fontColor
     */
    colorCode?: { [key: string]: string[] };
    /**
     * Specifies modeSwitcher button
     * @default false
     */
    modeSwitcher?: boolean;
}
/**
 * Interface for a class BackgroundColor
 */
export interface BackgroundColorModel {
    /**
     * Specifies default font color
     * @default '#ffff00'
     */
    default?: string;
    /**
     * Specifies mode
     * @default 'Palette'
     */
    mode?: ColorModeType;
    /**
     * Specifies columns
     * @default 10
     */
    columns?: number;
    /**
     * Specifies color code customization
     * @default backgroundColor
     */
    colorCode?: { [key: string]: string[] };
    /**
     * Specifies a modeSwitcher button
     * @default false
     */
    modeSwitcher?: boolean;
}
export  const predefinedItems: string[];
export  const fontFamily: IDropDownItemModel[];
export  const fontSize: IDropDownItemModel[];
export  const formatItems: IDropDownItemModel[];
export  const fontColor: {
    [key: string]: string[];
};
export  const backgroundColor: {
    [key: string]: string[];
};
/**
 * Configures the toolbar settings of the RTE.
 */
export  class ToolbarSettings extends base.ChildProperty<ToolbarSettings> {
    /**
     * Specifies whether to render toolbar in RTE.
     * @default true
     */
    enable: boolean;
    /**
     * Specifies whether to enable/disable floating toolbar.
     * @default true
     */
    enableFloating: boolean;
    /**
     * Specifies the Toolbar display types.
     * The possible types are:
     * - Expand: Toolbar items placed within the available space and rest of the items are placed to the extended menu section.
     * - MultiRow: Toolbar which placed at top of RTE editing area.
     * @default Expand
     */
    type: ToolbarType;
    /**
     * An array of string or object that is used to configure items.
     * @default predefinedItems
     */
    items: (string | IToolbarItems)[];
}
/**
 * Configures the image settings of the RTE.
 */
export  class ImageSettings extends base.ChildProperty<ImageSettings> {
    /**
     * Specifies whether to allowType based file select
     * @default ['.jpeg', '.jpg', '.png']
     */
    allowedTypes: string[];
    /**
     * Specifies whether insert image inline or break
     * @default 'inline'
     */
    display: string;
    /**
     * Specifies whether image width
     * @default 'auto'
     */
    width: string;
    /**
     * Specifies whether image height
     * @default 'auto'
     */
    height: string;
    /**
     * Specifies the URL of save action that will receive the upload files and save in the server.
     * @default 'null'
     */
    saveUrl: string;
    /**
     * Specifies the URL of save action that will receive the upload files and save in the server.
     * @default 'null'
     */
    path: string;
}
/**
 * Configures the quick toolbar settings of the RTE.
 */
export  class QuickToolbarSettings extends base.ChildProperty<QuickToolbarSettings> {
    /**
     * Specifies whether to enable quick toolbar in RTE.
     * @default true
     */
    enable: boolean;
    /**
     * specifies the action that should happen when scroll the target-parent container.
     * @default 'hide'
     */
    actionOnScroll: ActionOnScroll;
    /**
     * Specifies the items to render in quick toolbar, when link selected.
     * @default ['Open', 'Edit', 'UnLink']
     */
    link: (string | IToolbarItems)[];
    /**
     * Specifies the items to render in quick toolbar, when image selected.
     * @default ['Replace', 'Align', 'Caption', 'Remove', '-', 'InsertLink','OpenImageLink', 'EditImageLink', 'RemoveImageLink', 'Display', 'AltText', 'Dimension']
     */
    image: (string | IToolbarItems)[];
    /**
     * Specifies the items to render in quick toolbar, when text selected.
     * @default ['Cut', 'Copy', 'Paste']
     */
    text: (string | IToolbarItems)[];
}
/**
 * Configures the font family settings of the RTE.
 */
export  class FontFamily extends base.ChildProperty<FontFamily> {
    /**
     * Specifies default font family selection
     * @default 0
     */
    default: string;
    /**
     * Specifies content width
     * @default '65px'
     */
    width: string;
    /**
     * Specifies default font family items
     * @default fontFamily
     */
    items: IDropDownItemModel[];
}
/**
 * Configures the font size settings of the RTE.
 */
export  class FontSize extends base.ChildProperty<FontSize> {
    /**
     * Specifies default font size selection
     * @default 0
     */
    default: string;
    /**
     * Specifies content width
     * @default '35px'
     */
    width: string;
    /**
     * Specifies default font size items
     * @default fontSize
     */
    items: IDropDownItemModel[];
}
/**
 * Configures the format settings of the RTE.
 */
export  class Format extends base.ChildProperty<Format> {
    /**
     * Specifies default format
     * @default 'Paragraph'
     */
    default: string;
    /**
     * Specifies content width
     * @default '65px'
     */
    width: string;
    /**
     * Specifies default font size items
     * @default formatItems
     */
    types: IDropDownItemModel[];
}
/**
 * Configures the font Color settings of the RTE.
 */
export  class FontColor extends base.ChildProperty<FontColor> {
    /**
     * Specifies default font color
     * @default '#ff0000'
     */
    default: string;
    /**
     * Specifies mode
     * @default 'Palette'
     */
    mode: ColorModeType;
    /**
     * Specifies columns
     * @default 10
     */
    columns: number;
    /**
     * Specifies color code customization
     * @default fontColor
     */
    colorCode: {
        [key: string]: string[];
    };
    /**
     * Specifies modeSwitcher button
     * @default false
     */
    modeSwitcher: boolean;
}
/**
 * Configures the background Color settings of the RTE.
 */
export  class BackgroundColor extends base.ChildProperty<BackgroundColor> {
    /**
     * Specifies default font color
     * @default '#ffff00'
     */
    default: string;
    /**
     * Specifies mode
     * @default 'Palette'
     */
    mode: ColorModeType;
    /**
     * Specifies columns
     * @default 10
     */
    columns: number;
    /**
     * Specifies color code customization
     * @default backgroundColor
     */
    colorCode: {
        [key: string]: string[];
    };
    /**
     * Specifies a modeSwitcher button
     * @default false
     */
    modeSwitcher: boolean;
}
/**
 * QuickToolbar
 */
/**
 * Models
 */
/**
 * Content module is used to render RichTextEditor content
 * @hidden
 */
export  class ContentRender implements IRenderer {
    protected contentPanel: Element;
    protected parent: IRichTextEditor;
    protected editableElement: Element;
    private serviceLocator;
    /**
     * Constructor for content renderer module
     */
    constructor(parent?: IRichTextEditor, serviceLocator?: ServiceLocator);
    /**
     * The function is used to render RichTextEditor content div
     */
    renderPanel(): void;
    /**
     * Get the content div element of RichTextEditor
     * @return {Element}
     */
    getPanel(): Element;
    /**
     * Get the editable element of RichTextEditor
     * @return {Element}
     */
    getEditPanel(): Element;
    /**
     * Set the content div element of RichTextEditor
     * @param {Element} panel
     */
    setPanel(panel: Element): void;
    /**
     * Get the document of RichTextEditor
     * @return {Document}
     */
    getDocument(): Document;
}
/**
 * Content module is used to render RichTextEditor content
 * @hidden
 */
export  class IframeContentRender extends ContentRender {
    /**
     * The function is used to render RichTextEditor iframe
     */
    renderPanel(): void;
    /**
     * Get the editable element of RichTextEditor
     * @return {Element}
     */
    getEditPanel(): Element;
    /**
     * Get the document of RichTextEditor
     * @param  {Document}
     */
    getDocument(): Document;
}
/**
 * `Image` module is used to handle image actions.
 */
export  class Image {
    element: HTMLElement;
    private rteID;
    private parent;
    dialogObj: popups.Dialog;
    uploadObj: inputs.Uploader;
    private i10n;
    private inputUrl;
    private captionEle;
    private checkBoxObj;
    private uploadUrl;
    private contentModule;
    private rendererFactory;
    private quickToolObj;
    constructor(parent?: IRichTextEditor, serviceLocator?: ServiceLocator);
    protected addEventListener(): void;
    protected removeEventListener(): void;
    private onIframeMouseDown();
    private afterRender();
    private imageClick(e);
    private onToolbarAction(args);
    private openImgLink(e);
    private editImgLink(e);
    private removeImgLink(e);
    private onKeyDown(event);
    private alignmentSelect(e);
    private imageWithLinkQTBarItemUpdate();
    private showImageQuickToolbar(e);
    private hideImageQuickToolbar();
    private editAreaClickHandler(e);
    private insertImgLink(e, inputDetails?);
    private insertAltText(e);
    private insertAlt(e);
    private insertlink(e);
    private isUrl(url);
    private deleteImg(e);
    private caption(e);
    private imageSize(e);
    private break(e);
    private inline(e);
    private justifyImageLeft(e);
    private justifyImageRight(e);
    private justifyImageCenter(e);
    private imagDialog(e);
    private cancelDialog(e);
    private onDocumentClick(e);
    private imageUrlPopup(e);
    private insertImageUrl(e);
    private imgsizeInput(e);
    private insertSize(e);
    private insertImage(e);
    private imgUpload(e);
    private fileSelect();
    private url(dataurl);
    /**
     * Destroys the ToolBar.
     * @method destroy
     * @return {void}
     */
    destroy(): void;
    /**
     * For internal use only - Get the module name.
     */
    private getModuleName();
}
/**
 * `Link` module is used to handle undo actions.
 */
export  class Link {
    private rteID;
    private i10n;
    private parent;
    contentModule: IRenderer;
    private dialogObj;
    private checkBoxObj;
    serviceLocator: ServiceLocator;
    private rendererFactory;
    private quickToolObj;
    constructor(parent?: IRichTextEditor, serviceLocator?: ServiceLocator);
    protected addEventListener(): void;
    private onToolbarAction(args);
    protected removeEventListener(): void;
    private onIframeMouseDown();
    private showLinkQuickToolbar(e);
    private hideLinkQuickToolbar();
    private editAreaClickHandler(e);
    private onKeyDown(event);
    private linkDialog(e?, inputDetails?);
    private insertlink(e);
    private isUrl(url);
    private checkUrl(e);
    private removeLink(e);
    private openLink(e);
    private editLink(e);
    private cancelDialog(e);
    private onDocumentClick(e);
    /**
     * Destroys the ToolBar.
     * @method destroy
     * @return {void}
     */
    destroy(): void;
    /**
     * For internal use only - Get the module name.
     */
    private getModuleName();
}
/**
 * Markdown module is used to render RichTextEditor as Markdown editor content
 * @hidden
 */
export  class MarkdownRender implements IRenderer {
    private contentPanel;
    protected parent: IRichTextEditor;
    protected editableElement: Element;
    private rteID;
    /**
     * Constructor for content renderer module
     */
    constructor(parent?: IRichTextEditor);
    /**
     * The function is used to render RichTextEditor content div
     */
    renderPanel(): void;
    /**
     * Get the content div element of RichTextEditor
     * @return {Element}
     */
    getPanel(): Element;
    /**
     * Get the editable element of RichTextEditor
     * @return {Element}
     */
    getEditPanel(): Element;
    /**
     * Set the content div element of RichTextEditor
     * @param  {Element} panel
     */
    setPanel(panel: Element): void;
    /**
     * Get the document of RichTextEditor
     * @param  {Document}
     */
    getDocument(): Document;
}
/**
 * `Popup renderer` module is used to render popup in RichTextEditor.
 * @hidden
 */
export  class PopupRenderer implements IRenderer {
    private popupObj;
    private popupPanel;
    protected parent: IRichTextEditor;
    /**
     * Constructor for popup renderer module
     */
    constructor(parent?: IRichTextEditor);
    private popupOpen();
    renderPopup(args: BaseQuickToolbar): void;
    /**
     * The function is used to add popup class in Quick Toolbar
     */
    renderPanel(): void;
    /**
     * Get the popup element of RichTextEditor
     * @return {Element}
     */
    getPanel(): Element;
    /**
     * Set the popup element of RichTextEditor
     * @param  {Element} panel
     */
    setPanel(panel: Element): void;
}
/**
 * Content module is used to render RichTextEditor content
 * @hidden
 */
export  class Render {
    private parent;
    private locator;
    private contentRenderer;
    private renderer;
    /**
     * Constructor for render module
     */
    constructor(parent?: IRichTextEditor, locator?: ServiceLocator);
    /**
     * To initialize RichTextEditor header, content and footer rendering
     */
    render(): void;
    /**
     * Refresh the entire RichTextEditor.
     * @return {void}
     */
    refresh(e?: NotifyArgs): void;
    /**
     * Destroy the entire RichTextEditor.
     * @return {void}
     */
    destroy(): void;
    private addEventListener();
    private removeEventListener();
    private keyUp(e);
}
/**
 * `Toolbar renderer` module is used to render toolbar in RichTextEditor.
 * @hidden
 */
export  class ToolbarRenderer implements IRenderer {
    private mode;
    private toolbarPanel;
    protected parent: IRichTextEditor;
    private currentElement;
    private currentDropdown;
    private popupOverlay;
    /**
     * Constructor for toolbar renderer module
     */
    constructor(parent?: IRichTextEditor);
    private wireEvent();
    private unWireEvent();
    private toolbarBeforeCreate(e);
    private toolbarCreated();
    private toolbarClicked(args);
    private dropDownSelected(args);
    private beforeDropDownItemRender(args);
    private dropDownOpen(args);
    private dropDownClose(args);
    renderToolbar(args: IToolbarOptions): void;
    renderDropDownButton(args: IDropDownModel): splitbuttons.DropDownButton;
    private onPopupOverlay(args);
    private setIsModel(element);
    private paletteSelection(dropDownArgs, currentElement);
    renderColorPickerDropDown(args: IColorPickerModel, item: string, colorPicker: inputs.ColorPicker): splitbuttons.DropDownButton;
    renderColorPicker(args: IColorPickerModel, item: string): inputs.ColorPicker;
    /**
     * The function is used to render RichTextEditor toolbar
     */
    renderPanel(): void;
    /**
     * Get the toolbar element of RichTextEditor
     * @return {Element}
     */
    getPanel(): Element;
    /**
     * Set the toolbar element of RichTextEditor
     * @param  {Element} panel
     */
    setPanel(panel: Element): void;
}
/**
 * Content module is used to render RichTextEditor content
 * @hidden
 */
export  class ViewSource {
    private parent;
    private contentModule;
    private rendererFactory;
    private keyboardModule;
    private previewElement;
    /**
     * Constructor for view source module
     */
    constructor(parent?: IRichTextEditor, locator?: ServiceLocator);
    private addEventListener();
    private onInitialEnd();
    private removeEventListener();
    private getSourceCode();
    private wireEvent(element);
    private unWireEvent();
    private wireBaseKeyDown();
    private unWireBaseKeyDown();
    private mouseDownHandler(e);
    private previewKeyDown(event);
    private onKeyDown(e);
    sourceCode(args?: navigations.ClickEventArgs | IHtmlKeyboardEvent): void;
    updateSourceCode(args?: navigations.ClickEventArgs | base.KeyboardEventArgs): void;
    getPanel(): HTMLTextAreaElement | Element;
    /**
     * Destroy the entire RichTextEditor.
     * @return {void}
     */
    destroy(): void;
}
/**
 * Services
 */
/**
 * RendererFactory
 * @hidden
 */
export  class RendererFactory {
    rendererMap: {
        [c: string]: IRenderer;
    };
    addRenderer(name: RenderType, type: IRenderer): void;
    getRenderer(name: RenderType): IRenderer;
}
/**
 * ServiceLocator
 * @hidden
 */
export  class ServiceLocator {
    private services;
    register<T>(name: string, type: T): void;
    getService<T>(name: string): T;
}
/**
 * Actions
 */
/**
 * `Selection` module is used to handle RTE Selections.
 */
/**
 * `Selection` module is used to handle RTE Selections.
 */
export  class NodeSelection {
    range: Range;
    rootNode: Node;
    body: HTMLBodyElement;
    html: string;
    startContainer: number[];
    endContainer: number[];
    startOffset: number;
    endOffset: number;
    startNodeName: string[];
    endNodeName: string[];
    private saveInstance(range, body);
    private documentFromRange(range);
    getRange(docElement: Document): Range;
    get(docElement: Document): Selection;
    save(range: Range, docElement: Document): NodeSelection;
    getIndex(node: Node): number;
    private isChildNode(nodeCollection, parentNode);
    private getNode(startNode, endNode, nodeCollection);
    getNodeCollection(range: Range): Node[];
    getParentNodeCollection(range: Range): Node[];
    getParentNodes(nodeCollection: Node[], range: Range): Node[];
    getSelectionNodeCollection(range: Range): Node[];
    getSelectionNodes(nodeCollection: Node[]): Node[];
    getInsertNodeCollection(range: Range): Node[];
    getInsertNodes(nodeCollection: Node[]): Node[];
    getNodeArray(node: Node, isStart: boolean, root?: Document): number[];
    private setRangePoint(range, isvalid, num, size);
    restore(): Range;
    selectRange(docElement: Document, range: Range): void;
    setRange(docElement: Document, range: Range): void;
    setSelectionText(docElement: Document, startNode: Node, endNode: Node, startIndex: number, endIndex: number): void;
    setSelectionContents(docElement: Document, element: Node): void;
    setSelectionNode(docElement: Document, element: Node): void;
    getSelectedNodes(docElement: Document): Node[];
    Clear(docElement: Document): void;
    insertParentNode(docElement: Document, newNode: Node, range: Range): void;
    setCursorPoint(docElement: Document, element: Element, point: number): void;
}
 }
export namespace schedule { 

/**
 * Export Schedule components
 */
/**
 * Date Generator from Recurrence Rule
 */
export  function generateSummary(rule: string, localeObject: base.L10n, locale: string): string;
export  function generate(startDate: Date, rule: string, excludeDate: string, startDayOfWeek: number, maximumCount?: number, viewDate?: Date): number[];
export  function extractObjectFromRule(rules: String): RecRule;
export interface RecRule {
    freq: FreqType;
    interval: number;
    count: Number;
    until: Date;
    day: string[];
    month: number[];
    weekNo: number[];
    monthDay: number[];
    yearDay: number[];
    setPosition: number;
    validRules: string[];
}
export  type FreqType = 'DAILY' | 'WEEKLY' | 'MONTHLY' | 'YEARLY';
export  function getRecurrenceStringFromDate(date: Date): string;
/**
 * Recurrence-Editor component exported items
 */
/**
 * Interface for a class RecurrenceEditor
 */
export interface RecurrenceEditorModel extends base.ComponentModel{
    /**
     * Sets the recurrence pattern on the editor.
     * @default ['none', 'daily', 'weekly', 'monthly', 'yearly']
     */
    frequencies?: RepeatType[];
    /**
     * Sets the first day of the week.
     * @default 0
     */
    firstDayOfWeek?: number;
    /**
     * Sets the start date on recurrence editor.
     * @default new Date()
     */
    startDate?: Date;
    /**
     * Sets the user specific date format on recurrence editor.
     * @default null
     */
    dateFormat?: string;
    /**
     * Sets the locale to be applied on recurrence editor.
     * @default true
     */
    locale?: string;
    /**
     * Allows styling with custom class names.
     * @default ''
     */
    cssClass?: string;
    /**
     * Allows recurrence editor to render in RTL mode.
     * @default false
     */
    enableRtl?: boolean;
    /**
     * Sets the recurrence rule as its output values.
     * @default ''
     */
    value?: String;
    /**
     * Sets the minimum date on recurrence editor.
     * @default new Date(1900, 1, 1)
     */
    minDate?: Date;
    /**
     * Sets the maximum date on recurrence editor.
     * @default new Date(2099, 12, 31)
     */
    maxDate?: Date;
    /**
     * Sets the current repeat type to be set on the recurrence editor.
     * @default 0
     */
    selectedType?: Number;
    /**
     * Triggers for value changes on every sub-controls rendered within the recurrence editor.
     * @event
     */
    change?: base.EmitType<RecurrenceEditorChangeEventArgs>;
}
/**
 * Represents the RecurrenceEditor component.
 * ```html
 * <div id="recurrence"></div>
 * ```
 * ```typescript
 * <script>
 *   var recObj = new RecurrenceEditor();
 *   recObj.appendTo("#recurrence");
 * </script>
 * ```
 */
export  class RecurrenceEditor extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /**
     * Sets the recurrence pattern on the editor.
     * @default ['none', 'daily', 'weekly', 'monthly', 'yearly']
     */
    frequencies: RepeatType[];
    /**
     * Sets the first day of the week.
     * @default 0
     */
    firstDayOfWeek: number;
    /**
     * Sets the start date on recurrence editor.
     * @default new Date()
     */
    startDate: Date;
    /**
     * Sets the user specific date format on recurrence editor.
     * @default null
     */
    dateFormat: string;
    /**
     * Sets the locale to be applied on recurrence editor.
     * @default true
     */
    locale: string;
    /**
     * Allows styling with custom class names.
     * @default ''
     */
    cssClass: string;
    /**
     * Allows recurrence editor to render in RTL mode.
     * @default false
     */
    enableRtl: boolean;
    /**
     * Sets the recurrence rule as its output values.
     * @default ''
     */
    value: String;
    /**
     * Sets the minimum date on recurrence editor.
     * @default new Date(1900, 1, 1)
     */
    minDate: Date;
    /**
     * Sets the maximum date on recurrence editor.
     * @default new Date(2099, 12, 31)
     */
    maxDate: Date;
    /**
     * Sets the current repeat type to be set on the recurrence editor.
     * @default 0
     */
    selectedType: Number;
    /**
     * Triggers for value changes on every sub-controls rendered within the recurrence editor.
     * @event
     */
    change: base.EmitType<RecurrenceEditorChangeEventArgs>;
    /**
     * Constructor for creating the widget
     * @param  {object} options?
     */
    constructor(options?: RecurrenceEditorModel, element?: string | HTMLButtonElement);
    localeObj: base.L10n;
    private defaultLocale;
    private renderStatus;
    private destroyStatus;
    private ruleObject;
    private recurrenceCount;
    private monthDate;
    private repeatInterval;
    private untilDateObj;
    private repeatType;
    private endType;
    private monthWeekPos;
    private monthWeekDays;
    private monthValue;
    private onMonthDay;
    private onWeekDay;
    private dayButtons;
    private monthButtons;
    private startState(freq, endOn, startDate);
    protected preRender(): void;
    private applyCustomClass(cssClass);
    private initialize();
    private triggerChangeEvent();
    private resetDayButton();
    private daySelection(dayIndex);
    private rtlClass(status);
    private updateUntilDate(date);
    private selectMonthDay(date);
    private updateForm(state);
    private updateEndOnForm(state);
    private freshOnEndForm();
    private showFormElement();
    private renderDropdowns();
    private setDefaultValue();
    private resetFormValues();
    private getPopupWidth();
    private monthDayRendering();
    private renderDatePickers();
    private dayButtonRender();
    private radioButtonRender();
    private numericTextboxRender();
    private renderComponent();
    private rotateArray(data, count);
    private getEndData();
    private getDayPosition(date);
    private getRepeatData();
    private getMonthPosData();
    private getDayData(format);
    private getMonthData();
    private setTemplate();
    private getSelectedDaysData();
    private getSelectedMonthData();
    private getIntervalData();
    private getEndOnCount();
    private getYearMonthRuleData();
    private updateWeekButton(keys);
    private updateMonthUI();
    private updateUI(repeat, state);
    private getUntilData();
    private destroyComponents();
    resetFields(): void;
    getRuleSummary(rule?: string): string;
    getRecurrenceDates(startDate: Date, rule: string, excludeDate?: string, maximumCount?: number, viewDate?: Date): number[];
    getRecurrenceRule(): string;
    setRecurrenceRule(rule: string, startDate?: Date): void;
    /**
     * Destroys the widget.
     * @returns void
     */
    destroy(): void;
    /**
     * Get component name.
     * @returns string
     * @private
     */
    getModuleName(): string;
    /**
     * Get the properties to be maintained in the persisted state.
     * @returns string
     */
    getPersistData(): string;
    /**
     * Initialize the control rendering
     * @returns void
     * @private
     */
    render(): void;
    /**
     * Called internally, if any of the property value changed.
     * @private
     */
    onPropertyChanged(newProp: RecurrenceEditorModel, oldProp: RecurrenceEditorModel): void;
}
export interface RecurrenceEditorChangeEventArgs {
    value: string;
}
export  type RepeatType = 'none' | 'daily' | 'weekly' | 'monthly' | 'yearly';
/**
 * Schedule CRUD operations
 */
export  class Crud {
    parent: Schedule;
    timezone: Timezone;
    constructor(parent: Schedule);
    private getQuery();
    private refreshData(args);
    addEvent(eventData: Object | Object[]): void;
    saveEvent(event: {
        [key: string]: Object;
    } | {
        [key: string]: Object;
    }[], action?: CurrentAction): void;
    deleteEvent(id: string | number | {
        [key: string]: Object;
    } | {
        [key: string]: Object;
    }[], action?: CurrentAction): void;
    private processCrudTimezone(events);
    private excludeDateCheck(eventStartTime, exceptionDateList);
}
/**
 * data module is used to generate query and data source.
 * @hidden
 */
export  class Data {
    dataManager: data.DataManager;
    private query;
    /**
     * Constructor for data module
     * @private
     */
    constructor(dataSource?: Object | data.DataManager, query?: data.Query);
    /**
     * The function used to initialize dataManager and query
     * @return {void}
     * @private
     */
    initDataManager(dataSource: Object | data.DataManager, query: data.Query): void;
    /**
     * The function used to generate updated data.Query from schedule model
     * @return {void}
     * @private
     */
    generateQuery(startDate?: Date, endDate?: Date): data.Query;
    /**
     * The function used to get dataSource by executing given data.Query
     * @param  {data.Query} query - A data.Query that specifies to generate dataSource
     * @return {void}
     * @private
     */
    getData(query: data.Query): Promise<Object>;
}
/**
 * Keyboard interaction
 */
export  class KeyboardInteraction {
    /**
     * Constructor
     */
    private parent;
    private initialTarget;
    private selectedCells;
    private keyConfigs;
    private keyboardModule;
    constructor(parent: Schedule);
    private keyActionHandler(e);
    private addEventListener();
    private removeEventListener();
    private onCellMouseDown(e);
    onMouseSelection(e: Event): void;
    onAppointmentSelection(e: Event): void;
    private onMoveup(e);
    private processEnter(e);
    private getCells(isInverseTable, start, end);
    private focusFirstCell();
    private isInverseTableSelect();
    /** @hidden */
    selectCells(isMultiple: boolean, target: HTMLTableCellElement): void;
    private selectAppointment(isReverse, target, isMoreEvent?);
    private selectAppointmentElementFromWorkCell(isReverse, target);
    private getAllDayCells(cells);
    private getAppointmentElements();
    private getAppointmentElementsByGuid(guid);
    private getUniqueAppointmentElements();
    private getWorkCellFromAppointmentElement(target);
    private processViewNavigation(e);
    private processUp(e, isMultiple);
    private processDown(e, isMultiple);
    private processLeftRight(target, isMultiple);
    private isCancelLeftRightAction(isMultiple);
    private processRight(e, isMultiple);
    private processLeft(e, isMultiple);
    private processTab(e, isReverse);
    private processDelete(e);
    private processEscape();
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the keyboard module.
     * @return {void}
     * @private
     */
    destroy(): void;
}
/**
 * `Scroll` module
 */
export  class Scroll {
    private parent;
    /**
     * Constructor for the scrolling.
     * @hidden
     */
    constructor(parent?: Schedule);
    /**
     * For internal use only - Get the module name.
     * @private
     */
    protected getModuleName(): string;
    /**
     * @hidden
     */
    setWidth(): void;
    /**
     * @hidden
     */
    setHeight(): void;
    /**
     * @hidden
     */
    addEventListener(): void;
    /**
     * @hidden
     */
    removeEventListener(): void;
    private setDimensions();
    /**
     * @hidden
     */
    private getCssProperties(enableRtl);
    private onPropertyChanged(e);
    /**
     * @hidden
     */
    destroy(): void;
}
/**
 * `touch` module is used to handle touch interactions.
 */
export  class ScheduleTouch {
    private element;
    private currentPanel;
    private previousPanel;
    private nextPanel;
    private parent;
    private touchObj;
    private timeStampStart;
    private isScrollTriggered;
    private touchLeftDirection;
    private touchRightDirection;
    constructor(parent: Schedule);
    private scrollHandler(e);
    private swipeHandler(e);
    private tapHoldHandler(e);
    private renderPanel(clsName, nextPrevType);
    private swapPanels(direction);
    private confirmSwipe(swipeDirection);
    private cancelSwipe();
    private onTransitionEnd();
    private getTranslateX(element);
    private setDimensions(element);
    resetValues(): void;
    /**
     * @hidden
     */
    destroy(): void;
}
/**
 * Work cell interactions
 */
export  class WorkCellInteraction {
    private parent;
    constructor(parent: Schedule);
    cellMouseDown(e: Event): void;
    cellClick(e: Event & MouseEvent): void;
    cellDblClick(e: Event): void;
}
/**
 * Constants
 */
/** @hidden */
export  const cellClick: string;
/** @hidden */
export  const cellDoubleClick: string;
/** @hidden */
export  const actionBegin: string;
/** @hidden */
export  const actionComplete: string;
/** @hidden */
export  const actionFailure: string;
/** @hidden */
export  const navigating: string;
/** @hidden */
export  const renderCell: string;
/** @hidden */
export  const eventClick: string;
/** @hidden */
export  const eventRendered: string;
/** @hidden */
export  const dataBinding: string;
/** @hidden */
export  const dataBound: string;
/** @hidden */
export  const popupOpen: string;
/**
 * Specifies schedule internal events
 */
/** @hidden */
export  const initialLoad: string;
/** @hidden */
export  const initialEnd: string;
/** @hidden */
export  const dataReady: string;
/** @hidden */
export  const contentReady: string;
/** @hidden */
export  const scroll: string;
/** @hidden */
export  const scrollUiUpdate: string;
/** @hidden */
export  const uiUpdate: string;
/** @hidden */
export  const documentClick: string;
/** @hidden */
export  const cellMouseDown: string;
/**
 * CSS Constants
 */
/** @hidden */
export  const ROOT: string;
/** @hidden */
export  const RTL: string;
/** @hidden */
export  const DEVICE: string;
/** @hidden */
export  const ICON: string;
/** @hidden */
export  const ENABLE_CLASS: string;
/** @hidden */
export  const DISABLE_CLASS: string;
/** @hidden */
export  const TABLE_CONTAINER_CLASS: string;
/** @hidden */
export  const SCHEDULE_TABLE_CLASS: string;
/** @hidden */
export  const ALLDAY_CELLS_CLASS: string;
/** @hidden */
export  const HEADER_POPUP_CLASS: string;
/** @hidden */
export  const HEADER_CALENDAR_CLASS: string;
/** @hidden */
export  const ALLDAY_ROW_CLASS: string;
/** @hidden */
export  const CONTENT_TABLE_CLASS: string;
/** @hidden */
export  const WORK_CELLS_CLASS: string;
/** @hidden */
export  const WORK_HOURS_CLASS: string;
/** @hidden */
export  const POPUP_OPEN: string;
/** @hidden */
export  const DATE_HEADER_WRAP_CLASS: string;
/** @hidden */
export  const DATE_HEADER_CONTAINER_CLASS: string;
/** @hidden */
export  const HEADER_CELLS_CLASS: string;
/** @hidden */
export  const WORKDAY_CLASS: string;
/** @hidden */
export  const OTHERMONTH_CLASS: string;
/** @hidden */
export  const CURRENT_DAY_CLASS: string;
/** @hidden */
export  const CURRENTDATE_CLASS: string;
/** @hidden */
export  const EXPANDED_CELL_CLASS: string;
/** @hidden */
export  const APPOINTMENT_ROW_CLASS: string;
/** @hidden */
export  const APPOINTMENT_CELL_CLASS: string;
/** @hidden */
export  const CURRENT_PANEL_CLASS: string;
/** @hidden */
export  const PREVIOUS_PANEL_CLASS: string;
/** @hidden */
export  const NEXT_PANEL_CLASS: string;
/** @hidden */
export  const TRANSLATE_CLASS: string;
/** @hidden */
export  const LEFT_INDENT_CLASS: string;
/** @hidden */
export  const LEFT_INDENT_WRAP_CLASS: string;
/** @hidden */
export  const TIME_CELLS_WRAP_CLASS: string;
/** @hidden */
export  const TIME_CELLS_CLASS: string;
/** @hidden */
export  const ALTERNATE_CELLS_CLASS: string;
/** @hidden */
export  const CURRENT_TIME_CLASS: string;
/** @hidden */
export  const CURRENT_TIMELINE_CLASS: string;
/** @hidden */
export  const PREVIOUS_TIMELINE_CLASS: string;
/** @hidden */
export  const HIDE_CHILDS_CLASS: string;
/** @hidden */
export  const SCROLL_CONTAINER_CLASS: string;
/** @hidden */
export  const WRAPPER_CLASS: string;
/** @hidden */
export  const TIMELINE_WRAPPER_CLASS: string;
/** @hidden */
export  const APPOINTMENT_WRAPPER_CLASS: string;
/** @hidden */
export  const DAY_WRAPPER_CLASS: string;
/** @hidden */
export  const TOOLBAR_CONTAINER: string;
/** @hidden */
export  const HEADER_TOOLBAR: string;
/** @hidden */
export  const SELECTED_CELL_CLASS: string;
/** @hidden */
export  const APPOINTMENT_WRAP_CLASS: string;
/** @hidden */
export  const APPOINTMENT_CONTAINER_CLASS: string;
/** @hidden */
export  const APPOINTMENT_CLASS: string;
/** @hidden */
export  const APPOINTMENT_BORDER: string;
/** @hidden */
export  const APPOINTMENT_DETAILS: string;
/** @hidden */
export  const APPOINTMENT_SUBJECT_WRAP: string;
/** @hidden */
export  const APPOINTMENT_SUBJECT: string;
/** @hidden */
export  const APPOINTMENT_TIME: string;
/** @hidden */
export  const APPOINTMENT_LOCATION: string;
/** @hidden */
export  const TABLE_WRAP_CLASS: string;
/** @hidden */
export  const OUTER_TABLE_CLASS: string;
/** @hidden */
export  const CONTENT_WRAP_CLASS: string;
/** @hidden */
export  const AGENDA_CELLS_CLASS: string;
/** @hidden */
export  const AGENDA_CURRENT_DAY_CLASS: string;
/** @hidden */
export  const AGENDA_HEADER_CLASS: string;
/** @hidden */
export  const NAVIGATE_CLASS: string;
/** @hidden */
export  const DATE_HEADER_CLASS: string;
/** @hidden */
export  const DAY_HEADER_CLASS: string;
/** @hidden */
export  const AGENDA_HIDDEN_CLASS: string;
/** @hidden */
export  const AGENDA_ALIGN_CLASS: string;
/** @hidden */
export  const AGENDA_DAY_BORDER_CLASS: string;
/** @hidden */
export  const AGENDA_DATETIME_CLASS: string;
/** @hidden */
export  const AGENDA_EMPTY_EVENT_CLASS: string;
/** @hidden */
export  const AGENDA_NO_EVENT_CLASS: string;
/** @hidden */
export  const APPOINTMENT_INDICATOR_CLASS: string;
/** @hidden */
export  const EVENT_INDICATOR_CLASS: string;
/** @hidden */
export  const EVENT_ICON_UP_CLASS: string;
/** @hidden */
export  const EVENT_ICON_DOWN_CLASS: string;
/** @hidden */
export  const EVENT_ICON_LEFT_CLASS: string;
/** @hidden */
export  const EVENT_ICON_RIGHT_CLASS: string;
/** @hidden */
export  const EVENT_RECURRENCE_ICON_CLASS: string;
/** @hidden */
export  const EVENT_RECURRENCE_EDIT_ICON_CLASS: string;
/** @hidden */
export  const HEADER_ROW_CLASS: string;
/** @hidden */
export  const ALLDAY_APPOINTMENT_WRAPPER_CLASS: string;
/** @hidden */
export  const ALLDAY_APPOINTMENT_CLASS: string;
/** @hidden */
export  const ALLDAY_WRAPPER_CLASS: string;
/** @hidden */
export  const EVENT_COUNT_CLASS: string;
/** @hidden */
export  const ROW_COUNT_WRAPPER_CLASS: string;
/** @hidden */
export  const ALLDAY_APPOINTMENT_SECTION_CLASS: string;
/** @hidden */
export  const APPOINTMENT_ROW_EXPAND_CLASS: string;
/** @hidden */
export  const APPOINTMENT_ROW_COLLAPSE_CLASS: string;
/** @hidden */
export  const MORE_INDICATOR_CLASS: string;
/** @hidden */
export  const APPOINTMENT_SELECTION_CLASS: string;
/** @hidden */
export  const APPOINTMENT_CELL_SELECT_CLASS: string;
/** @hidden */
export  const SCHEDULE_INNER_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_ROOT_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_SUBJECT_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_TABLE_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_ICON_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_CLOSE_ICON_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_EDIT_ICON_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_CONTENT_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_RIGHT_FIELDS_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_DATE_TIME_DETAILS_CLASS: string;
/** @hidden */
export  const DEVICE_DATE_TIME_DETAILS_CLASS: string;
/** @hidden */
export  const DEVICE_RECURRENCE_SUMMARY_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_LOCATION_DETAILS_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_FOOTER_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_EVENT_DETAILS_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_EVENT_TITLE_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_EVENT_CREATE_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_EDIT_EVENT_CLASS: string;
/** @hidden */
export  const TOOLTIP_CLOSE_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_DELETE_EVENT_CLASS: string;
/** @hidden */
export  const QUICK_POPUP_TEXT_ALIGN_CLASS: string;
/** @hidden */
export  const MORE_POPUP_WRAPPER_CLASS: string;
/** @hidden */
export  const SELECT_POPUP_WRAPPER_CLASS: string;
/** @hidden */
export  const MORE_EVENT_POPUP_CLASS: string;
/** @hidden */
export  const MORE_EVENT_HEADER_CLASS: string;
/** @hidden */
export  const MORE_EVENT_DATE_HEADER_CLASS: string;
/** @hidden */
export  const MORE_EVENT_HEADER_DAY_CLASS: string;
/** @hidden */
export  const MORE_EVENT_HEADER_DATE_CLASS: string;
/** @hidden */
export  const MORE_EVENT_CLOSE_CLASS: string;
/** @hidden */
export  const MORE_EVENT_CLOSE_ICON_CLASS: string;
/** @hidden */
export  const MORE_EVENT_CONTENT_CLASS: string;
/** @hidden */
export  const MORE_EVENT_WRAPPER_CLASS: string;
/** @hidden */
export  const QUICK_DIALOG_CLASS: string;
/** @hidden */
export  const DIALOG_FOOTER_CONTENT_CLASS: string;
/** @hidden */
export  const QUICK_DIALOG_EDIT_EVENT_CLASS: string;
/** @hidden */
export  const QUICK_DIALOG_EDIT_SERIES_CLASS: string;
/** @hidden */
export  const QUICK_DIALOG_DELETE_CLASS: string;
/** @hidden */
export  const QUICK_DIALOG_CANCEL_CLASS: string;
/** @hidden */
export  const QUICK_DIALOG_ALERT_BTN_CLASS: string;
/** @hidden */
export  const QUICK_DIALOG_HIDE_BTN_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_DIALOG_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_DEVICE_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_FORM_DIV_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_FORM_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_ALLDAY_TZ_DIV_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_ALL_DAY_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_TZ_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_REPEAT_DIV_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_REPEAT_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_TITLE_LOCATION_DIV_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_TITLE_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_LOCATION_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_START_END_DIV_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_START_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_END_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_DESCRIPTION_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_TIME_ZONE_DIV_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_START_TZ_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_END_TZ_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_BACK_ICON_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_SAVE_ICON_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_DELETE_BUTTON_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_CANCEL_BUTTON_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_SAVE_BUTTON_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_DIALOG_PARENT_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_TITLE_TEXT_CLASS: string;
/** @hidden */
export  const EVENT_WINDOW_ICON_DISABLE_CLASS: string;
/** @hidden */
export  const SELECTED_EVENT_EDIT_CLASS: string;
/** @hidden */
export  const SELECTED_EVENT_DELETE_CLASS: string;
/** @hidden */
export  const SELECTED_DATE_TIME_CLASS: string;
/** @hidden */
export  const SELECTED_CALENDER_CLASS: string;
/** @hidden */
export  const SELECTED_EVENT_TITLE_CLASS: string;
/** @hidden */
export  const SELECTED_EVENT_CONTAINER_CLASS: string;
/** @hidden */
export  const SELECTED_EVENT_CLOSE_CLASS: string;
/** @hidden */
export  const EVENT_TIME_ZONE_CLASS: string;
/** @hidden */
export  const EVENT_ZONE_DETAILS_CLASS: string;
/** @hidden */
export  const EVENT_DETAILS_CLASS: string;
/** @hidden */
export  const EVENT_NOTE_CLASS: string;
/** @hidden */
export  const EVENT_NOTE_DETAILS_CLASS: string;
/** @hidden */
export  const EVENT_DISABLE_CLASS: string;
/** @hidden */
export  const EVENT_EDIT_DISABLE_CLASS: string;
/** @hidden */
export  const ERROR_VALIDATION_CLASS: string;
/** @hidden */
export  const EVENT_TOOLTIP_ROOT_CLASS: string;
/** @hidden */
export  const ALLDAY_ROW_ANIMATE_CLASS: string;
/**
 * Interface
 */
/** @hidden */
export interface TdData {
    date?: Date;
    className?: string[];
    colSpan?: number;
    rowSpan?: number;
    type: string;
    text?: string;
}
/** @hidden */
export interface TimeSlotData extends TdData {
    first: boolean;
    middle: boolean;
    last: boolean;
}
export interface ActionEventArgs extends base.BaseEventArgs {
    /** Returns the request type of the current action. */
    requestType: string;
    /** Defines the type of the event. */
    event?: Event;
    /** Defines the cancel option for the action taking place. */
    cancel: boolean;
    /** Returns the appropriate data based on the action. */
    data?: object;
}
export interface ToolbarActionArgs extends base.BaseEventArgs {
    /** Returns the request type of the current action. */
    requestType: string;
    /** Returns the toolbar items present in the Schedule header bar. */
    items: navigations.ItemModel[];
}
export interface CellClickEventArgs extends base.BaseEventArgs {
    /** Returns the start time of the cell. */
    startTime: Date;
    /** Returns the end time of the cell. */
    endTime: Date;
    /** Returns true or false, based on whether the clicked cell is all-day or not. */
    isAllDay: boolean;
    /** Returns the single or collection of HTML element(s). */
    element?: HTMLElement | HTMLElement[];
    /** Defines the cancel option. */
    cancel?: boolean;
    /** Defines the type of the event. */
    event?: Event;
}
export interface EventClickArgs extends base.BaseEventArgs {
    /** Returns the date of the event. */
    date?: Date;
    /** Returns a single or collection of selected or clicked events. */
    event: {
        [key: string]: Object;
    } | {
        [key: string]: Object;
    }[];
    /** Returns the single or collection of HTML element(s). */
    element: HTMLElement | HTMLElement[];
    /** Defines the cancel option. */
    cancel?: boolean;
}
export interface EventRenderedArgs extends base.BaseEventArgs {
    /** Returns the event data. */
    data: {
        [key: string]: Object;
    };
    /** Returns the event element which is currently being rendered on the UI. */
    element: HTMLElement;
}
export interface PopupOpenEventArgs extends base.BaseEventArgs {
    /** Returns the type of the popup which is currently being opted to open. */
    type: PopupType;
    /** Returns the cell or event data. */
    data: Object;
    /** Returns the target element on which the popup is getting opened. */
    target?: Element;
    /** Returns the popup wrapper element. */
    element: Element;
    /** Defines the cancel option. */
    cancel: boolean;
}
export interface NavigatingEventArgs extends base.BaseEventArgs {
    /** Returns the action type either as `date` or `view` due to which the navigation takes place. */
    action: string;
    /** Defines the cancel option. */
    cancel: boolean;
    /** Returns the date value before date navigation takes place. */
    previousDate?: Date;
    /** Returns the current date value after navigation takes place. */
    currentDate?: Date;
    /** Returns the view name before the view navigation takes place. */
    previousView?: string;
    /** Returns the active view name after the view navigation takes place. */
    currentView?: string;
}
export interface RenderCellEventArgs extends base.BaseEventArgs {
    /** Returns the type of the elements which is currently being rendered on the UI. */
    elementType: string;
    /** Returns the actual HTML element on which the required custom styling can be applied. */
    element?: Element;
    /** Returns the date value of the cell that is currently rendering on UI. */
    date?: Date;
}
/** @hidden */
export interface KeyEventArgs {
    element: HTMLTableElement;
    rowIndex: number;
    columnIndex: number;
    maxIndex: number;
}
/** @hidden */
export interface CellTemplateArgs {
    date: Date;
    type: string;
}
/** @hidden */
export interface CrudArgs extends ActionEventArgs {
    promise?: Promise<Object>;
}
/** @hidden */
export interface IRenderer {
    element: HTMLElement;
    renderDates: Date[];
    viewClass: string;
    isInverseTableSelect: boolean;
    startDate(): Date;
    endDate(): Date;
    scrollToHour?(hour: string): void;
    highlightCurrentTime?(): void;
    getStartHour(): Date;
    getEndHour(): Date;
    getLabelText(view: string): string;
    getDateRangeText(): string;
    getEndDateFromStartDate?(date: Date): Date;
    addEventListener?(): void;
    removeEventListener?(): void;
    getRenderDates?(): void;
    getNextPreviousDate?(type: string): Date;
    renderLayout(type: string): void;
    setPanel(panel: HTMLElement): void;
    getPanel(): HTMLElement;
    adjustEventWrapper(): void;
    destroy(): void;
}
/** @hidden */
export interface EJ2Instance extends HTMLElement {
    ej2_instances: Object[];
}
/** @hidden */
export interface ScrollCss {
    padding?: string;
    border?: string;
}
/** @hidden */
export interface NotifyEventArgs {
    module?: string;
    cssProperties?: ScrollCss;
    processedData?: Object[];
}
/** @hidden */
export interface LayoutData {
    element: HTMLElement;
    selectedDate: Date;
}
/** @hidden */
export interface PopupEventArgs {
    classList?: string[];
    data?: string[] | {
        [key: string]: Object;
    }[];
    fields?: EventFieldsMapping;
    id?: string;
    l10n?: {
        [key: string]: Object;
    };
}
/** @hidden */
export interface EventFieldsMapping {
    id?: string;
    subject?: string;
    startTime?: string;
    endTime?: string;
    startTimezone?: string;
    endTimezone?: string;
    location?: string;
    description?: string;
    isAllDay?: string;
    recurrenceID?: string;
    recurrenceRule?: string;
    recurrenceException?: string;
}
/** @hidden */
export interface ElementData {
    index: number;
    left: string;
    width: string;
    day: number;
    record: {
        [key: string]: Object;
    };
}
/** @hidden */
export interface SaveChanges {
    addedRecords: Object[];
    changedRecords: Object[];
    deletedRecords: Object[];
}
/** @hidden */
export interface UIStateArgs {
    expand?: boolean;
    isInitial?: boolean;
    left?: number;
    top?: number;
}
/**
 * Interface for a class Schedule
 */
export interface ScheduleModel extends base.ComponentModel{
    /**
     * Sets the `width` of the Schedule component, accepting both string and number values.
     * The string value can be either pixel or percentage format.
     * When set to `auto`, the Schedule width gets auto-adjusted and display its content related to the viewable screen size.
     * @default 'auto'
     */
    width?: string | number;
    /**
     * Sets the `height` of the Schedule component, accepting both string and number values.
     * The string type includes either pixel or percentage values.
     * When `height` is set with specific pixel value, then the Schedule will be rendered to that specified space.
     * In case, if `auto` value is set, then the height of the Schedule gets auto-adjusted within the given container.
     * @default 'auto'
     */
    height?: string | number;
    /**
     * When set to `false`, hides the header bar of the Schedule from UI. By default,
     *  the header bar holds the date and view navigation options, to which the user can add their own custom items onto it.
     * @default true
     */
    showHeaderBar?: boolean;
    /**
     * When set to `false`, hides the current time indicator from the Schedule. Otherwise,
     *  it visually depicts the live current system time appropriately on the user interface.
     * @default true
     */
    showTimeIndicator?: boolean;
    /**
     * To set the active view on Schedule, the `currentView` property can be used and it usually accepts either of the following available
     *  view options. The view option specified in this property will be initially loaded on the Schedule.
     * * base.Day
     * * base.Week
     * * Work base.Week
     * * base.Month
     * * base.Agenda
     * * base.Month base.Agenda
     * @default 'base.Week'
     */
    currentView?: View;
    /**
     * This property holds the views collection and its configurations. It accepts either the array of view names or the array of view
     *  objects that holds different configurations for each views. By default,
     *  Schedule displays all the views namely `base.Day`, `base.Week`, `Work base.Week`, `base.Month` and `base.Agenda`.
     * @default '['base.Day', 'base.Week', 'base.WorkWeek', 'base.Month', 'base.Agenda']'
     */
    views?: View[] | ViewsModel[];
    /**
     * To mark the active (current) date on the Schedule, `selectedDate` property can be defined.
     *  Usually, it defaults to the current System date.
     * @default 'new Date()'
     */
    selectedDate?: Date;
    /**
     * By default, Schedule follows the date-format as per the default culture assigned to it.
     *  It is also possible to manually set specific date format by using the `dateFormat` property. 
     * The format of the date range label in the header bar depends on the `dateFormat` value or else based on the 
     * locale assigned to the Schedule. 
     * @default null
     */
    dateFormat?: string;
    /**
     * When set to `false`, it hides the weekend days of a week from the Schedule. The days which are not defined in the working days
     *  collection are usually treated as weekend days.
     * Note: By default, this option is not applicable on `Work base.Week` view.
     * For example, if the working days are defined as [1, 2, 3, 4], then the remaining days of that week will be considered as
     *  the weekend days and will be hidden on all the views.
     * @default true
     */
    showWeekend?: boolean;
    /**
     * This option allows the user to set the first day of a week on Schedule. It should be based on the locale set to it and each culture
     *  defines its own first day of week values. If needed, the user can set it manually on his own by defining the value through
     *  this property. It usually accepts the integer values, whereby 0 is always denoted as Sunday, 1 as Monday and so on.
     * @default '0'
     */
    firstDayOfWeek?: number;
    /**
     * It is used to set the working days on Schedule. The only days that are defined in this collection will be rendered on the `workWeek`
     *  view whereas on other views, it will display all the usual days and simply highlights the working days with different shade.
     * @default '[1, 2, 3, 4, 5]'
     */
    workDays?: number[];
    /**
     * It is used to specify the starting hour, from which the Schedule starts to display. It accepts the time string in a short skeleton
     *  format and also, hides the time beyond the specified start time.
     * @default '00:00'
     */
    startHour?: string;
    /**
     * It is used to specify the end hour, at which the Schedule ends. It too accepts the time string in a short skeleton format.
     * @default '24:00'
     */
    endHour?: string;
    /**
     * The working hours should be highlighted on Schedule with different color shade and an additional option must be provided to
     *  highlight it or not. This functionality is handled through `workHours` property and the start work hour should be 9 AM by default
     *  and end work hour should point to 6 PM. The start and end working hours needs to be provided as Time value of short skeleton type.
     * @default { highlight: true, start: '09:00', end: '18:00' }
     */
    workHours?: WorkHoursModel;
    /**
     * When set to `true`, allows the keyboard interaction to take place on Schedule.
     * @default true
     */
    allowKeyboardInteraction?: boolean;
    /**
     * It accepts either the string or HTMLElement as template design content and parse it appropriately before displaying it onto
     *  the date header cells. The field that can be accessed via this template is `date`.
     * @default null
     */
    dateHeaderTemplate?: string;
    /**
     * The template option which is used to render the customized work cells on the Schedule. Here, the template accepts either
     *  the string or HTMLElement as template design and then the parsed design is displayed onto the work cells.
     *  The field accessible via template is `date`.
     * @default null
     */
    cellTemplate?: string;
    /**
     * When set to `true`, makes the Schedule to render in a read only mode. No CRUD actions will be allowed at this time.
     * @default false
     */
    readonly?: boolean;
    /**
     * When set to `true`, displays a quick popup with cell or event details on single clicking over the cells or on events.
     *  By default, it is set to `true`.
     * @default true
     */
    showQuickInfo?: boolean;
    /**
     * The template option to render the customized editor window. The form elements defined within this template should be accompanied
     *  with `e-field` class, so as to fetch and process it from internally.
     * @default null
     */
    editorTemplate?: string;
    /**
     * Sets the number of days to be displayed by default in base.Agenda View and in case of virtual scrolling,
     *  the number of days will be fetched on each scroll-end based on this count.
     * @default '7'
     */
    agendaDaysCount?: number;
    /**
     * The days which does not has even a single event to display will be hidden from the UI of base.Agenda View by default.
     *  When this property is set to `false`, the empty dates will also be displayed on the Schedule.
     * @default true
     */
    hideEmptyAgendaDays?: boolean;
    /**
     * Schedule will be assigned with specific timezone, so as to display the events in it accordingly. By default,
     *  Schedule dates are processed with System timezone, as no timezone will be assigned specifically to the Schedule at the initial time.
     *  Whenever the Schedule is bound to remote data services, it is always recommended to set specific timezone to Schedule to make the
     *  events on it to display on the same time irrespective of the system timezone. It usually accepts
     *  the valid [IANA](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) timezone names.
     * @default null
     */
    timezone?: string;
    /**
     * Complete set of settings related to Schedule events to bind it to local or remote dataSource, map applicable database fields and
     *  other validation to be carried out on the available fields.
     * @default null
     */
    eventSettings?: EventSettingsModel;
    /**
     * It is used to customize the Schedule which accepts custom CSS class names that defines specific user-defined styles and themes
     *  to be applied on the Schedule element.
     * @default null
     */
    cssClass?: string;
    /**
     * When set to `true`, enables the RTL mode on the Schedule, so that the Schedule and its content displays in the direction
     *  from right to left.
     * @default false
     */
    enableRtl?: boolean;
    /**
     * Triggers after the Schedule control is created.
     * @event
     */
    created?: base.EmitType<Object>;
    /**
     * Triggers when the Schedule control is destroyed.
     * @event
     */
    destroyed?: base.EmitType<Object>;
    /**
     * Triggers when the Schedule cells are single clicked or on single tap on the Schedule cells in mobile devices.
     * @event
     */
    cellClick?: base.EmitType<CellClickEventArgs>;
    /**
     * Triggers when the Schedule cells are double clicked.
     * @event
     */
    cellDoubleClick?: base.EmitType<CellClickEventArgs>;
    /**
     * Triggers on beginning of every Schedule action.
     * @event
     */
    actionBegin?: base.EmitType<ActionEventArgs>;
    /**
     * Triggers on successful completion of the Schedule actions.
     * @event
     */
    actionComplete?: base.EmitType<ActionEventArgs>;
    /**
     * Triggers when a Schedule action gets failed or interrupted and an error information will be returned.
     * @event
     */
    actionFailure?: base.EmitType<ActionEventArgs>;
    /**
     * Triggers before the date or view navigation takes place on Schedule.
     * @event
     */
    navigating?: base.EmitType<NavigatingEventArgs>;
    /**
     * Triggers before each element of the Schedule rendering on the page.
     * @event
     */
    renderCell?: base.EmitType<RenderCellEventArgs>;
    /**
     * Triggers when the events are single clicked or on single tapping the events on the mobile devices.
     * @event
     */
    eventClick?: base.EmitType<EventClickArgs>;
    /**
     * Triggers after each of the event gets rendered on the Schedule user interface.
     * @event
     */
    eventRendered?: base.EmitType<EventRenderedArgs>;
    /**
     * Triggers before the data binds to the Schedule.
     * @event
     */
    dataBinding?: base.EmitType<ReturnType>;
    /**
     * Triggers before any of the Schedule popups opens on the page.
     * @event
     */
    popupOpen?: base.EmitType<PopupOpenEventArgs>;
    /**
     * Triggers once the event data is bound to the Schedule.
     * @event
     */
    dataBound?: base.EmitType<ReturnType>;
}
/**
 * Represents the Schedule component that displays a list of events scheduled against specific date and timings,
 * thus helping us to plan and manage it properly.
 * ```html
 * <div id="schedule"></div>
 * ```
 * ```typescript
 * <script>
 *   var scheduleObj = new Schedule();
 *   scheduleObj.appendTo("#schedule");
 * </script>
 * ```
 */
export  class Schedule extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    globalize: base.Internationalization;
    localeObj: base.L10n;
    isAdaptive: Boolean;
    dataModule: Data;
    eventTooltip: EventTooltip;
    eventWindow: EventWindow;
    renderModule: Render;
    headerModule: HeaderRenderer;
    scrollModule: Scroll;
    crudModule: Crud;
    scheduleTouchModule: ScheduleTouch;
    keyboardInteractionModule: KeyboardInteraction;
    activeView: IRenderer;
    activeCellsData: CellClickEventArgs;
    activeEventData: EventClickArgs;
    eventBase: EventBase;
    private cellTemplateFn;
    private dateHeaderTemplateFn;
    private appointmentTemplateFn;
    private eventTooltipTemplateFn;
    private editorTemplateFn;
    private defaultLocale;
    dayModule: Day;
    weekModule: Week;
    workWeekModule: WorkWeek;
    monthAgendaModule: MonthAgenda;
    monthModule: Month;
    agendaModule: Agenda;
    viewOptions: {
        [key: string]: ViewsModel;
    };
    activeViewOptions: ViewsModel;
    eventFields: EventFieldsMapping;
    eventsData: Object[];
    eventsProcessed: Object[];
    currentAction: CurrentAction;
    quickPopup: QuickPopups;
    selectedElements: Element[];
    uiStateValues: UIStateArgs;
    /**
     * Sets the `width` of the Schedule component, accepting both string and number values.
     * The string value can be either pixel or percentage format.
     * When set to `auto`, the Schedule width gets auto-adjusted and display its content related to the viewable screen size.
     * @default 'auto'
     */
    width: string | number;
    /**
     * Sets the `height` of the Schedule component, accepting both string and number values.
     * The string type includes either pixel or percentage values.
     * When `height` is set with specific pixel value, then the Schedule will be rendered to that specified space.
     * In case, if `auto` value is set, then the height of the Schedule gets auto-adjusted within the given container.
     * @default 'auto'
     */
    height: string | number;
    /**
     * When set to `false`, hides the header bar of the Schedule from UI. By default,
     *  the header bar holds the date and view navigation options, to which the user can add their own custom items onto it.
     * @default true
     */
    showHeaderBar: boolean;
    /**
     * When set to `false`, hides the current time indicator from the Schedule. Otherwise,
     *  it visually depicts the live current system time appropriately on the user interface.
     * @default true
     */
    showTimeIndicator: boolean;
    /**
     * To set the active view on Schedule, the `currentView` property can be used and it usually accepts either of the following available
     *  view options. The view option specified in this property will be initially loaded on the Schedule.
     * * Day
     * * Week
     * * Work Week
     * * Month
     * * Agenda
     * * Month Agenda
     * @default 'Week'
     */
    currentView: View;
    /**
     * This property holds the views collection and its configurations. It accepts either the array of view names or the array of view
     *  objects that holds different configurations for each views. By default,
     *  Schedule displays all the views namely `Day`, `Week`, `Work Week`, `Month` and `Agenda`.
     * @default '['Day', 'Week', 'WorkWeek', 'Month', 'Agenda']'
     */
    views: View[] | ViewsModel[];
    /**
     * To mark the active (current) date on the Schedule, `selectedDate` property can be defined.
     *  Usually, it defaults to the current System date.
     * @default 'new Date()'
     */
    selectedDate: Date;
    /**
     * By default, Schedule follows the date-format as per the default culture assigned to it.
     *  It is also possible to manually set specific date format by using the `dateFormat` property.
     * The format of the date range label in the header bar depends on the `dateFormat` value or else based on the
     * locale assigned to the Schedule.
     * @default null
     */
    dateFormat: string;
    /**
     * When set to `false`, it hides the weekend days of a week from the Schedule. The days which are not defined in the working days
     *  collection are usually treated as weekend days.
     * Note: By default, this option is not applicable on `Work Week` view.
     * For example, if the working days are defined as [1, 2, 3, 4], then the remaining days of that week will be considered as
     *  the weekend days and will be hidden on all the views.
     * @default true
     */
    showWeekend: boolean;
    /**
     * This option allows the user to set the first day of a week on Schedule. It should be based on the locale set to it and each culture
     *  defines its own first day of week values. If needed, the user can set it manually on his own by defining the value through
     *  this property. It usually accepts the integer values, whereby 0 is always denoted as Sunday, 1 as Monday and so on.
     * @default '0'
     */
    firstDayOfWeek: number;
    /**
     * It is used to set the working days on Schedule. The only days that are defined in this collection will be rendered on the `workWeek`
     *  view whereas on other views, it will display all the usual days and simply highlights the working days with different shade.
     * @default '[1, 2, 3, 4, 5]'
     */
    workDays: number[];
    /**
     * It is used to specify the starting hour, from which the Schedule starts to display. It accepts the time string in a short skeleton
     *  format and also, hides the time beyond the specified start time.
     * @default '00:00'
     */
    startHour: string;
    /**
     * It is used to specify the end hour, at which the Schedule ends. It too accepts the time string in a short skeleton format.
     * @default '24:00'
     */
    endHour: string;
    /**
     * The working hours should be highlighted on Schedule with different color shade and an additional option must be provided to
     *  highlight it or not. This functionality is handled through `workHours` property and the start work hour should be 9 AM by default
     *  and end work hour should point to 6 PM. The start and end working hours needs to be provided as Time value of short skeleton type.
     * @default { highlight: true, start: '09:00', end: '18:00' }
     */
    workHours: WorkHoursModel;
    /**
     * When set to `true`, allows the keyboard interaction to take place on Schedule.
     * @default true
     */
    allowKeyboardInteraction: boolean;
    /**
     * It accepts either the string or HTMLElement as template design content and parse it appropriately before displaying it onto
     *  the date header cells. The field that can be accessed via this template is `date`.
     * @default null
     */
    dateHeaderTemplate: string;
    /**
     * The template option which is used to render the customized work cells on the Schedule. Here, the template accepts either
     *  the string or HTMLElement as template design and then the parsed design is displayed onto the work cells.
     *  The field accessible via template is `date`.
     * @default null
     */
    cellTemplate: string;
    /**
     * When set to `true`, makes the Schedule to render in a read only mode. No CRUD actions will be allowed at this time.
     * @default false
     */
    readonly: boolean;
    /**
     * When set to `true`, displays a quick popup with cell or event details on single clicking over the cells or on events.
     *  By default, it is set to `true`.
     * @default true
     */
    showQuickInfo: boolean;
    /**
     * The template option to render the customized editor window. The form elements defined within this template should be accompanied
     *  with `e-field` class, so as to fetch and process it from internally.
     * @default null
     */
    editorTemplate: string;
    /**
     * Sets the number of days to be displayed by default in Agenda View and in case of virtual scrolling,
     *  the number of days will be fetched on each scroll-end based on this count.
     * @default '7'
     */
    agendaDaysCount: number;
    /**
     * The days which does not has even a single event to display will be hidden from the UI of Agenda View by default.
     *  When this property is set to `false`, the empty dates will also be displayed on the Schedule.
     * @default true
     */
    hideEmptyAgendaDays: boolean;
    /**
     * Schedule will be assigned with specific timezone, so as to display the events in it accordingly. By default,
     *  Schedule dates are processed with System timezone, as no timezone will be assigned specifically to the Schedule at the initial time.
     *  Whenever the Schedule is bound to remote data services, it is always recommended to set specific timezone to Schedule to make the
     *  events on it to display on the same time irrespective of the system timezone. It usually accepts
     *  the valid [IANA](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) timezone names.
     * @default null
     */
    timezone: string;
    /**
     * Complete set of settings related to Schedule events to bind it to local or remote dataSource, map applicable database fields and
     *  other validation to be carried out on the available fields.
     * @default null
     */
    eventSettings: EventSettingsModel;
    /**
     * It is used to customize the Schedule which accepts custom CSS class names that defines specific user-defined styles and themes
     *  to be applied on the Schedule element.
     * @default null
     */
    cssClass: string;
    /**
     * When set to `true`, enables the RTL mode on the Schedule, so that the Schedule and its content displays in the direction
     *  from right to left.
     * @default false
     */
    enableRtl: boolean;
    /**
     * Triggers after the Schedule control is created.
     * @event
     */
    created: base.EmitType<Object>;
    /**
     * Triggers when the Schedule control is destroyed.
     * @event
     */
    destroyed: base.EmitType<Object>;
    /**
     * Triggers when the Schedule cells are single clicked or on single tap on the Schedule cells in mobile devices.
     * @event
     */
    cellClick: base.EmitType<CellClickEventArgs>;
    /**
     * Triggers when the Schedule cells are double clicked.
     * @event
     */
    cellDoubleClick: base.EmitType<CellClickEventArgs>;
    /**
     * Triggers on beginning of every Schedule action.
     * @event
     */
    actionBegin: base.EmitType<ActionEventArgs>;
    /**
     * Triggers on successful completion of the Schedule actions.
     * @event
     */
    actionComplete: base.EmitType<ActionEventArgs>;
    /**
     * Triggers when a Schedule action gets failed or interrupted and an error information will be returned.
     * @event
     */
    actionFailure: base.EmitType<ActionEventArgs>;
    /**
     * Triggers before the date or view navigation takes place on Schedule.
     * @event
     */
    navigating: base.EmitType<NavigatingEventArgs>;
    /**
     * Triggers before each element of the Schedule rendering on the page.
     * @event
     */
    renderCell: base.EmitType<RenderCellEventArgs>;
    /**
     * Triggers when the events are single clicked or on single tapping the events on the mobile devices.
     * @event
     */
    eventClick: base.EmitType<EventClickArgs>;
    /**
     * Triggers after each of the event gets rendered on the Schedule user interface.
     * @event
     */
    eventRendered: base.EmitType<EventRenderedArgs>;
    /**
     * Triggers before the data binds to the Schedule.
     * @event
     */
    dataBinding: base.EmitType<ReturnType>;
    /**
     * Triggers before any of the Schedule popups opens on the page.
     * @event
     */
    popupOpen: base.EmitType<PopupOpenEventArgs>;
    /**
     * Triggers once the event data is bound to the Schedule.
     * @event
     */
    dataBound: base.EmitType<ReturnType>;
    /**
     * Constructor for creating the Schedule widget
     * @hidden
     */
    constructor(options?: ScheduleModel, element?: string | HTMLElement);
    /**
     * Core method that initializes the control rendering.
     * @private
     */
    render(): void;
    private validateDate();
    private setViewOptions(isModuleLoad?);
    private getActiveViewOptions(viewName);
    private initializeDataModule();
    private initializeView(viewName);
    private initializeTemplates();
    private initializePopups();
    getDayNames(type: string): string[];
    changeView(view: View, event?: Event, muteOnChange?: boolean): void;
    changeDate(selectedDate: Date, event?: Event): void;
    isSelectedDate(date: Date): boolean;
    private animateLayout();
    /**
     * To provide the array of modules needed for control rendering
     * @return {base.ModuleDeclaration[]}
     * @hidden
     */
    requiredModules(): base.ModuleDeclaration[];
    /**
     * Initializes the values of private members.
     * @private
     */
    protected preRender(): void;
    /**
     * Binding events to the Schedule element.
     * @hidden
     */
    private wireEvents();
    removeSelectedClass(): void;
    addSelectedClass(cells: HTMLTableCellElement[], focusCell: HTMLTableCellElement): void;
    selectCell(element: HTMLElement & HTMLTableCellElement): void;
    getSelectedElements(): Element[];
    getAllDayRow(): Element;
    getContentTable(): HTMLElement;
    getWorkCellElements(): Element[];
    getIndexOfDate(collection: Date[], date: Date): number;
    isAllDayCell(td: Element): boolean;
    getDateFromElement(td: Element): Date;
    getCellTemplate(): Function;
    getDateHeaderTemplate(): Function;
    getAppointmentTemplate(): Function;
    getEventTooltipTemplate(): Function;
    getEditorTemplate(): Function;
    private onDocumentClick(args);
    private onScheduleResize(args);
    private templateParser(template);
    /**
     * Unbinding events from the element on widget destroy.
     * @hidden
     */
    private unwireEvents();
    /**
     * Core method to return the component name.
     * @private
     */
    getModuleName(): string;
    /**
     * Returns the properties to be maintained in the persisted state.
     * @private
     */
    protected getPersistData(): string;
    /**
     * Called internally, if any of the property value changed.
     * @private
     */
    onPropertyChanged(newProp: ScheduleModel, oldProp: ScheduleModel): void;
    private extendedPropertyChange(prop, newProp, oldProp);
    private onEventSettingsPropertyChanged(newProp, oldProp);
    /**
     * Sets different working hours on the required working days by accepting the required start and end time as well as the date collection
     *  as its parameters.
     * @method setWorkHours
     * @param {date} dates Collection of dates on which the given start and end hour range needs to be applied.
     * @param {string} start Defines the work start hour.
     * @param {string} end Defines the work end hour.
     * @returns {void}
     */
    setWorkHours(dates: Date[], start: string, end: string): void;
    /**
     * Retrieves the start and end time information of the specific cell element.
     * @method getCellDetails
     * @param  {Element} td The cell element whose start and end time details are to be retrieved.
     * @returns {CellClickEventArgs} Object An object holding the startTime, endTime and all-day information along with the target HTML
     *  element will be returned.
     */
    getCellDetails(td: Element): CellClickEventArgs;
    /**
     * Scrolls the Schedule content area to the specified time.
     * @method scrollTo
     * @param {string} hour Accepts the time value in the skeleton format of 'Hm'.
     * @returns {void}
     */
    scrollTo(hour: string): void;
    /**
     * Adds the newly created event into the Schedule dataSource.
     * @method addEvent
     * @param {Object | Object[]} data Single or collection of event objects to be added into Schedule.
     * @returns {void}
     */
    addEvent(data: Object | Object[]): void;
    /**
     * Updates the changes made in the event object by passing it as an parameter into the dataSource.
     * @method saveEvent
     * @param {[key: string]: Object} data Single or collection of event objects to be saved into Schedule.
     * @param {CurrentAction} currentAction Denotes the action that takes place either for editing occurrence or series.
     *  The valid current action names are `EditOccurrence` or `EditSeries`.
     * @returns {void}
     */
    saveEvent(data: {
        [key: string]: Object;
    } | {
        [key: string]: Object;
    }[], currentAction?: CurrentAction): void;
    /**
     * Deletes the events based on the provided ID or event collection in the argument list.
     * @method deleteEvent
     * @param {{[key: string]: Object}} id Single event objects to be removed from the Schedule.
     * @param {{[key: string]: Object }[]} id Collection of event objects to be removed from the Schedule.
     * @param {string | number} id Accepts the ID of the event object which needs to be removed from the Schedule.
     * @param {CurrentAction} currentAction Denotes the delete action that takes place either on occurrence or series events.
     *  The valid current action names are `Delete`, `DeleteOccurrence` or `DeleteSeries`.
     * @returns {void}
     */
    deleteEvent(id: string | number | {
        [key: string]: Object;
    } | {
        [key: string]: Object;
    }[], currentAction?: CurrentAction): void;
    /**
     * Retrieves the entire collection of events bound to the Schedule.
     * @method getEvents
     * @returns {Object[]} Returns the collection of event objects from the Schedule.
     */
    getEvents(): Object[];
    /**
     * Retrieves the occurrences of a single recurrence event based on the provided parent ID.
     * @method getOccurrencesByID
     * @param {number} eventID ID of the parent recurrence data from which the occurrences are fetched.
     * @returns {Object[]} Returns the collection of occurrence event objects.
     */
    getOccurrencesByID(eventID: number): Object[];
    /**
     * Retrieves all the occurrences that lies between the specific start and end time range.
     * @method getOccurrencesByRange
     * @param {Date} startTime Denotes the start time range.
     * @param {Date} endTime Denotes the end time range.
     * @returns {Object[]} Returns the collection of occurrence event objects that lies between the provided start and end time.
     */
    getOccurrencesByRange(startTime: Date, endTime: Date): Object[];
    /**
     * Retrieves the events that lies on the current date range of the active view of Schedule.
     * @method getCurrentViewEvents
     * @returns {Object[]} Returns the collection of events.
     */
    getCurrentViewEvents(): Object[];
    /**
     * Refreshes the event dataSource. This method may be useful when the events alone in the Schedule needs to be re-rendered.
     * @method refreshEvents
     * @returns {void}
     */
    refreshEvents(): void;
    /**
     * To get the appointment object from element.
     * @method getEventDetails
     * @param {Element} element Denotes the event UI element on the Schedule.
     * @returns {Object} Returns the event details.
     */
    getEventDetails(element: Element): Object;
    /**
     * To check whether the given time range slots are available for event creation or already occupied by other events.
     * @method isSlotAvailable
     * @param {Date} startTime Denotes the start time of the slot.
     * @param {Date} endTime Denotes the end time of the slot.
     * @returns {boolean} Returns true, if the slot that lies in the provided time range does not contain any other events.
     */
    isSlotAvailable(startTime: Date, endTime: Date): boolean;
    /**
     * To manually open the event editor on specific time or on certain events.
     * @method openEditor
     * @param {Object} data It can be either cell data or event data.
     * @param {CurrentAction} action Defines the action for which the editor needs to be opened such as either for new event creation or
     *  for editing of existing events. The applicable action names that can be used here are `Add`, `Save`, `EditOccurrence`
     *  and `EditSeries`.
     * @returns {void}
     */
    openEditor(data: Object, action: CurrentAction): void;
    /**
     * This method has been added to adjust the size of the outer event wrapper class that holds the collection of events,
     *  while trying to set manual height and width to the Schedule cells.
     * @method adjustEventWrapper
     * @returns {void}
     */
    adjustEventWrapper(): void;
    /**
     * Destroys the Schedule component.
     * @method destroy
     * @return {void}
     */
    destroy(): void;
}
/**
 * types
 */
export  type View = 'Day' | 'Week' | 'WorkWeek' | 'Month' | 'Agenda' | 'MonthAgenda';
export  type CurrentAction = 'Add' | 'Save' | 'Delete' | 'DeleteOccurrence' | 'DeleteSeries' | 'EditOccurrence' | 'EditSeries';
export  type ReturnType = {
    result: Object[];
    count: number;
    aggregates?: Object;
};
export  type PopupType = 'Editor' | 'EventContainer' | 'QuickInfo' | 'RecurrenceAlert' | 'DeleteAlert' | 'ViewEventInfo' | 'EditEventInfo' | 'ValidationAlert';
/**
 * Schedule common utilities
 */
export  const WEEK_LENGTH: number;
export  const MS_PER_DAY: number;
export  const MS_PER_MINUTE: number;
export  function getWeekFirstDate(date1: Date, firstDayOfWeek: number): Date;
export  function firstDateOfMonth(date: Date): Date;
export  function lastDateOfMonth(dt: Date): Date;
export  function getWeekNumber(dt: Date): number;
export  function setTime(date: Date, time: number): Date;
export  function resetTime(date: Date): Date;
export  function getDateInMs(date: Date): number;
export  function addDays(date: Date, i: number): Date;
export  function addMonths(date: Date, i: number): Date;
export  function addYears(date: Date, i: number): Date;
export  function getStartEndHours(date: Date, startHour: Date, endHour: Date): {
    [key: string]: Date;
};
export  function getMaxDays(d: Date): number;
export  function getDaysCount(startDate: number, endDate: number): number;
/** @hidden */
export  function getScrollBarWidth(): number;
/**
 * AgendaBase for event rendering
 */
export  class AgendaBase {
    parent: Schedule;
    l10n: base.L10n;
    /**
     * Constructor for AgendaBase
     */
    constructor(parent: Schedule);
    createAgendaContentElement(type: string, listData: {
        [key: string]: Object;
    }[], aTd: Element): Element;
    createAppointment(event: {
        [key: string]: Object;
    }): HTMLElement[];
    processAgendaEvents(events: Object[]): Object[];
    wireEventActions(): void;
}
/**
 * EventBase for appointment rendering
 */
export  class EventBase {
    parent: Schedule;
    timezone: Timezone;
    slots: Object[];
    /**
     * Constructor for EventBase
     */
    constructor(parent: Schedule);
    processData(events: {
        [key: string]: Object;
    }[], timeZonePropChanged?: boolean, oldTimezone?: string): Object[];
    timezonePropertyChange(oldTimezone: string): void;
    private processTimezoneChange(event, oldTimezone);
    private processTimezone(event);
    filterEvents(startDate: Date, endDate: Date, collection?: Object[]): Object[];
    sortByTime(appointments: Object[]): Object[];
    sortByDateTime(appointments: Object[]): Object[];
    getSmallestMissingNumber(array: Object[]): number;
    splitEventByDay(event: {
        [key: string]: Object;
    }): Object[];
    splitEvent(event: {
        [key: string]: Object;
    }, dateRender: Date[]): {
        [key: string]: Object;
    }[];
    private cloneEventObject(event, start, end, count, isLeft, isRight);
    private dateInRange(date, start, end);
    getSelectedEventElements(target: Element): Element[];
    getSelectedEvents(): EventClickArgs;
    removeSelectedAppointmentClass(): void;
    addSelectedAppointments(cells: Element[], focusCell?: Element): void;
    getSelectedAppointments(): Element[];
    focusElement(): void;
    selectWorkCellByTime(eventsData: Object[]): Element;
    isAllDayAppointment(event: {
        [key: string]: Object;
    }): boolean;
    addEventListener(): void;
    private appointmentBorderRemove(event);
    wireAppointmentEvents(element: Element): void;
    private eventClick(eventData);
    eventDoubleClick(e: Event): void;
    getEventByGuid(guid: string): Object;
    generateGuid(): string;
    getEventMaxId(): number;
    private activeEventData(eventData);
    generateOccurrence(event: {
        [key: string]: Object;
    }, viewDate?: Date): Object[];
    getRecurrenceEvent(eventData: {
        [key: string]: Object;
    }): {
        [key: string]: Object;
    };
    getOccurrencesByID(id: number): Object[];
    getOccurrencesByRange(startTime: Date, endTime: Date): Object[];
}
/**
 * Month view events render
 */
export  class MonthEvent extends EventBase {
    private element;
    private fields;
    private dateRender;
    private renderedEvents;
    private eventHeight;
    private monthHeaderHeight;
    private workCells;
    private cellWidth;
    private cellHeight;
    /**
     * Constructor for month events
     */
    constructor(parent: Schedule);
    renderAppointments(): void;
    private getElementHeightFromClass(container, elementClass);
    private getOuterHeight(element);
    private createAppointmentElement(record);
    private renderAppointmentMonth(event);
    private getIndex(record, date);
    private moreIndicatorClick(event);
}
/**
 * Vertical view appointment rendering
 */
export  class AppointmentRendering extends EventBase {
    private dateRender;
    private renderedEvents;
    private renderedAllDayEvents;
    private overlapEvents;
    private moreEvents;
    private overlapList;
    private minorSlotCount;
    private majorSlot;
    private allDayLevel;
    private startHour;
    private endHour;
    private element;
    private allDayElement;
    private animation;
    private fields;
    private cellHeight;
    /**
     * Constructor for vertical view
     */
    constructor(parent: Schedule);
    renderAppointments(): void;
    private createAppointmentElement(record, isAllDay, data);
    private createMoreIndicator(allDayRow, count, currentDay);
    private renderSpannedIcon(element, spanEvent, isAllDay);
    private isSpannedEvent(record, day);
    private renderAllDayEvents(event);
    private renderVerticalEvents(eventObj, day);
    private getTopValue(date, day);
    private getAppointmentHeight(cellHeight, startDate, endDate);
    private getOverlapIndex(record, day, isAllDay);
    private adjustOverlapElements(args);
    private setAllDayRowHeight(height);
    private addOrRemoveClass();
    private getEventHeight();
    private rowExpandCollapse(event);
    private animationUiUpdate();
}
/**
 * Schedule component exported items
 */
/**
 * Interface for a class EventSettings
 */
export interface EventSettingsModel {
    /**
     * It accepts either the string or HTMLElement as template design content and parse it appropriately before displaying
     *  it onto the event background. All the event fields mapped to Schedule from dataSource can be accessed within this template code.
     * @default null
     */
    template?: string;
    /**
     * With this property, the event data will be bound to Schedule.
     * The event data can be passed either as an array of JavaScript objects, 
     * or else can create an instance of [`data.DataManager`](http://ej2.syncfusion.com/documentation/data/api-dataManager.html)
     * in case of processing remote data and can be assigned to the `dataSource` property. 
     * With the remote data assigned to dataSource, check the available
     *  [adaptors](http://ej2.syncfusion.com/documentation/data/adaptors.html) to customize the data processing. 
     * @default []    
     */
    dataSource?: Object[] | data.DataManager;
    /**
     * Defines the external [`query`](http://ej2.syncfusion.com/documentation/data/api-query.html) 
     * that will be executed along with the data processing.    
     * @default null    
     */
    query?: data.Query;
    /**
     * Defines the collection of default event fields to be bind to the Schedule. 
     * @default null    
     */
    fields?: FieldModel;
    /**
     * When set to `true` will display the normal tooltip over the events with its subject, location, start and end time.
     * @default false
     */
    enableTooltip?: boolean;
    /**
     * It accepts either the string or HTMLElement as template design content and parse it appropriately before displaying it onto tooltip.
     *  All the event fields mapped with Schedule dataSource can be accessed within this template code.
     * @default null
     */
    tooltipTemplate?: string;
}
/**
 * Holds the configuration of event related options and dataSource binding to Schedule.
 */
export  class EventSettings extends base.ChildProperty<EventSettings> {
    /**
     * It accepts either the string or HTMLElement as template design content and parse it appropriately before displaying
     *  it onto the event background. All the event fields mapped to Schedule from dataSource can be accessed within this template code.
     * @default null
     */
    template: string;
    /**
     * With this property, the event data will be bound to Schedule.
     * The event data can be passed either as an array of JavaScript objects,
     * or else can create an instance of [`data.DataManager`](http://ej2.syncfusion.com/documentation/data/api-dataManager.html)
     * in case of processing remote data and can be assigned to the `dataSource` property.
     * With the remote data assigned to dataSource, check the available
     *  [adaptors](http://ej2.syncfusion.com/documentation/data/adaptors.html) to customize the data processing.
     * @default []
     */
    dataSource: Object[] | data.DataManager;
    /**
     * Defines the external [`query`](http://ej2.syncfusion.com/documentation/data/api-query.html)
     * that will be executed along with the data processing.
     * @default null
     */
    query: data.Query;
    /**
     * Defines the collection of default event fields to be bind to the Schedule.
     * @default null
     */
    fields: FieldModel;
    /**
     * When set to `true` will display the normal tooltip over the events with its subject, location, start and end time.
     * @default false
     */
    enableTooltip: boolean;
    /**
     * It accepts either the string or HTMLElement as template design content and parse it appropriately before displaying it onto tooltip.
     *  All the event fields mapped with Schedule dataSource can be accessed within this template code.
     * @default null
     */
    tooltipTemplate: string;
}
/**
 * Interface for a class FieldOptions
 */
export interface FieldOptionsModel {
    /**
     * It denotes the field name to be mapped from the dataSource for every event fields.
     * @default null
     */
    name?: string;
    /**
     * It assigns specific default value to the fields, when no values are provided to those fields from dataSource.
     * @default null
     */
    default?: string;
    /**
     * It is mainly for defining the validation rules to be applied on the event fields within the event editor.
     * @default {}
     */
    validation?: Object;
}
/**
 * Configuration of every event field related options on Schedule.
 */
export  class FieldOptions {
    /**
     * It denotes the field name to be mapped from the dataSource for every event fields.
     * @default null
     */
    name: string;
    /**
     * It assigns specific default value to the fields, when no values are provided to those fields from dataSource.
     * @default null
     */
    default: string;
    /**
     * It is mainly for defining the validation rules to be applied on the event fields within the event editor.
     * @default {}
     */
    validation: Object;
}
/**
 * Interface for a class Field
 */
export interface FieldModel {
    /**
     * The `id` field needs to be defined as mandatory, when the Schedule is bound to remote data and
     *  it is optional, if the same is bound with JSON data. This field usually assigns ID value to each of the events.
     * @default null
     */
    id?: FieldOptionsModel;
    /**
     * The `subject` field is optional, and usually assigns the subject text to each of the events.
     * @default null
     */
    subject?: FieldOptionsModel;
    /**
     * The `startTime` field defines the start time of an event and it is mandatory to provide it for any of the valid event objects.
     * @default null
     */
    startTime?: FieldOptionsModel;
    /**
     * The `endTime` field defines the end time of an event and it is mandatory to provide the end time for any of the valid event objects.
     * @default null
     */
    endTime?: FieldOptionsModel;
    /**
     * It maps the `startTimezone` field from the dataSource and usually accepts the valid IANA timezone names.
     *  It is assumed that the value provided for this field is taken into consideration while processing
     *  the `startTime` field. When this field is not mapped with any timezone names,
     *  then the events will be processed based on the timezone assigned to the Schedule.
     * @default null
     */
    startTimezone?: FieldOptionsModel;
    /**
     * It maps the `endTimezone` field from the dataSource and usually accepts the valid IANA timezone names.
     *  It is assumed that the value provided for this field is taken into consideration while processing the `endTime` field.
     *  When this field is not mapped with any timezone names, then the events will be processed based on the timezone assigned
     *  to the Schedule.
     * @default null
     */
    endTimezone?: FieldOptionsModel;
    /**
     * It maps the `location` field from the dataSource and the location field value will be displayed over
     *  events, while given it for an event object.
     * @default null
     */
    location?: FieldOptionsModel;
    /**
     * It maps the `description` field from the dataSource and denotes the event description which is optional. 
     * @default null
     */
    description?: FieldOptionsModel;
    /**
     * The `isAllDay` field is mapped from the dataSource and is used to denote whether an event is created 
     * for an entire day or for specific time alone. 
     * @default null
     */
    isAllDay?: FieldOptionsModel;
    /**
     * It maps the `recurrenceID` field from dataSource and usually holds the ID value of the parent
     *  recurrence event. It is applicable only for the edited occurrence events.
     * @default null
     */
    recurrenceID?: FieldOptionsModel;
    /**
     * It maps the `recurrenceRule` field from dataSource and is used to uniquely identify whether the
     *  event belongs to a recurring event type or normal ones.
     * @default null
     */
    recurrenceRule?: FieldOptionsModel;
    /**
     * It maps the `recurrenceException` field from dataSource and is used to hold the exception dates
     *  which needs to be excluded from recurring type.
     * @default null
     */
    recurrenceException?: FieldOptionsModel;
}
/**
 * A Class that holds the collection of event fields that requires to be mapped with the dataSource
 * fields along with its available configuration settings. Each field in it accepts both string and Object
 *  data type. When each of the field is assigned with simple `string` value, it is assumed that the dataSource field
 *  name is mapped with it. If the `object` type is defined on each fields, then the validation related settings and mapping of
 *  those fields with dataSource can be given altogether within it.
 */
export  class Field extends base.ChildProperty<Field> {
    /**
     * The `id` field needs to be defined as mandatory, when the Schedule is bound to remote data and
     *  it is optional, if the same is bound with JSON data. This field usually assigns ID value to each of the events.
     * @default null
     */
    id: FieldOptionsModel;
    /**
     * The `subject` field is optional, and usually assigns the subject text to each of the events.
     * @default null
     */
    subject: FieldOptionsModel;
    /**
     * The `startTime` field defines the start time of an event and it is mandatory to provide it for any of the valid event objects.
     * @default null
     */
    startTime: FieldOptionsModel;
    /**
     * The `endTime` field defines the end time of an event and it is mandatory to provide the end time for any of the valid event objects.
     * @default null
     */
    endTime: FieldOptionsModel;
    /**
     * It maps the `startTimezone` field from the dataSource and usually accepts the valid IANA timezone names.
     *  It is assumed that the value provided for this field is taken into consideration while processing
     *  the `startTime` field. When this field is not mapped with any timezone names,
     *  then the events will be processed based on the timezone assigned to the Schedule.
     * @default null
     */
    startTimezone: FieldOptionsModel;
    /**
     * It maps the `endTimezone` field from the dataSource and usually accepts the valid IANA timezone names.
     *  It is assumed that the value provided for this field is taken into consideration while processing the `endTime` field.
     *  When this field is not mapped with any timezone names, then the events will be processed based on the timezone assigned
     *  to the Schedule.
     * @default null
     */
    endTimezone: FieldOptionsModel;
    /**
     * It maps the `location` field from the dataSource and the location field value will be displayed over
     *  events, while given it for an event object.
     * @default null
     */
    location: FieldOptionsModel;
    /**
     * It maps the `description` field from the dataSource and denotes the event description which is optional.
     * @default null
     */
    description: FieldOptionsModel;
    /**
     * The `isAllDay` field is mapped from the dataSource and is used to denote whether an event is created
     * for an entire day or for specific time alone.
     * @default null
     */
    isAllDay: FieldOptionsModel;
    /**
     * It maps the `recurrenceID` field from dataSource and usually holds the ID value of the parent
     *  recurrence event. It is applicable only for the edited occurrence events.
     * @default null
     */
    recurrenceID: FieldOptionsModel;
    /**
     * It maps the `recurrenceRule` field from dataSource and is used to uniquely identify whether the
     *  event belongs to a recurring event type or normal ones.
     * @default null
     */
    recurrenceRule: FieldOptionsModel;
    /**
     * It maps the `recurrenceException` field from dataSource and is used to hold the exception dates
     *  which needs to be excluded from recurring type.
     * @default null
     */
    recurrenceException: FieldOptionsModel;
}
/**
 * Export model files
 */
/**
 * Interface for a class Views
 */
export interface ViewsModel {
    /**
     * It accepts the schedule view name, based on which we can define with its related properties in a single object.
     * @default null
     */
    option?: View;
    /**
     * To denote whether the view name given on the `option` is active or not. 
     * It acts similar to the `currentView` property and defines the active view of Schedule.
     * @default false
     */
    isSelected?: boolean;
    /**
     * By default, Schedule follows the date-format as per the default culture assigned to it. It is also possible to manually set
     *  specific date format by using the `dateFormat` property. The format of the date range label in the header bar depends on
     *  the `dateFormat` value or else based on the locale assigned to the Schedule.
     *  It gets applied only to the view objects on which it is defined.
     * @default null
     */
    dateFormat?: string;
    /**
     * When set to `true`, displays a quick popup with cell or event details on single clicking over the cells or on events.
     *  By default, it is set to `true`. It gets applied only to the view objects on which it is defined.
     * @default false
     */
    readonly?: boolean;
    /**
     * It is used to specify the starting hour, from which the Schedule starts to display.
     *  It accepts the time string in a short skeleton format and also, hides the time beyond the specified start time.
     * @default '00:00'
     */
    startHour?: string;
    /**
     * It is used to specify the end hour, at which the Schedule ends. It too accepts the time string in a short skeleton format.
     * @default '24:00'
     */
    endHour?: string;
    /**
     * It is used to allow or disallow the virtual scrolling functionality on Agenda View. This is applicable only on Agenda view.
     * @default true
     */
    allowVirtualScrolling?: boolean;
    /**
     * It accepts either the string or HTMLElement as template design content and parse it appropriately before displaying it onto the
     *  date header cells. The field that can be accessed via this template is `date`.
     *  It gets applied only to the view objects on which it is defined.
     * @default null
     */
    dateHeaderTemplate?: string;
    /**
     * The template option which is used to render the customized work cells on the Schedule. Here, the
     *  template accepts either the string or HTMLElement as template design and then the parsed design is displayed onto the work cells.
     *  The field accessible via template is `date`. It gets applied only to the view objects on which it is defined.
     * @default null
     */
    cellTemplate?: string;
    /**
     * It accepts either the string or HTMLElement as template design content and parse it appropriately before displaying it onto
     *  the event background. All the event fields mapped to Schedule from dataSource can be accessed within this template code.
     *  It is similar to that of the `template` option available within the `eventSettings` property,
     *  whereas it will get applied only on the events of the view to which it is currently being defined.
     * @default null
     */
    eventTemplate?: string;
    /**
     * When set to `false`, it hides the weekend days of a week from the Schedule. 
     * The days which are not defined in the working days collection are usually treated as weekend days.
     * Note: By default, this option is not applicable on `Work Week` view.
     * For example, if the working days are defined as [1, 2, 3, 4], then the remaining days of that week will be considered as the
     *  weekend days and will be hidden on all the views.
     * @default true
     */
    showWeekend?: boolean;
    /**
     * It is used to set the working days on Schedule. The only days that are defined in this collection will be rendered on the
     *  `workWeek` view whereas on other views, it will display all the usual days and simply highlights the working days with different
     *  shade.
     * @default '0'
     */
    workDays?: number[];
}
/**
 * Configuration of view-specific settings on Schedule.
 */
export  class Views extends base.ChildProperty<Views> {
    /**
     * It accepts the schedule view name, based on which we can define with its related properties in a single object.
     * @default null
     */
    option: View;
    /**
     * To denote whether the view name given on the `option` is active or not.
     * It acts similar to the `currentView` property and defines the active view of Schedule.
     * @default false
     */
    isSelected: boolean;
    /**
     * By default, Schedule follows the date-format as per the default culture assigned to it. It is also possible to manually set
     *  specific date format by using the `dateFormat` property. The format of the date range label in the header bar depends on
     *  the `dateFormat` value or else based on the locale assigned to the Schedule.
     *  It gets applied only to the view objects on which it is defined.
     * @default null
     */
    dateFormat: string;
    /**
     * When set to `true`, displays a quick popup with cell or event details on single clicking over the cells or on events.
     *  By default, it is set to `true`. It gets applied only to the view objects on which it is defined.
     * @default false
     */
    readonly: boolean;
    /**
     * It is used to specify the starting hour, from which the Schedule starts to display.
     *  It accepts the time string in a short skeleton format and also, hides the time beyond the specified start time.
     * @default '00:00'
     */
    startHour: string;
    /**
     * It is used to specify the end hour, at which the Schedule ends. It too accepts the time string in a short skeleton format.
     * @default '24:00'
     */
    endHour: string;
    /**
     * It is used to allow or disallow the virtual scrolling functionality on Agenda View. This is applicable only on Agenda view.
     * @default true
     */
    allowVirtualScrolling: boolean;
    /**
     * It accepts either the string or HTMLElement as template design content and parse it appropriately before displaying it onto the
     *  date header cells. The field that can be accessed via this template is `date`.
     *  It gets applied only to the view objects on which it is defined.
     * @default null
     */
    dateHeaderTemplate: string;
    /**
     * The template option which is used to render the customized work cells on the Schedule. Here, the
     *  template accepts either the string or HTMLElement as template design and then the parsed design is displayed onto the work cells.
     *  The field accessible via template is `date`. It gets applied only to the view objects on which it is defined.
     * @default null
     */
    cellTemplate: string;
    /**
     * It accepts either the string or HTMLElement as template design content and parse it appropriately before displaying it onto
     *  the event background. All the event fields mapped to Schedule from dataSource can be accessed within this template code.
     *  It is similar to that of the `template` option available within the `eventSettings` property,
     *  whereas it will get applied only on the events of the view to which it is currently being defined.
     * @default null
     */
    eventTemplate: string;
    /**
     * When set to `false`, it hides the weekend days of a week from the Schedule.
     * The days which are not defined in the working days collection are usually treated as weekend days.
     * Note: By default, this option is not applicable on `Work Week` view.
     * For example, if the working days are defined as [1, 2, 3, 4], then the remaining days of that week will be considered as the
     *  weekend days and will be hidden on all the views.
     * @default true
     */
    showWeekend: boolean;
    /**
     * It is used to set the working days on Schedule. The only days that are defined in this collection will be rendered on the
     *  `workWeek` view whereas on other views, it will display all the usual days and simply highlights the working days with different
     *  shade.
     * @default '0'
     */
    workDays: number[];
}
/**
 * Interface for a class WorkHours
 */
export interface WorkHoursModel {
    /**
     * When set to `true`, highlights the cells of working hour range with an active color.
     * @default true
     */
    highlight?: boolean;
    /**
     * It accepts the time string in short skeleton format `Hm` and usually denotes the start of the working hour range.  
     * @default '09:00'
     */
    start?: string;
    /**
     * It accepts the time string in short skeleton format `Hm` and usually denotes the end of the working hour range.
     * @default '18:00'
     */
    end?: string;
}
/**
 * Configuration of options related to working hours on Schedule.
 */
export  class WorkHours extends base.ChildProperty<WorkHours> {
    /**
     * When set to `true`, highlights the cells of working hour range with an active color.
     * @default true
     */
    highlight: boolean;
    /**
     * It accepts the time string in short skeleton format `Hm` and usually denotes the start of the working hour range.
     * @default '09:00'
     */
    start: string;
    /**
     * It accepts the time string in short skeleton format `Hm` and usually denotes the end of the working hour range.
     * @default '18:00'
     */
    end: string;
}
/**
 * Tooltip on appointments in Schedule
 */
export  class EventTooltip {
    private parent;
    private tooltipObj;
    private l10n;
    constructor(parent: Schedule);
    private onBeforeRender(args);
    close(): void;
    /**
     * To destroy the event tooltip.
     * @return {void}
     * @private
     */
    destroy(): void;
}
/**
 * Event editor window
 */
export  class EventWindow {
    parent: Schedule;
    dialogObject: popups.Dialog;
    private element;
    private fields;
    private l10n;
    private eventData;
    private fieldValidator;
    private recurrenceEditor;
    private repeatDialogObject;
    private repeatTempRule;
    private repeatRule;
    private repeatStatus;
    private repeatStartDate;
    private cellClickAction;
    private timezone;
    /**
     * Constructor for event window
     */
    constructor(parent: Schedule);
    private renderEventWindow();
    openEditor(data: Object, type: CurrentAction): void;
    setDialogContent(): void;
    private onBeforeOpen(args);
    private onBeforeClose(args);
    private getEventWindowContent();
    private getDefaultEventWindowContent();
    private createRecurrenceEditor(parentDiv);
    private createDivElement(className);
    private createInputElement(className, fieldName, type?);
    private renderDateTimePicker(value, changeEvent?);
    private onTimeChange(args);
    private renderDropDown(value);
    private onTimezoneChange();
    private renderCheckBox(value);
    private renderTextBox(value);
    private getFieldName(name);
    private onChange(args);
    private renderRepeatDialog();
    private loadRecurrenceEditor();
    private onRepeatChange(state);
    private repeatSaveDialog();
    private closeRepeatDialog();
    private repeatCancelDialog();
    private repeatOpenDialog();
    private onCellDetailsUpdate(args);
    private applyFormValidation();
    private showDetails(eventData);
    private onAllDayChange(allDayStatus);
    private updateDateTime(allDayStatus, startObj, endObj);
    private getFormat(formatType);
    private onEventDetailsUpdate(eventObj);
    private renderRecurrenceEditor();
    private updateRepeatLabel(repeatRule);
    private dialogClose(args);
    private timezoneChangeStyle(value);
    private resetFormFields();
    private eventSave();
    private getEventIdFromForm();
    private getFormElements();
    private getValueFromElement(element);
    private setValueToElement(element, value);
    private setDefaultValueToElement(element);
    private getInstance(className);
    private eventDelete(args);
    getRecurrenceEditorInstance(): RecurrenceEditor;
    /**
     * To destroy the event window.
     * @return {void}
     * @private
     */
    destroy(): void;
}
/**
 * Appointment window field validation
 */
export  class FieldValidator {
    private parent;
    formObj: inputs.FormValidator;
    constructor(parent: Schedule);
    renderFormValidator(form: HTMLFormElement, rules: {
        [key: string]: Object;
    }): void;
    private validationComplete(args);
    private errorPlacement(inputElement, error);
    private createTooltip(element, error, name, display);
    destroyToolTip(): void;
    /**
     * @hidden
     */
    destroyForm(): void;
}
/**
 * Quick Popups interactions
 */
export  class QuickPopups {
    private l10n;
    private flatButton;
    private primaryButton;
    private parent;
    private crudAction;
    private selectedEventPopup;
    private multipleEventPopup;
    private isMultipleEventSelect;
    quickDialog: popups.Dialog;
    quickPopup: popups.Tooltip;
    morePopup: popups.Popup;
    eventPopup: popups.Popup;
    private fieldValidator;
    /**
     * Constructor for QuickPopups
     */
    constructor(parent: Schedule);
    render(): void;
    private renderQuickPopup();
    private renderQuickDialog();
    private renderMoreEventPopup();
    private dayNavigationClick(e);
    renderEventPopup(): void;
    openRecurrenceAlert(): void;
    openDeleteAlert(): void;
    openValidationError(type: string): void;
    private showQuickDialog(popupType);
    private createMoreEventList(events);
    eventHold(args: Event): void;
    private cellClick(args);
    private applyFormValidation();
    private eventClick(events);
    private deviceEventClick(events);
    private showEventPopup(popupType);
    private getFormattedString(eventData, type);
    moreEventClick(data: EventClickArgs): void;
    private saveClick();
    private detailsClick();
    private editClick(event);
    deleteClick(): void;
    private closeClick();
    private dialogButtonClick(event);
    private selectedEventDialog(target);
    private getTimezone(event);
    private getTimeDetails(event);
    private getDateFormat(date, formatString);
    private afterQuickPopupOpen(args);
    private beforeQuickPopupOpen(args);
    private getDataFromTarget(target);
    private beforeQuickPopupClose(args);
    private beforeQuickDialogClose(args);
    private keyPress(event);
    private afterMorePopupOpen(event);
    private afterMorePopupClose(event);
    private afterQuickPopupClose(args);
    private quickDialogClass(action);
    private documentClick(e);
    onClosePopup(): void;
    addEventListener(): void;
    destroy(): void;
}
/**
 * agenda view
 */
export  class Agenda extends ViewBase implements IRenderer {
    viewClass: string;
    isInverseTableSelect: boolean;
    agendaDates: {
        [key: string]: Date;
    };
    virtualScrollTop: number;
    minDate: Date;
    maxDate: Date;
    agendaBase: AgendaBase;
    /**
     * Constructor for agenda view
     */
    constructor(parent: Schedule);
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    renderLayout(): void;
    private eventLoad(args);
    renderContent(tBody: Element, agendaDate: Date): void;
    private renderEmptyContent(tBody, agendaDate);
    private createTableRowElement(date, type);
    private createDateHeaderElement(date);
    private agendaScrolling(event);
    private virtualScrolling(event);
    private getElementFromScrollerPosition(event, direction?);
    private updateHeaderText(date?);
    private getPreviousNextDate(date, type);
    private appointmentFiltering(startDate?, endDate?);
    getStartDateFromEndDate(endDate: Date): Date;
    getEndDateFromStartDate(startDate: Date): Date;
    getNextPreviousDate(type: string): Date;
    startDate(): Date;
    endDate(): Date;
    getDateRangeText(date?: Date): string;
    dayNavigationClick(e: Event): void;
    private wireEvents();
    private unWireEvents();
    addEventListener(): void;
    removeEventListener(): void;
    private onAgendaScrollUiUpdate(args);
    /**
     * To destroy the agenda.
     * @return {void}
     * @private
     */
    destroy(): void;
}
/**
 * day view
 */
export  class Day extends VerticalView {
    viewClass: string;
    /**
     * Constructor for day view
     */
    constructor(parent: Schedule);
    getNextPreviousDate(type: string): Date;
    getDateRangeText(): string;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * Header module
 */
export  class HeaderRenderer {
    element: HTMLElement;
    private parent;
    private l10n;
    private toolbarObj;
    private headerPopup;
    private headerCalendar;
    /**
     * Constructor for render module
     */
    constructor(parent: Schedule);
    addEventListener(): void;
    removeEventListener(): void;
    private closeHeaderPopup(e);
    /** @hidden */
    hideHeaderPopup(): void;
    renderHeader(): void;
    private renderToolbar();
    updateItems(): void;
    getPopUpRelativeElement(): HTMLElement;
    setDayOfWeek(index: number): void;
    setCalendarDate(date: Date): void;
    getCalendarView(): calendars.CalendarView;
    setCalendarView(): void;
    setRtl(isRtl: boolean): void;
    updateActiveView(): void;
    updateDateRange(text?: string): void;
    private getDateRangeText();
    private getItems();
    private getItemObject(viewName);
    private renderHeaderPopup();
    private calendarChange(args);
    private toolbarClickHandler(args);
    getHeaderElement(): HTMLElement;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the headerbar.
     * @return {void}
     * @private
     */
    destroy(): void;
}
/**
 * month agenda view
 */
export  class MonthAgenda extends Month {
    dayNameFormat: string;
    viewClass: string;
    agendaDates: {
        [key: string]: Date;
    };
    agendaBase: AgendaBase;
    /**
     * Constructor
     */
    constructor(parent: Schedule);
    renderAppointmentContainer(): void;
    getDayNameFormat(): string;
    private setEventWrapperHeight();
    onDataReady(args: NotifyEventArgs): void;
    onCellClick(event: CellClickEventArgs): void;
    private onEventRender(events);
    private appointmentFiltering(date);
    private clearElements();
    private appendAppContainer(appWrap);
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * month view
 */
export  class Month extends ViewBase implements IRenderer {
    colLevels: TdData[][];
    dayNameFormat: string;
    viewClass: string;
    isInverseTableSelect: boolean;
    private workCellAction;
    /**
     * Constructor for month view
     */
    constructor(parent: Schedule);
    addEventListener(): void;
    removeEventListener(): void;
    onDataReady(args: NotifyEventArgs): void;
    onCellClick(event: CellClickEventArgs): void;
    private onContentScroll(e);
    private onScrollUiUpdate(args);
    private generateColLevels();
    getDayNameFormat(): string;
    renderLayout(type: string): void;
    private wireCellEvents(element);
    renderHeader(): void;
    renderContent(): void;
    renderAppointmentContainer(): void;
    private renderDatesHeader();
    private createHeaderCell(td);
    private isOtherMonth(date);
    private renderContentArea();
    getDatesHeaderElement(): HTMLElement;
    getContentAreaElement(): HTMLElement;
    private renderDateHeaderElement(data, ntd);
    getRenderDates(): void;
    getNextPreviousDate(type: string): Date;
    getEndDateFromStartDate(start: Date): Date;
    getDateRangeText(): string;
    getLabelText(view: string): string;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the month.
     * @return {void}
     * @private
     */
    destroy(): void;
}
/**
 * Schedule DOM rendering
 */
export  class Render {
    parent: Schedule;
    /**
     * Constructor for render
     */
    constructor(parent: Schedule);
    render(viewName: View): void;
    private initializeLayout(viewName);
    updateLabelText(view: string): void;
    refreshDataManager(): void;
    private dataManagerSuccess(e);
    private dataManagerFailure(e);
}
/**
 * vertical view
 */
export  class VerticalView extends ViewBase implements IRenderer {
    colLevels: TdData[][];
    currentTimeIndicatorTimer: number;
    currentDateIndex: number;
    minorSlotCount: number;
    majorSlot: number;
    viewClass: string;
    isInverseTableSelect: boolean;
    private workCellAction;
    /**
     * Constructor for vertical view
     */
    constructor(parent: Schedule);
    addEventListener(): void;
    removeEventListener(): void;
    private renderEvents();
    private onContentScroll(e);
    private scrollUiUpdate(args);
    private scrollToWorkHour();
    scrollToHour(hour: string): void;
    private generateColLevels();
    private isWorkHourRange(date);
    highlightCurrentTime(): void;
    private clearCurrentTimeIndicatorTimer();
    private removeCurrentTimeIndicatorElements();
    private changeCurrentTimePosition();
    private getTopFromDateTime(date);
    private getWorkCellHeight();
    private getTdContent(date, type);
    renderLayout(type: string): void;
    renderHeader(): void;
    renderContent(): void;
    private renderLeftIndent();
    private renderDatesHeader();
    createTd(td: TdData): Element;
    private wireCellEvents(element);
    private renderTimeCells();
    private renderContentArea();
    private getScrollableElement();
    getDatesHeaderElement(): HTMLElement;
    getTimeCellsElement(): HTMLElement;
    getContentAreaElement(): HTMLElement;
    getEndDateFromStartDate(start: Date): Date;
    adjustEventWrapper(): void;
    private getTimeSlotRows(handler?);
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the vertical view.
     * @return {void}
     * @private
     */
    destroy(): void;
}
/**
 * view base
 */
export  class ViewBase {
    element: HTMLElement;
    parent: Schedule;
    l10n: base.L10n;
    renderDates: Date[];
    customHelper: Object;
    /**
     * Constructor
     */
    constructor(parent: Schedule);
    createTableLayout(className?: string): Element;
    renderPanel(type: string): void;
    setPanel(panel: HTMLElement): void;
    getPanel(): HTMLElement;
    adjustEventWrapper(): void;
    startDate(): Date;
    endDate(): Date;
    getStartHour(): Date;
    getEndHour(): Date;
    isCurrentDate(date: Date): boolean;
    isCurrentMonth(date: Date): boolean;
    isWorkDay(date: Date): boolean;
    isWorkHour(date: Date): boolean;
    getRenderDates(): void;
    getNextPreviousDate(type: string): Date;
    getLabelText(view: string): string;
    getDateRangeText(): string;
    formatDateRange(startDate: Date, endDate?: Date): string;
    getMobileDateElement(date: Date, className?: string): Element;
}
/**
 * week view
 */
export  class Week extends VerticalView {
    viewClass: string;
    /**
     * Constructor
     */
    constructor(parent: Schedule);
    getRenderDates(): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * work week view
 */
export  class WorkWeek extends VerticalView {
    viewClass: string;
    /**
     * Constructor
     */
    constructor(par: Schedule);
    getRenderDates(): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
}
/**
 * Time zone
 */
export  class Timezone {
    offset(date: Date, timezone: string): number;
    convert(date: Date, fromOffset: number & string, toOffset: number & string): Date;
    add(date: Date, timezone: string): Date;
    remove(date: Date, timezone: string): Date;
    removeLocalOffset(date: Date): Date;
}
export  let localTimezoneName: string;
export  let timezoneData: {
    [key: string]: Object;
}[];
 }
export namespace splitbuttons { 

/**
 * Interface for a class Item
 */
export interface ItemModel {
    /**
     * Defines class/multiple classes separated by a space for the item that is used to include an icon.
     * Action item can include font icon and sprite image.
     * @default ''
     */
    iconCss?: string;
    /**
     * Specifies the id for item.
     * @default ''
     */
    id?: string;
    /**
     * Specifies separator between the items. Separator are horizontal lines used to group action items.
     * @default false
     */
    separator?: boolean;
    /**
     * Specifies text for item.
     * @default ''
     */
    text?: string;
    /**
     * Specifies url for item that creates the anchor link to navigate to the url provided.
     * @default ''
     */
    url?: string;
}
export  type SplitButtonIconPosition = 'Left' | 'Top';
/**
 * @param props
 * @param model
 */
export  function getModel(props: Object, model: string[]): Object;
export  class Item extends base.ChildProperty<Item> {
    /**
     * Defines class/multiple classes separated by a space for the item that is used to include an icon.
     * Action item can include font icon and sprite image.
     * @default ''
     */
    iconCss: string;
    /**
     * Specifies the id for item.
     * @default ''
     */
    id: string;
    /**
     * Specifies separator between the items. Separator are horizontal lines used to group action items.
     * @default false
     */
    separator: boolean;
    /**
     * Specifies text for item.
     * @default ''
     */
    text: string;
    /**
     * Specifies url for item that creates the anchor link to navigate to the url provided.
     * @default ''
     */
    url: string;
}
/**
 * Interface for before item render / select event.
 * @private
 */
export interface MenuEventArgs extends base.BaseEventArgs {
    element: HTMLElement;
    item: ItemModel;
}
/**
 * Interface for before open / close event.
 * @private
 */
export interface BeforeOpenCloseMenuEventArgs extends base.BaseEventArgs {
    element: HTMLElement;
    items: ItemModel[];
    event: Event;
    cancel?: boolean;
}
/**
 * Interface for open/close event.
 */
export interface OpenCloseMenuEventArgs extends base.BaseEventArgs {
    element: HTMLElement;
    items: ItemModel[];
    parentItem?: ItemModel;
}
/**
 * Common modules
 */
/**
 * Interface for a class DropDownButton
 */
export interface DropDownButtonModel extends base.ComponentModel{
    /**
     * Defines the content of the DropDownButton element that can either be a text or HTML elements.
     * @default ""
     */
    content?: string;
    /**
     * Defines class/multiple classes separated by a space in the DropDownButton element. The
     * DropDownButton size and styles can be customized by using this.
     * @default ""
     */
    cssClass?: string;
    /**
     * Specifies a value that indicates whether the DropDownButton is `disabled` or not.
     * @default false.
     */
    disabled?: boolean;
    /**
     * Defines class/multiple classes separated by a space for the DropDownButton that is used to
     * include an icon. DropDownButton can also include font icon and sprite image.
     * @default ""
     */
    iconCss?: string;
    /**
     * Positions the icon before/top of the text content in the DropDownButton. The possible values are:
     * * Left: The icon will be positioned to the left of the text content.
     * * Top: The icon will be positioned to the top of the text content.
     * @default "Left"
     */
    iconPosition?: SplitButtonIconPosition;
    /**
     * Specifies action items with its properties which will be rendered as DropDownButton popup.
     * @default []
     */
    items?: ItemModel[];
    /**
     * Allows to specify the DropDownButton popup item element.
     * @default ""
     */
    target?: string | Element;
    /**
     * Triggers while rendering each base.Popup item of DropDownButton.
     * @event
     */
    beforeItemRender?: base.EmitType<MenuEventArgs>;
    /**
     * Triggers before opening the DropDownButton popup.
     * @event
     */
    beforeOpen?: base.EmitType<BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers before closing the DropDownButton popup.
     * @event
     */
    beforeClose?: base.EmitType<BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers while closing the DropDownButton popup.
     * @event
     */
    close?: base.EmitType<OpenCloseMenuEventArgs>;
    /**
     * Triggers while opening the DropDownButton popup.
     * @event
     */
    open?: base.EmitType<OpenCloseMenuEventArgs>;
    /**
     * Triggers while selecting action item in DropDownButton popup.
     * @event
     */
    select?: base.EmitType<MenuEventArgs>;
}
/**
 * DropDownButton component is used to toggle contextual overlays for displaying list of action items.
 * It can contain both text and images.
 * ``````html
 * <button id="element">DropDownButton</button>
 * ```
 * ```typescript
 * <script>
 * var dropDownButtonObj = new DropDownButton({items: [{ text: 'Action1' }, { text: 'Action2' },{ text: 'Action3' }]);
 * dropDownButtonObj.appendTo("#element");
 * </script>
 * ```
 */
export  class DropDownButton extends base.Component<HTMLButtonElement> implements base.INotifyPropertyChanged {
    protected dropDown: popups.Popup;
    protected button: buttons.Button;
    protected activeElem: HTMLElement;
    /**
     * Defines the content of the DropDownButton element that can either be a text or HTML elements.
     * @default ""
     */
    content: string;
    /**
     * Defines class/multiple classes separated by a space in the DropDownButton element. The
     * DropDownButton size and styles can be customized by using this.
     * @default ""
     */
    cssClass: string;
    /**
     * Specifies a value that indicates whether the DropDownButton is `disabled` or not.
     * @default false.
     */
    disabled: boolean;
    /**
     * Defines class/multiple classes separated by a space for the DropDownButton that is used to
     * include an icon. DropDownButton can also include font icon and sprite image.
     * @default ""
     */
    iconCss: string;
    /**
     * Positions the icon before/top of the text content in the DropDownButton. The possible values are:
     * * Left: The icon will be positioned to the left of the text content.
     * * Top: The icon will be positioned to the top of the text content.
     * @default "Left"
     */
    iconPosition: SplitButtonIconPosition;
    /**
     * Specifies action items with its properties which will be rendered as DropDownButton popup.
     * @default []
     */
    items: ItemModel[];
    /**
     * Allows to specify the DropDownButton popup item element.
     * @default ""
     */
    target: string | Element;
    /**
     * Triggers while rendering each popups.Popup item of DropDownButton.
     * @event
     */
    beforeItemRender: base.EmitType<MenuEventArgs>;
    /**
     * Triggers before opening the DropDownButton popup.
     * @event
     */
    beforeOpen: base.EmitType<BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers before closing the DropDownButton popup.
     * @event
     */
    beforeClose: base.EmitType<BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers while closing the DropDownButton popup.
     * @event
     */
    close: base.EmitType<OpenCloseMenuEventArgs>;
    /**
     * Triggers while opening the DropDownButton popup.
     * @event
     */
    open: base.EmitType<OpenCloseMenuEventArgs>;
    /**
     * Triggers while selecting action item in DropDownButton popup.
     * @event
     */
    select: base.EmitType<MenuEventArgs>;
    /**
     * Constructor for creating the widget
     * @param  {DropDownButtonModel} options?
     * @param  {string|HTMLButtonElement} element?
     */
    constructor(options?: DropDownButtonModel, element?: string | HTMLButtonElement);
    protected preRender(): void;
    /**
     * Get the properties to be maintained in the persisted state.
     * @returns string
     */
    getPersistData(): string;
    /**
     * To open/close DropDownButton popup based on current state of the DropDownButton.
     * @returns void
     */
    toggle(): void;
    /**
     * Initialize the base.Component rendering
     * @returns void
     * @private
     */
    render(): void;
    private createPopup();
    private getTargetElement();
    private createItems(items);
    private hasIcon(items, field);
    private createAnchor(item);
    private initialize();
    protected setIconPositionTop(): void;
    private appendArrowSpan();
    protected setActiveElem(): void;
    /**
     * Get component name.
     * @returns string
     * @private
     */
    getModuleName(): string;
    private canOpen();
    /**
     * Destroys the widget.
     * @returns void
     */
    destroy(): void;
    protected getPopUpElement(): HTMLElement;
    protected getULElement(): HTMLElement;
    protected wireEvents(): void;
    protected keyBoardHandler(e: base.KeyboardEventArgs): void;
    protected upDownKeyHandler(e: base.KeyboardEventArgs): void;
    private isValidLI(li, index, keyCode, count?);
    private keyEventHandler(e);
    private getLI(elem);
    private getZIndex();
    protected clickHandler(e: MouseEvent | base.KeyboardEventArgs): void;
    private openPopUp(e?);
    private closePopup(e?);
    protected unWireEvents(): void;
    /**
     * Called internally if any of the property value changed.
     * @param  {DropDownButtonModel} newProp
     * @param  {DropDownButtonModel} oldProp
     * @returns void
     * @private
     */
    onPropertyChanged(newProp: DropDownButtonModel, oldProp: DropDownButtonModel): void;
}
/**
 * DropDownButton modules
 */
/**
 * SplitButton all module
 */
/**
 * Split Button modules
 */
/**
 * Interface for a class SplitButton
 */
export interface SplitButtonModel extends DropDownButtonModel{
    /**
     * Defines the content of the SplitButton primary action button can either be a text or HTML elements.
     * @default ""
     */
    content?: string;
    /**
     * Defines class/multiple classes separated by a space in the SplitButton element. The SplitButton
     * size and styles can be customized by using this.
     * @default ""
     */
    cssClass?: string;
    /**
     * Specifies a value that indicates whether the SplitButton is disabled or not.
     * @default false.
     */
    disabled?: boolean;
    /**
     * Defines class/multiple classes separated by a space for the SplitButton that is used to include an 
     * icon. SplitButton can also include font icon and sprite image.
     * @default ""
     */
    iconCss?: string;
    /**
     * Positions the icon before/top of the text content in the SplitButton. The possible values are
     * * Left: The icon will be positioned to the left of the text content.
     * * Top: The icon will be positioned to the top of the text content.
     * @default "Left"
     */
    iconPosition?: SplitButtonIconPosition;
    /**
     * Specifies action items with its properties which will be rendered as SplitButton secondary button popup.
     * @default []
     */
    items?: ItemModel[];
    /**
     * Allows to specify the SplitButton popup item element.
     * @default ""
     */
    target?: string | Element;
    /**
     * Triggers while rendering each Popup item of SplitButton.
     * @event
     */
    beforeItemRender?: base.EmitType<MenuEventArgs>;
    /**
     * Triggers before opening the SplitButton popup.
     * @event
     */
    beforeOpen?: base.EmitType<BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers before closing the SplitButton popup.
     * @event
     */
    beforeClose?: base.EmitType<BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers when the primary button of SplitButton has been clicked.
     * @event
     */
    click?: base.EmitType<ClickEventArgs>;
    /**
     * Triggers while closing the SplitButton popup.
     * @event
     */
    close?: base.EmitType<OpenCloseMenuEventArgs>;
    /**
     * Triggers while opening the SplitButton popup.
     * @event
     */
    open?: base.EmitType<OpenCloseMenuEventArgs>;
    /**
     * Triggers while selecting action item of SplitButton popup.
     * @event
     */
    select?: base.EmitType<MenuEventArgs>;
}

/**
 * SplitButton component has primary and secondary button. Primary button is used to select
 * default action and secondary button is used to toggle contextual overlays for displaying list of
 * action items. It can contain both text and images.
 * ```html
 * <button id="element"></button>
 * ```
 * ```typescript
 * <script>
 * var splitBtnObj = new SplitButton({content: 'SplitButton'});
 * splitBtnObj.appendTo("#element");
 * </script>
 * ```
 */
export  class SplitButton extends DropDownButton implements base.INotifyPropertyChanged {
    private wrapper;
    private primaryBtnObj;
    private secondaryBtnObj;
    /**
     * Defines the content of the SplitButton primary action button can either be a text or HTML elements.
     * @default ""
     */
    content: string;
    /**
     * Defines class/multiple classes separated by a space in the SplitButton element. The SplitButton
     * size and styles can be customized by using this.
     * @default ""
     */
    cssClass: string;
    /**
     * Specifies a value that indicates whether the SplitButton is disabled or not.
     * @default false.
     */
    disabled: boolean;
    /**
     * Defines class/multiple classes separated by a space for the SplitButton that is used to include an
     * icon. SplitButton can also include font icon and sprite image.
     * @default ""
     */
    iconCss: string;
    /**
     * Positions the icon before/top of the text content in the SplitButton. The possible values are
     * * Left: The icon will be positioned to the left of the text content.
     * * Top: The icon will be positioned to the top of the text content.
     * @default "Left"
     */
    iconPosition: SplitButtonIconPosition;
    /**
     * Specifies action items with its properties which will be rendered as SplitButton secondary button popup.
     * @default []
     */
    items: ItemModel[];
    /**
     * Allows to specify the SplitButton popup item element.
     * @default ""
     */
    target: string | Element;
    /**
     * Triggers while rendering each Popup item of SplitButton.
     * @event
     */
    beforeItemRender: base.EmitType<MenuEventArgs>;
    /**
     * Triggers before opening the SplitButton popup.
     * @event
     */
    beforeOpen: base.EmitType<BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers before closing the SplitButton popup.
     * @event
     */
    beforeClose: base.EmitType<BeforeOpenCloseMenuEventArgs>;
    /**
     * Triggers when the primary button of SplitButton has been clicked.
     * @event
     */
    click: base.EmitType<ClickEventArgs>;
    /**
     * Triggers while closing the SplitButton popup.
     * @event
     */
    close: base.EmitType<OpenCloseMenuEventArgs>;
    /**
     * Triggers while opening the SplitButton popup.
     * @event
     */
    open: base.EmitType<OpenCloseMenuEventArgs>;
    /**
     * Triggers while selecting action item of SplitButton popup.
     * @event
     */
    select: base.EmitType<MenuEventArgs>;
    /**
     * Constructor for creating the widget
     * @param  {SplitButtonModel} options?
     * @param  {string|HTMLButtonElement} element?
     */
    constructor(options?: SplitButtonModel, element?: string | HTMLButtonElement);
    /**
     * Initialize Angular support.
     * @private
     */
    protected preRender(): void;
    render(): void;
    private initWrapper();
    private createPrimaryButton();
    private createSecondaryButton();
    private setAria();
    /**
     * Get component name.
     * @returns string
     * @private
     */
    getModuleName(): string;
    /**
     * To open/close SplitButton popup based on current state of the SplitButton.
     * @returns void
     */
    toggle(): void;
    destroy(): void;
    protected wireEvents(): void;
    protected unWireEvents(): void;
    private primaryBtnClickHandler();
    private btnKeyBoardHandler(e);
    /**
     * Called internally if any of the property value changed.
     * @param  {SplitButtonModel} newProp
     * @param  {SplitButtonModel} oldProp
     * @returns void
     */
    onPropertyChanged(newProp: SplitButton, oldProp: SplitButton): void;
}
export interface ClickEventArgs extends base.BaseEventArgs {
    element: Element;
}
 }
export namespace svgbase { 

/**
 * Chart components exported.
 */
/**
 * Defines the shape of marker. They are
 * * circle - Renders a circle.
 * * rectangle - Renders a rectangle.
 * * triangle - Renders a triangle.
 * * diamond - Renders a diamond.
 * * cross - Renders a cross.
 * * horizontalLine - Renders a horizontalLine.
 * * verticalLine - Renders a verticalLine.
 * * pentagon- Renders a pentagon.
 * * invertedTriangle - Renders a invertedTriangle.
 * * image - Renders a image.
 */
export  type TooltipShape = 'Circle' | 'Rectangle' | 'Triangle' | 'Diamond' | 'Cross' | 'HorizontalLine' | 'VerticalLine' | 'Pentagon' | 'InvertedTriangle' | 'Image';
/**
 * Defines Theme of the chart. They are
 * * Material - Render a chart with Material theme.
 * * Fabric - Render a chart with Fabric theme
 */
export  type TooltipTheme = 'Material' | 'Fabric' | 'Bootstrap' | 'Highcontrast';
/**
 * Function to measure the height and width of the text.
 * @param  {string} text
 * @param  {FontModel} font
 * @param  {string} id
 * @returns no
 * @private
 */
export  function measureText(text: string, font: TextStyleModel): Size;
/** @private */
export  function findDirection(rX: number, rY: number, rect: Rect, arrowLocation: TooltipLocation, arrowPadding: number, top: boolean, bottom: boolean, left: boolean, tipX: number, tipY: number, tipRadius?: number): string;
/** @private */
export  class Size {
    height: number;
    width: number;
    constructor(width: number, height: number);
}
/** @private */
export  class Rect {
    x: number;
    y: number;
    height: number;
    width: number;
    constructor(x: number, y: number, width: number, height: number);
}
export  class Side {
    isRight: boolean;
    isBottom: boolean;
    constructor(bottom: boolean, right: boolean);
}
/** @private */
export  class CustomizeOption {
    id: string;
    constructor(id?: string);
}
/** @private */
export  class TextOption extends CustomizeOption {
    anchor: string;
    text: string | string[];
    transform: string;
    x: number;
    y: number;
    baseLine: string;
    constructor(id?: string, x?: number, y?: number, anchor?: string, text?: string | string[], transform?: string, baseLine?: string);
}
/** @private */
export  function getElement(id: string): Element;
/** @private */
export  function removeElement(id: string): void;
/** @private */
export interface IShapes {
    renderOption?: Object;
    functionName?: string;
}
/** @private */
export  function drawSymbol(location: TooltipLocation, shape: string, size: Size, url: string, options: PathOption, label: string): Element;
/** @private */
export  function calculateShapes(location: TooltipLocation, size: Size, shape: string, options: PathOption, url: string): IShapes;
/** @private */
export  class PathOption extends CustomizeOption {
    opacity: number;
    fill: string;
    stroke: string;
    ['stroke-width']: number;
    ['stroke-dasharray']: string;
    d: string;
    constructor(id: string, fill: string, width: number, color: string, opacity?: number, dashArray?: string, d?: string);
}
/** @private */
export  function textElement(options: TextOption, font: TextStyleModel, color: string, parent: HTMLElement | Element): Element;
export  class TooltipLocation {
    x: number;
    y: number;
    constructor(x: number, y: number);
}
/**
 * Chart component exported items
 */
/**
 * Specifies the Theme style for chart and accumulation.
 */
export interface ITooltipThemeStyle {
    tooltipFill: string;
    tooltipBoldLabel: string;
    tooltipLightLabel: string;
    tooltipHeaderLine: string;
}
export interface ITooltipEventArgs {
    /** Defines the name of the event */
    name: string;
    /** Defines the event cancel status */
    cancel: boolean;
}
export interface ITooltipRenderingEventArgs extends ITooltipEventArgs {
    /** Defines tooltip text collections */
    text?: string;
    /** Defines tooltip text style */
    textStyle?: TextStyleModel;
    /** Defines the current Tooltip instance */
    tooltip: Tooltip;
}
export interface ITooltipAnimationCompleteArgs extends ITooltipEventArgs {
    /** Defines the current Tooltip instance */
    tooltip: Tooltip;
}
export interface ITooltipLoadedEventArgs extends ITooltipEventArgs {
    /** Defines the current Tooltip instance */
    tooltip: Tooltip;
}
/** @private */
export  function getTooltipThemeColor(theme: TooltipTheme): ITooltipThemeStyle;
/**
 * Interface for a class TextStyle
 * @private
 */
export interface TextStyleModel {
    /**
     * Font size for the text.
     * @default null
     */
    size?: string;
    /**
     * Color for the text.
     * @default ''
     */
    color?: string;
    /**
     * FontFamily for the text.
     */
    fontFamily?: string;
    /**
     * FontWeight for the text.
     * @default 'Normal'
     */
    fontWeight?: string;
    /**
     * FontStyle for the text.
     * @default 'Normal'
     */
    fontStyle?: string;
    /**
     * Opacity for the text.
     * @default 1
     */
    opacity?: number;
}
/**
 * Interface for a class TooltipBorder
 * @private
 */
export interface TooltipBorderModel {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default ''
     */
    color?: string;
    /**
     * The width of the border in pixels.
     * @default 1
     */
    width?: number;
}
/**
 * Interface for a class AreaBounds
 * @private
 */
export interface AreaBoundsModel {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default ''
     */
    x?: number;
    /**
     * The width of the border in pixels.
     * @default 1
     */
    y?: number;
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default ''
     */
    width?: number;
    /**
     * The width of the border in pixels.
     * @default 1
     */
    height?: number;
}
/**
 * Interface for a class ToolLocation
 * @private
 */
export interface ToolLocationModel {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default ''
     */
    x?: number;
    /**
     * The width of the border in pixels.
     * @default 1
     */
    y?: number;
}
/**
 * Interface for a class Tooltip
 * @private
 */
export interface TooltipModel extends base.ComponentModel{
    /**
      * Enables / Disables the visibility of the tooltip.
      * @default false.
      * @private.
      */
    enable?: boolean;
    /**
     * If set to true, a single ToolTip will be displayed for every index.
     * @default false.
     * @private.
     */
    shared?: boolean;
    /**
     * To enable shadow for the tooltip.
     * @default true.
     * @private.
     */
    enableShadow?: boolean;
    /**
     * The fill color of the tooltip that accepts value in hex and rgba as a valid CSS color string. 
     * @private.
     */
    fill?: string;
    /**
     * Header for tooltip. 
     * @private.
     */
    header?: string;
    /**
     * The fill color of the tooltip that accepts value in hex and rgba as a valid CSS color string. 
     * @private.
     */
    opacity?: number;
    /**
     * Options to customize the ToolTip text.
     * @private.
     */
    textStyle?: TextStyleModel;
    /**
     * Custom template to format the ToolTip content. Use ${x} and ${y} as the placeholder text to display the corresponding data point.
     * @default null.
     * @private.
     */
    template?: string;
    /**
     * If set to true, ToolTip will animate while moving from one point to another.
     * @default true.
     * @private.
     */
    enableAnimation?: boolean;
    /**
    * To rotate the tooltip.
    * @default false.
    * @private.
    */
    inverted?: boolean;
    /**
    * Negative value of the tooltip.
    * @default true.
    * @private.
    */
    isNegative?: boolean;
    /**
     * Options to customize tooltip borders.
     * @private.
     */
    border?: TooltipBorderModel;
    /**
     * Content for the tooltip.
     * @private.
     */
    content?: string[];
    /**
     * Content for the tooltip.
     * @private.
     */
    markerSize?: number;
    /**
     * Clip location.
     * @private.
     */
    clipBounds?: ToolLocationModel;
    /**
     * Palette for marker.
     * @private.
     */
    palette?: string[];
    /**
     * Shapes for marker.
     * @private.
     */
    shapes?: TooltipShape[];
    /**
     * Location for Tooltip.
     * @private.
     */
    location?: ToolLocationModel;
    /**
     * Location for Tooltip.
     * @private.
     */
    offset?: number;
    /**
     * Rounded corner for x.
     * @private.
     */
    rx?: number;
    /**
     * Rounded corner for y.
     * @private.
     */
    ry?: number;
    /**
     * Margin for left and right.
     * @private.
     */
    marginX?: number;
    /**
     *  Margin for top and bottom.
     *  @private.
     */
    marginY?: number;
    /**
     * Padding for arrow.
     * @private.
     */
    arrowPadding?: number;
    /**
     * Data for template.
     * @private.
     */
    data?: Object;
    /**
    * Specifies the theme for the chart.
    * @default 'Material'
    * @private.
    */
    theme?: TooltipTheme;
    /**
     * Bounds for the rect.
     * @private.
     */
    areaBounds?: AreaBoundsModel;
    /**
     * Triggers before each axis range is rendered.
     * @event
     * @private.
     */
    tooltipRender?: base.EmitType<ITooltipRenderingEventArgs>;
    /**
     * Triggers after chart load.
     * @event
     * @private.
     */
    loaded?: base.EmitType<ITooltipLoadedEventArgs>;
    /**
     * Triggers after chart load.
     * @event
     * @private.
     */
    animationComplete?: base.EmitType<ITooltipAnimationCompleteArgs>;
}
/**
 * Configures the fonts in charts.
 * @private
 */
export  class TextStyle extends base.ChildProperty<TextStyle> {
    /**
     * Font size for the text.
     * @default null
     */
    size: string;
    /**
     * Color for the text.
     * @default ''
     */
    color: string;
    /**
     * FontFamily for the text.
     */
    fontFamily: string;
    /**
     * FontWeight for the text.
     * @default 'Normal'
     */
    fontWeight: string;
    /**
     * FontStyle for the text.
     * @default 'Normal'
     */
    fontStyle: string;
    /**
     * Opacity for the text.
     * @default 1
     */
    opacity: number;
}
/**
 * Configures the borders in the chart.
 * @private
 */
export  class TooltipBorder extends base.ChildProperty<TooltipBorder> {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default ''
     */
    color: string;
    /**
     * The width of the border in pixels.
     * @default 1
     */
    width: number;
}
/**
 * Configures the borders in the chart.
 * @private
 */
export  class AreaBounds extends base.ChildProperty<AreaBounds> {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default ''
     */
    x: number;
    /**
     * The width of the border in pixels.
     * @default 1
     */
    y: number;
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default ''
     */
    width: number;
    /**
     * The width of the border in pixels.
     * @default 1
     */
    height: number;
}
/**
 * Configures the borders in the chart.
 * @private
 */
export  class ToolLocation extends base.ChildProperty<ToolLocation> {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default ''
     */
    x: number;
    /**
     * The width of the border in pixels.
     * @default 1
     */
    y: number;
}
/**
 * Represents the Tooltip control.
 * ```html
 * <div id="tooltip"/>
 * <script>
 *   var tooltipObj = new Tooltip({ isResponsive : true });
 *   tooltipObj.appendTo("#tooltip");
 * </script>
 * ```
 * @private
 */
export  class Tooltip extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /**
     * Enables / Disables the visibility of the tooltip.
     * @default false.
     * @private.
     */
    enable: boolean;
    /**
     * If set to true, a single ToolTip will be displayed for every index.
     * @default false.
     * @private.
     */
    shared: boolean;
    /**
     * To enable shadow for the tooltip.
     * @default true.
     * @private.
     */
    enableShadow: boolean;
    /**
     * The fill color of the tooltip that accepts value in hex and rgba as a valid CSS color string.
     * @private.
     */
    fill: string;
    /**
     * Header for tooltip.
     * @private.
     */
    header: string;
    /**
     * The fill color of the tooltip that accepts value in hex and rgba as a valid CSS color string.
     * @private.
     */
    opacity: number;
    /**
     * Options to customize the ToolTip text.
     * @private.
     */
    textStyle: TextStyleModel;
    /**
     * Custom template to format the ToolTip content. Use ${x} and ${y} as the placeholder text to display the corresponding data point.
     * @default null.
     * @private.
     */
    template: string;
    /**
     * If set to true, ToolTip will animate while moving from one point to another.
     * @default true.
     * @private.
     */
    enableAnimation: boolean;
    /**
     * To rotate the tooltip.
     * @default false.
     * @private.
     */
    inverted: boolean;
    /**
     * Negative value of the tooltip.
     * @default true.
     * @private.
     */
    isNegative: boolean;
    /**
     * Options to customize tooltip borders.
     * @private.
     */
    border: TooltipBorderModel;
    /**
     * Content for the tooltip.
     * @private.
     */
    content: string[];
    /**
     * Content for the tooltip.
     * @private.
     */
    markerSize: number;
    /**
     * Clip location.
     * @private.
     */
    clipBounds: ToolLocationModel;
    /**
     * Palette for marker.
     * @private.
     */
    palette: string[];
    /**
     * Shapes for marker.
     * @private.
     */
    shapes: TooltipShape[];
    /**
     * Location for Tooltip.
     * @private.
     */
    location: ToolLocationModel;
    /**
     * Location for Tooltip.
     * @private.
     */
    offset: number;
    /**
     * Rounded corner for x.
     * @private.
     */
    rx: number;
    /**
     * Rounded corner for y.
     * @private.
     */
    ry: number;
    /**
     * Margin for left and right.
     * @private.
     */
    marginX: number;
    /**
     *  Margin for top and bottom.
     *  @private.
     */
    marginY: number;
    /**
     * Padding for arrow.
     * @private.
     */
    arrowPadding: number;
    /**
     * Data for template.
     * @private.
     */
    data: Object;
    /**
     * Specifies the theme for the chart.
     * @default 'Material'
     * @private.
     */
    theme: TooltipTheme;
    /**
     * Bounds for the rect.
     * @private.
     */
    areaBounds: AreaBoundsModel;
    /**
     * Triggers before each axis range is rendered.
     * @event
     * @private.
     */
    tooltipRender: base.EmitType<ITooltipRenderingEventArgs>;
    /**
     * Triggers after chart load.
     * @event
     * @private.
     */
    loaded: base.EmitType<ITooltipLoadedEventArgs>;
    /**
     * Triggers after chart load.
     * @event
     * @private.
     */
    animationComplete: base.EmitType<ITooltipAnimationCompleteArgs>;
    private elementSize;
    private toolTipInterval;
    private padding;
    private textElements;
    private templateFn;
    private formattedText;
    private markerPoint;
    /** @private */
    private valueX;
    /** @private */
    private valueY;
    private tipRadius;
    fadeOuted: boolean;
    /** @private */
    private renderer;
    /** @private */
    private themeStyle;
    private isFirst;
    /**
     * Constructor for creating the widget
     * @hidden
     */
    constructor(options?: TooltipModel, element?: string | HTMLElement);
    /**
     * Initialize the event handler.
     *  @private.
     */
    protected preRender(): void;
    private initPrivateVariable();
    private removeSVG();
    /**
     * To Initialize the control rendering.
     */
    protected render(): void;
    private createElement();
    private drawMarker(isBottom, isRight, size);
    private renderTooltipElement(areaBounds, location);
    private changeText(point, isBottom, isRight, rect);
    private findFormattedText();
    private renderText(isRender);
    private createTemplate(areaBounds, location);
    private sharedTooltipLocation(bounds, x, y);
    private tooltipLocation(bounds, symbolLocation, arrowLocation, tipLocation);
    private animateTooltipDiv(tooltipDiv, rect);
    private updateDiv(tooltipDiv, x, y);
    private updateTemplateFn();
    /** @private */
    fadeOut(): void;
    private progressAnimation(tooltipGroup, opacity, timeStamp);
    private endAnimation(tooltipGroup);
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    getPersistData(): string;
    /**
     * Get component name
     *  @private
     */
    getModuleName(): string;
    /**
     * To destroy the accumulationcharts
     * @private
     */
    destroy(): void;
    /**
     * Called internally if any of the property value changed.
     * @return {void}
     * @private
     */
    onPropertyChanged(newProp: TooltipModel, oldProp: TooltipModel): void;
}
 }
export namespace treemap { 

/**
 * exporting all modules from tree map index
 */
/**
 * export all modules from treemap component
 */
/**
 * Legend module class
 */
export  class TreeMapLegend {
    private treemap;
    legendRenderingCollections: Object[];
    legendCollections: Object[];
    private legendHeight;
    private legendWidth;
    private totalPages;
    private page;
    private translate;
    private legendBorderRect;
    private currentPage;
    private heightIncrement;
    private widthIncrement;
    private textMaxWidth;
    legendGroup: Element;
    private legendNames;
    private defsElement;
    private gradientCount;
    private clearTimeout;
    private legendItemRect;
    constructor(treemap: TreeMap);
    renderLegend(): void;
    calculateLegendBounds(): void;
    private getPageChanged();
    private findColorMappingLegendItems(data);
    private findPaletteLegendItems(data, type);
    private calculateLegendItems(data);
    private isAddNewLegendData(legendText);
    drawLegend(): void;
    private drawLegendItem(page);
    private renderLegendBorder();
    private renderLegendTitle();
    renderInteractivePointer(e: PointerEvent | TouchEvent): void;
    private drawInteractivePointer(legend, fill, stroke, id, strokeWidth, rect);
    private getLegendAlignment(treemap, width, height, legend);
    mouseUpHandler(e: PointerEvent): void;
    removeInteractivePointer(): void;
    changeNextPage(e: PointerEvent): void;
    wireEvents(element: Element): void;
    addEventListener(): void;
    removeEventListener(): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the legend.
     * @return {void}
     * @private
     */
    destroy(treemap: TreeMap): void;
}
/**
 * To calculate and render the shape layer
 */
export  class LayoutPanel {
    private treemap;
    private currentRect;
    layoutGroup: Element;
    private renderer;
    renderItems: Object[];
    private parentData;
    constructor(treemap: TreeMap);
    processLayoutPanel(): void;
    private getDrilldownData(data, drillData);
    calculateLayoutItems(data: Object, rect: Rect): void;
    private computeSliceAndDiceDimensional(data, coords);
    private sliceAndDiceProcess(processData, rect);
    private computeSquarifyDimensional(data, coords);
    private calculateChildrenLayout(parent, children, coords);
    private performRowsLayout(data, currentRow, rect, stack);
    private aspectRatio(currentRow, nextDatum, length);
    private findMaxAspectRatio(row, length);
    private cutArea(rect, area);
    private getCoordinates(row, rect);
    private computeTotalArea(data, area);
    renderLayoutItems(renderData: Object): void;
    private renderItemText(text, parentElement, textStyle, rect, interSectAction, groupId, fill, position);
    private getItemColor(isLeafItem, item);
    /**
     * To find saturated color for datalabel
     */
    private getSaturatedColor(color);
    private renderTemplate(secondaryEle, groupId, rect, position, template, item);
    private labelInterSectAction(rect, text, textStyle, alignment);
}
/**
 * Interface for a class Border
 */
export interface BorderModel {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default '#808080'
     */
    color?: string;
    /**
     * The width of the border in pixels.
     * @default 0
     */
    width?: number;
}
/**
 * Interface for a class Margin
 */
export interface MarginModel {
    /**
     * Left margin in pixels.
     * @default 10
     */
    left?: number;
    /**
     * Right margin in pixels.
     * @default 10
     */
    right?: number;
    /**
     * Top margin in pixels.
     * @default 10
     */
    top?: number;
    /**
     * Bottom margin in pixels.
     * @default 10
     */
    bottom?: number;
}
/**
 * Interface for a class Font
 */
export interface FontModel {
    /**
     * Font size for the text.
     * @default null
     */
    size?: string;
    /**
     * Color for the text.
     * @default null
     */
    color?: string;
    /**
     * fontFamily for the text.
     * @default ''
     */
    fontFamily?: string;
    /**
     * FontWeight for the text.
     * @default 'Normal'
     */
    fontWeight?: string;
    /**
     * FontStyle for the text.
     * @default 'Normal'
     */
    fontStyle?: string;
    /**
     * Opacity for the text.
     * @default 1
     */
    opacity?: number;
}
/**
 * Interface for a class CommonTitleSettings
 */
export interface CommonTitleSettingsModel {
    /**
     * To customize the text of the title.
     * @default ''
     */
    text?: string;
    /**
     * To customize title description for the accessibility.
     * @default ''
     */
    description?: string;
}
/**
 * Interface for a class SubTitleSettings
 */
export interface SubTitleSettingsModel extends CommonTitleSettingsModel{
    /**
     * Options for customizing title styles of the Maps.
     */
    textStyle?: FontModel;
    /**
     * Options for customize the text alignment.
     * @default 'Center'
     */
    alignment?: Alignment;
}
/**
 * Interface for a class TitleSettings
 */
export interface TitleSettingsModel extends CommonTitleSettingsModel{
    /**
     * Options for customizing title styles of the Maps.
     */
    textStyle?: FontModel;
    /**
     * Options for customize the text alignment.
     * @default 'Center'
     */
    alignment?: Alignment;
    /**
     * To configure sub title of maps.
     */
    subtitleSettings?: SubTitleSettingsModel;
}
/**
 * Interface for a class ColorMapping
 */
export interface ColorMappingModel {
    /**
     * Specifies the from
     * @default null
     */
    from?: number;
    /**
     * Specifies the to
     * @default null
     */
    to?: number;
    /**
     * specifies the color
     * @default null 
     */
    color?: string;
    /**
     * Specifies the label text.
     * @default null
     */
    label?: string;
    /**
     * Specifies the value
     * @default null
     */
    value?: string | number;
    /**
     * Specifies the minOpacity
     * @default null 
     */
    minOpacity?: number;
    /**
     * maxOpacity
     * @default null 
     */
    maxOpacity?: number;
}
/**
 * Interface for a class LegendSettings
 */
export interface LegendSettingsModel {
    /**
     * Toggle the legend visibility.
     * @default false
     */
    visible?: boolean;
    /**
     * Customize the legend mode.
     * @default 'Default'
     */
    mode?: LegendMode;
    /**
     * Customize the legend background
     * @default 'transparent'
     */
    background?: string;
    /**
     * Customize the legend shape.
     * @default 'Circle'
     */
    shape?: LegendShape;
    /**
     * Customize the legend width.
     * @default ''
     */
    width?: string;
    /**
     * Customize the legend height.
     * @default ''
     */
    height?: string;
    /**
     * Options for customize the legend text.
     */
    textStyle?: FontModel;
    /**
     * Specifies the legend shape color
     * @default null
     */
    fill?: string;
    /**
     * Customize the shape width.
     * @default 15
     */
    shapeWidth?: number;
    /**
     * Customize the shape height.
     * @default 15
     */
    shapeHeight?: number;
    /**
     * Customize the shape padding
     * @default 10
     */
    shapePadding?: number;
    /**
     * Specifies the images url.
     * @default null
     */
    imageUrl?: string;
    /**
     * Options for customizing the color and width of the legend border.
     */
    border?: BorderModel;
    /**
     * Options for customizing the color and width of the shape border.
     */
    shapeBorder?: BorderModel;
    /**
     * To configure the title of the legend.
     */
    title?: CommonTitleSettingsModel;
    /**
     * Options for customizing text styles of the legend.
     */
    titleStyle?: FontModel;
    /**
     * Customize the legend position of the maps.
     * @default 'Bottom'
     */
    position?: LegendPosition;
    /**
     * Customize the legend items placed
     * @default 'None'
     */
    orientation?: LegendOrientation;
    /**
     * Inverted pointer for interactive legend
     * @default false
     */
    invertedPointer?: boolean;
    /**
     * To place the label position for interactive legend.
     * @default 'After'
     */
    labelPosition?: LabelPlacement;
    /**
     * Specifies the label intersect action.
     * @default 'None'
     */
    labelDisplayMode?: LabelIntersectAction;
    /**
     * Customize the legend alignment.
     * @default 'Center'
     */
    alignment?: Alignment;
    /**
     * Customize the legend placed by given x and y values. 
     */
    location?: Location;
}
/**
 * Interface for a class InitialDrillSettings
 */
export interface InitialDrillSettingsModel {
    /**
     * Specifies the initial rendering level.
     * @default null
     */
    groupIndex?: number;
    /**
     * Specifies the initial rendering name.
     * @default null
     */
    groupName?: string;
}
/**
 * Interface for a class LeafItemSettings
 */
export interface LeafItemSettingsModel {
    /**
     * Specifies the fill color for leaf items.
     * @default '#808080'
     */
    fill?: string;
    /**
     * Items rendering with random colors.
     * @default false
     */
    autoFill?: boolean;
    /**
     * Specifies the border
     */
    border?: BorderModel;
    /**
     * Specifies the item gap.
     * @default 0
     */
    gap?: number;
    /**
     * Specifies the padding.
     * @default 10
     */
    padding?: number;
    /**
     * Specifies the opacity for color.
     * @default 1
     */
    opacity?: number;
    /**
     * To show or hide the labels
     * @default true
     */
    showLabels?: boolean;
    /**
     * Specifies the field name from the dataSource.
     * @default null
     */
    labelPath?: string;
    /**
     * Specifies the label format.
     * @default null
     */
    labelFormat?: string;
    /**
     * Specifies the alignment of label.
     * @default 'TopLeft'
     */
    labelPosition?: LabelPosition;
    /**
     * Customize the label style.
     */
    labelStyle?: FontModel;
    /**
     * Specifies the label template.
     * @default null
     */
    labelTemplate?: string;
    /**
     * Specifies the alignment of template.
     * @default 'Center'
     */
    templatePosition?: LabelPosition;
    /**
     * Specifies the label intersect action.
     * @default 'Trim'
     */
    interSectAction?: LabelAlignment;
    /**
     * Specifies the colorMapping
     */
    colorMapping?: ColorMappingModel[];
}
/**
 * Interface for a class TooltipSettings
 */
export interface TooltipSettingsModel {
    /**
     * To enable or disable the Tooltip.
     * @default false
     */
    visible?: boolean;
    /**
     * To specifies the template for tooltip.
     * @default ''
     */
    template?: string;
    /**
     * Specifies the format by given ${data}
     * @default null
     */
    format?: string;
    /**
     * To fill the tooltip background.
     * @default '#000816'
     */
    fill?: string;
    /**
     * Specifies the opacity for fill.
     * @default 0.75
     */
    opacity?: number;
    /**
     * Specifies the marker shapes.
     * @default '[Circle]'
     */
    markerShapes?: MarkerShape[];
    /**
     * Specifies the tooltip border.
     */
    border?: BorderModel;
    /**
     * Specifies the text style.
     */
    textStyle?: FontModel;
}
/**
 * Interface for a class SelectionSettings
 */
export interface SelectionSettingsModel {
    /**
     * To enable or disable the selection
     * @default false
     */
    enable?: boolean;
    /**
     * To specifies the selection color
     * @default '#808080'
     */
    fill?: string;
    /**
     * To specified the opacity of color.
     * @default '0.5'
     */
    opacity?: string;
    /**
     * To specifies the border
     */
    border?: BorderModel;
    /**
     * To specifies the selection mode.
     * @default 'Item'
     */
    mode?: SelectionMode;
}
/**
 * Interface for a class HighlightSettings
 */
export interface HighlightSettingsModel {
    /**
     * To enable or disable the highlight.
     * @default false
     */
    enable?: boolean;
    /**
     * To specifies the highlight color.
     * @default '#808080'
     */
    fill?: string;
    /**
     * To specified the opacity of color.
     * @default '0.5'
     */
    opacity?: string;
    /**
     * To specifies the border
     */
    border?: BorderModel;
    /**
     * To specifies the highlight mode.
     * @default 'Item'
     */
    mode?: HighLightMode;
}
/**
 * Interface for a class LevelSettings
 */
export interface LevelSettingsModel {
    /**
     * Specifies the field name from the dataSource.
     * @default null
     */
    groupPath?: string;
    /**
     * Specifies the padding.
     * @default 0
     */
    groupGap?: number;
    /**
     * Specifies the padding.
     * @default 10
     */
    groupPadding?: number;
    /**
     * Specifies the border
     */
    border?: BorderModel;
    /**
     * Specifies the background of level.
     * @default '#808080'
     */
    fill?: string;
    /**
     * Items rendering with random colors.
     * @default false
     */
    autoFill?: boolean;
    /**
     * Specifies the opacity for color.
     * @default 1
     */
    opacity?: number;
    /**
     * To Show or hide the header in level.
     * @default true
     */
    showHeader?: boolean;
    /**
     * To specifies the height of header.
     * @default 20
     */
    headerHeight?: number;
    /**
     * Specifies the template for header rendering.
     * @default null
     */
    headerTemplate?: string;
    /**
     * Specifies the header format.
     * @default null
     */
    headerFormat?: string;
    /**
     * Customize the text alignment
     * @default 'Near'
     */
    headerAlignment?: Alignment;
    /**
     * Customize the header style.
     */
    headerStyle?: FontModel;
    /**
     * Specifies the label position in level.
     * @default 'TopLeft'
     */
    templatePosition?: LabelPosition;
    /**
     * Specifies the colorMapping
     */
    colorMapping?: ColorMappingModel[];
}
/**
 * Maps base doc
 */
/**
 * Configures the borders in the maps.
 */
export  type MarkerShape = 'Circle' | 'Rectangle' | 'Triangle' | 'Diamond' | 'Cross' | 'HorizontalLine' | 'VerticalLine' | 'Pentagon' | 'InvertedTriangle' | 'Image';
export  class Border extends base.ChildProperty<Border> {
    /**
     * The color of the border that accepts value in hex and rgba as a valid CSS color string.
     * @default '#808080'
     */
    color: string;
    /**
     * The width of the border in pixels.
     * @default 0
     */
    width: number;
}
/**
 * Configures the treemap margin.
 */
export  class Margin extends base.ChildProperty<Margin> {
    /**
     * Left margin in pixels.
     * @default 10
     */
    left: number;
    /**
     * Right margin in pixels.
     * @default 10
     */
    right: number;
    /**
     * Top margin in pixels.
     * @default 10
     */
    top: number;
    /**
     * Bottom margin in pixels.
     * @default 10
     */
    bottom: number;
}
/**
 * Configures the fonts in treemap.
 */
export  class Font extends base.ChildProperty<Font> {
    /**
     * Font size for the text.
     * @default null
     */
    size: string;
    /**
     * Color for the text.
     * @default null
     */
    color: string;
    /**
     * fontFamily for the text.
     * @default ''
     */
    fontFamily: string;
    /**
     * FontWeight for the text.
     * @default 'Normal'
     */
    fontWeight: string;
    /**
     * FontStyle for the text.
     * @default 'Normal'
     */
    fontStyle: string;
    /**
     * Opacity for the text.
     * @default 1
     */
    opacity: number;
}
/**
 * To configure title of the maps.
 */
export  class CommonTitleSettings extends base.ChildProperty<CommonTitleSettings> {
    /**
     * To customize the text of the title.
     * @default ''
     */
    text: string;
    /**
     * To customize title description for the accessibility.
     * @default ''
     */
    description: string;
}
/**
 * To configure subtitle of the maps.
 */
export  class SubTitleSettings extends CommonTitleSettings {
    /**
     * Options for customizing title styles of the Maps.
     */
    textStyle: FontModel;
    /**
     * Options for customize the text alignment.
     * @default 'Center'
     */
    alignment: Alignment;
}
/**
 * To configure title of the maps.
 */
export  class TitleSettings extends CommonTitleSettings {
    /**
     * Options for customizing title styles of the Maps.
     */
    textStyle: FontModel;
    /**
     * Options for customize the text alignment.
     * @default 'Center'
     */
    alignment: Alignment;
    /**
     * To configure sub title of maps.
     */
    subtitleSettings: SubTitleSettingsModel;
}
export  class ColorMapping extends base.ChildProperty<ColorMapping> {
    /**
     * Specifies the from
     * @default null
     */
    from: number;
    /**
     * Specifies the to
     * @default null
     */
    to: number;
    /**
     * specifies the color
     * @default null
     */
    color: string;
    /**
     * Specifies the label text.
     * @default null
     */
    label: string;
    /**
     * Specifies the value
     * @default null
     */
    value: string | number;
    /**
     * Specifies the minOpacity
     * @default null
     */
    minOpacity: number;
    /**
     * maxOpacity
     * @default null
     */
    maxOpacity: number;
}
/**
 * Configures the legend settings.
 */
export  class LegendSettings extends base.ChildProperty<LegendSettings> {
    /**
     * Toggle the legend visibility.
     * @default false
     */
    visible: boolean;
    /**
     * Customize the legend mode.
     * @default 'Default'
     */
    mode: LegendMode;
    /**
     * Customize the legend background
     * @default 'transparent'
     */
    background: string;
    /**
     * Customize the legend shape.
     * @default 'Circle'
     */
    shape: LegendShape;
    /**
     * Customize the legend width.
     * @default ''
     */
    width: string;
    /**
     * Customize the legend height.
     * @default ''
     */
    height: string;
    /**
     * Options for customize the legend text.
     */
    textStyle: FontModel;
    /**
     * Specifies the legend shape color
     * @default null
     */
    fill: string;
    /**
     * Customize the shape width.
     * @default 15
     */
    shapeWidth: number;
    /**
     * Customize the shape height.
     * @default 15
     */
    shapeHeight: number;
    /**
     * Customize the shape padding
     * @default 10
     */
    shapePadding: number;
    /**
     * Specifies the images url.
     * @default null
     */
    imageUrl: string;
    /**
     * Options for customizing the color and width of the legend border.
     */
    border: BorderModel;
    /**
     * Options for customizing the color and width of the shape border.
     */
    shapeBorder: BorderModel;
    /**
     * To configure the title of the legend.
     */
    title: CommonTitleSettingsModel;
    /**
     * Options for customizing text styles of the legend.
     */
    titleStyle: FontModel;
    /**
     * Customize the legend position of the maps.
     * @default 'Bottom'
     */
    position: LegendPosition;
    /**
     * Customize the legend items placed
     * @default 'None'
     */
    orientation: LegendOrientation;
    /**
     * Inverted pointer for interactive legend
     * @default false
     */
    invertedPointer: boolean;
    /**
     * To place the label position for interactive legend.
     * @default 'After'
     */
    labelPosition: LabelPlacement;
    /**
     * Specifies the label intersect action.
     * @default 'None'
     */
    labelDisplayMode: LabelIntersectAction;
    /**
     * Customize the legend alignment.
     * @default 'Center'
     */
    alignment: Alignment;
    /**
     * Customize the legend placed by given x and y values.
     */
    location: Location;
}
export  class InitialDrillSettings extends base.ChildProperty<InitialDrillSettings> {
    /**
     * Specifies the initial rendering level.
     * @default null
     */
    groupIndex: number;
    /**
     * Specifies the initial rendering name.
     * @default null
     */
    groupName: string;
}
export  class LeafItemSettings extends base.ChildProperty<LeafItemSettings> {
    /**
     * Specifies the fill color for leaf items.
     * @default '#808080'
     */
    fill: string;
    /**
     * Items rendering with random colors.
     * @default false
     */
    autoFill: boolean;
    /**
     * Specifies the border
     */
    border: BorderModel;
    /**
     * Specifies the item gap.
     * @default 0
     */
    gap: number;
    /**
     * Specifies the padding.
     * @default 10
     */
    padding: number;
    /**
     * Specifies the opacity for color.
     * @default 1
     */
    opacity: number;
    /**
     * To show or hide the labels
     * @default true
     */
    showLabels: boolean;
    /**
     * Specifies the field name from the dataSource.
     * @default null
     */
    labelPath: string;
    /**
     * Specifies the label format.
     * @default null
     */
    labelFormat: string;
    /**
     * Specifies the alignment of label.
     * @default 'TopLeft'
     */
    labelPosition: LabelPosition;
    /**
     * Customize the label style.
     */
    labelStyle: FontModel;
    /**
     * Specifies the label template.
     * @default null
     */
    labelTemplate: string;
    /**
     * Specifies the alignment of template.
     * @default 'Center'
     */
    templatePosition: LabelPosition;
    /**
     * Specifies the label intersect action.
     * @default 'Trim'
     */
    interSectAction: LabelAlignment;
    /**
     * Specifies the colorMapping
     */
    colorMapping: ColorMappingModel[];
}
export  class TooltipSettings extends base.ChildProperty<TooltipSettings> {
    /**
     * To enable or disable the Tooltip.
     * @default false
     */
    visible: boolean;
    /**
     * To specifies the template for tooltip.
     * @default ''
     */
    template: string;
    /**
     * Specifies the format by given ${data}
     * @default null
     */
    format: string;
    /**
     * To fill the tooltip background.
     * @default '#000816'
     */
    fill: string;
    /**
     * Specifies the opacity for fill.
     * @default 0.75
     */
    opacity: number;
    /**
     * Specifies the marker shapes.
     * @default '[Circle]'
     */
    markerShapes: MarkerShape[];
    /**
     * Specifies the tooltip border.
     */
    border: BorderModel;
    /**
     * Specifies the text style.
     */
    textStyle: FontModel;
}
export  class SelectionSettings extends base.ChildProperty<SelectionSettings> {
    /**
     * To enable or disable the selection
     * @default false
     */
    enable: boolean;
    /**
     * To specifies the selection color
     * @default '#808080'
     */
    fill: string;
    /**
     * To specified the opacity of color.
     * @default '0.5'
     */
    opacity: string;
    /**
     * To specifies the border
     */
    border: BorderModel;
    /**
     * To specifies the selection mode.
     * @default 'Item'
     */
    mode: SelectionMode;
}
export  class HighlightSettings extends base.ChildProperty<HighlightSettings> {
    /**
     * To enable or disable the highlight.
     * @default false
     */
    enable: boolean;
    /**
     * To specifies the highlight color.
     * @default '#808080'
     */
    fill: string;
    /**
     * To specified the opacity of color.
     * @default '0.5'
     */
    opacity: string;
    /**
     * To specifies the border
     */
    border: BorderModel;
    /**
     * To specifies the highlight mode.
     * @default 'Item'
     */
    mode: HighLightMode;
}
/**
 * Options for customizing the tree map levels.
 */
export  class LevelSettings extends base.ChildProperty<LevelSettings> {
    /**
     * Specifies the field name from the dataSource.
     * @default null
     */
    groupPath: string;
    /**
     * Specifies the padding.
     * @default 0
     */
    groupGap: number;
    /**
     * Specifies the padding.
     * @default 10
     */
    groupPadding: number;
    /**
     * Specifies the border
     */
    border: BorderModel;
    /**
     * Specifies the background of level.
     * @default '#808080'
     */
    fill: string;
    /**
     * Items rendering with random colors.
     * @default false
     */
    autoFill: boolean;
    /**
     * Specifies the opacity for color.
     * @default 1
     */
    opacity: number;
    /**
     * To Show or hide the header in level.
     * @default true
     */
    showHeader: boolean;
    /**
     * To specifies the height of header.
     * @default 20
     */
    headerHeight: number;
    /**
     * Specifies the template for header rendering.
     * @default null
     */
    headerTemplate: string;
    /**
     * Specifies the header format.
     * @default null
     */
    headerFormat: string;
    /**
     * Customize the text alignment
     * @default 'Near'
     */
    headerAlignment: Alignment;
    /**
     * Customize the header style.
     */
    headerStyle: FontModel;
    /**
     * Specifies the label position in level.
     * @default 'TopLeft'
     */
    templatePosition: LabelPosition;
    /**
     * Specifies the colorMapping
     */
    colorMapping: ColorMappingModel[];
}
/**
 * TreeMap constants doc
 */
/**
 * Specifies TreeMap load event name.
 * @private
 */
export  const load: string;
/**
 * Specifies TreeMap loaded event name.
 * @private
 */
export  const loaded: string;
/**
 * Specifies TreeMap beforePrint event name.
 * @private
 */
export  const beforePrint: string;
/**
 * Specifies the itemRendering event name.
 * @private
 */
export  const itemRendering: string;
/**
 * Specifies the drilldown start event name.
 * @private
 */
export  const drillStart: string;
/**
 * Specifies the drilldown end event name.
 * @private
 */
export  const drillEnd: string;
/**
 * Specifies the item selected event name.
 * @private
 */
export  const itemSelected: string;
/**
 * Specifies the item highlight event name.
 * @private
 */
export  const itemHighlight: string;
/**
 * Specifies the tooltip rendering event name.
 * @private
 */
export  const tooltipRendering: string;
/**
 * Specifies the item click event name.
 * @private
 */
export  const itemClick: string;
/**
 * Specifies the item move event name.
 * @private
 */
export  const itemMove: string;
/**
 * Specifies the mouse click event name.
 * @private
 */
export  const click: string;
/**
 * Specifies the mouse move event name.
 * @private
 */
export  const mouseMove: string;
/**
 * Specifies legend item rendering event name.
 * @private
 */
export  const legendItemRendering: string;
/**
 * Specifies treemap resize event name.
 * @private
 */
export  const resize: string;
/**
 * Specifies the font family
 * @private
 */
export  const defaultFont: string;
/**
 * Specifies TreeMap Events
 * @private
 */
export interface ITreeMapEventArgs {
    /** Defines the name of the event */
    name: string;
    /** Defines the event cancel status */
    cancel: boolean;
}
export interface IPrintEventArgs extends ITreeMapEventArgs {
    htmlContent: Element;
}
/**
 * Specifies the Load Event arguments.
 */
export interface ILoadEventArgs extends ITreeMapEventArgs {
    /** Defines the current TreeMap instance */
    treemap: TreeMap;
}
/**
 * Specifies the Loaded Event arguments.
 */
export interface ILoadedEventArgs extends ITreeMapEventArgs {
    /** Defines the current TreeMap instance */
    treemap: TreeMap;
}
export interface IItemRenderingEventArgs extends ITreeMapEventArgs {
    /** Defines the current TreeMap instance */
    treemap: TreeMap;
    /**
     * Define the current rendering item.
     */
    currentItem: Object;
    /**
     * Define the all render items
     */
    RenderItems: Object[];
    /**
     * Define the options.
     */
    options: Object;
}
export interface IDrillStartEventArgs extends ITreeMapEventArgs {
    /** Defines the current TreeMap instance */
    treemap: TreeMap;
    /**
     * Define the current drillDown item.
     */
    item: Object;
    /**
     * Define the current element of drillDown.
     */
    element: Element;
}
export interface IDrillEndEventArgs extends ITreeMapEventArgs {
    /** Defines the current TreeMap instance */
    treemap: TreeMap;
    /**
     * Define the rendering all items.
     */
    renderItems: Object[];
}
export interface IItemClickEventArgs extends ITreeMapEventArgs {
    /** Defines the current TreeMap instance */
    treemap: TreeMap;
    /**
     * Define the current item click.
     */
    item: Object;
    /**
     * Define the mouse event.
     */
    mouseEvent: PointerEvent;
}
export interface IItemMoveEventArgs extends ITreeMapEventArgs {
    /** Defines the current TreeMap instance */
    treemap: TreeMap;
    /**
     * Define the current item move.
     */
    item: Object;
    /**
     * Define the mouse event.
     */
    mouseEvent: PointerEvent;
}
export interface IClickEventArgs extends ITreeMapEventArgs {
    /** Defines the current TreeMap instance */
    treemap: TreeMap;
    /**
     * Define the mouse event.
     */
    mouseEvent: PointerEvent;
}
export interface IMouseMoveEventArgs extends ITreeMapEventArgs {
    /** Defines the current TreeMap instance */
    treemap: TreeMap;
    /**
     * Define the mouse event.
     */
    mouseEvent: PointerEvent;
}
export interface IItemSelectedEventArgs extends ITreeMapEventArgs {
    /** Defines the current TreeMap instance */
    treemap: TreeMap;
    /**
     * Define the current item selected.
     */
    items: Object[];
    /**
     * Define the current element of selected.
     */
    elements: Element[];
}
export interface IItemHighlightEventArgs extends ITreeMapEventArgs {
    /** Defines the current TreeMap instance */
    treemap: TreeMap;
    /**
     * Define the current item highlight.
     */
    items: Object[];
    /**
     * Define the current element of highlight.
     */
    elements: Element[];
}
export interface ITreeMapTooltipRenderEventArgs extends ITreeMapEventArgs {
    /** Defines the current TreeMap instance */
    treemap: TreeMap;
    /**
     * Define the current tooltip item.
     */
    item: Object;
    /**
     * Define the tooltip options.
     */
    options: Object;
    /**
     * Define the current tooltip element.
     */
    element: Element;
    /**
     * Define the mouse location.
     */
    eventArgs: PointerEvent;
}
/**
 * Specifies legendRendering event arguments for maps.
 */
export interface ILegendItemRenderingEventArgs extends ITreeMapEventArgs {
    /**
     * maps instance event argument
     */
    treemap?: TreeMap;
    /**
     * Specifies the legend shape color
     */
    fill?: string;
    /**
     * Options for customizing the color and width of the shape border.
     */
    shapeBorder?: BorderModel;
    /**
     * Customize the legend shape of the maps.
     */
    shape?: LegendShape;
    /**
     * Customize the image url.
     */
    imageUrl: string;
}
/**
 * TreeMap Resize event arguments.
 */
export interface IResizeEventArgs extends ITreeMapEventArgs {
    /** Defines the previous size of the treemap */
    previousSize: Size;
    /** Defines the current size of the treemap */
    currentSize: Size;
    /** Defines the treemap instance */
    treemap: TreeMap;
}
/** @private */
export interface IFontMapping {
    size?: string;
    color?: string;
    fontWeight?: string;
    fontStyle?: string;
    fontFamily?: string;
}
/** @private */
export interface IShapes {
    renderOption?: Object;
    functionName?: string;
}
/**
 * Maps Themes doc
 */
export  namespace Theme {
    /** @private */
    let mapsTitleFont: IFontMapping;
}
/**
 * Interface for a class TreeMap
 */
export interface TreeMapModel extends base.ComponentModel{
    /**
     * Specifies the width by given pixel or percentage.
     * @default null
     */
    width?: string;
    /**
     * Specifies the height by given pixel or percentage.
     * @default null
     */
    height?: string;
    /**
     * Specifies the border of tree map.
     */
    border?: BorderModel;
    /**
     * Specifies the margin to move the render area.
     */
    margin?: MarginModel;
    /**
     * Specifies the background.
     */
    background?: string;
    /**
     * Specifies the theme.
     */
    theme?: TreeMapTheme;
    /**
     * Specifies the title for tree map.
     */
    titleSettings?: TitleSettingsModel;
    /**
     * Specifies the rendering of layout type.
     */
    layoutType?: LayoutMode;
    /**
     * Specifies the dataSource.
     * @default null
     */
    dataSource?: data.DataManager | TreeMapAjax | Object[];
    /**
     * Specifies the query for filter the data.
     * @default null
     */
    query?: data.Query;
    /**
     * Specifies the weight value path
     */
    weightValuePath?: string;
    /**
     * Specifies the colorValuePath
     */
    rangeColorValuePath?: string;
    /**
     * Specifies the colorValuePath
     */
    equalColorValuePath?: string;
    /**
     * Specifies the palette colors.
     */
    palette?: string[];
    /**
     * To enable or disable the drillDown.
     */
    enableDrillDown?: boolean;
    /**
     * Specifies the initial drillDown.
     */
    initialDrillDown?: InitialDrillSettingsModel;
    /**
     * Specifies to access all leaf items in levels.
     */
    leafItemSettings?: LeafItemSettingsModel;
    /**
     * Specifies the item levels.
     */
    levels?: LevelSettingsModel[];
    /**
     * To specifies the highlight settings.
     */
    highlightSettings?: HighlightSettingsModel;
    /**
     * To specifies the selection settings.
     */
    selectionSettings?: SelectionSettingsModel;
    /**
     * Specifies the tooltip settings.
     */
    tooltipSettings?: TooltipSettingsModel;
    /**
     * Specifies the legend settings.
     */
    legendSettings?: LegendSettingsModel;
    /**
     * To enable the separator
     * @default false
     */
    useGroupingSeparator?: boolean;
    /**
     * Description for maps.
     * @default null
     */
    description?: string;
    /**
     * TabIndex value for treemap.
     * @default 1
     */
    tabIndex?: number;
    /**
     * To apply internationalization for treemap
     * @default null
     */
    format?: string;
    /**
     * Triggers before treemap rendered.
     * @event
     */
    load?: base.EmitType<ILoadEventArgs>;
    /**
     * Triggers before the prints gets started.
     * @event
     */
    beforePrint?: base.EmitType<IPrintEventArgs>;
    /**
     * Triggers after treemap rendered.
     * @event
     */
    loaded?: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers before item rendering.
     * @event
     */
    itemRendering?: base.EmitType<IItemRenderingEventArgs>;
    /**
     * Triggers the drillDown start.
     * @event
     */
    drillStart?: base.EmitType<IDrillStartEventArgs>;
    /**
     * Triggers the drillDown end.
     * @event
     */
    drillEnd?: base.EmitType<IDrillEndEventArgs>;
    /**
     * Triggers the item selected.
     * @event
     */
    itemSelected?: base.EmitType<IItemSelectedEventArgs>;
    /**
     * Triggers the item highlight.
     * @event
     */
    itemHighlight?: base.EmitType<IItemHighlightEventArgs>;
    /**
     * Triggers the tooltip rendering.
     * @event
     */
    tooltipRendering?: base.EmitType<ITreeMapTooltipRenderEventArgs>;
    /**
     * Triggers the item click.
     * @event
     */
    itemClick?: base.EmitType<IItemClickEventArgs>;
    /**
     * Triggers the item move.
     * @event
     */
    itemMove?: base.EmitType<IItemMoveEventArgs>;
    /**
     * Triggers the click event.
     * @event
     */
    click?: base.EmitType<IItemClickEventArgs>;
    /**
     * Triggers the mouse move event.
     * @event
     */
    mouseMove?: base.EmitType<IMouseMoveEventArgs>;
    /**
     * Triggers the resize event.
     * @event
     */
    resize?: base.EmitType<IResizeEventArgs>;
}
/**
 * Tree Map base.Component
 */
/**
 * Represents the TreeMap control.
 * ```html
 * <div id="container"/>
 * <script>
 *   var treemap = new TreeMap();
 *   treemap.appendTo("#container");
 * </script>
 * ```
 */
export  class TreeMap extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
    /**
     * `tooltipModule` is used to render the treemap tooltip.
     */
    treeMapTooltipModule: TreeMapTooltip;
    /**
     * `highlightModule` is used for highlight the items.
     */
    treeMapHighlightModule: TreeMapHighlight;
    /**
     * `selectionModule` is used for select the items.
     */
    treeMapSelectionModule: TreeMapSelection;
    /**
     * `legendModule` is used for render the legend items.
     */
    treeMapLegendModule: TreeMapLegend;
    /**
     * Specifies the width by given pixel or percentage.
     * @default null
     */
    width: string;
    /**
     * Specifies the height by given pixel or percentage.
     * @default null
     */
    height: string;
    /**
     * Specifies the border of tree map.
     */
    border: BorderModel;
    /**
     * Specifies the margin to move the render area.
     */
    margin: MarginModel;
    /**
     * Specifies the background.
     */
    background: string;
    /**
     * Specifies the theme.
     */
    theme: TreeMapTheme;
    /**
     * Specifies the title for tree map.
     */
    titleSettings: TitleSettingsModel;
    /**
     * Specifies the rendering of layout type.
     */
    layoutType: LayoutMode;
    /**
     * Specifies the dataSource.
     * @default null
     */
    dataSource: data.DataManager | TreeMapAjax | Object[];
    /**
     * Specifies the query for filter the data.
     * @default null
     */
    query: data.Query;
    /**
     * Specifies the weight value path
     */
    weightValuePath: string;
    /**
     * Specifies the colorValuePath
     */
    rangeColorValuePath: string;
    /**
     * Specifies the colorValuePath
     */
    equalColorValuePath: string;
    /**
     * Specifies the palette colors.
     */
    palette: string[];
    /**
     * To enable or disable the drillDown.
     */
    enableDrillDown: boolean;
    /**
     * Specifies the initial drillDown.
     */
    initialDrillDown: InitialDrillSettingsModel;
    /**
     * Specifies to access all leaf items in levels.
     */
    leafItemSettings: LeafItemSettingsModel;
    /**
     * Specifies the item levels.
     */
    levels: LevelSettingsModel[];
    /**
     * To specifies the highlight settings.
     */
    highlightSettings: HighlightSettingsModel;
    /**
     * To specifies the selection settings.
     */
    selectionSettings: SelectionSettingsModel;
    /**
     * Specifies the tooltip settings.
     */
    tooltipSettings: TooltipSettingsModel;
    /**
     * Specifies the legend settings.
     */
    legendSettings: LegendSettingsModel;
    /**
     * To enable the separator
     * @default false
     */
    useGroupingSeparator: boolean;
    /**
     * Description for maps.
     * @default null
     */
    description: string;
    /**
     * TabIndex value for treemap.
     * @default 1
     */
    tabIndex: number;
    /**
     * To apply internationalization for treemap
     * @default null
     */
    format: string;
    /**
     * Triggers before treemap rendered.
     * @event
     */
    load: base.EmitType<ILoadEventArgs>;
    /**
     * Triggers before the prints gets started.
     * @event
     */
    beforePrint: base.EmitType<IPrintEventArgs>;
    /**
     * Triggers after treemap rendered.
     * @event
     */
    loaded: base.EmitType<ILoadedEventArgs>;
    /**
     * Triggers before item rendering.
     * @event
     */
    itemRendering: base.EmitType<IItemRenderingEventArgs>;
    /**
     * Triggers the drillDown start.
     * @event
     */
    drillStart: base.EmitType<IDrillStartEventArgs>;
    /**
     * Triggers the drillDown end.
     * @event
     */
    drillEnd: base.EmitType<IDrillEndEventArgs>;
    /**
     * Triggers the item selected.
     * @event
     */
    itemSelected: base.EmitType<IItemSelectedEventArgs>;
    /**
     * Triggers the item highlight.
     * @event
     */
    itemHighlight: base.EmitType<IItemHighlightEventArgs>;
    /**
     * Triggers the tooltip rendering.
     * @event
     */
    tooltipRendering: base.EmitType<ITreeMapTooltipRenderEventArgs>;
    /**
     * Triggers the item click.
     * @event
     */
    itemClick: base.EmitType<IItemClickEventArgs>;
    /**
     * Triggers the item move.
     * @event
     */
    itemMove: base.EmitType<IItemMoveEventArgs>;
    /**
     * Triggers the click event.
     * @event
     */
    click: base.EmitType<IItemClickEventArgs>;
    /**
     * Triggers the mouse move event.
     * @event
     */
    mouseMove: base.EmitType<IMouseMoveEventArgs>;
    /**
     * Triggers the resize event.
     * @event
     */
    resize: base.EmitType<IResizeEventArgs>;
    /**
     * svg renderer object.
     * @private
     */
    renderer: base.SvgRenderer;
    /**
     * treemap svg element object
     * @private
     */
    svgObject: Element;
    /**
     *  Stores the exact size of treemap.
     * @private
     */
    availableSize: Size;
    /**
     * Internal use of internationalization instance.
     * @private
     */
    intl: base.Internationalization;
    /**
     * @private
     * Stores the area bounds.
     */
    areaRect: Rect;
    /** @private */
    levelsOfData: Object[];
    /** @private */
    layout: LayoutPanel;
    /** @private */
    orientation: string;
    /** @private */
    drilledItems: Object[];
    /** @private */
    isHierarchicalData: boolean;
    /** @private */
    private resizeTo;
    /** @private */
    private hierarchyData;
    /**s
     * Constructor for TreeMap component.
     */
    constructor(options?: TreeMapModel, element?: string | HTMLElement);
    protected preRender(): void;
    protected render(): void;
    private processDataManager();
    private renderTreeMapElements();
    protected createSvg(): void;
    /**
     * To initilize the private varibales of treemap.
     */
    private initPrivateVariable();
    /**
     * To change font styles of map based on themes
     */
    private themeEffect();
    private setTextStyle(color);
    private createSecondaryElement();
    private elementChange();
    /**
     * @private
     * Render the treemap border
     */
    private renderBorder();
    private renderTitle(title, type, bounds, groupEle);
    protected processingData(): void;
    private checkIsHierarchicalData();
    private processHierarchicalData(data, dataCount);
    /**
     * Handles the print method for chart control.
     */
    print(id?: string[] | string | Element): void;
    /**
     * Handles the export method for chart control.
     * @param type
     * @param fileName
     */
    export(type: ExportType, fileName: string, orientation?: pdfexport.PdfPageOrientation): void;
    private processFlatJsonData();
    reOrderLevelData(start: number): void;
    findTotalWeight(processData: Object[], type: string): void;
    /**
     * To unbind event handlers for treemap.
     */
    private unWireEVents();
    /**
     * To bind event handlers for treemap.
     */
    private wireEVents();
    /**
     * Method to set culture for maps
     */
    private setCulture();
    /**
     * To add tab index for treemap element
     */
    private addTabIndex();
    /**
     * To handle the window resize event on treemap.
     */
    resizeOnTreeMap(e: Event): void;
    clickOnTreeMap(e: PointerEvent): void;
    mouseDownOnTreeMap(e: PointerEvent): void;
    mouseMoveOnTreeMap(e: PointerEvent): void;
    mouseEndOnTreeMap(e: PointerEvent): void;
    mouseLeaveOnTreeMap(e: PointerEvent): void;
    /**
     * To provide the array of modules needed for maps rendering
     * @return {base.ModuleDeclaration[]}
     * @private
     */
    requiredModules(): base.ModuleDeclaration[];
    onPropertyChanged(newProp: TreeMapModel, oldProp: TreeMapModel): void;
    /**
     * Get component name
     */
    getModuleName(): string;
    /**
     * To destroy the treemap control.
     */
    destroy(): void;
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    getPersistData(): string;
}
/**
 * Performing treemap highlight
 */
export  class TreeMapHighlight {
    private treemap;
    private highLightId;
    constructor(treeMap: TreeMap);
    mouseMove(e: PointerEvent): boolean;
    /**
     * To bind events for highlight
     */
    private addEventListener();
    /**
     * To unbind events for highlight
     */
    private removeEventListener();
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the hightlight.
     * @return {void}
     * @private
     */
    destroy(treeMap: TreeMap): void;
}
export  class TreeMapSelection {
    private treemap;
    private selectionId;
    constructor(treeMap: TreeMap);
    mouseDown(e: PointerEvent): void;
    /**
     * To bind events for selection
     */
    private addEventListener();
    /**
     * To unbind events for selection
     */
    private removeEventListener();
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the selection.
     * @return {void}
     * @private
     */
    destroy(treeMap: TreeMap): void;
}
/**
 * Render Tooltip
 */
export  class TreeMapTooltip {
    private treemap;
    private tooltipSettings;
    private svgTooltip;
    private isTouch;
    private tooltipId;
    private currentTime;
    private clearTimeout;
    constructor(treeMap: TreeMap);
    renderTooltip(e: PointerEvent): void;
    mouseUpHandler(e: PointerEvent): void;
    removeTooltip(): void;
    /**
     * To bind events for tooltip module
     */
    addEventListener(): void;
    /**
     * To unbind events for tooltip module
     */
    removeEventListener(): void;
    /**
     * Get module name.
     */
    protected getModuleName(): string;
    /**
     * To destroy the tooltip.
     * @return {void}
     * @private
     */
    destroy(treeMap: TreeMap): void;
}
/**
 * Specifies the enum values for tree map components.
 */
/**
 * Specifies the types of label position.
 */
export  type LabelPosition = 'TopLeft' | 'TopCenter' | 'TopRight' | 'CenterLeft' | 'Center' | 'CenterRight' | 'BottomLeft' | 'BottomCenter' | 'BottomRight';
/**
 * Specifies the types of layout rendering modes.
 */
export  type LayoutMode = 'Squarified' | 'SliceAndDiceHorizontal' | 'SliceAndDiceVertical' | 'SliceAndDiceAuto';
/**
 * Defines the Alignment.
 */
export  type Alignment = 'Near' | 'Center' | 'Far';
/**
 * Defines the highlight mode.
 */
export  type HighLightMode = 'Item' | 'Child' | 'Parent' | 'All';
/**
 * Defines the highlight mode.
 */
export  type SelectionMode = 'Item' | 'Child' | 'Parent' | 'All';
export  type ExportType = 'PNG' | 'JPEG' | 'SVG' | 'PDF';
/**
 * labelAlignment
 */
export  type LabelAlignment = 'Trim' | 'Hide' | 'WrapByWord' | 'Wrap';
/**
 * Defines the shape of legend.
 */
export  type LegendShape = 'Circle' | 'Rectangle' | 'Triangle' | 'Diamond' | 'Cross' | 'Star' | 'HorizontalLine' | 'VerticalLine' | 'Pentagon' | 'InvertedTriangle' | 'Image';
/**
 * Defines the position of the legend. They are
 * * top - Displays the legend on the top.
 * * left - Displays the legend on the left.
 * * bottom - Displays the legend on the bottom.
 * * right - Displays the legend on the right.
 * * float - Displays the legend  based on given x and y value.
 */
export  type LegendPosition = 'Top' | 'Left' | 'Bottom' | 'Right' | 'Float';
/**
 * Defines the Legend modes. They are
 * * Default - Specifies the Default mode.
 * * interactive - specifies the Interactive mode.
 */
export  type LegendMode = 'Default' | 'Interactive';
/**
 * Defines the legend arrangement
 */
export  type LegendOrientation = 'None' | 'Horizontal' | 'Vertical';
/**
 * Defines the label intersect action types
 */
export  type LabelIntersectAction = 'None' | 'Trim' | 'Hide';
/**
 * Defines the label placement type
 */
export  type LabelPlacement = 'Before' | 'After';
/**
 * Defines Theme. They are
 * * Material - Render a treemap with Material theme.
 * * Fabric - Render a treemap with Fabric theme
 * * Bootstrap - Render a treemap with Bootstrap theme
 */
export  type TreeMapTheme = 'Material' | 'Fabric' | 'Highcontrast' | 'Bootstrap';
/**
 * Annotation Module handles the Annotation for Maps
 */
export  class ExportUtils {
    private control;
    private printWindow;
    /**
     * Constructor for Maps
     * @param control
     */
    constructor(control: TreeMap);
    /**
     * To print the Maps
     * @param elements
     */
    print(elements?: string[] | string | Element): void;
    /**
     * To get the html string of the Maps
     * @param elements
     * @private
     */
    getHTMLContent(elements?: string[] | string | Element): Element;
    /**
     * To export the file as image/svg format
     * @param type
     * @param fileName
     */
    export(type: ExportType, fileName: string, orientation?: pdfexport.PdfPageOrientation): void;
    /**
     * To trigger the download element
     * @param fileName
     * @param type
     * @param url
     */
    triggerDownload(fileName: string, type: ExportType, url: string, isDownload: boolean): void;
}
/**
 * Create the class for size
 * @private
 */
export  class Size {
    height: number;
    width: number;
    constructor(width: number, height: number);
}
export  function stringToNumber(value: string, containerSize: number): number;
/**
 * Internal use of type rect
 * @private
 */
export  class Rect {
    x: number;
    y: number;
    height: number;
    width: number;
    constructor(x: number, y: number, width: number, height: number);
}
/**
 * Internal use of rectangle options
 * @private
 */
export  class RectOption {
    id: string;
    fill: string;
    x: number;
    y: number;
    height: number;
    width: number;
    opacity: number;
    stroke: string;
    ['stroke-width']: number;
    ['stroke-dasharray']: string;
    constructor(id: string, fill: string, border: BorderModel, opacity: number, rect: Rect, dashArray?: string);
}
export  class PathOption {
    id: string;
    opacity: number;
    fill: string;
    stroke: string;
    ['stroke-width']: number;
    ['stroke-dasharray']: string;
    d: string;
    constructor(id: string, fill: string, width: number, color: string, opacity?: number, dashArray?: string, d?: string);
}
/**
 * Function to measure the height and width of the text.
 * @param  {string} text
 * @param  {FontModel} font
 * @param  {string} id
 * @returns no
 * @private
 */
export  function measureText(text: string, font: FontModel): Size;
/**
 * Internal use of text options
 * @private
 */
export  class TextOption {
    anchor: string;
    id: string;
    transform: string;
    x: number;
    y: number;
    text: string | string[];
    baseLine: string;
    constructor(id?: string, x?: number, y?: number, anchor?: string, text?: string | string[], transform?: string, baseLine?: string);
}
/**
 * @private
 * Trim the title text
 */
export  function textTrim(maxWidth: number, text: string, font: FontModel): string;
/**
 * Map internal class for Point
 */
export  class Location {
    x: number;
    y: number;
    constructor(x: number, y: number);
}
/**
 * Method to calculate x position of title
 */
export  function findPosition(location: Rect, alignment: Alignment, textSize: Size, type: string): Location;
/**
 * Internal rendering of text
 * @private
 */
export  function renderTextElement(options: TextOption, font: FontModel, color: string, parent: HTMLElement | Element, isMinus?: boolean): Element;
export  function getElement(id: string): Element;
export  function itemsToOrder(a: Object, b: Object): number;
export  function isContainsData(source: string[], pathName: string, processData: Object, treemap: TreeMap): boolean;
export  function findChildren(data: Object): Object;
export  function findHightLightItems(data: Object, items: string[], mode: string, treeMap: TreeMap): string[];
/**
 * Function to compile the template function for maps.
 * @returns Function
 * @private
 */
export  function getTemplateFunction(template: string): Function;
/**
 * @private
 */
export  function convertElement(element: HTMLCollection, labelId: string, data: Object): HTMLElement;
export  function findLabelLocation(rect: Rect, position: LabelPosition, labelSize: Size, type: string, treemap: TreeMap): Location;
export  function measureElement(element: HTMLElement, parentElement: HTMLElement): Size;
export  function getArea(rect: Rect): number;
export  function getShortestEdge(input: Rect): number;
export  function convertToContainer(rect: Rect): Rect;
export  function convertToRect(container: Rect): Rect;
export  function getMousePosition(pageX: number, pageY: number, element: Element): Location;
export  function colorMap(colorMapping: ColorMappingModel[], equalValue: string, value: number | string, weightValuePath: number): object;
export  function deSaturationColor(weightValuePath: number, colorMapping: ColorMappingModel, color: string, rangeValue: number): string;
export  function wordWrap(maximumWidth: number, dataLabel: string, font: FontModel): string[];
export  function textWrap(maxWidth: number, label: string, font: FontModel): string[];
/**
 * hide function
 */
export  function hide(maxWidth: number, maxHeight: number, text: string, font: FontModel): string;
export  function orderByArea(a: number, b: number): number;
export  function removeClassNames(elements: HTMLCollection, type: string, treemap: TreeMap): void;
export  function applyOptions(element: SVGPathElement, options: Object): void;
export  function textFormatter(format: string, data: object, treemap: TreeMap): string;
export  function formatValue(value: number, treemap: TreeMap): string | number;
/** @private */
export  class ColorValue {
    r: number;
    g: number;
    b: number;
    constructor(r?: number, g?: number, b?: number);
}
/** @private */
export  function convertToHexCode(value: ColorValue): string;
/** @private */
export  function componentToHex(value: number): string;
/** @private */
export  function convertHexToColor(hex: string): ColorValue;
/** @private */
export  function colorNameToHex(color: string): string;
/** @private */
export  function drawSymbol(location: Location, shape: string, size: Size, url: string, options: PathOption, label: string): Element;
/** @private */
export  function renderLegendShape(location: Location, size: Size, shape: string, options: PathOption, url: string): IShapes;
export  function isParentItem(data: Object[], item: Object): boolean;
export  class TreeMapAjax {
    dataOptions: string | Object;
    type: string;
    async: boolean;
    contentType: string;
    sendData: string | Object;
    constructor(options: string | Object, type?: string, async?: boolean, contentType?: string, sendData?: string | Object);
}
 }
 export namespace inputs { 
    /**
     * Interface for a class ColorPicker
     */
    export interface ColorPickerModel extends base.ComponentModel{
        /**
         * It is used to set the color value for ColorPicker. It should be specified as Hex code.
         * @default '#008000'
         */
        value?: string;
        /**
         * This property sets the CSS classes to root element of the ColorPicker
         *  which helps to customize the UI styles.
         * @default ''
         */
        cssClass?: string;
        /**
         * It is used to enable / disable ColorPicker component. If it is disabled the ColorPicker popup won’t open.
         * @default false
         */
        disabled?: boolean;
        /**
         * It is used to render the ColorPicker component from right to left direction.
         * @default false
         */
        enableRtl?: boolean;
        /**
         * It is used to render the ColorPicker with the specified mode.
         * @default 'Picker'
         */
        mode?: ColorPickerMode;
        /**
         * It is used to show / hide the mode switcher button of ColorPicker component.
         * @default true
         */
        modeSwitcher?: boolean;
        /**
         * It is used to load custom colors to palette.
         * @default null
         */
        presetColors?: { [key: string]: string[] };
        /**
         * It is used to show / hide the control buttons (apply / cancel) of  ColorPicker component.
         * @default true
         */
        showButtons?: boolean;
        /**
         * It is used to render the ColorPicker palette with specified columns.
         * @default 10
         */
        columns?: number;
        /**
         * It is used to render the ColorPicker component as inline (flat).
         * @default false
         */
        inline?: boolean;
        /**
         * It is used to enable / disable the no color option of ColorPicker component.
         * @default false
         */
        noColor?: boolean;
        /**
         * To enable or disable persisting component's state between page reloads and it is extended from component class.
         * @default false
         */
        enablePersistence?: boolean;
        /**
         * Triggers while selecting the color in picker / palette, when showButtons property is enabled.
         * @event
         */
        select?: base.EmitType<ColorPickerEventArgs>;
        /**
         * Triggers while changing the colors. It will be triggered based on the showButtons property.
         * If the property is false, the event will be triggered while selecting the colors.
         * If the property is true, the event will be triggered while apply the selected color.
         * @event
         */
        change?: base.EmitType<ColorPickerEventArgs>;
        /**
         * Trigger while rendering each palette tile.
         * @event
         */
        beforeTileRender?: base.EmitType<PaletteTileEventArgs>;
        /**
         * Triggers before opening the ColorPicker popup.
         * @event
         */
        beforeOpen?: base.EmitType<BeforeOpenCloseEventArgs>;
        /**
         * Triggers while opening the ColorPicker popup.
         * @event
         */
        open?: base.EmitType<OpenEventArgs>;
        /**
         * Triggers before closing the ColorPicker popup.
         * @event
         */
        beforeClose?: base.EmitType<BeforeOpenCloseEventArgs>;
        /**
         * Triggers before Switching between ColorPicker mode.
         * @event
         */
        beforeModeSwitch?: base.EmitType<ModeSwitchEventArgs>;
    }
    /**
     * ColorPicker Mode
     */
    export  type ColorPickerMode = 'Picker' | 'Palette';
    /**
     * ColorPicker component is a user interface to select and adjust color values. It provides supports for various
     * color specification like Red Green Blue, Hue Saturation Value and Hex codes.
     * ```html
     * <input type="color" id="color-picker">
     * ```
     * ```typescript
     * <script>
     *   let colorPickerObj: ColorPicker = new ColorPicker(null , "#color-picker");
     * </script>
     * ```
     */
    export  class ColorPicker extends base.Component<HTMLInputElement> implements base.INotifyPropertyChanged {
        private splitBtn;
        private hueSlider;
        private opacitySlider;
        private tooltipEle;
        private container;
        private modal;
        private l10n;
        private tileRipple;
        private ctrlBtnRipple;
        private clientX;
        private clientY;
        private rgb;
        private hsv;
        /**
         * It is used to set the color value for ColorPicker. It should be specified as Hex code.
         * @default '#008000'
         */
        value: string;
        /**
         * This property sets the CSS classes to root element of the ColorPicker
         *  which helps to customize the UI styles.
         * @default ''
         */
        cssClass: string;
        /**
         * It is used to enable / disable ColorPicker component. If it is disabled the ColorPicker popup won’t open.
         * @default false
         */
        disabled: boolean;
        /**
         * It is used to render the ColorPicker component from right to left direction.
         * @default false
         */
        enableRtl: boolean;
        /**
         * It is used to render the ColorPicker with the specified mode.
         * @default 'Picker'
         */
        mode: ColorPickerMode;
        /**
         * It is used to show / hide the mode switcher button of ColorPicker component.
         * @default true
         */
        modeSwitcher: boolean;
        /**
         * It is used to load custom colors to palette.
         * @default null
         */
        presetColors: {
            [key: string]: string[];
        };
        /**
         * It is used to show / hide the control buttons (apply / cancel) of  ColorPicker component.
         * @default true
         */
        showButtons: boolean;
        /**
         * It is used to render the ColorPicker palette with specified columns.
         * @default 10
         */
        columns: number;
        /**
         * It is used to render the ColorPicker component as inline (flat).
         * @default false
         */
        inline: boolean;
        /**
         * It is used to enable / disable the no color option of ColorPicker component.
         * @default false
         */
        noColor: boolean;
        /**
         * To enable or disable persisting component's state between page reloads and it is extended from component class.
         * @default false
         */
        enablePersistence: boolean;
        /**
         * Triggers while selecting the color in picker / palette, when showButtons property is enabled.
         * @event
         */
        select: base.EmitType<ColorPickerEventArgs>;
        /**
         * Triggers while changing the colors. It will be triggered based on the showButtons property.
         * If the property is false, the event will be triggered while selecting the colors.
         * If the property is true, the event will be triggered while apply the selected color.
         * @event
         */
        change: base.EmitType<ColorPickerEventArgs>;
        /**
         * Trigger while rendering each palette tile.
         * @event
         */
        beforeTileRender: base.EmitType<PaletteTileEventArgs>;
        /**
         * Triggers before opening the ColorPicker popup.
         * @event
         */
        beforeOpen: base.EmitType<BeforeOpenCloseEventArgs>;
        /**
         * Triggers while opening the ColorPicker popup.
         * @event
         */
        open: base.EmitType<OpenEventArgs>;
        /**
         * Triggers before closing the ColorPicker popup.
         * @event
         */
        beforeClose: base.EmitType<BeforeOpenCloseEventArgs>;
        /**
         * Triggers before Switching between ColorPicker mode.
         * @event
         */
        beforeModeSwitch: base.EmitType<ModeSwitchEventArgs>;
        constructor(options?: ColorPickerModel, element?: string | HTMLInputElement);
        protected preRender(): void;
        /**
         * To Initialize the component rendering
         * @private
         */
        render(): void;
        private initWrapper();
        private getWrapper();
        private createWidget();
        private createSplitBtn();
        private onOpen(args);
        private getPopupInst();
        private beforeOpenFn(args);
        private popupClose(args);
        private createPalette();
        private firstPaletteFocus();
        private appendPalette(colors, key, refEle?);
        private setNoColor();
        private appendElement(ele, insertPos?);
        private addTileSelection(ele);
        private createPicker();
        private setHsvContainerBg(h?);
        private getHsvContainer();
        private setHandlerPosition();
        private createSlider();
        private updateOpacitySliderBg();
        private hueChange(args);
        private opacityChange(args);
        private createPreview(parentEle?);
        private isPicker();
        private getPopupEle();
        private getNumericTextBoxModel(value, label, max);
        private createInput(child?);
        private createCtrlBtn();
        private appendModeSwitchBtn();
        private createDragTooltip();
        private getTooltipInst();
        private setTooltipOffset(value);
        private toggleDisabled(enable);
        private convertToRgbString(rgb);
        private convertToHsvString(hsv);
        private updateHsv();
        private convertToOtherFormat(isKey?);
        private updateInput(value);
        private updatePreview(value);
        private getDragHandler();
        private removeTileSelection();
        private convertRgbToNumberArray(value);
        /**
         * To get color value in specified type.
         * @param value - Specify the color value.
         * @param type - Specify the converted color value type.
         * @method getValue
         * @return {string}
         */
        getValue(value?: string, type?: string): string;
        /**
         * To show/hide ColorPicker popup based on current state of the SplitButton.
         * @method toggle
         * @return {void}
         */
        toggle(): void;
        /**
         * Get component name.
         * @returns string
         * @private
         */
        getModuleName(): string;
        /**
         * Gets the properties to be maintained in the persisted state.
         * @return {string}
         */
        getPersistData(): string;
        protected wireEvents(): void;
        private addCtrlSwitchEvent();
        private addInputEvent();
        private addvalueEventHandler();
        private pickerKeyDown(e);
        private enterKeyHandler(value);
        private triggerChangeEvent(value);
        private handlerDragPosition(prob, value, e);
        private handlerDown(e);
        private handlerMove(e);
        private setHsv(clientX, clientY);
        private handlerEnd(e);
        private btnClickHandler(e);
        private switchToPalette();
        private refreshPopupPos();
        private formatSwitchHandler(e);
        private updateValue(value, format, idx?, max?);
        private previewHandler(e);
        private paletteClickHandler(e);
        private noColorTile(isKey?);
        private switchToPicker();
        private ctrlBtnClick(ele);
        private paletteKeyDown(e);
        private keySelectionChanges(newEle);
        private tilePosition(items, element, cIdx);
        private inputHandler(e);
        private inputValueChange(hsv, pValue, value?);
        private triggerEvent(cValue, pValue, rgba, isKey?);
        /**
         * Removes the component from the DOM and detaches all its related event handlers.
         * Also it maintains the initial input element from the DOM.
         * @method destroy
         * @return {void}
         */
        destroy(): void;
        private destroyOtherComp();
        private isPopupOpen();
        protected unWireEvents(): void;
        private roundValue(value);
        private hexToRgb(hex);
        private rgbToHsv(r, g, b, opacity?);
        private hsvToRgb(h, s, v, opacity?);
        private rgbToHex(rgb);
        private hex(x);
        private changeModeSwitcherProp(prop);
        private changeShowBtnProps(prop);
        private changeValueProp(newProp);
        private setInputEleProps(prop);
        private changeDisabledProp(newProp);
        private changeCssClassProps(newProp, oldProp);
        private changeRtlProps(newProp);
        private changePaletteProps();
        /**
         * Called internally if any of the property value changed.
         * @param  {ColorPickerModel} newProp
         * @param  {ColorPickerModel} oldProp
         * @returns void
         * @private
         */
        onPropertyChanged(newProp: ColorPickerModel, oldProp: ColorPickerModel): void;
    }
    /**
     * Interface for change / select event.
     * @private
     */
    export interface ColorPickerEventArgs extends base.BaseEventArgs {
        currentValue: {
            hex: string;
            rgba: string;
        };
        previousValue: {
            hex: string;
            rgba: string;
        };
    }
    /**
     * Interface for before change event.
     * @private
     */
    export interface PaletteTileEventArgs extends base.BaseEventArgs {
        element: HTMLElement;
        presetName: string;
        value: string;
    }
    /**
     * Interface for before open / close event.
     * @private
     */
    export interface BeforeOpenCloseEventArgs extends base.BaseEventArgs {
        element: HTMLElement;
        event: Event;
        cancel: boolean;
    }
    /**
     * Interface for open event.
     * @private
     */
    export interface OpenEventArgs extends base.BaseEventArgs {
        element: HTMLElement;
    }
    /**
     * Interface for mode switching event.
     * @private
     */
    export interface ModeSwitchEventArgs extends base.BaseEventArgs {
        element: HTMLElement;
        mode: string;
    }
    /**
     * ColorPicker modules
     */
    /**
     * Interface for a class FormValidator
     */
    export interface FormValidatorModel {
        /**
         * Ignores input fields based on the class name
         * @default 'e-hidden';
         */
        ignore?: string;
        /**
         * Maps the input fields with validation rules
         * @default {};
         */
        rules?: { [name: string]: { [rule: string]: Object } };
        /**
         * Sets the defined css class to error fields 
         * @default 'e-error';
         */
        errorClass?: string;
        /**
         * Sets the defined css class to valid fields 
         * @default : 'e-valid';
         */
        validClass?: string;
        /**
         * Specify HTML element for error
         * @default : 'label';
         */
        errorElement?: string;
        /**
         * Specify HTML element for error container 
         * @default : 'div';
         */
        errorContainer?: string;
        /**
         * Option to display the error
         * @default : ErrorOption.Label;
         */
        errorOption?: ErrorOption;
        /**
         * Triggers when a field's focused  out
         * @event
         */
        focusout?: base.EmitType<Event>;
        /**
         * Trigger when keyup is triggered in any fields
         * @event
         */
        keyup?: base.EmitType<KeyboardEvent>;
        /**
         * Triggers when a check box field is clicked
         * @event
         */
        click?: base.EmitType<Event>;
        /**
         * Trigger when a base.select/drop-down field is changed
         * @event
         */
        change?: base.EmitType<Event>;
        /**
         * Triggers before form is being submitted
         * @event
         */
        submit?: base.EmitType<Event>;
        /**
         * Triggers before validation starts
         * @event
         */
        validationBegin?: base.EmitType<Object>;
        /**
         * Triggers after validation is completed
         * @event
         */
        validationComplete?: base.EmitType<Object>;
        /**
         * Assigns the custom function to place the error message in the page.
         * @event
         */
        customPlacement?: base.EmitType<Object>;
    }
    /**
     * ErrorOption values
     * @private
     */
    export  enum ErrorOption {
        Message = 0,
        Label = 1,
    }
    /**
     * FormValidator class enables you to validate the form fields based on your defined rules
     * ```html
     * <form id='formId'>
     *  <input type='text' name='Name' />
     *  <input type='text' name='Age' />
     * </form>
     * <script>
     *   let formObject = new FormValidator('#formId', {
     *      rules: { Name: { required: true }, Age: { range: [18, 30] } };
     *   });
     *   formObject.validate();
     * </script>
     * ```
     */
    export  class FormValidator extends base.Base<HTMLFormElement> implements base.INotifyPropertyChanged {
        private validated;
        private errorRules;
        private allowSubmit;
        private required;
        private infoElement;
        private inputElement;
        private selectQuery;
        private inputElements;
        /**
         * Ignores input fields based on the class name
         * @default 'e-hidden';
         */
        ignore: string;
        /**
         * Maps the input fields with validation rules
         * @default {};
         */
        rules: {
            [name: string]: {
                [rule: string]: Object;
            };
        };
        /**
         * Sets the defined css class to error fields
         * @default 'e-error';
         */
        errorClass: string;
        /**
         * Sets the defined css class to valid fields
         * @default : 'e-valid';
         */
        validClass: string;
        /**
         * Specify HTML element for error
         * @default : 'label';
         */
        errorElement: string;
        /**
         * Specify HTML element for error container
         * @default : 'div';
         */
        errorContainer: string;
        /**
         * Option to display the error
         * @default : ErrorOption.Label;
         */
        errorOption: ErrorOption;
        /**
         * Triggers when a field's focused  out
         * @event
         */
        focusout: base.EmitType<Event>;
        /**
         * Trigger when keyup is triggered in any fields
         * @event
         */
        keyup: base.EmitType<KeyboardEvent>;
        /**
         * Triggers when a check box field is clicked
         * @event
         */
        click: base.EmitType<Event>;
        /**
         * Trigger when a select/drop-down field is changed
         * @event
         */
        change: base.EmitType<Event>;
        /**
         * Triggers before form is being submitted
         * @event
         */
        submit: base.EmitType<Event>;
        /**
         * Triggers before validation starts
         * @event
         */
        validationBegin: base.EmitType<Object>;
        /**
         * Triggers after validation is completed
         * @event
         */
        validationComplete: base.EmitType<Object>;
        /**
         * Assigns the custom function to place the error message in the page.
         * @event
         */
        customPlacement: base.EmitType<Object>;
        /**
         * Add validation rules to the corresponding input element based on `name` attribute.
         * @param {string} name `name` of form field.
         * @param {Object} rules Validation rules for the corresponding element.
         * @return {void}
         */
        addRules(name: string, rules: Object): void;
        /**
         * Remove validation to the corresponding field based on name attribute.
         * When no parameter is passed, remove all the validations in the form.
         * @param {string} name Input name attribute value.
         * @param {string[]} rules List of validation rules need to be remove from the corresponding element.
         * @return {void}
         */
        removeRules(name?: string, rules?: string[]): void;
        /**
         * Validate the current form values using defined rules.
         * Returns `true` when the form is valid otherwise `false`
         * @param {string} selected - Optional parameter to validate specified element.
         * @return {boolean}
         */
        validate(selected?: string): boolean;
        /**
         * Reset the value of all the fields in form.
         * @return {void}
         */
        reset(): void;
        /**
         * Get input element by name.
         * @param {string} name - Input element name attribute value.
         * @return {HTMLInputElement}
         */
        getInputElement(name: string): HTMLInputElement;
        /**
         * Destroy the form validator object and error elements.
         * @return {void}
         */
        destroy(): void;
        /**
         * Specifies the default messages for validation rules.
         * @default : { List of validation message };
         */
        defaultMessages: {
            [rule: string]: string;
        };
        /**
         * @private
         */
        onPropertyChanged(newProp: FormValidatorModel, oldProp?: FormValidatorModel): void;
        /**
         * @private
         */
        getModuleName(): string;
        constructor(element: string | HTMLFormElement, options?: FormValidatorModel);
        private clearForm();
        private createHTML5Rules();
        private annotationRule(input, ruleCon, ruleName, value);
        private defRule(input, ruleCon, ruleName, value);
        private wireEvents();
        private unwireEvents();
        private focusOutHandler(e);
        private keyUpHandler(e);
        private clickHandler(e);
        private changeHandler(e);
        private submitHandler(e);
        private resetHandler();
        private validateRules(name);
        private isValid(name, rule);
        private getErrorMessage(ruleValue, rule);
        private createErrorElement(name, message, input);
        private getErrorElement(name);
        private removeErrorRules(name);
        private showMessage(errorRule);
        private hideMessage(name);
        private checkRequired(name);
        private static checkValidator;
        private static isCheckable(input);
    }
    /**
     * Input box Component
     */
    /**
     * NumericTextBox all modules
     */
    /**
     * Input box Component
     */
    /**
     * Defines floating label type of the input and decides how the label should float on the input.
     */
    export  type FloatLabelType = 'Never' | 'Always' | 'Auto';
    /**
     * Base for Input creation through util methods.
     */
    export  namespace Input {
        /**
         * Create a wrapper to input element with multiple span elements and set the basic properties to input based components.
         * ```
         * E.g : Input.createInput({ element: element, floatLabelType : "Auto", properties: { placeholder: 'Search' } });
         * ```
         * @param args
         */
        function createInput(args: InputArgs): InputObject;
        /**
         * Sets the value to the input element.
         * ```
         * E.g : Input.setValue('content', element, "Auto", true );
         * ```
         * @param value - Specify the value of the input element.
         * @param element - The element on which the specified value is updated.
         * @param floatLabelType - Specify the float label type of the input element.
         * @param clearButton - Boolean value to specify whether the clear icon is enabled / disabled on the input.
         */
        function setValue(value: string, element: HTMLInputElement, floatLabelType?: string, clearButton?: boolean): void;
        /**
         * Sets the single or multiple cssClass to wrapper of input element.
         * ```
         * E.g : Input.setCssClass('e-custom-class', [element]);
         * ```
         * @param cssClass - Css class names which are needed to add.
         * @param elements - The elements which are needed to add / remove classes.
         * @param oldClass - Css class names which are needed to remove. If old classes are need to remove, can give this optional parameter.
         */
        function setCssClass(cssClass: string, elements: Element[] | NodeList, oldClass?: string): void;
        /**
         * Set the placeholder attribute to the input element.
         * ```
         * E.g : Input.setPlaceholder('Search here', element);
         * ```
         * @param placeholder - Placeholder value which is need to add.
         * @param element - The element on which the placeholder is need to add.
         */
        function setPlaceholder(placeholder: string, element: HTMLInputElement): void;
        /**
         * Set the read only attribute to the input element
         * ```
         * E.g : Input.setReadonly(true, element);
         * ```
         * @param isReadonly
         * - Boolean value to specify whether to set read only. Setting "True" value enables read only.
         * @param element
         * - The element which is need to enable read only.
         */
        function setReadonly(isReadonly: boolean, element: HTMLInputElement, floatLabelType?: string): void;
        /**
         * Displays the element direction from right to left when its enabled.
         * ```
         * E.g : Input.setEnableRtl(true, [inputObj.container]);
         * ```
         * @param isRtl
         * - Boolean value to specify whether to set RTL. Setting "True" value enables the RTL mode.
         * @param elements
         * - The elements that are needed to enable/disable RTL.
         */
        function setEnableRtl(isRtl: boolean, elements: Element[] | NodeList): void;
        /**
         * Enables or disables the given input element.
         * ```
         * E.g : Input.setEnabled(false, element);
         * ```
         * @param isEnable
         * - Boolean value to specify whether to enable or disable.
         * @param element
         * - Element to be enabled or disabled.
         */
        function setEnabled(isEnable: boolean, element: HTMLInputElement, floatLabelType?: string): void;
        function setClearButton(isClear: boolean, element: HTMLInputElement, inputObject: InputObject, initial?: boolean): void;
        /**
         * Removing the multiple attributes from the given element such as "disabled","id" , etc.
         * ```
         * E.g : Input.removeAttributes({ 'disabled': 'disabled', 'aria-disabled': 'true' }, element);
         * ```
         * @param attrs
         *  - Array of attributes which are need to removed from the element.
         * @param element
         *  - Element on which the attributes are needed to be removed.
         */
        function removeAttributes(attrs: {
            [key: string]: string;
        }, element: HTMLInputElement | HTMLElement): void;
        /**
         * Adding the multiple attributes to the given element such as "disabled","id" , etc.
         * ```
         * E.g : Input.addAttributes({ 'id': 'inputpopup' }, element);
         * ```
         * @param attrs
         * - Array of attributes which is added to element.
         * @param element
         * - Element on which the attributes are needed to be added.
         */
        function addAttributes(attrs: {
            [key: string]: string;
        }, element: HTMLInputElement | HTMLElement): void;
        function removeFloating(input: InputObject): void;
        function addFloating(input: HTMLInputElement, type: FloatLabelType | string, placeholder: string): void;
        /**
         * Enable or Disable the ripple effect on the icons inside the Input. Ripple effect is only applicable for material theme.
         * ```
         * E.g : Input.setRipple(true, [inputObjects]);
         * ```
         * @param isRipple
         * - Boolean value to specify whether to enable the ripple effect.
         * @param inputObject
         * - Specify the collection of input objects.
         */
        function setRipple(isRipple: boolean, inputObj: InputObject[]): void;
        /**
         * Creates a new span element with the given icons added and append it in container element.
         * ```
         * E.g : Input.appendSpan('e-icon-spin', inputObj.container);
         * ```
         * @param iconClass - Icon classes which are need to add to the span element which is going to created.
         * Span element acts as icon or button element for input.
         * @param container - The container on which created span element is going to append.
         */
        function appendSpan(iconClass: string, container: HTMLElement): HTMLElement;
    }
    export interface InputObject {
        container?: HTMLElement;
        buttons?: HTMLElement[];
        clearButton?: HTMLElement;
    }
    /**
     * Arguments to create input element for input text boxes utility.These properties are optional.
     */
    export interface InputArgs {
        /**
         * Element which is needed to add to the container.
         * ```
         * E.g : Input.createInput({ element: element });
         * ```
         */
        element: HTMLInputElement;
        /**
         * ```
         * E.g : Input.createInput({ element: element, buttons: ['e-icon-up', 'e-icon-down'] });
         * ```
         * Specifies the icon classes for span element which will be append to the container.
         */
        buttons?: string[];
        /**
         * ```
         * E.g : Input.createInput({ element: element, customTag: 'ej2-custom-input' });
         * ```
         * Specifies the custom tag which is acts as container to the input.
         */
        customTag?: string;
        /**
         * ```
         * E.g : Input.createInput({ element: element, floatLabelType : "Always" });
         * ```
         * Specifies how the floating label works.
         * Possible values are:
         * * Never - Never float the label in the input when the placeholder is available.
         * * Always - The floating label will always float above the input.
         * * Auto - The floating label will float above the input after focusing or entering a value in the input.
         */
        floatLabelType?: FloatLabelType | string;
        /**
         * ```
         * E.g : Input.createInput({ element: element, properties: { readonly: true, placeholder: 'Search here' } });
         * ```
         * To specifies the properties such as readonly,enable rtl,etc.
         */
        properties?: {
            readonly?: boolean;
            placeholder?: string;
            cssClass?: string;
            enableRtl?: boolean;
            enabled?: boolean;
            showClearButton?: boolean;
        };
    }
    /**
     * Default required properties for input components.
     */
    export interface IInput {
        /**
         *  Sets the placeholder value to input.
         */
        placeholder: string;
        /**
         *  Sets the css class value to input.
         */
        cssClass: string;
        /**
         *  Sets the enabled value to input.
         */
        enabled?: boolean;
        /**
         *  Sets the readonly value to input.
         */
        readonly: boolean;
        /**
         *  Sets the enable rtl value to input.
         */
        enableRtl: boolean;
        /**
         *  Specifies whether to display the Clear button in the input.
         */
        showClearButton?: boolean;
        /**
         * Specifies how the floating label works.
         * Possible values are:
         * * Never - Never float the label in the input when the placeholder is available.
         * * Always - The floating label will always float above the input.
         * * Auto - The floating label will float above the input after focusing or entering a value in the input.
         */
        floatLabelType?: FloatLabelType | string;
        /**
         *  Sets the change event mapping function to input.
         */
        change: Function;
    }
    /**
     * Defines the argument for the focus event.
     */
    export interface FocusEventArgs {
        model?: Object;
    }
    /**
     * Defines the argument for the blur event.
     */
    export interface BlurEventArgs {
        model?: Object;
    }
    /**
     * MaskedTextbox base modules
     */
    /**
     * @hidden
     * Built-in masking elements collection.
     */
    export  let regularExpressions: {
        [key: string]: string;
    };
    /**
     * @hidden
     * Generate required masking elements to the MaskedTextBox from user mask input.
     */
    export  function createMask(): void;
    /**
     * @hidden
     * Apply mask ability with masking elements to the MaskedTextBox.
     */
    export  function applyMask(): void;
    /**
     * @hidden
     * To wire required events to the MaskedTextBox.
     */
    export  function wireEvents(): void;
    /**
     * @hidden
     * To unwire events attached to the MaskedTextBox.
     */
    export  function unwireEvents(): void;
    /**
     * @hidden
     * To bind required events to the MaskedTextBox clearButton.
     */
    export  function bindClearEvent(): void;
    /**
     * @hidden
     * To get masked value from the MaskedTextBox.
     */
    export  function unstrippedValue(element: HTMLInputElement): string;
    /**
     * @hidden
     * To extract raw value from the MaskedTextBox.
     */
    export  function strippedValue(element: HTMLInputElement, maskValues: string): string;
    export  function maskInputFocusHandler(event: KeyboardEvent): void;
    export  function maskInputBlurHandler(event: KeyboardEvent): void;
    export  function maskInputDropHandler(event: MouseEvent): void;
    export  function mobileRemoveFunction(): void;
    /**
     * @hidden
     * To set updated values in the MaskedTextBox.
     */
    export  function setMaskValue(val?: string): void;
    /**
     * @hidden
     * To set updated values in the input element.
     */
    export  function setElementValue(val: string, element?: HTMLInputElement): void;
    /**
     * @hidden
     * Provide mask support to input textbox through utility method.
     */
    export  function maskInput(args: MaskInputArgs): void;
    /**
     * @hidden
     * Gets raw value of the textbox which has been masked through utility method.
     */
    export  function getVal(args: GetValueInputArgs): string;
    /**
     * @hidden
     * Gets masked value of the textbox which has been masked through utility method.
     */
    export  function getMaskedVal(args: GetValueInputArgs): string;
    /**
     * @hidden
     * Arguments to get the raw and masked value of MaskedTextBox which has been masked through utility method.
     */
    export interface GetValueInputArgs {
        element: HTMLInputElement;
        mask: string;
        promptChar?: string;
        customCharacters?: {
            [x: string]: Object;
        };
    }
    /**
     * @hidden
     * Arguments to mask input textbox through utility method.
     */
    export interface MaskInputArgs extends GetValueInputArgs {
        value?: string;
    }
    /**
     * @hidden
     * Arguments to perform undo and redo functionalities.
     */
    export  class MaskUndo {
        value: string;
        startIndex: Number;
        endIndex: Number;
    }
    /**
     * MaskedTextbox modules
     */
    /**
     * MaskedTextbox modules
     */
    /**
     * Interface for a class MaskedTextBox
     */
    export interface MaskedTextBoxModel extends base.ComponentModel{
        /**
         * Gets or sets the CSS classes to root element of the MaskedTextBox which helps to customize the
         * complete UI styles for the MaskedTextBox component.
         * @default null
         */
        cssClass?: string;
        /**
         * Sets the width of the MaskedTextBox.
         * @default null
         */
        width?: number | string;
        /**
         * Gets or sets the string shown as a hint/placeholder when the MaskedTextBox is empty.
         * It acts as a label and floats above the MaskedTextBox based on the
         * <b><a href="#floatlabeltype-string" target="_blank">floatLabelType.</a></b>
         * @default null
         */
        placeholder?: string;
        /**
         * The <b><a href="#placeholder-string" target="_blank">placeholder</a></b> acts as a label
         * and floats above the MaskedTextBox based on the below values.
         * Possible values are:
         * * Never - The floating label will not be enable when the placeholder is available.
         * * Always - The floating label always floats above the MaskedTextBox.
         * * Auto - The floating label floats above the MaskedTextBox after focusing it or when enters the value in it.
         * @default Never
         */
        floatLabelType?: FloatLabelType;
        /**
         * Sets a value that enables or disables the MaskedTextBox component.
         * @default true
         */
        enabled?: boolean;
        /**
         * Specifies whether to show or hide the clear icon.
         * @default false
         */
        showClearButton?: boolean;
        /**
         * Sets a value that enables or disables the persisting state of the MaskedTextBox after reloading the page.
         * If enabled, the 'value' state will be persisted.
         * @default false
         */
        enablePersistence?: boolean;
        /**
         * Sets a value that enables or disables the RTL mode on the MaskedTextBox. If it is true, 
         * MaskedTextBox will display the content in the right to left direction.
         * @default false
         */
        enableRtl?: boolean;
        /**
         * Sets a value that masks the MaskedTextBox to allow/validate the user input.
         * * Mask allows <b><a href="../maskedtextbox/mask-configuration.html#standard-mask-elements" target="_blank">standard mask elements
         * </a></b>, <b><a href="../maskedtextbox/mask-configuration.html#custom-characters" target="_blank">custom characters</a></b> and
         * <b><a href="../maskedtextbox/mask-configuration.html#regular-expression" target="_blank">regular expression</a></b> as mask elements.
         * For more information on mask, refer to
         * [mask](./mask-configuration.html#standard-mask-elements).
         * * If the mask value is empty, the MaskedTextBox will behave as an input element with text type.
         * @default null
         */
        mask?: string;
        /**
         * Gets or sets a value that will be shown as a prompting symbol for the masked value.
         * The symbol used to show input positions in the MaskedTextBox.
         * For more information on prompt-character, refer to
         * [prompt-character](./mask-configuration.html#prompt-character).
         * @default _
         */
        promptChar?: string;
        /**
         * Gets or sets the value of the MaskedTextBox. It is a raw value of the MaskedTextBox excluding literals
         * and prompt characters. By using `getMaskedValue` property, you can get the value of MaskedTextBox with the masked format.
         * ```html
         * <input id="mask" type="text" />
         * ```
         * ```typescript
         * <script>
         * var maskObj = new MaskedTextBox({ mask: "(999) 9999-999", value: "8674321756" });
         * maskObj.appendTo('#mask');
         * </script>
         * ```
         * @default null
         */
        value?: string;
        /**
         * Sets the collection of values to be mapped for non-mask elements(literals)
         * which have been set in the mask of MaskedTextBox.
         * * In the below example, non-mask elements "P" accepts values
         * "P" , "A" , "p" , "a" and "M" accepts values "M", "m" mentioned in the custom characters collection.
         * ```html
         * <input id="mask" type="text" />
         * ```
         * ```typescript
         * <script>
         * var customChar = { P: 'P,A,p,a', M: 'M,m'};
         * var maskObj = new MaskedTextBox({ mask: "99 : 99 PM", customCharacters: customChar });
         * maskObj.appendTo('#mask');
         * </script>
         * ```
         * For more information on customCharacters, refer to
         * [customCharacters](./mask-configuration.html#custom-characters).
         * @default null
         */
        customCharacters?: { [x: string]: Object };
        /**
         * Triggers when the MaskedTextBox component is created.
         * @event
         */
        created?: base.EmitType<Object>;
        /**
         * Triggers when the MaskedTextBox component is destroyed.
         * @event
         */
        destroyed?: base.EmitType<Object>;
        /**
         * Triggers when the value of the MaskedTextBox changes.
         * @event
         */
        change?: base.EmitType <MaskChangeEventArgs>;
        /**
         * Triggers when the MaskedTextBox while got focus in.
         * @event
         */
        focus?: base.EmitType<MaskFocusEventArgs>;
    }
    /**
     * The MaskedTextBox allows the user to enter the valid input only based on the provided mask.
     * ```html
     * <input id="mask" type="text" />
     * ```
     * ```typescript
     * <script>
     * var maskObj = new MaskedTextBox({ mask: "(999) 9999-999" });
     * maskObj.appendTo('#mask');
     * </script>
     * ```
     */
    export  class MaskedTextBox extends base.Component<HTMLInputElement> implements base.INotifyPropertyChanged {
        private cloneElement;
        private promptMask;
        private hiddenMask;
        private escapeMaskValue;
        private regExpCollec;
        private customRegExpCollec;
        private inputObj;
        private undoCollec;
        private redoCollec;
        private changeEventArgs;
        private focusEventArgs;
        private maskKeyPress;
        private angularTagName;
        private prevValue;
        private isFocus;
        private isInitial;
        private isIosInvalid;
        /**
         * Gets or sets the CSS classes to root element of the MaskedTextBox which helps to customize the
         * complete UI styles for the MaskedTextBox component.
         * @default null
         */
        cssClass: string;
        /**
         * Sets the width of the MaskedTextBox.
         * @default null
         */
        width: number | string;
        /**
         * Gets or sets the string shown as a hint/placeholder when the MaskedTextBox is empty.
         * It acts as a label and floats above the MaskedTextBox based on the
         * <b><a href="#floatlabeltype-string" target="_blank">floatLabelType.</a></b>
         * @default null
         */
        placeholder: string;
        /**
         * The <b><a href="#placeholder-string" target="_blank">placeholder</a></b> acts as a label
         * and floats above the MaskedTextBox based on the below values.
         * Possible values are:
         * * Never - The floating label will not be enable when the placeholder is available.
         * * Always - The floating label always floats above the MaskedTextBox.
         * * Auto - The floating label floats above the MaskedTextBox after focusing it or when enters the value in it.
         * @default Never
         */
        floatLabelType: FloatLabelType;
        /**
         * Sets a value that enables or disables the MaskedTextBox component.
         * @default true
         */
        enabled: boolean;
        /**
         * Specifies whether to show or hide the clear icon.
         * @default false
         */
        showClearButton: boolean;
        /**
         * Sets a value that enables or disables the persisting state of the MaskedTextBox after reloading the page.
         * If enabled, the 'value' state will be persisted.
         * @default false
         */
        enablePersistence: boolean;
        /**
         * Sets a value that enables or disables the RTL mode on the MaskedTextBox. If it is true,
         * MaskedTextBox will display the content in the right to left direction.
         * @default false
         */
        enableRtl: boolean;
        /**
         * Sets a value that masks the MaskedTextBox to allow/validate the user input.
         * * Mask allows <b><a href="../maskedtextbox/mask-configuration.html#standard-mask-elements" target="_blank">standard mask elements
         * </a></b>, <b><a href="../maskedtextbox/mask-configuration.html#custom-characters" target="_blank">custom characters</a></b> and
         * <b><a href="../maskedtextbox/mask-configuration.html#regular-expression" target="_blank">regular expression</a></b> as mask elements.
         * For more information on mask, refer to
         * [mask](./mask-configuration.html#standard-mask-elements).
         * * If the mask value is empty, the MaskedTextBox will behave as an input element with text type.
         * @default null
         */
        mask: string;
        /**
         * Gets or sets a value that will be shown as a prompting symbol for the masked value.
         * The symbol used to show input positions in the MaskedTextBox.
         * For more information on prompt-character, refer to
         * [prompt-character](./mask-configuration.html#prompt-character).
         * @default _
         */
        promptChar: string;
        /**
         * Gets or sets the value of the MaskedTextBox. It is a raw value of the MaskedTextBox excluding literals
         * and prompt characters. By using `getMaskedValue` property, you can get the value of MaskedTextBox with the masked format.
         * ```html
         * <input id="mask" type="text" />
         * ```
         * ```typescript
         * <script>
         * var maskObj = new MaskedTextBox({ mask: "(999) 9999-999", value: "8674321756" });
         * maskObj.appendTo('#mask');
         * </script>
         * ```
         * @default null
         */
        value: string;
        /**
         * Sets the collection of values to be mapped for non-mask elements(literals)
         * which have been set in the mask of MaskedTextBox.
         * * In the below example, non-mask elements "P" accepts values
         * "P" , "A" , "p" , "a" and "M" accepts values "M", "m" mentioned in the custom characters collection.
         * ```html
         * <input id="mask" type="text" />
         * ```
         * ```typescript
         * <script>
         * var customChar = { P: 'P,A,p,a', M: 'M,m'};
         * var maskObj = new MaskedTextBox({ mask: "99 : 99 PM", customCharacters: customChar });
         * maskObj.appendTo('#mask');
         * </script>
         * ```
         * For more information on customCharacters, refer to
         * [customCharacters](./mask-configuration.html#custom-characters).
         * @default null
         */
        customCharacters: {
            [x: string]: Object;
        };
        /**
         * Triggers when the MaskedTextBox component is created.
         * @event
         */
        created: base.EmitType<Object>;
        /**
         * Triggers when the MaskedTextBox component is destroyed.
         * @event
         */
        destroyed: base.EmitType<Object>;
        /**
         * Triggers when the value of the MaskedTextBox changes.
         * @event
         */
        change: base.EmitType<MaskChangeEventArgs>;
        /**
         * Triggers when the MaskedTextBox while got focus in.
         * @event
         */
        focus: base.EmitType<MaskFocusEventArgs>;
        constructor(options?: MaskedTextBoxModel, element?: string | HTMLElement | HTMLInputElement);
        /**
         * Gets the component name
         * @private
         */
        protected getModuleName(): string;
        /**
         * Initializes the event handler
         * @private
         */
        protected preRender(): void;
        /**
         * Gets the properties to be maintained in the persisted state.
         * @return {string}
         */
        getPersistData(): string;
        /**
         * Initializes the component rendering.
         * @private
         */
        render(): void;
        private resetMaskedTextBox();
        private setMaskPlaceholder(setVal, dynamicPlaceholder);
        private setCssClass(cssClass, element);
        private setWidth(width);
        private createWrapper();
        /**
         * Calls internally if any of the property value is changed.
         * @hidden
         */
        onPropertyChanged(newProp: MaskedTextBoxModel, oldProp: MaskedTextBoxModel): void;
        private updateValue(strippedVal);
        /**
         * Gets the value of the MaskedTextBox with the masked format.
         * By using `value` property, you can get the raw value of maskedtextbox without literals and prompt characters.
         * @return {string}
         */
        getMaskedValue(): string;
        /**
         * Removes the component from the DOM and detaches all its related event handlers.
         * Also it maintains the initial input element from the DOM.
         * @method destroy
         * @return {void}
         */
        destroy(): void;
    }
    export interface MaskChangeEventArgs extends base.BaseEventArgs {
        /** Returns the value of the MaskedTextBox with the masked format. */
        maskedValue?: string;
        /** Returns the raw value of MaskedTextBox by removing the prompt characters and literals(non-mask elements)
         * which have been set in the mask of MaskedTextBox.
         */
        value?: string;
        /** Returns true when the value of MaskedTextBox is changed by user interaction. Otherwise, it returns false */
        isInteraction?: boolean;
        /** Returns the original event arguments. */
        event?: Event;
    }
    export interface MaskFocusEventArgs extends base.BaseEventArgs {
        /** Returns selectionStart value as zero by default */
        selectionStart?: number;
        /** Returns selectionEnd value depends on mask length */
        selectionEnd?: number;
    }
    /**
     * NumericTextBox modules
     */
    /**
     * Interface for a class NumericTextBox
     */
    export interface NumericTextBoxModel extends base.ComponentModel{
        /**
         * Gets or Sets the CSS classes to root element of the NumericTextBox which helps to customize the
         * complete UI styles for the NumericTextBox component.
         * @default null
         */
        cssClass?: string;
        /**
         * Sets the value of the NumericTextBox.
         * @default null
         */
        value?: number;
        /**
         * Specifies a minimum value that is allowed a user can enter.
         * For more information on min, refer to
         * [min](./getting-started.html#range-validation).
         * @default null
         */
        min?: number;
        /**
         * Specifies a maximum value that is allowed a user can enter.
         * For more information on max, refer to
         * [max](./getting-started.html#range-validation).
         * @default null
         */
        max?: number;
        /**
         * Specifies the incremental or decremental step size for the NumericTextBox.
         * For more information on step, refer to
         * [step](./getting-started.html#range-validation).
         * @default 1
         */
        step?: number;
        /**
         * Specifies the width of the NumericTextBox.
         * @default null
         */
        width?: number | string;
        /**
         * Gets or sets the string shown as a hint/placeholder when the NumericTextBox is empty.
         * It acts as a label and floats above the NumericTextBox based on the
         * <b><a href="#floatlabeltype-string" target="_blank">floatLabelType.</a></b>
         * @default null
         */
        placeholder?: string;
        /**
         * Specifies whether the up and down spin buttons should be displayed in NumericTextBox.
         * @default true
         */
        showSpinButton?: boolean;
        /**
         * Sets a value that enables or disables the readonly state on the NumericTextBox. If it is true, 
         * NumericTextBox will not allow your input.
         * @default false
         */
        readonly?: boolean;
        /**
         * Sets a value that enables or disables the NumericTextBox control.
         * @default true
         */
        enabled?: boolean;
        /**
         * Sets a value that enables or disables the RTL mode on the NumericTextBox. If it is true, 
         * NumericTextBox will display the content in the right to left direction.
         * @default false
         */
        enableRtl?: boolean;
        /**
         * Specifies whether to show or hide the clear icon.
         * @default false
         */
        showClearButton?: boolean;
        /**
         * Enable or disable persisting NumericTextBox state between page reloads. If enabled, the `value` state will be persisted.
         * @default false
         */
        enablePersistence?: boolean;
        /**
         * Specifies the number format that indicates the display format for the value of the NumericTextBox.
         * For more information on formats, refer to
         * [formats](./formats.html#standard-formats).
         * @default 'n2'
         */
        format?: string;
        /**
         * Specifies the number precision applied to the textbox value when the NumericTextBox is focused.
         * For more information on decimals, refer to
         * [decimals](./formats.html#precision-of-numbers).
         * @default null
         */
        decimals?: number;
        /**
         * Specifies the currency code to use in currency formatting.
         * Possible values are the ISO 4217 currency codes, such as 'USD' for the US dollar,'EUR' for the euro.
         * @default null
         */
        currency?: string;
        /**
         * Specifies the currency code to use in currency formatting.
         * Possible values are the ISO 4217 currency codes, such as 'USD' for the US dollar,'EUR' for the euro.
         * @default null
         * @private
         */
        currencyCode?: string;
        /**
         * Specifies a value that indicates whether the NumericTextBox control allows the value for the specified range.
         * * If it is true, the input value will be restricted between the min and max range.
         * The typed value gets modified to fit the range on focused out state.
         * ```html
         * <input type='text' id="numeric"/>
         * ```
         * ```typescript
         * <script>
         *   var numericObj = new NumericTextBox({ min: 10, max: 20, value: 15 });
         *   numericObj.appendTo("#numeric");
         * </script>
         * ```
         * * Else, it allows any value even out of range value,
         * At that time of wrong value entered, the error class will be added to the component to highlight the error.
         * ```html
         * <input type='text' id="numeric"/>
         * ```
         * ```typescript
         * <script>
         *   var numericObj = new NumericTextBox({ strictMode: false, min: 10, max: 20, value: 15 });
         *   numericObj.appendTo("#numeric");
         * </script>
         * ```
         * @default true
         */
        strictMode?: boolean;
        /**
         * Specifies whether the decimals length should be restricted during typing.
         * @default false
         */
        validateDecimalOnType?: boolean;
        /**
         * The <b><a href="#placeholder-string" target="_blank">placeholder</a></b> acts as a label
         * and floats above the NumericTextBox based on the below values.
         * Possible values are:
         * * `Never` - Never floats the label in the NumericTextBox when the placeholder is available.
         * * `Always` - The floating label always floats above the NumericTextBox.
         * * `Auto` - The floating label floats above the NumericTextBox after focusing it or when enters the value in it.
         * @default Never
         */
        floatLabelType?: FloatLabelType;
        /**
         * Triggers when the NumericTextBox component is created.
         * @event
         */
        created?: base.EmitType<Object>;
        /**
         * Triggers when the NumericTextBox component is destroyed.
         * @event
         */
        destroyed?: base.EmitType<Object>;
        /**
         * Triggers when the value of the NumericTextBox changes.
         * @event
         */
        change?: base.EmitType<ChangeEventArgs>;
    }
    /**
     * Represents the NumericTextBox component that allows the user to enter only numeric values.
     * ```html
     * <input type='text' id="numeric"/>
     * ```
     * ```typescript
     * <script>
     *   var numericObj = new NumericTextBox({ value: 10 });
     *   numericObj.appendTo("#numeric");
     * </script>
     * ```
     */
    export  class NumericTextBox extends base.Component<HTMLInputElement> implements base.INotifyPropertyChanged {
        private container;
        private inputWrapper;
        private cloneElement;
        private hiddenInput;
        private spinUp;
        private spinDown;
        private timeOut;
        private prevValue;
        private isValidState;
        private isFocused;
        private isPrevFocused;
        private instance;
        private cultureInfo;
        private inputStyle;
        private inputName;
        private decimalSeparator;
        private angularTagName;
        private intRegExp;
        private l10n;
        private isCalled;
        private prevVal;
        private nextEle;
        private cursorPosChanged;
        private changeEventArgs;
        private isInteract;
        /**
         * Gets or Sets the CSS classes to root element of the NumericTextBox which helps to customize the
         * complete UI styles for the NumericTextBox component.
         * @default null
         */
        cssClass: string;
        /**
         * Sets the value of the NumericTextBox.
         * @default null
         */
        value: number;
        /**
         * Specifies a minimum value that is allowed a user can enter.
         * For more information on min, refer to
         * [min](./getting-started.html#range-validation).
         * @default null
         */
        min: number;
        /**
         * Specifies a maximum value that is allowed a user can enter.
         * For more information on max, refer to
         * [max](./getting-started.html#range-validation).
         * @default null
         */
        max: number;
        /**
         * Specifies the incremental or decremental step size for the NumericTextBox.
         * For more information on step, refer to
         * [step](./getting-started.html#range-validation).
         * @default 1
         */
        step: number;
        /**
         * Specifies the width of the NumericTextBox.
         * @default null
         */
        width: number | string;
        /**
         * Gets or sets the string shown as a hint/placeholder when the NumericTextBox is empty.
         * It acts as a label and floats above the NumericTextBox based on the
         * <b><a href="#floatlabeltype-string" target="_blank">floatLabelType.</a></b>
         * @default null
         */
        placeholder: string;
        /**
         * Specifies whether the up and down spin buttons should be displayed in NumericTextBox.
         * @default true
         */
        showSpinButton: boolean;
        /**
         * Sets a value that enables or disables the readonly state on the NumericTextBox. If it is true,
         * NumericTextBox will not allow your input.
         * @default false
         */
        readonly: boolean;
        /**
         * Sets a value that enables or disables the NumericTextBox control.
         * @default true
         */
        enabled: boolean;
        /**
         * Sets a value that enables or disables the RTL mode on the NumericTextBox. If it is true,
         * NumericTextBox will display the content in the right to left direction.
         * @default false
         */
        enableRtl: boolean;
        /**
         * Specifies whether to show or hide the clear icon.
         * @default false
         */
        showClearButton: boolean;
        /**
         * Enable or disable persisting NumericTextBox state between page reloads. If enabled, the `value` state will be persisted.
         * @default false
         */
        enablePersistence: boolean;
        /**
         * Specifies the number format that indicates the display format for the value of the NumericTextBox.
         * For more information on formats, refer to
         * [formats](./formats.html#standard-formats).
         * @default 'n2'
         */
        format: string;
        /**
         * Specifies the number precision applied to the textbox value when the NumericTextBox is focused.
         * For more information on decimals, refer to
         * [decimals](./formats.html#precision-of-numbers).
         * @default null
         */
        decimals: number;
        /**
         * Specifies the currency code to use in currency formatting.
         * Possible values are the ISO 4217 currency codes, such as 'USD' for the US dollar,'EUR' for the euro.
         * @default null
         */
        currency: string;
        /**
         * Specifies the currency code to use in currency formatting.
         * Possible values are the ISO 4217 currency codes, such as 'USD' for the US dollar,'EUR' for the euro.
         * @default null
         * @private
         */
        private currencyCode;
        /**
         * Specifies a value that indicates whether the NumericTextBox control allows the value for the specified range.
         * * If it is true, the input value will be restricted between the min and max range.
         * The typed value gets modified to fit the range on focused out state.
         * ```html
         * <input type='text' id="numeric"/>
         * ```
         * ```typescript
         * <script>
         *   var numericObj = new NumericTextBox({ min: 10, max: 20, value: 15 });
         *   numericObj.appendTo("#numeric");
         * </script>
         * ```
         * * Else, it allows any value even out of range value,
         * At that time of wrong value entered, the error class will be added to the component to highlight the error.
         * ```html
         * <input type='text' id="numeric"/>
         * ```
         * ```typescript
         * <script>
         *   var numericObj = new NumericTextBox({ strictMode: false, min: 10, max: 20, value: 15 });
         *   numericObj.appendTo("#numeric");
         * </script>
         * ```
         * @default true
         */
        strictMode: boolean;
        /**
         * Specifies whether the decimals length should be restricted during typing.
         * @default false
         */
        validateDecimalOnType: boolean;
        /**
         * The <b><a href="#placeholder-string" target="_blank">placeholder</a></b> acts as a label
         * and floats above the NumericTextBox based on the below values.
         * Possible values are:
         * * `Never` - Never floats the label in the NumericTextBox when the placeholder is available.
         * * `Always` - The floating label always floats above the NumericTextBox.
         * * `Auto` - The floating label floats above the NumericTextBox after focusing it or when enters the value in it.
         * @default Never
         */
        floatLabelType: FloatLabelType;
        /**
         * Triggers when the NumericTextBox component is created.
         * @event
         */
        created: base.EmitType<Object>;
        /**
         * Triggers when the NumericTextBox component is destroyed.
         * @event
         */
        destroyed: base.EmitType<Object>;
        /**
         * Triggers when the value of the NumericTextBox changes.
         * @event
         */
        change: base.EmitType<ChangeEventArgs>;
        constructor(options?: NumericTextBoxModel, element?: string | HTMLInputElement);
        protected preRender(): void;
        /**
         * To Initialize the control rendering
         * @private
         */
        render(): void;
        private checkAttributes();
        private updatePlaceholder();
        private initCultureFunc();
        private initCultureInfo();
        private createWrapper();
        private spinBtnCreation();
        private validateMinMax();
        private formattedValue(decimals, value);
        private validateStep();
        private action(operation, event);
        private checkErrorClass();
        private bindClearEvent();
        protected resetHandler(e?: MouseEvent): void;
        private clear(event);
        private wireEvents();
        private wireSpinBtnEvents();
        private unwireEvents();
        private unwireSpinBtnEvents();
        private changeHandler(event);
        private raiseChangeEvent(event?);
        private pasteHandler();
        private preventHandler();
        private keyUpHandler(event);
        private inputHandler(event);
        private keyDownHandler(event);
        private performAction(value, step, operation);
        private correctRounding(value, step, result);
        private roundValue(result, precision);
        private updateValue(value, event?);
        private updateCurrency(prop, propVal);
        private changeValue(value);
        private modifyText();
        private setElementValue(val, element?);
        private validateState();
        private formatNumber();
        private trimValue(value);
        private roundNumber(value, precision);
        private cancelEvent(event);
        private keyPressHandler(event);
        private numericRegex();
        private mouseWheel(event);
        private focusIn(event);
        private focusOut(event);
        private mouseDownOnSpinner(event);
        private touchMoveOnSpinner(event);
        private mouseUpOnSpinner(event);
        private getElementData(event);
        private floatLabelTypeUpdate();
        private mouseUpClick(event);
        /**
         * Increments the NumericTextBox value with the specified step value.
         * @param  {number} step - Specifies the value used to increment the NumericTextBox value.
         * if its not given then numeric value will be incremented based on the step property value.
         */
        increment(step?: number): void;
        /**
         * Decrements the NumericTextBox value with specified step value.
         * @param  {number} step - Specifies the value used to decrement the NumericTextBox value.
         * if its not given then numeric value will be decremented based on the step property value.
         */
        decrement(step?: number): void;
        /**
         * Removes the component from the DOM and detaches all its related event handlers.
         * Also it maintains the initial input element from the DOM.
         * @method destroy
         * @return {void}
         */
        destroy(): void;
        /**
         * Returns the value of NumericTextBox with the format applied to the NumericTextBox.
         */
        getText(): string;
        /**
         * Gets the properties to be maintained in the persisted state.
         * @return {string}
         */
        getPersistData(): string;
        /**
         * Calls internally if any of the property value is changed.
         * @private
         */
        onPropertyChanged(newProp: NumericTextBoxModel, oldProp: NumericTextBoxModel): void;
        /**
         * Gets the component name
         * @private
         */
        getModuleName(): string;
    }
    export interface ChangeEventArgs extends base.BaseEventArgs {
        /** Returns the entered value of the NumericTextBox. */
        value?: number;
        /** Returns the previously entered value of the NumericTextBox. */
        previousValue?: number;
        /** Returns the event parameters from NumericTextBox. */
        event?: Event;
        /** Returns the original event arguments. */
        isInteraction?: boolean;
    }
    /**
     * Slider modules
     */
    /**
     * Interface for a class TicksData
     */
    export interface TicksDataModel {
        /**
         * It is used to denote the position of the ticks in the Slider. The available options are:
         *
         *  * before - Ticks are placed in the top of the horizontal slider bar or at the left of the vertical slider bar.
         *  * after - Ticks are placed in the bottom of the horizontal slider bar or at the right of the vertical slider bar.
         *  * both - Ticks are placed on the both side of the Slider bar.
         *  * none - Ticks are not shown.
         *
         * @default : 'None'
         */
        placement?: Placement;
        /**
         * It is used to denote the distance between two major (large) ticks from the scale of the Slider.
         * @default : 10
         */
        largeStep?: number;
        /**
         * It is used to denote the distance between two minor (small) ticks from the scale of the Slider.
         * @default : 1
         */
        smallStep?: number;
        /**
         * We can show or hide the small ticks in the Slider, which will be appeared in between the largeTicks.
         * @default : false
         */
        showSmallTicks?: boolean;
        /**
         * It is used to customize the Slider scale value to the desired format using base.Internationalization or events(custom formatting).
         */
        format?: string;
    }
    /**
     * Interface for a class LimitData
     */
    export interface LimitDataModel {
        /**
         * It is used to enable the limit in the slider.
         * @default false
         */
        enabled?: boolean;
        /**
         * It is used to set the minimum start limit value.
         * @default null
         */
        minStart?: number;
        /**
         * It is used to set the minimum end limit value.
         * @default null
         */
        minEnd?: number;
        /**
         * It is used to set the maximum start limit value.
         * @default null
         */
        maxStart?: number;
        /**
         * It is used to set the maximum end limit value.
         * @default null
         */
        maxEnd?: number;
        /**
         * It is used to lock the first handle.
         * @default false
         */
        startHandleFixed?: boolean;
        /**
         * It is used to lock the second handle.
         * @default false
         */
        endHandleFixed?: boolean;
    }
    /**
     * Interface for a class TooltipData
     */
    export interface TooltipDataModel {
        /**
         * It is used to customize the base.Tooltip which accepts custom CSS class names that define
         *  specific user-defined styles and themes to be applied on the base.Tooltip element.
         * @default ''
         */
        cssClass?: string;
        /**
         * It is used to denote the position for the tooltip element in the Slider. The available options are:
         *
         *  * Before - base.Tooltip is shown in the top of the horizontal slider bar or at the left of the vertical slider bar.
         *  * After - base.Tooltip is shown in the bottom of the horizontal slider bar or at the right of the vertical slider bar.
         */
        placement?: TooltipPlacement;
        /**
         * It is used to determine the device mode to show the base.Tooltip.
         * If it is in desktop, it will show the base.Tooltip content when hovering on the target element.
         * If it is in touch device. It will show the base.Tooltip content when tap and holding on the target element.
         * @default 'Auto'
         */
        showOn?: TooltipShowOn;
        /**
         * It is used to show or hide the base.Tooltip of Slider base.Component.
         */
        isVisible?: boolean;
        /**
         * It is used to customize the base.Tooltip content to the desired format
         *  using internationalization or events (custom formatting).
         */
        format?: string;
    }
    /**
     * Interface for a class Slider
     */
    export interface SliderModel extends base.ComponentModel{
        /**
         * It is used to denote the current value of the Slider.
         * The value should be specified in array of number when render Slider type as range.
         * @default null
         */
        value?: number | number[];
        /**
         * It is used to denote own array of slider values.
         * The value should be specified in array of number or string.The min,max and step value is not considered
         * @default null
         */
        customValues?: string[] | number[];
        /**
         * It is used to denote the step value of Slider component which is the amount of Slider value change
         *  when increase / decrease button is clicked or press arrow keys or drag the thumb.
         *  Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/ticks.html?lang=typescript#step here}
         *  to know more about this property with demo.
         * @default 1
         */
        step?: number;
        /**
         * It sets the minimum value of Slider base.Component
         * @default 0
         */
        min?: number;
        /**
         * It sets the maximum value of Slider base.Component
         * @default 100
         */
        max?: number;
        /**
         * It is used to render the Slider component in read-only mode.
         * The slider rendered with user defined values and can’t be interacted with user actions.
         * @default false
         */
        readonly?: boolean;
        /**
         * It is used to denote the type of the Slider. The available options are:
         *
         *  * default - Used to select a single value in the Slider.
         *  * minRange - Used to select a single value in the Slider. It displays shadow from the start value to the current value.
         *  * range - Used to select a range of values in the Slider. It displays shadow in-between the selection range.
         */
        type?: SliderType;
        /**
         * It is used to render the slider ticks options such as placement and step values.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/ticks.html?lang=typescript here}
         *  to know more about this property with demo.
         * @default { placement: 'before' }
         */
        ticks?: TicksDataModel;
        /**
         * It is used to limit the slider movement within certain limits.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/limits.html?lang=typescript here}
         *  to know more about this property with demo
         * @default { enabled: false }
         */
        limits?: LimitDataModel;
        /**
         * It is used to enable or disable the slider.
         * @default true
         */
        enabled?: boolean;
        /**
         * It is used to render the Slider component from right to left direction.
         * @default false
         */
        enableRtl?: boolean;
        /**
         * It is used to denote the slider tooltip and it's position.
         * @default { placement: 'Before', isVisible: false, showOn: 'Focus', format: null }
         */
        tooltip?: TooltipDataModel;
        /**
         * It is used to show or hide the increase and decrease button of Slider base.Component,
         *  which is used to change the slider value.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/getting-started.html?lang=typescript#buttons here}
         *  to know more about this property with demo.
         * @default false
         */
        showButtons?: boolean;
        /**
         * It is used to enable or disable the Slider handle moving animation.
         * @default true
         */
        enableAnimation?: boolean;
        /**
         * It is used to render Slider in either horizontal or vertical orientation.
         *  Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/getting-started.html?lang=typescript#orientation here}
         *  to know more about this property with demo.
         * @default 'Horizontal'
         */
        orientation?: SliderOrientation;
        /**
         * This property sets the CSS classes to root element of the Slider
         *  which helps to customize the UI styles.
         * @default ''
         */
        cssClass?: string;
        /**
         * We can trigger created event when the Slider is created.
         * @event
         */
        created?: base.EmitType<Object>;
        /**
         * We can trigger change event whenever Slider value is changed.
         *  In other term, this event will be triggered while drag the slider thumb.
         * @event
         */
        change?: base.EmitType<Object>;
        /**
         * We can trigger changed event when Slider component action is completed while we change the Slider value.
         *  In other term, this event will be triggered, while drag the slider thumb completed.
         * @event
         */
        changed?: base.EmitType<Object>;
        /**
         * We can trigger renderingTicks event when the ticks rendered on Slider,
         *  which is used to customize the ticks labels dynamically.
         * @event
         */
        renderingTicks?: base.EmitType<Object>;
        /**
         * We can trigger renderedTicks event when the ticks are rendered on the Slider.
         * @event
         */
        renderedTicks?: base.EmitType<Object>;
        /**
         * We can trigger tooltipChange event when we change the Sider tooltip value.
         * @event
         */
        tooltipChange?: base.EmitType<SliderTooltipEventArgs>;
    }
    /**
     * Configures the ticks data of the Slider.
     */
    export  class TicksData extends base.ChildProperty<TicksData> {
        /**
         * It is used to denote the position of the ticks in the Slider. The available options are:
         *
         *  * before - Ticks are placed in the top of the horizontal slider bar or at the left of the vertical slider bar.
         *  * after - Ticks are placed in the bottom of the horizontal slider bar or at the right of the vertical slider bar.
         *  * both - Ticks are placed on the both side of the Slider bar.
         *  * none - Ticks are not shown.
         *
         * @default : 'None'
         */
        placement: Placement;
        /**
         * It is used to denote the distance between two major (large) ticks from the scale of the Slider.
         * @default : 10
         */
        largeStep: number;
        /**
         * It is used to denote the distance between two minor (small) ticks from the scale of the Slider.
         * @default : 1
         */
        smallStep: number;
        /**
         * We can show or hide the small ticks in the Slider, which will be appeared in between the largeTicks.
         * @default : false
         */
        showSmallTicks: boolean;
        /**
         * It is used to customize the Slider scale value to the desired format using Internationalization or events(custom formatting).
         */
        format: string;
    }
    /**
     * It is used to denote the TooltipChange Event arguments.
     */
    export interface SliderTooltipEventArgs {
        /**
         * It is used to get the value of the Slider.
         */
        value: number | number[];
        /**
         * It is used to get the text shown in the Slider tooltip.
         */
        text: string;
    }
    /**
     * It is used to denote the Slider Change/Changed Event arguments.
     */
    export interface SliderChangeEventArgs {
        /**
         * It is used to get the current value of the Slider.
         */
        value: number | number[];
        /**
         * It is used to get the previous value of the Slider.
         */
        previousValue: number | number[];
        /**
         * It is used to get the current text or formatted text of the Slider, which is placed in tooltip.
         */
        text?: string;
        /**
         * It is used to get the action applied on the Slider.
         */
        action: string;
    }
    /**
     * It is used to denote the TicksRender Event arguments.
     */
    export interface SliderTickEventArgs {
        /**
         * It is used to get the value of the tick.
         */
        value: number;
        /**
         * It is used to get the label text of the tick.
         */
        text: string;
        /**
         * It is used to get the current tick element.
         */
        tickElement: Element;
    }
    /**
     * It is used t denote the ticks rendered Event arguments.
     */
    export interface SliderTickRenderedEventArgs {
        /**
         * It returns the wrapper of the ticks element.
         */
        ticksWrapper: HTMLElement;
        /**
         * It returns the collection of tick elements.
         */
        tickElements: HTMLElement[];
    }
    /**
     * It illustrates the limit data in slider.
     */
    export  class LimitData extends base.ChildProperty<LimitData> {
        /**
         * It is used to enable the limit in the slider.
         * @default false
         */
        enabled: boolean;
        /**
         * It is used to set the minimum start limit value.
         * @default null
         */
        minStart: number;
        /**
         * It is used to set the minimum end limit value.
         * @default null
         */
        minEnd: number;
        /**
         * It is used to set the maximum start limit value.
         * @default null
         */
        maxStart: number;
        /**
         * It is used to set the maximum end limit value.
         * @default null
         */
        maxEnd: number;
        /**
         * It is used to lock the first handle.
         * @default false
         */
        startHandleFixed: boolean;
        /**
         * It is used to lock the second handle.
         * @default false
         */
        endHandleFixed: boolean;
    }
    /**
     * It illustrates the tooltip data in slider.
     */
    export  class TooltipData extends base.ChildProperty<TooltipData> {
        /**
         * It is used to customize the Tooltip which accepts custom CSS class names that define
         *  specific user-defined styles and themes to be applied on the Tooltip element.
         * @default ''
         */
        cssClass: string;
        /**
         * It is used to denote the position for the tooltip element in the Slider. The available options are:
         *
         *  * Before - Tooltip is shown in the top of the horizontal slider bar or at the left of the vertical slider bar.
         *  * After - Tooltip is shown in the bottom of the horizontal slider bar or at the right of the vertical slider bar.
         */
        placement: TooltipPlacement;
        /**
         * It is used to determine the device mode to show the Tooltip.
         * If it is in desktop, it will show the Tooltip content when hovering on the target element.
         * If it is in touch device. It will show the Tooltip content when tap and holding on the target element.
         * @default 'Auto'
         */
        showOn: TooltipShowOn;
        /**
         * It is used to show or hide the Tooltip of Slider base.Component.
         */
        isVisible: boolean;
        /**
         * It is used to customize the Tooltip content to the desired format
         *  using internationalization or events (custom formatting).
         */
        format: string;
    }
    /**
     * Ticks Placement.
     */
    export  type Placement = 'Before' | 'After' | 'Both' | 'None';
    /**
     * Tooltip Placement.
     */
    export  type TooltipPlacement = 'Before' | 'After';
    /**
     * Tooltip ShowOn.
     */
    export  type TooltipShowOn = 'Focus' | 'Hover' | 'Always' | 'Auto';
    /**
     * Slider type.
     */
    export  type SliderType = 'Default' | 'MinRange' | 'Range';
    /**
     * Slider orientation.
     */
    export  type SliderOrientation = 'Horizontal' | 'Vertical';
    /**
     * The Slider component allows the user to select a value or range
     * of values in-between a min and max range, by dragging the handle over the slider bar.
     * ```html
     * <div id='slider'></div>
     * ```
     * ```typescript
     * <script>
     *   var sliderObj = new Slider({ value: 10 });
     *   sliderObj.appendTo('#slider');
     * </script>
     * ```
     */
    export  class Slider extends base.Component<HTMLElement> implements base.INotifyPropertyChanged {
        private hiddenInput;
        private firstHandle;
        private sliderContainer;
        private secondHandle;
        private rangeBar;
        private onresize;
        private isElementFocused;
        private handlePos1;
        private handlePos2;
        private rtl;
        private preHandlePos1;
        private preHandlePos2;
        private handleVal1;
        private handleVal2;
        private val;
        private activeHandle;
        private sliderTrack;
        private firstMaterialHandle;
        private secondMaterialHandle;
        private firstBtn;
        private firstTooltipObj;
        private secondTooltipObj;
        private firstTooltipElement;
        private secondTooltipElement;
        private secondBtn;
        private ul;
        private firstChild;
        private firstHandleTooltipPosition;
        private secondHandleTooltipPosition;
        private lastChild;
        private previousTooltipClass;
        private horDir;
        private verDir;
        private transition;
        private transitionOnMaterialTooltip;
        private scaleTransform;
        private previousVal;
        private previousChanged;
        private repeatInterval;
        private isMaterial;
        private bootstrapCollisionArgs;
        private isBootstrap;
        private zIndex;
        private l10n;
        private internationalization;
        private tooltipFormatInfo;
        private ticksFormatInfo;
        private customAriaText;
        private noOfDecimals;
        private tickElementCollection;
        private limitBarFirst;
        private limitBarSecond;
        private firstPartRemain;
        private secondPartRemain;
        private minDiff;
        private drag;
        /**
         * It is used to denote the current value of the Slider.
         * The value should be specified in array of number when render Slider type as range.
         * @default null
         */
        value: number | number[];
        /**
         * It is used to denote own array of slider values.
         * The value should be specified in array of number or string.The min,max and step value is not considered
         * @default null
         */
        customValues: string[] | number[];
        /**
         * It is used to denote the step value of Slider component which is the amount of Slider value change
         *  when increase / decrease button is clicked or press arrow keys or drag the thumb.
         *  Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/ticks.html?lang=typescript#step here}
         *  to know more about this property with demo.
         * @default 1
         */
        step: number;
        /**
         * It sets the minimum value of Slider base.Component
         * @default 0
         */
        min: number;
        /**
         * It sets the maximum value of Slider base.Component
         * @default 100
         */
        max: number;
        /**
         * It is used to render the Slider component in read-only mode.
         * The slider rendered with user defined values and can’t be interacted with user actions.
         * @default false
         */
        readonly: boolean;
        /**
         * It is used to denote the type of the Slider. The available options are:
         *
         *  * default - Used to select a single value in the Slider.
         *  * minRange - Used to select a single value in the Slider. It displays shadow from the start value to the current value.
         *  * range - Used to select a range of values in the Slider. It displays shadow in-between the selection range.
         */
        type: SliderType;
        /**
         * It is used to render the slider ticks options such as placement and step values.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/ticks.html?lang=typescript here}
         *  to know more about this property with demo.
         * @default { placement: 'before' }
         */
        ticks: TicksDataModel;
        /**
         * It is used to limit the slider movement within certain limits.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/limits.html?lang=typescript here}
         *  to know more about this property with demo
         * @default { enabled: false }
         */
        limits: LimitDataModel;
        /**
         * It is used to enable or disable the slider.
         * @default true
         */
        enabled: boolean;
        /**
         * It is used to render the Slider component from right to left direction.
         * @default false
         */
        enableRtl: boolean;
        /**
         * It is used to denote the slider tooltip and it's position.
         * @default { placement: 'Before', isVisible: false, showOn: 'Focus', format: null }
         */
        tooltip: TooltipDataModel;
        /**
         * It is used to show or hide the increase and decrease button of Slider base.Component,
         *  which is used to change the slider value.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/getting-started.html?lang=typescript#buttons here}
         *  to know more about this property with demo.
         * @default false
         */
        showButtons: boolean;
        /**
         * It is used to enable or disable the Slider handle moving animation.
         * @default true
         */
        enableAnimation: boolean;
        /**
         * It is used to render Slider in either horizontal or vertical orientation.
         *  Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/getting-started.html?lang=typescript#orientation here}
         *  to know more about this property with demo.
         * @default 'Horizontal'
         */
        orientation: SliderOrientation;
        /**
         * This property sets the CSS classes to root element of the Slider
         *  which helps to customize the UI styles.
         * @default ''
         */
        cssClass: string;
        /**
         * We can trigger created event when the Slider is created.
         * @event
         */
        created: base.EmitType<Object>;
        /**
         * We can trigger change event whenever Slider value is changed.
         *  In other term, this event will be triggered while drag the slider thumb.
         * @event
         */
        change: base.EmitType<Object>;
        /**
         * We can trigger changed event when Slider component action is completed while we change the Slider value.
         *  In other term, this event will be triggered, while drag the slider thumb completed.
         * @event
         */
        changed: base.EmitType<Object>;
        /**
         * We can trigger renderingTicks event when the ticks rendered on Slider,
         *  which is used to customize the ticks labels dynamically.
         * @event
         */
        renderingTicks: base.EmitType<Object>;
        /**
         * We can trigger renderedTicks event when the ticks are rendered on the Slider.
         * @event
         */
        renderedTicks: base.EmitType<Object>;
        /**
         * We can trigger tooltipChange event when we change the Sider tooltip value.
         * @event
         */
        tooltipChange: base.EmitType<SliderTooltipEventArgs>;
        constructor(options?: SliderModel, element?: string | HTMLElement);
        protected preRender(): void;
        private initCultureFunc();
        private initCultureInfo();
        private formatString(value, formatInfo);
        private formatNumber(value);
        private numberOfDecimals(value);
        private makeRoundNumber(value, precision);
        private fractionalToInteger(value);
        /**
         * To Initialize the control rendering
         * @private
         */
        render(): void;
        private initialize();
        private setCSSClass(oldCSSClass?);
        private setEnabled();
        private getTheme(container);
        /**
         * Initialize the rendering
         * @private
         */
        private initRender();
        private createRangeBar();
        private createLimitBar();
        private setOrientClass();
        private setAriaAttributes(element);
        private createSecondHandle();
        private createFirstHandle();
        private wireFirstHandleEvt(destroy);
        private wireSecondHandleEvt(destroy);
        private handleStart();
        private transitionEnd(e);
        private handleFocusOut();
        private handleFocus(e);
        private handleOver(e);
        private handleLeave(e);
        private setHandler();
        private setEnableRTL();
        private tooltipValue();
        private setTooltipContent();
        private formatContent(formatInfo, ariaContent);
        private addTooltipClass(content);
        private tooltipPlacement();
        private tooltipBeforeOpen(args);
        private wireMaterialTooltipEvent(destroy);
        private tooltipPositionCalculation(position);
        private getTooltipTransformProperties(className);
        private openMaterialTooltip();
        private checkTooltipPosition(args);
        private renderTooltip();
        private tooltipAfterClose(args);
        private setButtons();
        private buttonTitle();
        private buttonFocusOut();
        private repeatButton(args);
        private repeatHandlerMouse(args);
        private materialChange();
        private repeatHandlerUp(e);
        private customTickCounter(bigNum);
        private renderScale();
        private tickesAlignment(orien, tickWidth);
        private createTick(li, start);
        private formatTicksValue(li, start);
        private scaleAlignment();
        private tickValuePosition();
        private setAriaAttrValue(element);
        private handleValueUpdate();
        private getLimitCorrectedValues(value);
        private focusSliderElement();
        private buttonClick(args);
        private tooltipAnimation();
        private buttonUp(args);
        private setRangeBar();
        private checkValidValueAndPos(value);
        private setLimitBarPositions(fromMinPostion, fromMaxpostion, toMinPostion?, toMaxpostion?);
        private setLimitBar();
        private getLimitValueAndPosition(currentValue, minValue, maxValue, limitBar?);
        private setValue();
        private rangeValueUpdate();
        private validateRangeValue();
        private modifyZindex();
        private setHandlePosition();
        private getHandle();
        private setRangeValue();
        private changeEvent(eventName);
        private changeEventArgs(eventName);
        private setPreviousVal(eventName, value);
        private updateRangeValue();
        private checkHandlePosition(value);
        private checkHandleValue(value);
        private onResize();
        private changeHandleValue(value);
        private tempStartEnd();
        private xyToPosition(position);
        private stepValueCalculation(value);
        private add(a, b, addition);
        private round(a);
        private positionToValue(pos);
        private sliderBarClick(evt);
        private refreshTooltipOnMove();
        private sliderDown(event);
        private handleValueAdjust(handleValue, assignValue, handleNumber);
        private dragRangeBarMove(event);
        private sliderBarUp();
        private sliderBarMove(evt);
        private dragRangeBarUp(event);
        private checkRepeatedValue(currentValue);
        private refreshTooltip();
        private openTooltip();
        private keyDown(event);
        private wireButtonEvt(destroy);
        private wireEvents();
        private unwireEvents();
        private keyUp(event);
        private hover(event);
        private sliderFocusOut(event);
        private closeTooltip();
        private removeElement(element);
        private changeSliderType(type);
        private changeRtl();
        private changeOrientation();
        private updateConfig();
        private limitsPropertyChange();
        /**
         * Get the properties to be maintained in the persisted state.
         * @private
         */
        protected getPersistData(): string;
        /**
         * Prepares the slider for safe removal from the DOM.
         * Detaches all event handlers, attributes, and classes to avoid memory leaks.
         * @method destroy
         * @return {void}
         */
        destroy(): void;
        /**
         * Calls internally if any of the property value is changed.
         * @private
         */
        onPropertyChanged(newProp: SliderModel, oldProp: SliderModel): void;
        private setReadOnly();
        private setMinMaxValue();
        private setZindex();
        setTooltip(): void;
        /**
         * Gets the component name
         * @private
         */
        getModuleName(): string;
    }
    /**
     * Uploader modules
     */
    /**
     * Interface for a class FilesProp
     */
    export interface FilesPropModel {
        /**
         * Specifies the name of the file
         * @default ''
         */
        name?: string;
        /**
         * Specifies the size of the file
         * @default null
         */
        size?: number;
        /**
         * Specifies the type of the file
         * @default ''
         */
        type?: string;
    }
    /**
     * Interface for a class ButtonsProps
     */
    export interface ButtonsPropsModel {
        /**
         * Specifies the text or html content to browse button
         * @default 'Browse...'
         */
        browse?: string | HTMLElement;
        /**
         * Specifies the text or html content to upload button
         * @default 'Upload'
         */
        upload?: string | HTMLElement;
        /**
         * Specifies the text or html content to clear button
         * @default 'Clear'
         */
        clear?: string | HTMLElement;
    }
    /**
     * Interface for a class AsyncSettings
     */
    export interface AsyncSettingsModel {
        /**
         * Specifies the URL of save action that will receive the upload files and save in the server.
         * The save action type must be POST request and define the argument as same input name used to render the component.
         * The upload operations could not perform without this property.
         * @default ''
         */
        saveUrl?: string;
        /**
         * Specifies the URL of remove action that receives the file information and handle the remove operation in server.
         * The remove action type must be POST request and define “removeFileNames” attribute to get file information that will be removed.
         * This property is optional.
         * @default ''
         */
        removeUrl?: string;
        /**
         * Specifies the chunk size to split the large file into chunks, and upload it to the server in a sequential order.
         * If the chunk size property has value, the uploader enables the chunk upload by default.
         * It must be specified in bytes value.
         * 
         * > For more information, refer to the [chunk upload](./chunk-upload.html) section from the documentation.
         * 
         * @default 0
         */
        chunkSize?: number;
        /**
         * Specifies the number of retries that the uploader can perform on the file failed to upload.
         * By default, the uploader set 3 as maximum retries. This property must be specified to prevent infinity looping.
         * @default 3
         */
        retryCount?: number;
        /**
         * Specifies the delay time in milliseconds that the automatic retry happens after the delay.
         * @default 500
         */
        retryAfterDelay?: number;
    }
    /**
     * Interface for a class Uploader
     */
    export interface UploaderModel extends base.ComponentModel{
        /**
         * Configures the save and remove URL to perform the upload operations in the server asynchronously.
         * @default { saveUrl: '', removeUrl: '' }
         */
        asyncSettings?: AsyncSettingsModel;
        /**
         * When this property is enabled, the uploader component elements are aligned from right-to-left direction to support locales.
         * @default false
         */
        enableRtl?: boolean;
        /**
         * Specifies Boolean value that indicates whether the component is enabled or disabled.
         * The uploader component does not allow to interact when this property is disabled.
         * @default true
         */
        enabled?: boolean;
        /**
         * Specifies the HTML string that used to customize the content of each file in the list.
         * 
         * > For more information, refer to the [template](./template.html) section from the documentation.
         * 
         * @default null
         */
        template?: string;
        /**
         * Specifies a Boolean value that indicates whether the multiple files can be browsed or
         * dropped simultaneously in the uploader component.
         * @default true
         */
        multiple?: boolean;
        /**
         * By default, the uploader component initiates automatic upload when the files are added in upload queue.
         * If you want to manipulate the files before uploading to server, disable the autoUpload property.
         * The buttons “upload” and “clear” will be hided from file list when autoUpload property is true.
         * @default true
         */
        autoUpload?: boolean;
        /**
         * You can customize the default text of “browse, clear, and upload” buttons with plain text or HTML elements.
         * The buttons’ text can be customized from localization also. If you configured both locale and buttons property,
         * the uploader component considers the buttons property value.
         * @default { browse : 'Browse...', clear: 'Clear', upload: 'Upload' }
         */
        buttons?: ButtonsPropsModel;
        /**
         * Specifies the extensions of the file types allowed in the uploader component and pass the extensions
         * with comma separators. For example,
         * if you want to upload specific image files,  pass allowedExtensions as “.jpg,.png”.
         * @default ''
         */
        allowedExtensions?: string;
        /**
         * Specifies the minimum file size to be uploaded in bytes.
         * The property used to make sure that you cannot upload empty files and small files.
         * @default 0
         */
        minFileSize?: number;
        /**
         * Specifies the maximum allowed file size to be uploaded in bytes.
         * The property used to make sure that you cannot upload too large files.
         * @default 30000000
         */
        maxFileSize?: number;
        /**
         * Specifies the drop target to handle the drag-and-drop upload.
         * By default, the component creates wrapper around file input that will act as drop target.
         * 
         * > For more information, refer to the [drag-and-drop](./draganddrop.html) section from the documentation.
         * 
         * @default null
         */
        dropArea?: string | HTMLElement;
        /**
         * Specifies the list of files that will be preloaded on rendering of uploader component.
         * The property used to view and remove the uploaded files from server. By default, the files are configured with
         * uploaded successfully state. The following properties are mandatory to configure the preload files:
         * * Name
         * * Size
         * * Type
         * 
         * {% codeBlock src="uploader/files-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="uploader/files-api/index.html" %}{% endcodeBlock %}
         * @default { name: '', size: null, type: '' }
         */
        files?: FilesPropModel[];
        /**
         * Specifies a Boolean value that indicates whether the default file list can be rendered.
         * The property used to prevent default file list and design own template for file list.
         * @default true
         */
        showFileList?: boolean;
        /**
         * Triggers after selecting or dropping the files by adding the files in upload queue.
         * @event
         */
        selected?: base.EmitType<SelectedEventArgs>;
        /**
         * Triggers when the upload process gets started. This event is used to add additional parameter with upload request.
         * @event
         */
        uploading?: base.EmitType<Object>;
        /**
         * Triggers when the AJAX request gets success on uploading files or removing files.
         * @event
         */
        success?: base.EmitType<Object>;
        /**
         * Triggers when the AJAX request fails on uploading or removing files.
         * @event
         */
        failure?: base.EmitType<Object>;
        /**
         * Triggers on removing the uploaded file. The event used to get confirm before removing the file from server.
         * @event
         */
        removing?: base.EmitType<RemovingEventArgs>;
        /**
         * Triggers before clearing the items in file list when clicking “clear”.
         * @event
         */
        clearing?: base.EmitType<ClearingEventArgs>;
        /**
         * Triggers when uploading a file to the server using the AJAX request.
         * @event
         */
        progress?: base.EmitType<Object>;
        /**
         * Triggers when changes occur in uploaded file list by selecting or dropping files.
         * @event
         */
        change?: base.EmitType<Object>;
        /**
         * Fires when the chunk file uploaded successfully.
         * @event
         */
        chunkSuccess?: base.EmitType<Object>;
        /**
         * Fires if the chunk file failed to upload.
         * @event
         */
        chunkFailure?: base.EmitType<Object>;
        /**
         * Fires if cancel the chunk file uploading.
         * @event
         */
        canceling?: base.EmitType<Object>;
        /**
         * Fires if pause the chunk file uploading.
         * @event
         */
        pausing?: base.EmitType<Object>;
        /**
         * Fires if resume the paused chunk file upload.
         * @event
         */
        resuming?: base.EmitType<Object>;
    }
    export  class FilesProp extends base.ChildProperty<FilesProp> {
        /**
         * Specifies the name of the file
         * @default ''
         */
        name: string;
        /**
         * Specifies the size of the file
         * @default null
         */
        size: number;
        /**
         * Specifies the type of the file
         * @default ''
         */
        type: string;
    }
    export  class ButtonsProps extends base.ChildProperty<ButtonsProps> {
        /**
         * Specifies the text or html content to browse button
         * @default 'Browse...'
         */
        browse: string | HTMLElement;
        /**
         * Specifies the text or html content to upload button
         * @default 'Upload'
         */
        upload: string | HTMLElement;
        /**
         * Specifies the text or html content to clear button
         * @default 'Clear'
         */
        clear: string | HTMLElement;
    }
    export  class AsyncSettings extends base.ChildProperty<AsyncSettings> {
        /**
         * Specifies the URL of save action that will receive the upload files and save in the server.
         * The save action type must be POST request and define the argument as same input name used to render the component.
         * The upload operations could not perform without this property.
         * @default ''
         */
        saveUrl: string;
        /**
         * Specifies the URL of remove action that receives the file information and handle the remove operation in server.
         * The remove action type must be POST request and define “removeFileNames” attribute to get file information that will be removed.
         * This property is optional.
         * @default ''
         */
        removeUrl: string;
        /**
         * Specifies the chunk size to split the large file into chunks, and upload it to the server in a sequential order.
         * If the chunk size property has value, the uploader enables the chunk upload by default.
         * It must be specified in bytes value.
         *
         * > For more information, refer to the [chunk upload](./chunk-upload.html) section from the documentation.
         *
         * @default 0
         */
        chunkSize: number;
        /**
         * Specifies the number of retries that the uploader can perform on the file failed to upload.
         * By default, the uploader set 3 as maximum retries. This property must be specified to prevent infinity looping.
         * @default 3
         */
        retryCount: number;
        /**
         * Specifies the delay time in milliseconds that the automatic retry happens after the delay.
         * @default 500
         */
        retryAfterDelay: number;
    }
    export interface FileInfo {
        /**
         * Returns the upload file name.
         */
        name: string;
        /**
         * Returns the details about upload file.
         */
        rawFile: string | Blob;
        /**
         * Returns the size of file in bytes.
         */
        size: number;
        /**
         * Returns the status of file.
         */
        status: string;
        /**
         * Returns the MIME type of file as a string. Returns empty string if the file’s type is not determined.
         */
        type: string;
        /**
         * Returns the list of validation errors (if any).
         */
        validationMessages: ValidationMessages;
        /**
         * Returns the current state of the file such as Failed, Canceled, Selected, Uploaded, or Uploading.
         */
        statusCode: string;
    }
    export interface MetaData {
        chunkIndex: number;
        blob: Blob | string;
        file: FileInfo;
        start: number;
        end: number;
        retryCount: number;
        request: base.Ajax;
    }
    export interface ValidationMessages {
        minSize?: string;
        maxSize?: string;
    }
    export interface SelectedEventArgs {
        /**
         * Returns the original event arguments.
         */
        event: MouseEvent | TouchEvent | DragEvent;
        /**
         * Defines whether the current action can be prevented.
         */
        cancel: boolean;
        /**
         * Returns the list of selected files.
         */
        filesData: FileInfo[];
        /**
         * Determines whether the file list generates based on the modified data.
         */
        isModified: boolean;
        /**
         * Specifies the modified files data to generate the file items. The argument depends on `isModified` argument.
         */
        modifiedFilesData: FileInfo[];
        /**
         * Specifies the step value to the progress bar.
         */
        progressInterval: string;
    }
    export interface RemovingEventArgs {
        /**
         * Defines whether the current action can be prevented.
         */
        cancel: boolean;
        /**
         * Defines the additional data with key and value pair format that will be submitted to the remove action.
         */
        customFormData: {
            [key: string]: Object;
        }[];
        /**
         * Returns the original event arguments.
         */
        event: MouseEvent | TouchEvent | base.KeyboardEventArgs;
        /**
         * Returns the list of files’ details that will be removed.
         */
        filesData: FileInfo[];
        /**
         * Returns the XMLHttpRequest instance that is associated with remove action.
         */
        currentRequest?: XMLHttpRequest;
        /**
         * Defines whether the selected raw file send to server remove action.
         * Set true to send raw file.
         * Set false to send file name only.
         */
        postRawFile?: boolean;
    }
    export interface ClearingEventArgs {
        /**
         * Defines whether the current action can be prevented.
         */
        cancel: boolean;
        /**
         * Returns the list of files that will be cleared from the FileList.
         */
        filesData: FileInfo[];
    }
    export interface UploadingEventArgs {
        /**
         * Returns the list of files that will be uploaded.
         */
        fileData: FileInfo;
        /**
         * Defines the additional data in key and value pair format that will be submitted to the upload action.
         */
        customFormData: {
            [key: string]: Object;
        }[];
        /**
         * Defines whether the current action can be prevented.
         */
        cancel: boolean;
        /**
         * Returns the chunk size in bytes if the chunk upload is enabled.
         */
        chunkSize?: number;
        /**
         * Returns the XMLHttpRequest instance that is associated with upload action.
         */
        currentRequest?: XMLHttpRequest;
    }
    export interface CancelEventArgs {
        /**
         * Defines whether the current action can be prevented.
         */
        cancel: boolean;
        /**
         * Returns the original event arguments.
         */
        event: ProgressEventInit;
        /**
         * Returns the file details that will be canceled.
         */
        fileData: FileInfo;
    }
    export interface PauseResumeEventArgs {
        /**
         * Returns the original event arguments.
         */
        event: Event;
        /**
         * Returns the file data that is Paused or Resumed.
         */
        file: FileInfo;
        /**
         * Returns the total number of chunks.
         */
        chunkCount: number;
        /**
         * Returns the index of chunk that is Paused or Resumed.
         */
        chunkIndex: number;
        /**
         * Returns the chunk size value in bytes.
         */
        chunkSize: number;
    }
    /**
     * The uploader component allows to upload images, documents, and other files from local to server.
     * ```html
     * <input type='file' name='images[]' id='upload'/>
     * ```
     * ```typescript
     * <script>
     *   var uploadObj = new Uploader();
     *   uploadObj.appendTo('#upload');
     * </script>
     * ```
     */
    export  class Uploader extends base.Component<HTMLInputElement> implements base.INotifyPropertyChanged {
        private initialAttr;
        private uploadWrapper;
        private browseButton;
        private listParent;
        private cloneElement;
        private fileList;
        private actionButtons;
        private uploadButton;
        private clearButton;
        private pauseButton;
        private formElement;
        private dropAreaWrapper;
        private filesData;
        private uploadedFilesData;
        private dropZoneElement;
        private currentStatus;
        private l10n;
        private preLocaleObj;
        private uploadTemplateFn;
        private keyboardModule;
        private progressInterval;
        private progressAnimation;
        private isForm;
        private allTypes;
        private keyConfigs;
        private localeText;
        private pausedData;
        private uploadMetaData;
        /**
         * Configures the save and remove URL to perform the upload operations in the server asynchronously.
         * @default { saveUrl: '', removeUrl: '' }
         */
        asyncSettings: AsyncSettingsModel;
        /**
         * When this property is enabled, the uploader component elements are aligned from right-to-left direction to support locales.
         * @default false
         */
        enableRtl: boolean;
        /**
         * Specifies Boolean value that indicates whether the component is enabled or disabled.
         * The uploader component does not allow to interact when this property is disabled.
         * @default true
         */
        enabled: boolean;
        /**
         * Specifies the HTML string that used to customize the content of each file in the list.
         *
         * > For more information, refer to the [template](./template.html) section from the documentation.
         *
         * @default null
         */
        template: string;
        /**
         * Specifies a Boolean value that indicates whether the multiple files can be browsed or
         * dropped simultaneously in the uploader component.
         * @default true
         */
        multiple: boolean;
        /**
         * By default, the uploader component initiates automatic upload when the files are added in upload queue.
         * If you want to manipulate the files before uploading to server, disable the autoUpload property.
         * The buttons “upload” and “clear” will be hided from file list when autoUpload property is true.
         * @default true
         */
        autoUpload: boolean;
        /**
         * You can customize the default text of “browse, clear, and upload” buttons with plain text or HTML elements.
         * The buttons’ text can be customized from localization also. If you configured both locale and buttons property,
         * the uploader component considers the buttons property value.
         * @default { browse : 'Browse...', clear: 'Clear', upload: 'Upload' }
         */
        buttons: ButtonsPropsModel;
        /**
         * Specifies the extensions of the file types allowed in the uploader component and pass the extensions
         * with comma separators. For example,
         * if you want to upload specific image files,  pass allowedExtensions as “.jpg,.png”.
         * @default ''
         */
        allowedExtensions: string;
        /**
         * Specifies the minimum file size to be uploaded in bytes.
         * The property used to make sure that you cannot upload empty files and small files.
         * @default 0
         */
        minFileSize: number;
        /**
         * Specifies the maximum allowed file size to be uploaded in bytes.
         * The property used to make sure that you cannot upload too large files.
         * @default 30000000
         */
        maxFileSize: number;
        /**
         * Specifies the drop target to handle the drag-and-drop upload.
         * By default, the component creates wrapper around file input that will act as drop target.
         *
         * > For more information, refer to the [drag-and-drop](./draganddrop.html) section from the documentation.
         *
         * @default null
         */
        dropArea: string | HTMLElement;
        /**
         * Specifies the list of files that will be preloaded on rendering of uploader component.
         * The property used to view and remove the uploaded files from server. By default, the files are configured with
         * uploaded successfully state. The following properties are mandatory to configure the preload files:
         * * Name
         * * Size
         * * Type
         *
         * {% codeBlock src="uploader/files-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="uploader/files-api/index.html" %}{% endcodeBlock %}
         * @default { name: '', size: null, type: '' }
         */
        files: FilesPropModel[];
        /**
         * Specifies a Boolean value that indicates whether the default file list can be rendered.
         * The property used to prevent default file list and design own template for file list.
         * @default true
         */
        showFileList: boolean;
        /**
         * Triggers after selecting or dropping the files by adding the files in upload queue.
         * @event
         */
        selected: base.EmitType<SelectedEventArgs>;
        /**
         * Triggers when the upload process gets started. This event is used to add additional parameter with upload request.
         * @event
         */
        uploading: base.EmitType<Object>;
        /**
         * Triggers when the AJAX request gets success on uploading files or removing files.
         * @event
         */
        success: base.EmitType<Object>;
        /**
         * Triggers when the AJAX request fails on uploading or removing files.
         * @event
         */
        failure: base.EmitType<Object>;
        /**
         * Triggers on removing the uploaded file. The event used to get confirm before removing the file from server.
         * @event
         */
        removing: base.EmitType<RemovingEventArgs>;
        /**
         * Triggers before clearing the items in file list when clicking “clear”.
         * @event
         */
        clearing: base.EmitType<ClearingEventArgs>;
        /**
         * Triggers when uploading a file to the server using the AJAX request.
         * @event
         */
        progress: base.EmitType<Object>;
        /**
         * Triggers when changes occur in uploaded file list by selecting or dropping files.
         * @event
         */
        change: base.EmitType<Object>;
        /**
         * Fires when the chunk file uploaded successfully.
         * @event
         */
        chunkSuccess: base.EmitType<Object>;
        /**
         * Fires if the chunk file failed to upload.
         * @event
         */
        chunkFailure: base.EmitType<Object>;
        /**
         * Fires if cancel the chunk file uploading.
         * @event
         */
        canceling: base.EmitType<Object>;
        /**
         * Fires if pause the chunk file uploading.
         * @event
         */
        pausing: base.EmitType<Object>;
        /**
         * Fires if resume the paused chunk file upload.
         * @event
         */
        resuming: base.EmitType<Object>;
        /**
         * Triggers when change the Uploader value.
         */
        constructor(options?: UploaderModel, element?: string | HTMLInputElement);
        /**
         * Calls internally if any of the property value is changed.
         * @private
         */
        onPropertyChanged(newProp: UploaderModel, oldProp: UploaderModel): void;
        private setLocalizedTexts();
        private getKeyValue(val);
        private updateFileList();
        private reRenderFileList();
        protected preRender(): void;
        protected getPersistData(): string;
        /**
         * Return the module name of the component.
         */
        getModuleName(): string;
        /**
         * To Initialize the control rendering
         * @private
         */
        render(): void;
        private renderBrowseButton();
        private renderActionButtons();
        private wireActionButtonEvents();
        private unwireActionButtonEvents();
        private removeActionButtons();
        private renderButtonTemplates();
        private initializeUpload();
        private renderPreLoadFiles();
        private checkActionButtonStatus();
        private setDropArea();
        private setMultipleSelection();
        private checkAutoUpload(fileData);
        private wireEvents();
        private unWireEvents();
        private resetForm();
        private keyActionHandler(e);
        private getCurrentMetaData(fileInfo?, e?);
        private setReverseFocus(e);
        private setTabFocus(e);
        private removeFocus();
        private browseButtonClick();
        private uploadButtonClick();
        private clearButtonClick();
        private bindDropEvents();
        private unBindDropEvents();
        private onDragLeave(e);
        private dragHover(e);
        private dropElement(e);
        private removeFiles(args);
        private removeFilesData(file, customTemplate);
        private removeUploadedFile(file, eventArgs, removeDirectly, custom);
        private updateFormData(formData, customData);
        private removeCompleted(e, files, customTemplate);
        private removeFailed(e, files, customTemplate);
        private onSelectFiles(args);
        private clearData(singleUpload?);
        private updateSortedFileList(filesData);
        private checkExtension(files);
        private validatedFileSize(fileSize);
        private createCustomfileList(fileData);
        private createParentUL();
        private createFileList(fileData);
        private truncateName(name);
        private getFileType(name);
        private getFileNameOnly(name);
        private setInitialAttributes();
        private filterfileList(files);
        private updateStatus(files, status?, statusCode?);
        private getLiElement(files);
        private createProgressBar(liElement);
        private updateProgressbar(e, li);
        private changeProgressValue(li, progressValue);
        private uploadInProgress(e, files, customUI?, request?);
        private removecanceledFile(e, file);
        private renderFailureState(e, file, liElement);
        private reloadcanceledFile(e, file, liElement);
        private uploadComplete(e, file, customUI?);
        private raiseSuccessEvent(e, file);
        private uploadFailed(e, file);
        private updateProgressBarClasses(li, className);
        private removeProgressbar(li, callType);
        private animateProgressBar(li, callType);
        private setExtensions(extensions);
        private templateComplier(uploadTemplate);
        private setRTL();
        private localizedTexts(localeText);
        private setControlStatus();
        private checkHTMLAttributes();
        private chunkUpload(file, custom?);
        private sendRequest(file, metaData, custom?);
        private eventCancelByArgs(e, eventArgs, file);
        private checkChunkUpload();
        private chunkUploadComplete(e, metaData, custom?);
        private sendNextRequest(metaData);
        private removeChunkFile(e, metaData, custom);
        private pauseUpload(metaData, e?, custom?);
        private abortUpload(metaData, custom, eventArgs?);
        private resumeUpload(metaData, e?, custom?);
        private updateMetaData(metaData);
        private removeChunkProgressBar(metaData);
        private chunkUploadFailed(e, metaData, custom?);
        private retryRequest(liElement, metaData, custom?);
        private checkPausePlayAction(e);
        private retryUpload(metaData, fromcanceledStage?);
        private chunkUploadInProgress(e, metaData, custom?);
        /**
         * It is used to convert bytes value into kilobytes or megabytes depending on the size based
         * on [binary prefix](https://en.wikipedia.org/wiki/Binary_prefix).
         * @param { number } bytes - specifies the file size in bytes.
         * @returns string
         */
        bytesToSize(bytes: number): string;
        /**
         * Allows you to sort the file data alphabetically based on its file name clearly.
         * @param { FileList } filesData - specifies the files data for upload.
         * @returns File[]
         */
        sortFileList(filesData: FileList): File[];
        /**
         * Removes the component from the DOM and detaches all its related event handlers. Also it removes the attributes and classes.
         * @method destroy
         * @return {void}.
         */
        destroy(): void;
        /**
         * Allows you to call the upload process manually by calling save URL action.
         * To process the selected files (added in upload queue), pass an empty argument otherwise
         * upload the specific file based on its argument.
         * @param { FileInfo | FileInfo[] } files - specifies the files data for upload.
         * @returns void
         */
        upload(files: FileInfo | FileInfo[], custom?: boolean): void;
        private validateFileType(files);
        private uploadFiles(files, custom?);
        /**
         * Remove the uploaded file from server manually by calling the remove URL action.
         * If you pass an empty argument to this method, the complete file list can be cleared,
         * otherwise remove the specific file based on its argument (“file_data”).
         * @param { FileInfo | FileInfo[] } fileData - specifies the files data to remove from file list/server.
         * @param { boolean } customTemplate - Set true if the component rendering with customize template.
         * @param { boolean } removeDirectly - Set true if files remove without removing event.
         * @returns void
         */
        remove(fileData?: FileInfo | FileInfo[], customTemplate?: boolean, removeDirectly?: boolean, args?: MouseEvent | TouchEvent | base.KeyboardEventArgs): void;
        /**
         * Clear all the file entries from list that can be uploaded files or added in upload queue.
         * @returns void
         */
        clearAll(): void;
        /**
         * Get the data of files which are shown in file list.
         * @returns FileInfo[]
         */
        getFilesData(): FileInfo[];
        /**
         * Pauses the in-progress chunked upload based on the file data.
         * @param { FileInfo | FileInfo[] } fileData - specifies the files data to pause from uploading.
         * @param { boolean } custom - Set true if used custom UI.
         * @returns void
         */
        pause(fileData: FileInfo | FileInfo[], custom?: boolean): void;
        private pauseUploading(fileData, custom?);
        private getFiles(fileData);
        /**
         * Resumes the chunked upload that is previously paused based on the file data.
         * @param { FileInfo | FileInfo[] } fileData - specifies the files data to resume the paused file.
         * @param { boolean } custom - Set true if used custom UI.
         * @returns void
         */
        resume(fileData: FileInfo | FileInfo[], custom?: boolean): void;
        private resumeFiles(fileData, custom?);
        /**
         * Retries the canceled or failed file upload based on the file data.
         * @param { FileInfo | FileInfo[] } fileData - specifies the files data to retry the canceled or failed file.
         * @param { boolean } fromcanceledStage - Set true to retry from canceled stage and set false to retry from initial stage.
         * @returns void
         */
        retry(fileData: FileInfo | FileInfo[], fromcanceledStage?: boolean): void;
        private retryFailedFiles(fileData, fromcanceledStage?);
        /**
         * Stops the in-progress chunked upload based on the file data.
         * When the file upload is canceled, the partially uploaded file is removed from server.
         * @param { FileInfo | FileInfo[] } fileData - specifies the files data to cancel the progressing file.
         * @returns void
         */
        cancel(fileData: FileInfo[]): void;
        private cancelUpload(fileData);
    }
    

}
}